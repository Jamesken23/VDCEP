{"sol name": "22074.sol", "label": 1, "first path": "function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; ", "second path": "function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; ", "third path": "function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; ", "long path": "pragma solidity ^0.4.19; contract SIMPLE_PIGGY_BANK { address creator = msg.sender; mapping (address => uint) public Bal; uint public MinSum = 1 ether; function()    public     payable    { Bal[msg.sender]+=msg.value; } function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; } } function Break()    public    payable    { if(msg.sender==creator && this.balance>= MinSum)   { selfdestruct(msg.sender); } } } "}
{"sol name": "39326.sol", "label": 0, "first path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "second path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "third path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "long path": "pragma solidity ^0.4.4; contract Owned { address public owner; function setOwner(address _owner) onlyOwner { owner = _owner; } modifier onlyOwner { if (msg.sender != owner) throw; _; } } contract Destroyable { address public hammer; function setHammer(address _hammer) onlyHammer { hammer = _hammer; } function destroy() onlyHammer { suicide(msg.sender); } modifier onlyHammer { if (msg.sender != hammer) throw; _; } } contract Object is Owned, Destroyable { function Object() { owner  = msg.sender; hammer = msg.sender; } } contract ERC20 { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256); function transfer(address _to, uint256 _value) returns (bool); function transferFrom(address _from, address _to, uint256 _value) returns (bool); function approve(address _spender, uint256 _value) returns (bool); function allowance(address _owner, address _spender) constant returns (uint256); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Recipient { event ReceivedEther(address indexed sender, uint256 indexed amount); event ReceivedTokens(address indexed from, uint256 indexed value, address indexed token, bytes extraData); function receiveApproval(address _from, uint256 _value, ERC20 _token, bytes _extraData) { if (!_token.transferFrom(_from, this, _value)) throw; ReceivedTokens(_from, _value, _token, _extraData); } function () payable { ReceivedEther(msg.sender, msg.value); } } contract Congress is Object, Recipient { uint256 public minimumQuorum; uint256 public debatingPeriodInMinutes; int256 public majorityMargin; Proposal[] public proposals; function numProposals() constant returns (uint256) { return proposals.length; } Member[] public members; mapping(address => uint256) public memberId; event ProposalAdded(uint256 indexed proposal, address indexed recipient, uint256 indexed amount, string description); event Voted(uint256 indexed proposal, bool    indexed position, address indexed voter, string justification); event ProposalTallied(uint256 indexed proposal, uint256 indexed quorum, bool    indexed active); event MembershipChanged(address indexed member, bool    indexed isMember); event ChangeOfRules(uint256 indexed minimumQuorum, uint256 indexed debatingPeriodInMinutes, int256  indexed majorityMargin); struct Proposal { address recipient; uint256 amount; string  description; uint256 votingDeadline; bool    executed; bool    proposalPassed; uint256 numberOfVotes; int256  currentResult; bytes32 proposalHash; Vote[]  votes; mapping(address => bool) voted; } struct Member { address member; string  name; uint256 memberSince; } struct Vote { bool    inSupport; address voter; string  justification; } modifier onlyMembers { if (memberId[msg.sender] == 0) throw; _; } function Congress( uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256  marginOfVotesForMajority, address congressLeader ) { changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority); addMember(0, ''); if (congressLeader != 0) addMember(congressLeader, 'The Founder'); } function addMember(address targetMember, string memberName) onlyOwner { if (memberId[targetMember] != 0) throw; memberId[targetMember] = members.length; members.push(Member({member:      targetMember, memberSince: now, name:        memberName})); MembershipChanged(targetMember, true); } function removeMember(address targetMember) onlyOwner { if (memberId[targetMember] == 0) throw; uint256 targetId = memberId[targetMember]; uint256 lastId   = members.length - 1; Member memory moved    = members[lastId]; members[targetId]      = moved; memberId[moved.member] = targetId; memberId[targetMember] = 0; delete members[lastId]; --members.length; MembershipChanged(targetMember, false); } function changeVotingRules( uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256  marginOfVotesForMajority ) onlyOwner { minimumQuorum           = minimumQuorumForProposals; debatingPeriodInMinutes = minutesForDebate; majorityMargin          = marginOfVotesForMajority; ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin); } function newProposal( address beneficiary, uint256 amount, string  jobDescription, bytes   transactionBytecode ) onlyMembers returns (uint256 id) { id               = proposals.length++; Proposal p       = proposals[id]; p.recipient      = beneficiary; p.amount         = amount; p.description    = jobDescription; p.proposalHash   = sha3(beneficiary, amount, transactionBytecode); p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes; p.executed       = false; p.proposalPassed = false; p.numberOfVotes  = 0; ProposalAdded(id, beneficiary, amount, jobDescription); } function checkProposalCode( uint256 id, address beneficiary, uint256 amount, bytes   transactionBytecode ) constant returns (bool codeChecksOut) { return proposals[id].proposalHash == sha3(beneficiary, amount, transactionBytecode); } function vote( uint256 id, bool    supportsProposal, string  justificationText ) onlyMembers returns (uint256 vote) { Proposal p = proposals[id]; if (p.voted[msg.sender] == true) throw; p.voted[msg.sender] = true; p.numberOfVotes++; if (supportsProposal) { p.currentResult++; } else { p.currentResult--; } Voted(id,  supportsProposal, msg.sender, justificationText); } function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; } ProposalTallied(id, p.numberOfVotes, p.proposalPassed); } } library CreatorCongress { function create(uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256 marginOfVotesForMajority, address congressLeader) returns (Congress) { return new Congress(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority, congressLeader); } function version() constant returns (string) { return \"v0.6.3\"; } function abi() constant returns (string) { return '[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"name\":\"currentResult\",\"type\":\"int256\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hammer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"memberSince\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriodInMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"majorityMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"jobDescription\",\"type\":\"string\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"}],\"name\":\"changeVotingRules\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"},{\"name\":\"memberName\",\"type\":\"string\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hammer\",\"type\":\"address\"}],\"name\":\"setHammer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"supportsProposal\",\"type\":\"bool\"},{\"name\":\"justificationText\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"vote\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"codeChecksOut\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"},{\"name\":\"congressLeader\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"justification\",\"type\":\"string\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"quorum\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"isMember\",\"type\":\"bool\"}],\"name\":\"MembershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minimumQuorum\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"debatingPeriodInMinutes\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"majorityMargin\",\"type\":\"int256\"}],\"name\":\"ChangeOfRules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ReceivedTokens\",\"type\":\"event\"}]'; } } contract Builder is Object { event Builded(address indexed client, address indexed instance); mapping(address => address[]) public getContractsOf; function getLastContract() constant returns (address) { var sender_contracts = getContractsOf[msg.sender]; return sender_contracts[sender_contracts.length - 1]; } address public beneficiary; function setBeneficiary(address _beneficiary) onlyOwner { beneficiary = _beneficiary; } uint public buildingCostWei; function setCost(uint _buildingCostWei) onlyOwner { buildingCostWei = _buildingCostWei; } string public securityCheckURI; function setSecurityCheck(string _uri) onlyOwner { securityCheckURI = _uri; } } contract BuilderCongress is Builder { function create(uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256 marginOfVotesForMajority, address congressLeader, address _client) payable returns (address) { if (buildingCostWei > 0 && beneficiary != 0) { if (msg.value < buildingCostWei) throw; if (!beneficiary.send(buildingCostWei)) throw; if (msg.value > buildingCostWei) { if (!msg.sender.send(msg.value - buildingCostWei)) throw; } } else { if (msg.value > 0) { if (!msg.sender.send(msg.value)) throw; } } if (_client == 0) _client = msg.sender; if (congressLeader == 0) congressLeader = _client; var inst = CreatorCongress.create(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority, congressLeader); inst.setOwner(_client); inst.setHammer(_client); getContractsOf[_client].push(inst); Builded(_client, inst); return inst; } } "}
{"sol name": "5629.sol", "label": 0, "first path": "constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); ", "second path": "constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); ", "third path": "constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); ", "long path": "pragma solidity ^0.4.6; pragma solidity ^0.4.24; contract fomo3d { function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256); function withdraw() public; } contract giveAirdrop { constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); } function () public payable {} } contract AirdropTryer { address owner; giveAirdrop airdropper; constructor () public { owner = msg.sender; } function tryAirdrop() public payable{ airdropper = (new giveAirdrop).value(msg.value)(); } function empty() public { require(msg.sender == owner); selfdestruct(owner); } } "}
{"sol name": "3270.sol", "label": 0, "first path": "function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); ", "second path": "function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); ", "third path": "function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); ", "long path": "pragma solidity ^0.4.24; interface FoMo3DlongInterface { function getBuyPrice() public view returns(uint256) ; function getTimeLeft() public view returns(uint256) ; function withdraw() external; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract PwnFoMo3D is Owned { FoMo3DlongInterface fomo3d; constructor() public payable { fomo3d  = FoMo3DlongInterface(0x0aD3227eB47597b566EC138b3AfD78cFEA752de5); } function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); } function withdrawOwner(uint256 a)  public onlyOwner { msg.sender.transfer(a); } } "}
{"sol name": "16925.sol", "label": 1, "first path": "function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; ", "second path": "function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; ", "third path": "function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; ", "long path": "pragma solidity ^0.4.23; contract PoormansHoneyPot { mapping (address => uint) public balances; constructor() public payable { store(); } function store() public payable { balances[msg.sender] = msg.value; } function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; } } "}
{"sol name": "21390.sol", "label": 1, "first path": "function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==\"In\")   { FundsMove(msg.value,\"In\",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, \"Out\", _to); function() payable { In(msg.sender); function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,\"\",msg.sender,admin); function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, \"In\", to,admin); ", "second path": "function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==\"In\")   { FundsMove(msg.value,\"In\",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, \"Out\", _to); function() payable { In(msg.sender); function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,\"\",msg.sender,admin); function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, \"In\", to,admin); ", "third path": "function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==\"In\")   { FundsMove(msg.value,\"In\",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, \"Out\", _to); function() payable { In(msg.sender); function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,\"\",msg.sender,admin); function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, \"In\", to,admin); ", "long path": "contract Accrual_account { address admin = msg.sender; uint targetAmount = 1 ether; mapping(address => uint) public investors; event FundsMove(uint amount,bytes32 typeAct,address adr); function changeAdmin(address _new) { if(_new==0x0)throw; if(msg.sender!=admin)throw; admin=_new; } function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==\"In\")   { FundsMove(msg.value,\"In\",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; } if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, \"Out\", _to); } } function() payable { In(msg.sender); } function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,\"\",msg.sender,admin); } function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, \"In\", to,admin); } } "}
{"sol name": "2387.sol", "label": 1, "first path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "second path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "third path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "long path": "pragma solidity ^0.4.24; pragma experimental \"v0.5.0\"; pragma experimental ABIEncoderV2; library AddressExtension { function isValid(address _address) internal pure returns (bool) { return 0 != _address; } function isAccount(address _address) internal view returns (bool result) { assembly { result := iszero(extcodesize(_address)) } } function toBytes(address _address) internal pure returns (bytes b) { assembly { let m := mload(0x40) mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address)) mstore(0x40, add(m, 52)) b := m } } } library Math { struct Fraction { uint256 numerator; uint256 denominator; } function isPositive(Fraction memory fraction) internal pure returns (bool) { return fraction.numerator > 0 && fraction.denominator > 0; } function mul(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a * b; require((a == 0) || (r / a == b)); } function div(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a - b) <= a); } function add(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a + b) >= a); } function min(uint256 x, uint256 y) internal pure returns (uint256 r) { return x <= y ? x : y; } function max(uint256 x, uint256 y) internal pure returns (uint256 r) { return x >= y ? x : y; } function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { r /= d; } else { r = mul(value / d, m); } } function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { if (r % d == 0) { r /= d; } else { r = (r / d) + 1; } } else { r = mul(value / d, m); if (value % d != 0) { r += 1; } } } function mul(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.numerator, f.denominator); } function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.numerator, f.denominator); } function div(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.denominator, f.numerator); } function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.denominator, f.numerator); } function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) { return Math.Fraction({ numerator: mul(x.numerator, y.numerator), denominator: mul(x.denominator, y.denominator) }); } } contract FsTKAuthority { function isAuthorized(address sender, address _contract, bytes data) public view returns (bool); function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool); function validate() public pure returns (bytes4); } contract Authorizable { event SetFsTKAuthority(FsTKAuthority indexed _address); modifier onlyFsTKAuthorized { require(fstkAuthority.isAuthorized(msg.sender, this, msg.data)); _; } modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) { require(fstkAuthority.isApproved(hash, approveTime, approveToken)); _; } FsTKAuthority internal fstkAuthority; constructor(FsTKAuthority _fstkAuthority) internal { fstkAuthority = _fstkAuthority; } function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized { require(_fstkAuthority.validate() == _fstkAuthority.validate.selector); emit SetFsTKAuthority(fstkAuthority = _fstkAuthority); } } contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function balanceOf(address owner) public view returns (uint256); function allowance(address owner, address spender) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); } contract SecureERC20 is ERC20 { event SetERC20ApproveChecking(bool approveChecking); function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool); function increaseAllowance(address spender, uint256 value) public returns (bool); function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool); function setERC20ApproveChecking(bool approveChecking) public; } contract FsTKToken { enum DelegateMode { PublicMsgSender, PublicTxOrigin, PrivateMsgSender, PrivateTxOrigin } event Consume(address indexed from, uint256 value, bytes32 challenge); event IncreaseNonce(address indexed from, uint256 nonce); event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info); event TerminateDirectDebit(address indexed debtor, address indexed receiver); event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver); event SetMetadata(string metadata); event SetLiquid(bool liquidity); event SetDelegate(bool isDelegateEnable); event SetDirectDebit(bool isDirectDebitEnable); struct DirectDebitInfo { uint256 amount; uint256 startTime; uint256 interval; } struct DirectDebit { DirectDebitInfo info; uint256 epoch; } struct Instrument { uint256 allowance; DirectDebit directDebit; } struct Account { uint256 balance; uint256 nonce; mapping (address => Instrument) instruments; } function spendableAllowance(address owner, address spender) public view returns (uint256); function transfer(uint256[] data) public returns (bool); function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool); function nonceOf(address owner) public view returns (uint256); function increaseNonce() public returns (bool); function delegateTransferAndCall(uint256 nonce, uint256 fee, uint256 gasAmount, address to, uint256 value, bytes data, DelegateMode mode, uint8 v, bytes32 r, bytes32 s) public returns (bool); function directDebit(address debtor, address receiver) public view returns (DirectDebit); function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool); function terminateDirectDebit(address receiver) public returns (bool); function withdrawDirectDebit(address debtor) public returns (bool); function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool); } contract ERC20Like is SecureERC20, FsTKToken { using AddressExtension for address; using Math for uint256; modifier liquid { require(isLiquid); _; } modifier canUseDirectDebit { require(isDirectDebitEnable); _; } modifier canDelegate { require(isDelegateEnable); _; } bool public erc20ApproveChecking; bool public isLiquid = true; bool public isDelegateEnable; bool public isDirectDebitEnable; string public metadata; mapping(address => Account) internal accounts; constructor(string _metadata) public { metadata = _metadata; } function balanceOf(address owner) public view returns (uint256) { return accounts[owner].balance; } function allowance(address owner, address spender) public view returns (uint256) { return accounts[owner].instruments[spender].allowance; } function transfer(address to, uint256 value) public liquid returns (bool) { Account storage senderAccount = accounts[msg.sender]; senderAccount.balance = senderAccount.balance.sub(value); accounts[to].balance += value; emit Transfer(msg.sender, to, value); return true; } function transferFrom(address from, address to, uint256 value) public liquid returns (bool) { Account storage fromAccount = accounts[from]; Instrument storage senderInstrument = fromAccount.instruments[msg.sender]; fromAccount.balance = fromAccount.balance.sub(value); senderInstrument.allowance = senderInstrument.allowance.sub(value); accounts[to].balance += value; emit Transfer(from, to, value); return true; } function approve(address spender, uint256 value) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; if (erc20ApproveChecking) { require((value == 0) || (spenderInstrument.allowance == 0)); } emit Approval( msg.sender, spender, spenderInstrument.allowance = value ); return true; } function setERC20ApproveChecking(bool approveChecking) public { emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking); } function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; require(spenderInstrument.allowance == expectedValue); emit Approval( msg.sender, spender, spenderInstrument.allowance = newValue ); return true; } function increaseAllowance(address spender, uint256 value) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; emit Approval( msg.sender, spender, spenderInstrument.allowance = spenderInstrument.allowance.add(value) ); return true; } function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; uint256 currentValue = spenderInstrument.allowance; uint256 newValue; if (strict) { newValue = currentValue.sub(value); } else if (value < currentValue) { newValue = currentValue - value; } emit Approval( msg.sender, spender, spenderInstrument.allowance = newValue ); return true; } function setMetadata0(string _metadata) internal { emit SetMetadata(metadata = _metadata); } function setLiquid0(bool liquidity) internal { emit SetLiquid(isLiquid = liquidity); } function setDelegate(bool delegate) public { emit SetDelegate(isDelegateEnable = delegate); } function setDirectDebit(bool directDebit) public { emit SetDirectDebit(isDirectDebitEnable = directDebit); } function spendableAllowance(address owner, address spender) public view returns (uint256) { Account storage ownerAccount = accounts[owner]; return Math.min( ownerAccount.instruments[spender].allowance, ownerAccount.balance ); } function transfer(uint256[] data) public liquid returns (bool) { Account storage senderAccount = accounts[msg.sender]; uint256 totalValue; for (uint256 i = 0; i < data.length; i++) { address receiver = address(data[i] >> 96); uint256 value = data[i] & 0xffffffffffffffffffffffff; totalValue = totalValue.add(value); accounts[receiver].balance += value; emit Transfer(msg.sender, receiver, value); } senderAccount.balance = senderAccount.balance.sub(totalValue); return true; } function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) } require(to.call.value(msg.value)(data)); return true; } function nonceOf(address owner) public view returns (uint256) { return accounts[owner].nonce; } function increaseNonce() public returns (bool) { emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1); } function delegateTransferAndCall(uint256 nonce, uint256 fee, uint256 gasAmount, address to, uint256 value, bytes data, DelegateMode mode, uint8 v, bytes32 r, bytes32 s) public liquid canDelegate returns (bool) { require(to != address(this)); address signer; address relayer; if (mode == DelegateMode.PublicMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PublicTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))), v, r, s ); relayer = tx.origin; } else if (mode == DelegateMode.PrivateMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, msg.sender)), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PrivateTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, tx.origin)), v, r, s ); relayer = tx.origin; } else { revert(); } Account storage signerAccount = accounts[signer]; require(nonce == signerAccount.nonce); emit IncreaseNonce(signer, signerAccount.nonce += 1); signerAccount.balance = signerAccount.balance.sub(value.add(fee)); accounts[to].balance += value; if (fee != 0) { accounts[relayer].balance += fee; emit Transfer(signer, relayer, fee); } if (!to.isAccount() && data.length >= 68) { assembly { mstore(add(data, 36), value) mstore(add(data, 68), signer) } if (to.call.gas(gasAmount)(data)) { emit Transfer(signer, to, value); } else { signerAccount.balance += value; accounts[to].balance -= value; } } else { emit Transfer(signer, to, value); } return true; } function directDebit(address debtor, address receiver) public view returns (DirectDebit) { return accounts[debtor].instruments[receiver].directDebit; } function setupDirectDebit( address receiver, DirectDebitInfo info ) public returns (bool) { accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({ info: info, epoch: 0 }); emit SetupDirectDebit(msg.sender, receiver, info); return true; } function terminateDirectDebit(address receiver) public returns (bool) { delete accounts[msg.sender].instruments[receiver].directDebit; emit TerminateDirectDebit(msg.sender, receiver); return true; } function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) { Account storage debtorAccount = accounts[debtor]; DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit; uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1); uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount); require(amount > 0); debtorAccount.balance = debtorAccount.balance.sub(amount); accounts[msg.sender].balance += amount; debit.epoch = epoch; emit Transfer(debtor, msg.sender, amount); return true; } function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) { Account storage receiverAccount = accounts[msg.sender]; result = true; uint256 total; for (uint256 i = 0; i < debtors.length; i++) { address debtor = debtors[i]; Account storage debtorAccount = accounts[debtor]; DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit; uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1); uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount); require(amount > 0); uint256 debtorBalance = debtorAccount.balance; if (amount > debtorBalance) { if (strict) { revert(); } result = false; emit WithdrawDirectDebitFailure(debtor, msg.sender); } else { debtorAccount.balance = debtorBalance - amount; total += amount; debit.epoch = epoch; emit Transfer(debtor, msg.sender, amount); } } receiverAccount.balance += total; } } contract ServiceVoucher is Authorizable, ERC20Like { uint256 public totalSupply; string public name; string public symbol; uint8 public constant decimals = 0; bool public constant isConsumable = true; constructor( FsTKAuthority _fstkAuthority, string _name, string _symbol, string _metadata ) Authorizable(_fstkAuthority) ERC20Like(_metadata) public { name = _name; symbol = _symbol; } function mint(address to, uint256 value) public liquid onlyFsTKAuthorized returns (bool) { totalSupply = totalSupply.add(value); accounts[to].balance += value; emit Transfer(address(0), to, value); return true; } function consume(address from, uint256 value) public liquid onlyFsTKAuthorized returns (bool) { Account storage fromAccount = accounts[from]; fromAccount.balance = fromAccount.balance.sub(value); totalSupply -= value; emit Consume(from, value, bytes32(0)); emit Transfer(from, address(0), value); return true; } function delegateConsume( uint256 nonce, uint256 fee, uint256 value, bytes32 challenge, DelegateMode mode, uint8 v, bytes32 r, bytes32 s ) public liquid canDelegate returns (bool) { require(value > 0); address signer; address relayer; if (mode == DelegateMode.PublicMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, address(0))), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PublicTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, address(0))), v, r, s ); relayer = tx.origin; } else if (mode == DelegateMode.PrivateMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, msg.sender)), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PrivateTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, tx.origin)), v, r, s ); relayer = tx.origin; } else { revert(); } Account storage signerAccount = accounts[signer]; require(nonce == signerAccount.nonce); emit IncreaseNonce(signer, signerAccount.nonce += 1); signerAccount.balance = signerAccount.balance.sub(value.add(fee)); totalSupply -= value; emit Consume(signer, value, challenge); emit Transfer(signer, address(0), value); if (fee != 0) { accounts[relayer].balance += fee; emit Transfer(signer, relayer, fee); } return true; } function setMetadata(string infoUrl) public onlyFsTKAuthorized { setMetadata0(infoUrl); } function setLiquid(bool liquidity) public onlyFsTKAuthorized { setLiquid0(liquidity); } function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized { super.setERC20ApproveChecking(approveChecking); } function setDelegate(bool delegate) public onlyFsTKAuthorized { super.setDelegate(delegate); } function setDirectDebit(bool directDebit) public onlyFsTKAuthorized { super.setDirectDebit(directDebit); } function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized { erc20.transfer(to, value); } } "}
{"sol name": "14458.sol", "label": 0, "first path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); ", "second path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); ", "third path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); ", "long path": "pragma solidity ^0.4.18; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) public pure returns (uint256) { return  a / b; } function safeSub(uint256 a, uint256 b) public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract ERC20 { function totalSupply() public constant returns (uint256); function balanceOf(address _owner) public constant returns (uint256); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ContractReceiver { function tokenFallback(address _from, uint256 _value, bytes _data) public; } contract ERC223 is ERC20 { function transfer(address _to, uint256 _value, bytes _data) public returns (bool success); function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success); event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data); } contract BankeraToken is ERC223, SafeMath { string public constant name = \"Banker Token\"; string public constant symbol = \"BNK\"; uint8 public constant decimals = 8; uint256 private issued = 0; uint256 private totalTokens = 25000000000 * 100000000; address private contractOwner; address private rewardManager; address private roundManager; address private issueManager; uint64 public currentRound = 0; bool public paused = false; mapping (uint64 => Reward) public reward; mapping (address => AddressBalanceInfoStructure) public accountBalances; mapping (uint64 => uint256) public issuedTokensInRound; mapping (address => mapping (address => uint256)) internal allowed; uint256 public blocksPerRound; uint256 public lastBlockNumberInRound; struct Reward { uint64 roundNumber; uint256 rewardInWei; uint256 rewardRate; bool isConfigured; } struct AddressBalanceInfoStructure { uint256 addressBalance; mapping (uint256 => uint256) roundBalanceMap; mapping (uint64 => bool) wasModifiedInRoundMap; uint64[] mapKeys; uint64 claimedRewardTillRound; uint256 totalClaimedReward; } function BankeraToken(uint256 _blocksPerRound, uint64 _round) public { contractOwner = msg.sender; lastBlockNumberInRound = block.number; blocksPerRound = _blocksPerRound; currentRound = _round; } function() public whenNotPaused payable { } function tokenFallback(address _from, uint256 _value, bytes _data) public whenNotPaused view { revert(); } function setReward(uint64 _roundNumber, uint256 _roundRewardInWei) public whenNotPaused onlyRewardManager { isNewRound(); Reward storage rewardInfo = reward[_roundNumber]; assert(rewardInfo.roundNumber == _roundNumber); assert(!rewardInfo.isConfigured); rewardInfo.rewardInWei = _roundRewardInWei; if(_roundRewardInWei > 0){ rewardInfo.rewardRate = safeDiv(_roundRewardInWei, issuedTokensInRound[_roundNumber]); } rewardInfo.isConfigured = true; } function changeContractOwner(address _newContractOwner) public onlyContractOwner { isNewRound(); if (_newContractOwner != contractOwner) { contractOwner = _newContractOwner; } else { revert(); } } function changeRewardManager(address _newRewardManager) public onlyContractOwner { isNewRound(); if (_newRewardManager != rewardManager) { rewardManager = _newRewardManager; } else { revert(); } } function changeRoundManager(address _newRoundManager) public onlyContractOwner { isNewRound(); if (_newRoundManager != roundManager) { roundManager = _newRoundManager; } else { revert(); } } function changeIssueManager(address _newIssueManager) public onlyContractOwner { isNewRound(); if (_newIssueManager != issueManager) { issueManager = _newIssueManager; } else { revert(); } } function setBlocksPerRound(uint64 _newBlocksPerRound) public whenNotPaused onlyRoundManager { blocksPerRound = _newBlocksPerRound; } function pause() onlyContractOwner whenNotPaused public { paused = true; } function resume() onlyContractOwner whenPaused public { paused = false; } modifier onlyContractOwner() { if(msg.sender != contractOwner){ revert(); } _; } modifier onlyRewardManager() { if(msg.sender != rewardManager && msg.sender != contractOwner){ revert(); } _; } modifier onlyRoundManager() { if(msg.sender != roundManager && msg.sender != contractOwner){ revert(); } _; } modifier onlyIssueManager() { if(msg.sender != issueManager && msg.sender != contractOwner){ revert(); } _; } modifier notSelf(address _to) { if(msg.sender == _to){ revert(); } _; } modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function getRoundBalance(address _address, uint256 _round) public view returns (uint256) { return accountBalances[_address].roundBalanceMap[_round]; } function isModifiedInRound(address _address, uint64 _round) public view returns (bool) { return accountBalances[_address].wasModifiedInRoundMap[_round]; } function getBalanceModificationRounds(address _address) public view returns (uint64[]) { return accountBalances[_address].mapKeys; } function issueTokens(address _receiver, uint256 _tokenAmount) public whenNotPaused onlyIssueManager { isNewRound(); issue(_receiver, _tokenAmount); } function withdrawEther() public onlyContractOwner { isNewRound(); if(this.balance > 0) { contractOwner.transfer(this.balance); } else { revert(); } } function transfer(address _to, uint256 _value) public notSelf(_to) whenNotPaused returns (bool success){ require(_to != address(0)); bytes memory empty; if(isContract(_to)) { return transferToContract(msg.sender, _to, _value, empty); } else { return transferToAddress(msg.sender, _to, _value, empty); } } function balanceOf(address _owner) public constant returns (uint256 balance) { return accountBalances[_owner].addressBalance; } function totalSupply() public constant returns (uint256){ return totalTokens; } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { require(_to != address(0)); require(_value <= allowed[_from][msg.sender]); bytes memory empty; if(isContract(_to)) { require(transferToContract(_from, _to, _value, empty)); } else { require(transferToAddress(_from, _to, _value, empty)); } allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value); return true; } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view whenNotPaused returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) { allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function transfer(address _to, uint256 _value, bytes _data) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { return transferToContract(msg.sender, _to, _value, _data); } else { return transferToAddress(msg.sender, _to, _value, _data); } } function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); } if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); } isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); } } function claimReward() public whenNotPaused returns (uint256 rewardAmountInWei) { isNewRound(); return claimRewardTillRound(currentRound); } function claimRewardTillRound(uint64 _claimTillRound) public whenNotPaused returns (uint256 rewardAmountInWei) { isNewRound(); rewardAmountInWei = calculateClaimableRewardTillRound(msg.sender, _claimTillRound); accountBalances[msg.sender].claimedRewardTillRound = _claimTillRound; if (rewardAmountInWei > 0){ accountBalances[msg.sender].totalClaimedReward = safeAdd(accountBalances[msg.sender].totalClaimedReward, rewardAmountInWei); msg.sender.transfer(rewardAmountInWei); } return rewardAmountInWei; } function calculateClaimableReward(address _address) public constant returns (uint256 rewardAmountInWei) { return calculateClaimableRewardTillRound(_address, currentRound); } function calculateClaimableRewardTillRound(address _address, uint64 _claimTillRound) public constant returns (uint256) { uint256 rewardAmountInWei = 0; if (_claimTillRound > currentRound) { revert(); } if (currentRound < 1) { revert(); } AddressBalanceInfoStructure storage accountBalanceInfo = accountBalances[_address]; if(accountBalanceInfo.mapKeys.length == 0){\trevert(); } uint64 userLastClaimedRewardRound = accountBalanceInfo.claimedRewardTillRound; if (_claimTillRound < userLastClaimedRewardRound) { revert(); } for (uint64 workRound = userLastClaimedRewardRound; workRound < _claimTillRound; workRound++) { Reward storage rewardInfo = reward[workRound]; assert(rewardInfo.isConfigured); if(accountBalanceInfo.wasModifiedInRoundMap[workRound]){ rewardAmountInWei = safeAdd(rewardAmountInWei, safeMul(accountBalanceInfo.roundBalanceMap[workRound], rewardInfo.rewardRate)); } else { uint64 lastBalanceModifiedRound = 0; for (uint256 i = accountBalanceInfo.mapKeys.length; i > 0; i--) { uint64 modificationInRound = accountBalanceInfo.mapKeys[i-1]; if (modificationInRound <= workRound) { lastBalanceModifiedRound = modificationInRound; break; } } rewardAmountInWei = safeAdd(rewardAmountInWei, safeMul(accountBalanceInfo.roundBalanceMap[lastBalanceModifiedRound], rewardInfo.rewardRate)); } } return rewardAmountInWei; } function createRounds(uint256 maxRounds) public { uint256 blocksAfterLastRound = safeSub(block.number, lastBlockNumberInRound); if(blocksAfterLastRound >= blocksPerRound){ uint256 roundsNeedToCreate = safeDiv(blocksAfterLastRound, blocksPerRound); if(roundsNeedToCreate > maxRounds){ roundsNeedToCreate = maxRounds; } lastBlockNumberInRound = safeAdd(lastBlockNumberInRound, safeMul(roundsNeedToCreate, blocksPerRound)); for (uint256 i = 0; i < roundsNeedToCreate; i++) { updateRoundInformation(); } } } function isContract(address _address) private view returns (bool is_contract) { uint256 length; assembly { length := extcodesize(_address) } return (length > 0); } function isNewRound() private { uint256 blocksAfterLastRound = safeSub(block.number, lastBlockNumberInRound); if(blocksAfterLastRound >= blocksPerRound){ updateRoundsInformation(blocksAfterLastRound); } } function updateRoundsInformation(uint256 _blocksAfterLastRound) private { uint256 roundsNeedToCreate = safeDiv(_blocksAfterLastRound, blocksPerRound); lastBlockNumberInRound = safeAdd(lastBlockNumberInRound, safeMul(roundsNeedToCreate, blocksPerRound)); for (uint256 i = 0; i < roundsNeedToCreate; i++) { updateRoundInformation(); } } function updateRoundInformation() private { issuedTokensInRound[currentRound] = issued; Reward storage rewardInfo = reward[currentRound]; rewardInfo.roundNumber = currentRound; currentRound = currentRound + 1; } function issue(address _receiver, uint256 _tokenAmount) private { if(_tokenAmount == 0){ revert(); } uint256 newIssuedAmount = safeAdd(_tokenAmount, issued); if(newIssuedAmount > totalTokens){ revert(); } addToAddressBalancesInfo(_receiver, _tokenAmount); issued = newIssuedAmount; bytes memory empty; if(isContract(_receiver)) { ContractReceiver receiverContract = ContractReceiver(_receiver); receiverContract.tokenFallback(msg.sender, _tokenAmount, empty); } Transfer(msg.sender, _receiver, _tokenAmount, empty); Transfer(msg.sender, _receiver, _tokenAmount); } function addToAddressBalancesInfo(address _receiver, uint256 _tokenAmount) private { AddressBalanceInfoStructure storage accountBalance = accountBalances[_receiver]; if(!accountBalance.wasModifiedInRoundMap[currentRound]){ if(accountBalance.mapKeys.length == 0 && currentRound > 0){ accountBalance.claimedRewardTillRound = currentRound; } accountBalance.mapKeys.push(currentRound); accountBalance.wasModifiedInRoundMap[currentRound] = true; } accountBalance.addressBalance = safeAdd(accountBalance.addressBalance, _tokenAmount); accountBalance.roundBalanceMap[currentRound] = accountBalance.addressBalance; } function subFromAddressBalancesInfo(address _adr, uint256 _tokenAmount) private { AddressBalanceInfoStructure storage accountBalance = accountBalances[_adr]; if(!accountBalance.wasModifiedInRoundMap[currentRound]){ accountBalance.mapKeys.push(currentRound); accountBalance.wasModifiedInRoundMap[currentRound] = true; } accountBalance.addressBalance = safeSub(accountBalance.addressBalance, _tokenAmount); accountBalance.roundBalanceMap[currentRound] = accountBalance.addressBalance; } function transferToAddress(address _from, address _to, uint256 _value, bytes _data) private returns (bool success) { if(accountBalances[_from].addressBalance < _value){ revert(); } if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); } isNewRound(); subFromAddressBalancesInfo(_from, _value); addToAddressBalancesInfo(_to, _value); Transfer(_from, _to, _value, _data); Transfer(_from, _to, _value); return true; } function transferToContract(address _from, address _to, uint256 _value, bytes _data) private returns (bool success) { if(accountBalances[_from].addressBalance < _value){ revert(); } if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); } isNewRound(); subFromAddressBalancesInfo(_from, _value); addToAddressBalancesInfo(_to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(_from, _value, _data); Transfer(_from, _to, _value, _data); Transfer(_from, _to, _value); return true; } } "}
{"sol name": "30101.sol", "label": 0, "first path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "second path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "third path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "long path": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract TelcoinSaleCapEscrow { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event WalletChanged(address indexed previousWallet, address indexed newWallet); event ValuePlaced(address indexed purchaser, address indexed beneficiary, uint256 amount); event Approved(address indexed participant, uint256 amount); event Rejected(address indexed participant); event Closed(); address public owner; address public wallet; bool public closed = false; mapping(address => uint256) public deposited; modifier onlyOwner() { require(msg.sender == owner); _; } modifier escrowOpen() { require(!closed); _; } function TelcoinSaleCapEscrow(address _wallet) public payable { require(msg.value > 0); require(_wallet != address(0)); owner = msg.sender; wallet = _wallet; wallet.transfer(msg.value); } function () public payable { placeValue(msg.sender); } function approve(address _participant, uint256 _weiAmount) onlyOwner public { uint256 depositedAmount = deposited[_participant]; require(depositedAmount > 0); require(_weiAmount <= depositedAmount); deposited[_participant] = depositedAmount.sub(_weiAmount); Approved(_participant, _weiAmount); wallet.transfer(_weiAmount); } function approveMany(address[] _participants, uint256[] _weiAmounts) onlyOwner public { require(_participants.length == _weiAmounts.length); for (uint256 i = 0; i < _participants.length; i++) { approve(_participants[i], _weiAmounts[i]); } } function changeWallet(address _wallet) onlyOwner public payable { require(_wallet != 0x0); require(msg.value > 0); WalletChanged(wallet, _wallet); wallet = _wallet; wallet.transfer(msg.value); } function close() onlyOwner public { require(!closed); closed = true; Closed(); } function placeValue(address _beneficiary) escrowOpen public payable { require(_beneficiary != address(0)); uint256 weiAmount = msg.value; require(weiAmount > 0); uint256 newDeposited = deposited[_beneficiary].add(weiAmount); deposited[_beneficiary] = newDeposited; ValuePlaced( msg.sender, _beneficiary, weiAmount ); } function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); } function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); } } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } } "}
{"sol name": "9600.sol", "label": 0, "first path": "function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); ", "second path": "function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); ", "third path": "function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); ", "long path": "pragma solidity ^0.4.24; contract safeSend { bool private txMutex3847834; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); } function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; } } contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; } function _getPayTo() internal view returns (address) { return _payTo; } function _setPayTo(address newPayTo) internal { _payTo = newPayTo; } function payoutAll() external { address a = _getPayTo(); uint bal = address(this).balance; doSafeSend(a, bal); emit PayoutAll(a, bal); } } contract payoutAllCSettable is payoutAllC { constructor (address initPayTo) payoutAllC(initPayTo) public { } function setPayTo(address) external; function getPayTo() external view returns (address) { return _getPayTo(); } } contract owned { address public owner; event OwnerChanged(address newOwner); modifier only_owner() { require(msg.sender == owner, \"only_owner: forbidden\"); _; } modifier owner_or(address addr) { require(msg.sender == addr || msg.sender == owner, \"!owner-or\"); _; } constructor() public { owner = msg.sender; } function setOwner(address newOwner) only_owner() external { owner = newOwner; emit OwnerChanged(newOwner); } } contract CanReclaimToken is owned { function reclaimToken(ERC20Interface token) external only_owner { uint256 balance = token.balanceOf(this); require(token.approve(owner, balance)); } } contract controlledIface { function controller() external view returns (address); } contract hasAdmins is owned { mapping (uint => mapping (address => bool)) admins; uint public currAdminEpoch = 0; bool public adminsDisabledForever = false; address[] adminLog; event AdminAdded(address indexed newAdmin); event AdminRemoved(address indexed oldAdmin); event AdminEpochInc(); event AdminDisabledForever(); modifier only_admin() { require(adminsDisabledForever == false, \"admins must not be disabled\"); require(isAdmin(msg.sender), \"only_admin: forbidden\"); _; } constructor() public { _setAdmin(msg.sender, true); } function isAdmin(address a) view public returns (bool) { return admins[currAdminEpoch][a]; } function getAdminLogN() view external returns (uint) { return adminLog.length; } function getAdminLog(uint n) view external returns (address) { return adminLog[n]; } function upgradeMeAdmin(address newAdmin) only_admin() external { require(msg.sender != owner, \"owner cannot upgrade self\"); _setAdmin(msg.sender, false); _setAdmin(newAdmin, true); } function setAdmin(address a, bool _givePerms) only_admin() external { require(a != msg.sender && a != owner, \"cannot change your own (or owner's) permissions\"); _setAdmin(a, _givePerms); } function _setAdmin(address a, bool _givePerms) internal { admins[currAdminEpoch][a] = _givePerms; if (_givePerms) { emit AdminAdded(a); adminLog.push(a); } else { emit AdminRemoved(a); } } function incAdminEpoch() only_owner() external { currAdminEpoch++; admins[currAdminEpoch][msg.sender] = true; emit AdminEpochInc(); } function disableAdminForever() internal { currAdminEpoch++; adminsDisabledForever = true; emit AdminDisabledForever(); } } contract permissioned is owned, hasAdmins { mapping (address => bool) editAllowed; bool public adminLockdown = false; event PermissionError(address editAddr); event PermissionGranted(address editAddr); event PermissionRevoked(address editAddr); event PermissionsUpgraded(address oldSC, address newSC); event SelfUpgrade(address oldSC, address newSC); event AdminLockdown(); modifier only_editors() { require(editAllowed[msg.sender], \"only_editors: forbidden\"); _; } modifier no_lockdown() { require(adminLockdown == false, \"no_lockdown: check failed\"); _; } constructor() owned() hasAdmins() public { } function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external { editAllowed[e] = _editPerms; if (_editPerms) emit PermissionGranted(e); else emit PermissionRevoked(e); } function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external { editAllowed[oldSC] = false; editAllowed[newSC] = true; emit PermissionsUpgraded(oldSC, newSC); } function upgradeMe(address newSC) only_editors() external { editAllowed[msg.sender] = false; editAllowed[newSC] = true; emit SelfUpgrade(msg.sender, newSC); } function hasPermissions(address a) public view returns (bool) { return editAllowed[a]; } function doLockdown() external only_owner() no_lockdown() { disableAdminForever(); adminLockdown = true; emit AdminLockdown(); } } contract upgradePtr { address ptr = address(0); modifier not_upgraded() { require(ptr == address(0), \"upgrade pointer is non-zero\"); _; } function getUpgradePointer() view external returns (address) { return ptr; } function doUpgradeInternal(address nextSC) internal { ptr = nextSC; } } interface ERC20Interface { function totalSupply() constant external returns (uint256 _totalSupply); function balanceOf(address _owner) constant external returns (uint256 balance); function transfer(address _to, uint256 _value) external returns (bool success); function transferFrom(address _from, address _to, uint256 _value) external returns (bool success); function approve(address _spender, uint256 _value) external returns (bool success); function allowance(address _owner, address _spender) constant external returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } library SafeMath { function subToZero(uint a, uint b) internal pure returns (uint) { if (a < b) { return 0; } return a - b; } } contract ixPaymentEvents { event UpgradedToPremium(bytes32 indexed democHash); event GrantedAccountTime(bytes32 indexed democHash, uint additionalSeconds, bytes32 ref); event AccountPayment(bytes32 indexed democHash, uint additionalSeconds); event SetCommunityBallotFee(uint amount); event SetBasicCentsPricePer30Days(uint amount); event SetPremiumMultiplier(uint8 multiplier); event DowngradeToBasic(bytes32 indexed democHash); event UpgradeToPremium(bytes32 indexed democHash); event SetExchangeRate(uint weiPerCent); event FreeExtension(bytes32 democHash); event SetBallotsPer30Days(uint amount); event SetFreeExtension(bytes32 democHash, bool hasFreeExt); event SetDenyPremium(bytes32 democHash, bool isPremiumDenied); event SetPayTo(address payTo); event SetMinorEditsAddr(address minorEditsAddr); event SetMinWeiForDInit(uint amount); } interface hasVersion { function getVersion() external pure returns (uint); } contract IxPaymentsIface is hasVersion, ixPaymentEvents, permissioned, CanReclaimToken, payoutAllCSettable { function emergencySetOwner(address newOwner) external; function weiBuysHowManySeconds(uint amount) public view returns (uint secs); function weiToCents(uint w) public view returns (uint); function centsToWei(uint c) public view returns (uint); function payForDemocracy(bytes32 democHash) external payable; function doFreeExtension(bytes32 democHash) external; function downgradeToBasic(bytes32 democHash) external; function upgradeToPremium(bytes32 democHash) external; function accountInGoodStanding(bytes32 democHash) external view returns (bool); function getSecondsRemaining(bytes32 democHash) external view returns (uint); function getPremiumStatus(bytes32 democHash) external view returns (bool); function getFreeExtension(bytes32 democHash) external view returns (bool); function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension); function getDenyPremium(bytes32 democHash) external view returns (bool); function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) external; function setPayTo(address) external; function setMinorEditsAddr(address) external; function setBasicCentsPricePer30Days(uint amount) external; function setBasicBallotsPer30Days(uint amount) external; function setPremiumMultiplier(uint8 amount) external; function setWeiPerCent(uint) external; function setFreeExtension(bytes32 democHash, bool hasFreeExt) external; function setDenyPremium(bytes32 democHash, bool isPremiumDenied) external; function setMinWeiForDInit(uint amount) external; function getBasicCentsPricePer30Days() external view returns(uint); function getBasicExtraBallotFeeWei() external view returns (uint); function getBasicBallotsPer30Days() external view returns (uint); function getPremiumMultiplier() external view returns (uint8); function getPremiumCentsPricePer30Days() external view returns (uint); function getWeiPerCent() external view returns (uint weiPerCent); function getUsdEthExchangeRate() external view returns (uint centsPerEth); function getMinWeiForDInit() external view returns (uint); function getPaymentLogN() external view returns (uint); function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue); } contract SVPayments is IxPaymentsIface { uint constant VERSION = 2; struct Account { bool isPremium; uint lastPaymentTs; uint paidUpTill; uint lastUpgradeTs; } struct PaymentLog { bool _external; bytes32 _democHash; uint _seconds; uint _ethValue; } address public minorEditsAddr; uint basicCentsPricePer30Days = 125000; uint basicBallotsPer30Days = 10; uint8 premiumMultiplier = 5; uint weiPerCent = 0.000016583747 ether; uint minWeiForDInit = 1; mapping (bytes32 => Account) accounts; PaymentLog[] payments; mapping (bytes32 => bool) denyPremium; mapping (bytes32 => bool) freeExtension; address public emergencyAdmin; function emergencySetOwner(address newOwner) external { require(msg.sender == emergencyAdmin, \"!emergency-owner\"); owner = newOwner; } constructor(address _emergencyAdmin) payoutAllCSettable(msg.sender) public { emergencyAdmin = _emergencyAdmin; assert(_emergencyAdmin != address(0)); } function getVersion() external pure returns (uint) { return VERSION; } function() payable public { _getPayTo().transfer(msg.value); } function _modAccountBalance(bytes32 democHash, uint additionalSeconds) internal { uint prevPaidTill = accounts[democHash].paidUpTill; if (prevPaidTill < now) { prevPaidTill = now; } accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds; accounts[democHash].lastPaymentTs = now; } function weiBuysHowManySeconds(uint amount) public view returns (uint) { uint centsPaid = weiToCents(amount); uint monthsOffsetPaid = ((10 ** 18) * centsPaid) / basicCentsPricePer30Days; uint secondsOffsetPaid = monthsOffsetPaid * (30 days); uint additionalSeconds = secondsOffsetPaid / (10 ** 18); return additionalSeconds; } function weiToCents(uint w) public view returns (uint) { return w / weiPerCent; } function centsToWei(uint c) public view returns (uint) { return c * weiPerCent; } function payForDemocracy(bytes32 democHash) external payable { require(msg.value > 0, \"need to send some ether to make payment\"); uint additionalSeconds = weiBuysHowManySeconds(msg.value); if (accounts[democHash].isPremium) { additionalSeconds /= premiumMultiplier; } if (additionalSeconds >= 1) { _modAccountBalance(democHash, additionalSeconds); } payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value)); emit AccountPayment(democHash, additionalSeconds); _getPayTo().transfer(msg.value); } function doFreeExtension(bytes32 democHash) external { require(freeExtension[democHash], \"!free\"); uint newPaidUpTill = now + 60 days; accounts[democHash].paidUpTill = newPaidUpTill; emit FreeExtension(democHash); } function downgradeToBasic(bytes32 democHash) only_editors() external { require(accounts[democHash].isPremium, \"!premium\"); accounts[democHash].isPremium = false; uint paidTill = accounts[democHash].paidUpTill; uint timeRemaining = SafeMath.subToZero(paidTill, now); if (timeRemaining > 0) { require(accounts[democHash].lastUpgradeTs < (now - 24 hours), \"downgrade-too-soon\"); timeRemaining *= premiumMultiplier; accounts[democHash].paidUpTill = now + timeRemaining; } emit DowngradeToBasic(democHash); } function upgradeToPremium(bytes32 democHash) only_editors() external { require(denyPremium[democHash] == false, \"upgrade-denied\"); require(!accounts[democHash].isPremium, \"!basic\"); accounts[democHash].isPremium = true; uint paidTill = accounts[democHash].paidUpTill; uint timeRemaining = SafeMath.subToZero(paidTill, now); if (timeRemaining > 0) { timeRemaining /= premiumMultiplier; accounts[democHash].paidUpTill = now + timeRemaining; } accounts[democHash].lastUpgradeTs = now; emit UpgradedToPremium(democHash); } function accountInGoodStanding(bytes32 democHash) external view returns (bool) { return accounts[democHash].paidUpTill >= now; } function getSecondsRemaining(bytes32 democHash) external view returns (uint) { return SafeMath.subToZero(accounts[democHash].paidUpTill, now); } function getPremiumStatus(bytes32 democHash) external view returns (bool) { return accounts[democHash].isPremium; } function getFreeExtension(bytes32 democHash) external view returns (bool) { return freeExtension[democHash]; } function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) { isPremium = accounts[democHash].isPremium; lastPaymentTs = accounts[democHash].lastPaymentTs; paidUpTill = accounts[democHash].paidUpTill; hasFreeExtension = freeExtension[democHash]; } function getDenyPremium(bytes32 democHash) external view returns (bool) { return denyPremium[democHash]; } function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external { _modAccountBalance(democHash, additionalSeconds); payments.push(PaymentLog(true, democHash, additionalSeconds, 0)); emit GrantedAccountTime(democHash, additionalSeconds, ref); } function setPayTo(address newPayTo) only_owner() external { _setPayTo(newPayTo); emit SetPayTo(newPayTo); } function setMinorEditsAddr(address a) only_owner() external { minorEditsAddr = a; emit SetMinorEditsAddr(a); } function setBasicCentsPricePer30Days(uint amount) only_owner() external { basicCentsPricePer30Days = amount; emit SetBasicCentsPricePer30Days(amount); } function setBasicBallotsPer30Days(uint amount) only_owner() external { basicBallotsPer30Days = amount; emit SetBallotsPer30Days(amount); } function setPremiumMultiplier(uint8 m) only_owner() external { premiumMultiplier = m; emit SetPremiumMultiplier(m); } function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external { weiPerCent = wpc; emit SetExchangeRate(wpc); } function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external { freeExtension[democHash] = hasFreeExt; emit SetFreeExtension(democHash, hasFreeExt); } function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external { denyPremium[democHash] = isPremiumDenied; emit SetDenyPremium(democHash, isPremiumDenied); } function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external { minWeiForDInit = amount; emit SetMinWeiForDInit(amount); } function getBasicCentsPricePer30Days() external view returns (uint) { return basicCentsPricePer30Days; } function getBasicExtraBallotFeeWei() external view returns (uint) { return centsToWei(basicCentsPricePer30Days / basicBallotsPer30Days); } function getBasicBallotsPer30Days() external view returns (uint) { return basicBallotsPer30Days; } function getPremiumMultiplier() external view returns (uint8) { return premiumMultiplier; } function getPremiumCentsPricePer30Days() external view returns (uint) { return _premiumPricePer30Days(); } function _premiumPricePer30Days() internal view returns (uint) { return uint(premiumMultiplier) * basicCentsPricePer30Days; } function getWeiPerCent() external view returns (uint) { return weiPerCent; } function getUsdEthExchangeRate() external view returns (uint) { return 1 ether / weiPerCent; } function getMinWeiForDInit() external view returns (uint) { return minWeiForDInit; } function getPaymentLogN() external view returns (uint) { return payments.length; } function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue) { _external = payments[n]._external; _democHash = payments[n]._democHash; _seconds = payments[n]._seconds; _ethValue = payments[n]._ethValue; } } "}
{"sol name": "40425.sol", "label": 0, "first path": "function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; ", "second path": "function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; ", "third path": "function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; ", "long path": "contract MyEtherBank { address private _owner; uint256 private _bankDonationsBalance = 0; bool private _connectBankAccountToNewOwnerAddressEnabled = true; struct BankAccount { bool passwordSha3HashSet; uint32 number; uint32 passwordAttempts; uint256 balance; address owner; bytes32 passwordSha3Hash; mapping(bytes32 => bool) passwordSha3HashesUsed; } struct BankAccountAddress { bool accountSet; uint32 accountNumber; } uint32 private _totalBankAccounts = 0; BankAccount[] private _bankAccountsArray; mapping(address => BankAccountAddress) private _bankAccountAddresses; function MyEtherBank() public { _owner = msg.sender; } event event_donationMadeToBank_ThankYou(uint256 donationAmount); event event_getBankDonationsBalance(uint256 donationBalance); event event_bankDonationsWithdrawn(uint256 donationsAmount); event event_bankAccountOpened_Successful(address indexed bankAccountOwner, uint32 indexed bankAccountNumber, uint256 indexed depositAmount); event event_getBankAccountNumber_Successful(uint32 indexed bankAccountNumber); event event_getBankAccountBalance_Successful(uint32 indexed bankAccountNumber, uint256 indexed balance); event event_depositMadeToBankAccount_Successful(uint32 indexed bankAccountNumber, uint256 indexed depositAmount); event event_depositMadeToBankAccount_Failed(uint32 indexed bankAccountNumber, uint256 indexed depositAmount); event event_depositMadeToBankAccountFromDifferentAddress_Successful(uint32 indexed bankAccountNumber, address indexed addressFrom, uint256 indexed depositAmount); event event_depositMadeToBankAccountFromDifferentAddress_Failed(uint32 indexed bankAccountNumber, address indexed addressFrom, uint256 indexed depositAmount); event event_withdrawalMadeFromBankAccount_Successful(uint32 indexed bankAccountNumber, uint256 indexed withdrawalAmount); event event_withdrawalMadeFromBankAccount_Failed(uint32 indexed bankAccountNumber, uint256 indexed withdrawalAmount); event event_transferMadeFromBankAccountToAddress_Successful(uint32 indexed bankAccountNumber, uint256 indexed transferalAmount, address indexed destinationAddress); event event_transferMadeFromBankAccountToAddress_Failed(uint32 indexed bankAccountNumber, uint256 indexed transferalAmount, address indexed destinationAddress); event event_securityConnectingABankAccountToANewOwnerAddressIsDisabled(); event event_securityHasPasswordSha3HashBeenAddedToBankAccount_Yes(uint32 indexed bankAccountNumber); event event_securityHasPasswordSha3HashBeenAddedToBankAccount_No(uint32 indexed bankAccountNumber); event event_securityPasswordSha3HashAddedToBankAccount_Successful(uint32 indexed bankAccountNumber); event event_securityPasswordSha3HashAddedToBankAccount_Failed_PasswordHashPreviouslyUsed(uint32 indexed bankAccountNumber); event event_securityBankAccountConnectedToNewAddressOwner_Successful(uint32 indexed bankAccountNumber, address indexed newAddressOwner); event event_securityBankAccountConnectedToNewAddressOwner_Failed_PasswordHashHasNotBeenAddedToBankAccount(uint32 indexed bankAccountNumber); event event_securityBankAccountConnectedToNewAddressOwner_Failed_SentPasswordDoesNotMatchAccountPasswordHash(uint32 indexed bankAccountNumber, uint32 indexed passwordAttempts); event event_securityGetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress(uint32 indexed bankAccountNumber, uint32 indexed attempts); modifier modifier_isContractOwner() { if (msg.sender != _owner) { throw; } _; } modifier modifier_doesSenderHaveABankAccount() { if (_bankAccountAddresses[msg.sender].accountSet == false) { throw; } else { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (msg.sender != _bankAccountsArray[accountNumber_].owner) { throw; } } _; } modifier modifier_wasValueSent() { if (msg.value > 0) { throw; } _; } function Donate() public { if (msg.value > 0) { _bankDonationsBalance += msg.value; event_donationMadeToBank_ThankYou(msg.value); } } function BankOwner_GetDonationsBalance() public modifier_isContractOwner() modifier_wasValueSent() returns (uint256) { event_getBankDonationsBalance(_bankDonationsBalance); return _bankDonationsBalance; } function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; } } } function BankOwner_EnableConnectBankAccountToNewOwnerAddress() public modifier_isContractOwner() { if (_connectBankAccountToNewOwnerAddressEnabled == false) { _connectBankAccountToNewOwnerAddressEnabled = true; } } function  BankOwner_DisableConnectBankAccountToNewOwnerAddress() public modifier_isContractOwner() { if (_connectBankAccountToNewOwnerAddressEnabled) { _connectBankAccountToNewOwnerAddressEnabled = false; } } function OpenBankAccount() public returns (uint32 newBankAccountNumber) { if (_bankAccountAddresses[msg.sender].accountSet) { throw; } newBankAccountNumber = _totalBankAccounts; _bankAccountsArray.push( BankAccount( { passwordSha3HashSet: false, passwordAttempts: 0, number: newBankAccountNumber, balance: 0, owner: msg.sender, passwordSha3Hash: \"0\" } )); bytes32 passwordHash_ = sha3(\"password\"); _bankAccountsArray[newBankAccountNumber].passwordSha3HashesUsed[passwordHash_] = true; passwordHash_ = sha3(\"Password\"); _bankAccountsArray[newBankAccountNumber].passwordSha3HashesUsed[passwordHash_] = true; _bankAccountAddresses[msg.sender].accountSet = true; _bankAccountAddresses[msg.sender].accountNumber = newBankAccountNumber; if (msg.value > 0) { _bankAccountsArray[newBankAccountNumber].balance += msg.value; } _totalBankAccounts++; event_bankAccountOpened_Successful(msg.sender, newBankAccountNumber, msg.value); return newBankAccountNumber; } function GetBankAccountNumber() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (uint32) { event_getBankAccountNumber_Successful(_bankAccountAddresses[msg.sender].accountNumber); return _bankAccountAddresses[msg.sender].accountNumber; } function GetBankAccountBalance() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (uint256) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; event_getBankAccountBalance_Successful(accountNumber_, _bankAccountsArray[accountNumber_].balance); return _bankAccountsArray[accountNumber_].balance; } function DepositToBankAccount() public modifier_doesSenderHaveABankAccount() returns (bool) { if (msg.value > 0) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if ((_bankAccountsArray[accountNumber_].balance + msg.value) < _bankAccountsArray[accountNumber_].balance) { throw; } _bankAccountsArray[accountNumber_].balance += msg.value; event_depositMadeToBankAccount_Successful(accountNumber_, msg.value); return true; } else { event_depositMadeToBankAccount_Failed(accountNumber_, msg.value); return false; } } function DepositToBankAccountFromDifferentAddress(uint32 bankAccountNumber) public returns (bool) { if (bankAccountNumber >= _totalBankAccounts) { event_depositMadeToBankAccountFromDifferentAddress_Failed(bankAccountNumber, msg.sender, msg.value); return false; } if (msg.value > 0) { if ((_bankAccountsArray[bankAccountNumber].balance + msg.value) < _bankAccountsArray[bankAccountNumber].balance) { throw; } _bankAccountsArray[bankAccountNumber].balance += msg.value; event_depositMadeToBankAccountFromDifferentAddress_Successful(bankAccountNumber, msg.sender, msg.value); return true; } else { event_depositMadeToBankAccountFromDifferentAddress_Failed(bankAccountNumber, msg.sender, msg.value); return false; } } function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; } else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; } } if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; } } function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; } } if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; } } function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; } } if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; } } function Security_HasPasswordSha3HashBeenAddedToBankAccount() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (_bankAccountsArray[accountNumber_].passwordSha3HashSet) { event_securityHasPasswordSha3HashBeenAddedToBankAccount_Yes(accountNumber_); return true; } else { event_securityHasPasswordSha3HashBeenAddedToBankAccount_No(accountNumber_); return false; } } function Security_AddPasswordSha3HashToBankAccount(bytes32 sha3Hash) public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (_bankAccountsArray[accountNumber_].passwordSha3HashesUsed[sha3Hash] == true) { event_securityPasswordSha3HashAddedToBankAccount_Failed_PasswordHashPreviouslyUsed(accountNumber_); return false; } _bankAccountsArray[accountNumber_].passwordSha3HashSet = true; _bankAccountsArray[accountNumber_].passwordSha3Hash = sha3Hash; _bankAccountsArray[accountNumber_].passwordSha3HashesUsed[sha3Hash] = true; _bankAccountsArray[accountNumber_].passwordAttempts = 0; event_securityPasswordSha3HashAddedToBankAccount_Successful(accountNumber_); return true; } function Security_ConnectBankAccountToNewOwnerAddress(uint32 bankAccountNumber, string password) public modifier_wasValueSent() returns (bool) { if (_connectBankAccountToNewOwnerAddressEnabled == false) { event_securityConnectingABankAccountToANewOwnerAddressIsDisabled(); return false; } if (bankAccountNumber >= _totalBankAccounts) { return false; } if (_bankAccountAddresses[msg.sender].accountSet) { return false; } if (_bankAccountsArray[bankAccountNumber].passwordSha3HashSet == false) { event_securityBankAccountConnectedToNewAddressOwner_Failed_PasswordHashHasNotBeenAddedToBankAccount(bankAccountNumber); return false; } bytes memory passwordString = bytes(password); if (sha3(passwordString) != _bankAccountsArray[bankAccountNumber].passwordSha3Hash) { _bankAccountsArray[bankAccountNumber].passwordAttempts++; event_securityBankAccountConnectedToNewAddressOwner_Failed_SentPasswordDoesNotMatchAccountPasswordHash(bankAccountNumber, _bankAccountsArray[bankAccountNumber].passwordAttempts); return false; } _bankAccountsArray[bankAccountNumber].owner = msg.sender; _bankAccountAddresses[msg.sender].accountSet = true; _bankAccountAddresses[msg.sender].accountNumber = bankAccountNumber; _bankAccountsArray[bankAccountNumber].passwordSha3HashSet = false; _bankAccountsArray[bankAccountNumber].passwordSha3Hash = \"0\"; _bankAccountsArray[bankAccountNumber].passwordAttempts = 0; event_securityBankAccountConnectedToNewAddressOwner_Successful(bankAccountNumber, msg.sender); return true; } function Security_GetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (uint64) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; event_securityGetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress(accountNumber_, _bankAccountsArray[accountNumber_].passwordAttempts); return _bankAccountsArray[accountNumber_].passwordAttempts; } function() { if (_bankAccountAddresses[msg.sender].accountSet) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; address accountOwner_ = _bankAccountsArray[accountNumber_].owner; if (msg.sender == accountOwner_) { if (msg.value > 0) { if ((_bankAccountsArray[accountNumber_].balance + msg.value) < _bankAccountsArray[accountNumber_].balance) { throw; } _bankAccountsArray[accountNumber_].balance += msg.value; event_depositMadeToBankAccount_Successful(accountNumber_, msg.value); } else { throw; } } else { throw; } } else { OpenBankAccount(); } } } "}
{"sol name": "1710.sol", "label": 0, "first path": "function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); function buyFST (address receiver) public payable { buyFST0(receiver); function buyFST () public payable { buyFST0(msg.sender); function () external payable { buyFST0(msg.sender); ", "second path": "function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); function buyFST (address receiver) public payable { buyFST0(receiver); function buyFST () public payable { buyFST0(msg.sender); function () external payable { buyFST0(msg.sender); ", "third path": "function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); function buyFST (address receiver) public payable { buyFST0(receiver); function buyFST () public payable { buyFST0(msg.sender); function () external payable { buyFST0(msg.sender); ", "long path": "pragma solidity ^0.4.24; contract ERC20 { function balanceOf (address owner) public view returns (uint256); function allowance (address owner, address spender) public view returns (uint256); function transfer (address to, uint256 value) public returns (bool); function transferFrom (address from, address to, uint256 value) public returns (bool); function approve (address spender, uint256 value) public returns (bool); } contract MiddleSaleService { address public frontWindow; address public salesPipe; ERC20   public erc; address public owner; constructor(address _frontWindow, address _salesPipe, ERC20 _erc) public { frontWindow = _frontWindow; salesPipe = _salesPipe; erc = _erc; owner = msg.sender; } function setFrontWindow (address _frontWindow) external { require(msg.sender == owner); frontWindow = _frontWindow; } function setSalesPipe (address _salesPipe) external { require(msg.sender == owner); salesPipe = _salesPipe; } function setERC (ERC20 _erc) external { require(msg.sender == owner); erc = _erc; } function setOwner (address _owner) external { require(msg.sender == owner); owner = _owner; } function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); } } function buyFST (address receiver) public payable { buyFST0(receiver); } function buyFST () public payable { buyFST0(msg.sender); } function () external payable { buyFST0(msg.sender); } } "}
{"sol name": "40038.sol", "label": 1, "first path": "function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; ", "second path": "function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; ", "third path": "function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; ", "long path": "pragma solidity ^0.4.0; contract Lockable { uint public numOfCurrentEpoch; uint public creationTime; uint public constant UNLOCKED_TIME = 25 days; uint public constant LOCKED_TIME = 5 days; uint public constant EPOCH_LENGTH = 30 days; bool public lock; bool public tokenSwapLock; event Locked(); event Unlocked(); modifier isTokenSwapOn { if (tokenSwapLock) throw; _; } modifier isNewEpoch { if (numOfCurrentEpoch * EPOCH_LENGTH + creationTime < now ) { numOfCurrentEpoch = (now - creationTime) / EPOCH_LENGTH + 1; } _; } modifier checkLock { if ((creationTime + numOfCurrentEpoch * UNLOCKED_TIME) + (numOfCurrentEpoch - 1) * LOCKED_TIME < now) { if (lock) throw; lock = true; Locked(); return; } else { if (lock) { lock = false; Unlocked(); } } _; } function Lockable() { creationTime = now; numOfCurrentEpoch = 1; tokenSwapLock = true; } } contract ERC20 { function totalSupply() constant returns (uint); function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract Token is ERC20, Lockable { mapping( address => uint ) _balances; mapping( address => mapping( address => uint ) ) _approvals; uint _supply; address public walletAddress; event TokenMint(address newTokenHolder, uint amountOfTokens); event TokenSwapOver(); modifier onlyFromWallet { if (msg.sender != walletAddress) throw; _; } function Token( uint initial_balance, address wallet) { _balances[msg.sender] = initial_balance; _supply = initial_balance; walletAddress = wallet; } function totalSupply() constant returns (uint supply) { return _supply; } function balanceOf( address who ) constant returns (uint value) { return _balances[who]; } function allowance(address owner, address spender) constant returns (uint _allowance) { return _approvals[owner][spender]; } function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a && a + b >= b); } function transfer( address to, uint value) isTokenSwapOn isNewEpoch  checkLock returns (bool ok) { if( _balances[msg.sender] < value ) { throw; } if( !safeToAdd(_balances[to], value) ) { throw; } _balances[msg.sender] -= value; _balances[to] += value; Transfer( msg.sender, to, value ); return true; } function transferFrom( address from, address to, uint value) isTokenSwapOn isNewEpoch checkLock returns (bool ok) { if( _balances[from] < value ) { throw; } if( _approvals[from][msg.sender] < value ) { throw; } if( !safeToAdd(_balances[to], value) ) { throw; } _approvals[from][msg.sender] -= value; _balances[from] -= value; _balances[to] += value; Transfer( from, to, value ); return true; } function approve(address spender, uint value) isTokenSwapOn isNewEpoch checkLock returns (bool ok) { _approvals[msg.sender][spender] = value; Approval( msg.sender, spender, value ); return true; } function currentSwapRate() constant returns(uint) { if (creationTime + 1 weeks > now) { return 130; } else if (creationTime + 2 weeks > now) { return 120; } else if (creationTime + 4 weeks > now) { return 100; } else { return 0; } } function mintTokens(address newTokenHolder, uint etherAmount) external onlyFromWallet { uint tokensAmount = currentSwapRate() * etherAmount; if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw; if(!safeToAdd(_supply,tokensAmount)) throw; _balances[newTokenHolder] += tokensAmount; _supply += tokensAmount; TokenMint(newTokenHolder, tokensAmount); } function disableTokenSwapLock() external onlyFromWallet { tokenSwapLock = false; TokenSwapOver(); } } pragma solidity ^0.4.0; contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(msg.sender)) _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; } function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); } function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external { if (isOwner(_owner)) return; clearPending(); if (m_numOwners >= c_maxOwners) reorganizeOwners(); if (m_numOwners >= c_maxOwners) return; m_numOwners++; m_owners[m_numOwners] = uint(_owner); m_ownerIndex[uint(_owner)] = m_numOwners; OwnerAdded(_owner); } function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); reorganizeOwners(); OwnerRemoved(_owner); } function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); } function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); } function isOwner(address _addr) returns (bool) { return m_ownerIndex[uint(_addr)] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; return !(pending.ownersDone & ownerIndexBit == 0); } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } } function reorganizeOwners() private { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; } } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) if (m_pendingIndex[i] != 0) delete m_pending[m_pendingIndex[i]]; delete m_pendingIndex; } uint public m_required; uint public m_numOwners; uint[256] m_owners; uint constant c_maxOwners = 250; mapping(uint => uint) m_ownerIndex; mapping(bytes32 => PendingState) m_pending; bytes32[] m_pendingIndex; } contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _; } function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); } function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external { m_dailyLimit = _newLimit; } function resetSpentToday() onlymanyowners(sha3(msg.data)) external { m_spentToday = 0; } function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; } function today() private constant returns (uint) { return now / 1 days; } uint public m_dailyLimit; uint public m_spentToday; uint public m_lastDay; } contract multisig { event Deposit(address _from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); } contract tokenswap is multisig, multiowned { Token public tokenCtr; bool public tokenSwap; uint public constant SWAP_LENGTH = 4  weeks; uint public constant MAX_ETH = 700000 ether; uint public amountRaised; modifier isZeroValue { if (msg.value == 0) throw; _; } modifier isOverCap { if (amountRaised + msg.value > MAX_ETH) throw; _; } modifier isSwapStopped { if (!tokenSwap) throw; _; } modifier areConditionsSatisfied { if (tokenCtr.creationTime() + SWAP_LENGTH < now) { tokenCtr.disableTokenSwapLock(); tokenSwap = false; } else { _; if (amountRaised == MAX_ETH) { tokenCtr.disableTokenSwapLock(); tokenSwap = false; } } } function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a && a + b >= b); } function startTokenSwap() onlyowner { tokenSwap = true; } function stopTokenSwap() onlyowner { tokenSwap = false; } function setTokenContract(address newTokenContractAddr) onlyowner { if (newTokenContractAddr == address(0x0)) throw; if (tokenCtr != address(0x0)) throw; tokenCtr = Token(newTokenContractAddr); } function buyTokens(address _beneficiary) payable isZeroValue isOverCap isSwapStopped areConditionsSatisfied { Deposit(msg.sender, msg.value); tokenCtr.mintTokens(_beneficiary, msg.value); if (!safeToAdd(amountRaised, msg.value)) throw; amountRaised += msg.value; } } contract Wallet is multisig, multiowned, daylimit, tokenswap { struct Transaction { address to; uint value; bytes data; } function Wallet(address[] _owners, uint _required, uint _daylimit) multiowned(_owners, _required) daylimit(_daylimit) { } function kill(address _to) onlymanyowners(sha3(msg.data)) external { if (tokenCtr.tokenSwapLock()) throw; suicide(_to); } function() payable { buyTokens(msg.sender); } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; } _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } } function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); } mapping (bytes32 => Transaction) m_txs; } "}
{"sol name": "9221.sol", "label": 0, "first path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "second path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "third path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "long path": "pragma solidity ^0.4.24; contract EtherBet{ address gameOwner = address(0); bool locked = false; function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; } } function lock() { if (gameOwner==msg.sender) { locked = true; } } function unlock()  { if (gameOwner==msg.sender) { locked = false; } } function own(address owner) { if ((gameOwner == address(0)) || (gameOwner == msg.sender)) { gameOwner = owner; } } function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; } } function random() view returns (uint8) { return uint8(uint256(keccak256(block.timestamp, block.difficulty))%256); } function () public  payable { bet(); } } "}
{"sol name": "3255.sol", "label": 0, "first path": "function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))); return(_eventData_); ", "second path": "function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))); return(_eventData_); ", "third path": "function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))); return(_eventData_); ", "long path": "pragma solidity ^0.4.24; contract Owned { address public owner; address public newOwner; constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); owner = newOwner; newOwner = address(0); } } contract LOLevents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } contract modularLong is LOLevents {} contract LOLlong is modularLong,Owned { using SafeMath for *; using NameFilter for string; using LOLKeysCalcLong for uint256; LOLOfficalBankInterface constant private lol_offical_bank = LOLOfficalBankInterface(0xF66E2D098D85b803D5ae710008fCc876c8656fFd); LOLPlayerBookInterface constant private PlayerBook = LOLPlayerBookInterface(0xb9Db77600A611c1DfC923c2c8b513cB1Fc4Fe113); string constant public name = \"LOL Official\"; string constant public symbol = \"LOL\"; uint256 private rndExtra_ = 1 hours; uint256 private rndGap_ = 24 hours; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => LOLdatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => LOLdatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => LOLdatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => LOLdatasets.TeamFee) public fees_; mapping (uint256 => LOLdatasets.PotSplit) public potSplit_; constructor()  public    { fees_[0] = LOLdatasets.TeamFee(36,0); fees_[1] = LOLdatasets.TeamFee(43,0); fees_[2] = LOLdatasets.TeamFee(66,0); fees_[3] = LOLdatasets.TeamFee(51,0); potSplit_[0] = LOLdatasets.PotSplit(25,0); potSplit_[1] = LOLdatasets.PotSplit(25,0); potSplit_[2] = LOLdatasets.PotSplit(40,0); potSplit_[3] = LOLdatasets.PotSplit(40,0); } modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } function() isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    { LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } function buyXid(uint256 _affCode, uint256 _team) isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    { LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    { LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    { LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)       isActivated()        isHuman()        isWithinLimits(_eth)        public    { LOLdatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    { LOLdatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    { LOLdatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function withdraw()        isActivated()        isHuman()        public    { uint256 _rID = rID_; uint256 _now = now; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _eth; if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { LOLdatasets.EventReturns memory _eventData_; round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit LOLevents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } else { _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); emit LOLevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit LOLevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all)      isHuman()        public        payable    { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit LOLevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit LOLevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function getBuyPrice()       public         view        returns(uint256)    { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else return ( 75000000000000 ); } function getTimeLeft() public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { uint256 _rID = rID_; if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; return ( round_[_rID].ico, _rID, round_[_rID].keys, round_[_rID].end, round_[_rID].strt, round_[_rID].pot, (round_[_rID].team + (round_[_rID].plyr * 10)), plyr_[round_[_rID].plyr].addr, plyr_[round_[_rID].plyr].name, rndTmEth_[_rID][0], rndTmEth_[_rID][1], rndTmEth_[_rID][2], rndTmEth_[_rID][3], airDropTracker_ + (airDropPot_ * 1000) ); } function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID, plyr_[_pID].name, plyrRnds_[_pID][_rID].keys, plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff, plyrRnds_[_pID][_rID].eth ); } function buyCore(uint256 _pID, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { core(_rID, _pID, msg.value, _affID, _team, _eventData_); } else { if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit LOLevents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, LOLdatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); core(_rID, _pID, _eth, _affID, _team, _eventData_); } else if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit LOLevents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; } if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; } } _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); } } function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); else return ( (_eth).keys() ); } function iWantXKeys(uint256 _keys) public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else return ( (_keys).eth() ); } function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function determinePID(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; if (_pID == 0) { _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } function managePlayer(uint256 _pID, LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) { if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); plyr_[_pID].lrnd = rID_; _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\")))) { _p3d = _p3d.add(_com); _com = 0; } round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } function updateTimer(uint256 _keys, uint256 _rID) private { uint256 _now = now; uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) { uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); } address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))); return(_eventData_); } function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) { uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; uint256 _air = (_eth / 50); airDropPot_ = airDropPot_.add(_air); _eth = _eth.sub(((_eth.mul(14)) / 100)); uint256 _pot = _eth.sub(_gen); uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } function withdrawEarnings(uint256 _pID) private returns(uint256) { updateGenVault(_pID, plyr_[_pID].lrnd); uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, LOLdatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit LOLevents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } bool public activated_ = false; function activate() public { require( msg.sender == owner, \"only team just can activate\" ); require(activated_ == false, \"fomo3d already activated\"); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } library LOLdatasets { struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr; bytes32 winnerName; uint256 amountWon; uint256 newPot; uint256 P3DAmount; uint256 genAmount; uint256 potAmount; } struct Player { address addr; bytes32 name; uint256 win; uint256 gen; uint256 aff; uint256 lrnd; uint256 laff; } struct PlayerRounds { uint256 eth; uint256 keys; uint256 mask; uint256 ico; } struct Round { uint256 plyr; uint256 team; uint256 end; bool ended; uint256 strt; uint256 keys; uint256 eth; uint256 pot; uint256 mask; uint256 ico; uint256 icoGen; uint256 icoAvg; } struct TeamFee { uint256 gen; uint256 p3d; } struct PotSplit { uint256 gen; uint256 p3d; } } library LOLKeysCalcLong { using SafeMath for *; function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } interface LOLOfficalBankInterface { function deposit() external payable returns(bool); } interface LOLPlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } library NameFilter { function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } bool _hasNonNumber; for (uint256 i = 0; i < _length; i++) { if (_temp[i] > 0x40 && _temp[i] < 0x5b) { _temp[i] = byte(uint(_temp[i]) + 32); if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( _temp[i] == 0x20 || (_temp[i] > 0x60 && _temp[i] < 0x7b) || (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } "}
{"sol name": "39705.sol", "label": 0, "first path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "second path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "third path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "long path": "pragma solidity ^0.4.6; contract TokenTracker { uint public restrictedShare; mapping(address => uint) public tokens; mapping(address => uint) public restrictions; uint public totalRestrictedTokens; uint public totalUnrestrictedTokens; uint public totalRestrictedAssignments; uint public totalUnrestrictedAssignments; bool public assignmentsClosed = false; uint public burnMultDen; uint public burnMultNom; function TokenTracker(uint _restrictedShare) { if (_restrictedShare >= 100) { throw; } restrictedShare = _restrictedShare; } function isUnrestricted() constant returns (bool) { return (assignmentsClosed && totalRestrictedTokens == 0); } function multFracCeiling(uint x, uint a, uint b) returns (uint) { if (a == 0) { return 0; } return (x * a + (b - 1)) / b; } function isRegistered(address addr, bool restricted) constant returns (bool) { if (restricted) { return (restrictions[addr] > 0); } else { return (tokens[addr] > 0); } } function assign(address addr, uint tokenAmount, bool restricted) internal { if (assignmentsClosed) { throw; } tokens[addr] += tokenAmount; if (restricted) { totalRestrictedTokens += tokenAmount; totalRestrictedAssignments += 1; restrictions[addr] += tokenAmount; } else { totalUnrestrictedTokens += tokenAmount; totalUnrestrictedAssignments += 1; } } function closeAssignmentsIfOpen() internal { if (assignmentsClosed) { return; } assignmentsClosed = true; uint totalTokensTarget = (totalUnrestrictedTokens * 100) / (100 - restrictedShare); uint totalTokensExisting = totalRestrictedTokens + totalUnrestrictedTokens; uint totalBurn = 0; if (totalTokensExisting > totalTokensTarget) { totalBurn = totalTokensExisting - totalTokensTarget; } burnMultNom = totalBurn; burnMultDen = totalRestrictedTokens; } function unrestrict(address addr) internal returns (uint) { if (!assignmentsClosed) { throw; } uint restrictionsForAddr = restrictions[addr]; if (restrictionsForAddr == 0) { throw; } uint burn = multFracCeiling(restrictionsForAddr, burnMultNom, burnMultDen); tokens[addr] -= burn; delete restrictions[addr]; totalRestrictedTokens   -= restrictionsForAddr; totalUnrestrictedTokens += restrictionsForAddr - burn; return burn; } } contract Phased { uint[] public phaseEndTime; uint public N; mapping(uint => uint) public maxDelay; function getPhaseAtTime(uint time) constant returns (uint n) { if (time > now) { throw; } while (n < N && phaseEndTime[n] <= time) { n++; } } function isPhase(uint time, uint n) constant returns (bool) { if (time > now) { throw; } if (n >= N) { throw; } if (n > 0 && phaseEndTime[n-1] > time) { return false; } if (n < N && time >= phaseEndTime[n]) { return false; } return true; } function getPhaseStartTime(uint n) constant returns (uint) { if (n == 0) { throw; } return phaseEndTime[n-1]; } function addPhase(uint time) internal { if (N > 0 && time <= phaseEndTime[N-1]) { throw; } if (time <= now) { throw; } phaseEndTime.push(time); N++; } function setMaxDelay(uint i, uint timeDelta) internal { if (i >= N) { throw; } maxDelay[i] = timeDelta; } function delayPhaseEndBy(uint n, uint timeDelta) internal { if (n >= N) { throw; } if (now >= phaseEndTime[n]) { throw; } if (timeDelta > maxDelay[n]) { throw; } maxDelay[n] -= timeDelta; for (uint i = n; i < N; i++) { phaseEndTime[i] += timeDelta; } } function endCurrentPhaseIn(uint timeDelta) internal { uint n = getPhaseAtTime(now); if (n >= N) { throw; } if (timeDelta == 0) { timeDelta = 1; } if (now + timeDelta < phaseEndTime[n]) { phaseEndTime[n] = now + timeDelta; } } } contract StepFunction { uint public phaseLength; uint public nSteps; uint public step; function StepFunction(uint _phaseLength, uint _initialValue, uint _nSteps) { if (_nSteps > _phaseLength) { throw; } step = _initialValue / _nSteps; if ( step * _nSteps != _initialValue) { throw; } phaseLength = _phaseLength; nSteps = _nSteps; } function getStepFunction(uint elapsedTime) constant returns (uint) { if (elapsedTime >= phaseLength) { throw; } uint timeLeft  = phaseLength - elapsedTime - 1; uint stepsLeft = ((nSteps + 1) * timeLeft) / phaseLength; return stepsLeft * step; } } contract Targets { mapping(uint => uint) public counter; mapping(uint => uint) public target; function targetReached(uint id) constant returns (bool) { return (counter[id] >= target[id]); } function setTarget(uint id, uint _target) internal { target[id] = _target; } function addTowardsTarget(uint id, uint amount) internal returns (bool firstReached) { firstReached = (counter[id] < target[id]) && (counter[id] + amount >= target[id]); counter[id] += amount; } } contract Parameters { uint public constant round0StartTime      = 1484676000; uint public constant round1StartTime      = 1495040400; uint public constant round0EndTime        = round0StartTime + 6 weeks; uint public constant round1EndTime        = round1StartTime + 6 weeks; uint public constant finalizeStartTime    = round1EndTime   + 1 weeks; uint public constant finalizeEndTime      = finalizeStartTime + 1000 years; uint public constant maxRoundDelay     = 270 days; uint public constant gracePeriodAfterRound0Target  = 1 days; uint public constant gracePeriodAfterRound1Target  = 0 days; uint public constant tokensPerCHF = 10; uint public constant minDonation = 1 ether; uint public constant round0Bonus = 200; uint public constant round1InitialBonus = 25; uint public constant round1BonusSteps = 5; uint public constant millionInCents = 10**6 * 100; uint public constant round0Target = 1 * millionInCents; uint public constant round1Target = 20 * millionInCents; uint public constant earlyContribShare = 22; } contract FDC is TokenTracker, Phased, StepFunction, Targets, Parameters { string public name; enum state { pause, earlyContrib, round0, round1, offChainReg, finalization, done } mapping(uint => state) stateOfPhase; mapping(bytes32 => bool) memoUsed; address[] public donorList; address[] public earlyContribList; uint public weiPerCHF; uint public totalWeiDonated; mapping(address => uint) public weiDonated; address public foundationWallet; address public registrarAuth; address public exchangeRateAuth; address public masterAuth; uint phaseOfRound0; uint phaseOfRound1; event DonationReceipt (address indexed addr, string indexed currency, uint indexed bonusMultiplierApplied, uint timestamp, uint tokenAmount, bytes32 memo); event EarlyContribReceipt (address indexed addr, uint tokenAmount, bytes32 memo); event BurnReceipt (address indexed addr, uint tokenAmountBurned); function FDC(address _masterAuth, string _name) TokenTracker(earlyContribShare) StepFunction(round1EndTime-round1StartTime, round1InitialBonus, round1BonusSteps) { name = _name; foundationWallet  = _masterAuth; masterAuth     = _masterAuth; exchangeRateAuth  = _masterAuth; registrarAuth  = _masterAuth; stateOfPhase[0] = state.earlyContrib; addPhase(round0StartTime); stateOfPhase[1] = state.round0; addPhase(round0EndTime); stateOfPhase[2] = state.offChainReg; addPhase(round1StartTime); stateOfPhase[3] = state.round1; addPhase(round1EndTime); stateOfPhase[4] = state.offChainReg; addPhase(finalizeStartTime); stateOfPhase[5] = state.finalization; addPhase(finalizeEndTime); stateOfPhase[6] = state.done; phaseOfRound0 = 1; phaseOfRound1 = 3; setMaxDelay(phaseOfRound0 - 1, maxRoundDelay); setMaxDelay(phaseOfRound1 - 1, maxRoundDelay); setTarget(phaseOfRound0, round0Target); setTarget(phaseOfRound1, round1Target); } function getState() constant returns (state) { return stateOfPhase[getPhaseAtTime(now)]; } function getMultiplierAtTime(uint time) constant returns (uint) { uint n = getPhaseAtTime(time); if (stateOfPhase[n] == state.round0) { return 100 + round0Bonus; } if (stateOfPhase[n] == state.round1) { return 100 + getStepFunction(time - getPhaseStartTime(n)); } throw; } function donateAsWithChecksum(address addr, bytes4 checksum) payable returns (bool) { bytes32 hash = sha256(addr); if (bytes4(hash) != checksum) { throw ; } return donateAs(addr); } function finalize(address addr) { if (getState() != state.finalization) { throw; } closeAssignmentsIfOpen(); uint tokensBurned = unrestrict(addr); BurnReceipt(addr, tokensBurned); if (isUnrestricted()) { endCurrentPhaseIn(0); } } function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); } function getStatus(uint donationRound, address dfnAddr, address fwdAddr) public constant returns ( state currentState, uint fxRate, uint currentMultiplier, uint donationCount, uint totalTokenAmount, uint startTime, uint endTime, bool isTargetReached, uint chfCentsDonated, uint tokenAmount, uint fwdBalance, uint donated) { currentState = getState(); if (currentState == state.round0 || currentState == state.round1) { currentMultiplier = getMultiplierAtTime(now); } fxRate = weiPerCHF; donationCount = totalUnrestrictedAssignments; totalTokenAmount = totalUnrestrictedTokens; if (donationRound == 0) { startTime = getPhaseStartTime(phaseOfRound0); endTime = getPhaseStartTime(phaseOfRound0 + 1); isTargetReached = targetReached(phaseOfRound0); chfCentsDonated = counter[phaseOfRound0]; } else { startTime = getPhaseStartTime(phaseOfRound1); endTime = getPhaseStartTime(phaseOfRound1 + 1); isTargetReached = targetReached(phaseOfRound1); chfCentsDonated = counter[phaseOfRound1]; } tokenAmount = tokens[dfnAddr]; donated = weiDonated[dfnAddr]; fwdBalance = fwdAddr.balance; } function setWeiPerCHF(uint weis) { if (msg.sender != exchangeRateAuth) { throw; } weiPerCHF = weis; } function registerEarlyContrib(address addr, uint tokenAmount, bytes32 memo) { if (msg.sender != registrarAuth) { throw; } if (getState() != state.earlyContrib) { throw; } if (!isRegistered(addr, true)) { earlyContribList.push(addr); } assign(addr, tokenAmount, true); EarlyContribReceipt(addr, tokenAmount, memo); } function registerOffChainDonation(address addr, uint timestamp, uint chfCents, string currency, bytes32 memo) { if (msg.sender != registrarAuth) { throw; } uint currentPhase = getPhaseAtTime(now); state currentState = stateOfPhase[currentPhase]; if (currentState != state.round0 && currentState != state.round1 && currentState != state.offChainReg) { throw; } if (timestamp > now) { throw; } uint timestampPhase = getPhaseAtTime(timestamp); state timestampState = stateOfPhase[timestampPhase]; if ((currentState == state.round0 || currentState == state.round1) && (timestampState != currentState)) { throw; } if (currentState == state.offChainReg && timestampPhase != currentPhase-1) { throw; } if (memoUsed[memo]) { throw; } memoUsed[memo] = true; bookDonation(addr, timestamp, chfCents, currency, memo); } function delayDonPhase(uint donPhase, uint timedelta) { if (msg.sender != registrarAuth) { throw; } if (donPhase == 0) { delayPhaseEndBy(phaseOfRound0 - 1, timedelta); } else if (donPhase == 1) { delayPhaseEndBy(phaseOfRound1 - 1, timedelta); } } function setFoundationWallet(address newAddr) { if (msg.sender != masterAuth) { throw; } if (getPhaseAtTime(now) >= phaseOfRound0) { throw; } foundationWallet = newAddr; } function setExchangeRateAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } exchangeRateAuth = newAuth; } function setRegistrarAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } registrarAuth = newAuth; } function setMasterAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } masterAuth = newAuth; } function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); } function bookDonation(address addr, uint timestamp, uint chfCents, string currency, bytes32 memo) private { uint phase = getPhaseAtTime(timestamp); bool targetReached = addTowardsTarget(phase, chfCents); if (targetReached && phase == getPhaseAtTime(now)) { if (phase == phaseOfRound0) { endCurrentPhaseIn(gracePeriodAfterRound0Target); } else if (phase == phaseOfRound1) { endCurrentPhaseIn(gracePeriodAfterRound1Target); } } uint bonusMultiplier = getMultiplierAtTime(timestamp); chfCents = (chfCents * bonusMultiplier) / 100; uint tokenAmount = (chfCents * tokensPerCHF) / 100; if (!isRegistered(addr, false)) { donorList.push(addr); } assign(addr,tokenAmount,false); DonationReceipt(addr, currency, bonusMultiplier, timestamp, tokenAmount, memo); } } "}
{"sol name": "39664.sol", "label": 0, "first path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "second path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "third path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "long path": "library ArrayLib { function insertInPlace(uint8[] storage self, uint8 n) { uint8 insertingIndex = 0; while (self.length > 0 && insertingIndex < self.length && self[insertingIndex] < n) { insertingIndex += 1; } self.length += 1; for (uint8 i = uint8(self.length) - 1; i > insertingIndex; i--) { self[i] = self[i - 1]; } self[insertingIndex] = n; } } library DeckLib { using ArrayLib for uint8[]; enum Suit { Spades, Hearts, Clubs, Diamonds } uint8 constant cardsPerSuit = 13; uint8 constant suits = 4; uint8 constant totalCards = cardsPerSuit * suits; struct Deck { uint8[] usedCards; address player; uint256 gameID; } function init(Deck storage self, uint256 gameID)  { self.usedCards = new uint8[](0); self.player = msg.sender; self.gameID = gameID; } function getCard(Deck storage self, uint256 blockNumber)  returns (uint8)  { uint cardIndex = self.usedCards.length; if (cardIndex >= totalCards) throw; uint8 r = uint8(getRandomNumber(blockNumber, self.player, self.gameID, cardIndex, totalCards - cardIndex)); for (uint8 i = 0; i < cardIndex; i++) { if (self.usedCards[i] <= r) r += 1; } self.usedCards.insertInPlace(r); return r; } function cardDescription(uint8 self) constant returns (Suit, uint8) { return (Suit(self / cardsPerSuit), cardFacevalue(self)); } function cardEmojified(uint8 self) constant returns (uint8, string) { string memory emojiSuit; var (suit, number) = cardDescription(self); if (suit == Suit.Clubs) emojiSuit = \"\u2663\ufe0f\"; else if (suit == Suit.Diamonds) emojiSuit = \"\u2666\ufe0f\"; else if (suit == Suit.Hearts) emojiSuit = \"\u2665\ufe0f\"; else if (suit == Suit.Spades) emojiSuit = \"\u2660\ufe0f\"; return (number, emojiSuit); } function cardFacevalue(uint8 self) constant returns (uint8) { return 1 + self % cardsPerSuit; } function blackjackValue(uint8 self) constant returns (uint8) { uint8 cardValue = cardFacevalue(self); return cardValue < 10 ? cardValue : 10; } function getRandomNumber(uint b, address player, uint256 gameID, uint n, uint m) constant returns (uint) { bytes32 blockHash = block.blockhash(b); if (blockHash == 0x0) throw; return uint(uint256(keccak256(blockHash, player, gameID, n)) % m); } } contract AbstractBlockjackLogs { event GameEnded(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand); event GameNeedsTick(uint256 gameID, address player, uint256 actionBlock); function recordLog(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand); function tickRequiredLog(uint256 gameID, address player, uint256 actionBlock); } library GameLib { using DeckLib for *; uint8 constant houseLimit = 17; uint8 constant target = 21; enum ComparaisonResult { First, Second, Tie } enum GameState { InitialCards, Waiting, Hit, Stand, DoubleDown, Finished } enum GameResult { Ongoing, House, Tie, Player, PlayerNatural } struct Game { address player; uint256 bet; uint256 payout; uint256 gameID; DeckLib.Deck deck; uint8[] houseCards; uint8[] playerCards; uint256 actionBlock; GameState state; GameResult result; bool closed; } function init(Game storage self, uint256 gameID) { self.player = msg.sender; self.bet = msg.value; self.payout = 0; self.houseCards = new uint8[](0); self.playerCards = new uint8[](0); self.actionBlock = block.number; self.state = GameState.InitialCards; self.result = GameResult.Ongoing; self.closed = false; self.gameID = gameID; self.deck.init(gameID); } function tick(Game storage self) returns (bool) { if (block.number <= self.actionBlock) return false; if (self.actionBlock + 255 < block.number) { endGame(self, GameResult.House); return true; } if (!needsTick(self)) return true; if (self.state == GameState.InitialCards) dealInitialCards(self); if (self.state == GameState.Hit) dealHitCard(self); if (self.state == GameState.DoubleDown) { if (!canDoubleDown(self)) throw; self.bet += msg.value; dealHitCard(self); forceStand(self); } if (self.state == GameState.Stand) { dealHouseCards(self); checkGameResult(self); } else { checkGameContinues(self); } return true; } function needsTick(Game storage self) constant returns (bool) { if (self.state == GameState.Waiting) return false; if (self.state == GameState.Finished) return false; return true; } function checkGameResult(Game storage self)  { uint8 houseHand = countHand(self.houseCards); if (houseHand == target && self.houseCards.length == 2) return endGame(self, GameResult.House); ComparaisonResult result = compareHands(houseHand, countHand(self.playerCards)); if (result == ComparaisonResult.First) return endGame(self, GameResult.House); if (result == ComparaisonResult.Second) return endGame(self, GameResult.Player); endGame(self, GameResult.Tie); } function checkGameContinues(Game storage self)  { uint8 playerHand = countHand(self.playerCards); if (playerHand == target && self.playerCards.length == 2) return endGame(self, GameResult.PlayerNatural); if (playerHand > target) return endGame(self, GameResult.House); if (playerHand == target) { forceStand(self); if (!tick(self)) throw; } } function forceStand(Game storage self) { uint256 currentActionBlock = self.actionBlock; playerDecision(self, GameState.Stand); self.actionBlock = currentActionBlock; } function canDoubleDown(Game storage self) returns (bool) { if (self.playerCards.length > 2) return false; uint8 totalPlayer = countHand(self.playerCards); if (totalPlayer < 9 || totalPlayer > 11) return false; if (msg.value != self.bet) return false; } function playerDecision(Game storage self, GameState decision)  { if (self.state != GameState.Waiting) throw; if (decision != GameState.Hit && decision != GameState.Stand) throw; self.state = decision; self.actionBlock = block.number; } function dealInitialCards(Game storage self) private { self.playerCards.push(self.deck.getCard(self.actionBlock)); self.houseCards.push(self.deck.getCard(self.actionBlock)); self.playerCards.push(self.deck.getCard(self.actionBlock)); self.state = GameState.Waiting; } function dealHitCard(Game storage self) private { self.playerCards.push(self.deck.getCard(self.actionBlock)); self.state = GameState.Waiting; } function dealHouseCards(Game storage self) private { self.houseCards.push(self.deck.getCard(self.actionBlock)); if (countHand(self.houseCards) < houseLimit) dealHouseCards(self); } function endGame(Game storage self, GameResult result) { self.result = result; self.state = GameState.Finished; self.payout = payoutForResult(self.result, self.bet); closeGame(self); } function closeGame(Game storage self) private { if (self.closed) throw; if (self.state != GameState.Finished) throw; self.closed = true; if (self.payout > 0) { if (!self.player.send(self.payout)) throw; } } function payoutForResult(GameResult result, uint256 bet) private returns (uint256) { if (result == GameResult.PlayerNatural) return bet * 5 / 2; if (result == GameResult.Player) return bet * 2; if (result == GameResult.Tie) return bet; return 0; } function countHand(uint8[] memory hand)  returns (uint8) { uint8[] memory possibleSums = new uint8[](1); for (uint i = 0; i < hand.length; i++) { uint8 value = hand[i].blackjackValue(); uint l = possibleSums.length; for (uint j = 0; j < l; j++) { possibleSums[j] += value; if (value == 1) { possibleSums = appendArray(possibleSums, possibleSums[j] + 10); } } } return bestSum(possibleSums); } function bestSum(uint8[] possibleSums)  returns (uint8 bestSum) { bestSum = 50; for (uint i = 0; i < possibleSums.length; i++) { if (compareHands(bestSum, possibleSums[i]) == ComparaisonResult.Second) { bestSum = possibleSums[i]; } } return; } function appendArray(uint8[] memory array, uint8 n)  returns (uint8[] memory) { uint8[] memory newArray = new uint8[](array.length + 1); for (uint8 i = 0; i < array.length; i++) { newArray[i] = array[i]; } newArray[array.length] = n; return newArray; } function compareHands(uint8 a, uint8 b)  returns (ComparaisonResult) { if (a <= target && b <= target) { if (a > b) return ComparaisonResult.First; if (a < b) return ComparaisonResult.Second; } if (a > target && b > target) { if (a < b) return ComparaisonResult.First; if (a > b) return ComparaisonResult.Second; } if (a > target) return ComparaisonResult.Second; if (b > target) return ComparaisonResult.First; return ComparaisonResult.Tie; } } contract Blockjack { AbstractBlockjackLogs blockjacklogs; using GameLib for GameLib.Game; GameLib.Game[] games; mapping (address => uint256) public currentGame; bool contractCleared; uint256 public minBet = 50 finney; uint256 public maxBet = 500 finney; bool public allowsNewGames = false; uint256 public maxBlockActions = 10; mapping (uint256 => uint256) blockActions; address public DX = 0x296Ae1d2D9A8701e113EcdF6cE986a4a7D0A6dC5; address public DEV = 0xBC4343B11B7cfdd6dD635f61039b8a66aF6E73Bb; address public ADMIN_CONTRACT; uint256 public BANKROLL_LOCK_PERIOD = 30 days; uint256 public bankrollLockedUntil; uint256 public profitsLockedUntil; uint256 public initialBankroll; uint256 public currentBankroll; mapping (address => bool) public isOwner; modifier onlyOwner { if (!isOwner[msg.sender]) throw; _; } modifier only(address x) { if (msg.sender != x) throw; _; } modifier onlyPlayer(uint256 gameID) { if (msg.sender != games[gameID].player) throw; _; } modifier blockActionProtected { blockActions[block.number] += 1; if (blockActions[block.number] > maxBlockActions) throw; _; } function Blockjack(address _admin_contract, address _logs_contract) { ADMIN_CONTRACT = _admin_contract; blockjacklogs = AbstractBlockjackLogs(_logs_contract); games.length += 1; games[0].init(0); games[0].player = this; setupTrustedAccounts(); } function () payable { startGame(); } function startGame() blockActionProtected payable { if (!allowsNewGames) throw; if (msg.value < minBet) throw; if (msg.value > maxBet) throw; uint256 currentGameId = currentGame[msg.sender]; if (games.length > currentGameId) { GameLib.Game openedGame = games[currentGameId]; if (openedGame.player == msg.sender && !openedGame.closed) { if (!openedGame.tick()) throw; if (!openedGame.closed) throw; recordEndedGame(currentGameId); } } uint256 newGameID = games.length; games.length += 1; games[newGameID].init(newGameID); currentGame[msg.sender] = newGameID; tickRequiredLog(games[newGameID]); } function hit(uint256 gameID) onlyPlayer(gameID) blockActionProtected { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.Hit); tickRequiredLog(game); } function doubleDown(uint256 gameID) onlyPlayer(gameID) blockActionProtected payable { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.DoubleDown); tickRequiredLog(game); } function stand(uint256 gameID) onlyPlayer(gameID) blockActionProtected { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.Stand); tickRequiredLog(game); } function gameTick(uint256 gameID) blockActionProtected { GameLib.Game openedGame = games[gameID]; if (openedGame.closed) throw; if (!openedGame.tick()) throw; if (openedGame.closed) recordEndedGame(gameID); } function recordEndedGame(uint gameID) private { GameLib.Game openedGame = games[gameID]; if(currentBankroll + openedGame.bet > openedGame.payout){ currentBankroll = currentBankroll + openedGame.bet - openedGame.payout; } blockjacklogs.recordLog( openedGame.gameID, openedGame.player, uint(openedGame.result), openedGame.payout, GameLib.countHand(openedGame.playerCards), GameLib.countHand(openedGame.houseCards) ); } function tickRequiredLog(GameLib.Game storage game) private { blockjacklogs.tickRequiredLog(game.gameID, game.player, game.actionBlock); } function gameState(uint i) constant returns (uint8[], uint8[], uint8, uint8, uint256, uint256, uint8, uint8, bool, uint256) { GameLib.Game game = games[i]; return ( game.houseCards, game.playerCards, GameLib.countHand(game.houseCards), GameLib.countHand(game.playerCards), game.bet, game.payout, uint8(game.state), uint8(game.result), game.closed, game.actionBlock ); } function setupTrustedAccounts() internal { isOwner[DX] = true; isOwner[DEV] = true; isOwner[ADMIN_CONTRACT] = true; } function changeDev(address newDev) only(DEV) { isOwner[DEV] = false; DEV = newDev; isOwner[DEV] = true; } function changeDX(address newDX) only(DX) { isOwner[DX] = false; DX = newDX; isOwner[DX] = true; } function changeAdminContract(address _new_admin_contract) only(ADMIN_CONTRACT) { isOwner[ADMIN_CONTRACT] = false; ADMIN_CONTRACT = _new_admin_contract; isOwner[ADMIN_CONTRACT] = true; } function setSettings(uint256 _min, uint256 _max, uint256 _maxBlockActions) only(ADMIN_CONTRACT) { minBet = _min; maxBet = _max; maxBlockActions = _maxBlockActions; } function registerOwner(address _new_watcher) only(ADMIN_CONTRACT) { isOwner[_new_watcher] = true; } function removeOwner(address _old_watcher) only(ADMIN_CONTRACT) { isOwner[_old_watcher] = false; } function stopBlockjack() onlyOwner { allowsNewGames = false; } function startBlockjack() only(ADMIN_CONTRACT) { allowsNewGames = true; } function addBankroll() only(DX) payable { initialBankroll += msg.value; currentBankroll += msg.value; } function remainingBankroll() constant returns (uint256) { return currentBankroll > initialBankroll ? initialBankroll : currentBankroll; } function removeBankroll() only(DX) { if (initialBankroll > currentBankroll - 5 ether && bankrollLockedUntil > now) throw; stopBlockjack(); if (currentBankroll > initialBankroll) { if (!DEV.send(currentBankroll - initialBankroll)) throw; } suicide(DX); contractCleared = true; } function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; } suicide(DX); } function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; } } "}
{"sol name": "12182.sol", "label": 0, "first path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "second path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "third path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "long path": "pragma solidity ^0.4.23; contract Ownable { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } constructor() public { owner = msg.sender; } function setOwner(address _owner) public onlyOwner returns (bool) { require(_owner != address(0)); owner = _owner; return true; } } interface TokenHandler { function handleTokens(Token _token) public returns (bool); } contract HasWorkers is Ownable { mapping(address => uint256) private workerToIndex; address[] private workers; event AddedWorker(address _worker); event RemovedWorker(address _worker); constructor() public { workers.length++; } modifier onlyWorker() { require(isWorker(msg.sender)); _; } modifier workerOrOwner() { require(isWorker(msg.sender) || msg.sender == owner); _; } function isWorker(address _worker) public view returns (bool) { return workerToIndex[_worker] != 0; } function allWorkers() public view returns (address[] memory result) { result = new address[](workers.length - 1); for (uint256 i = 1; i < workers.length; i++) { result[i - 1] = workers[i]; } } function addWorker(address _worker) public onlyOwner returns (bool) { require(!isWorker(_worker)); uint256 index = workers.push(_worker) - 1; workerToIndex[_worker] = index; emit AddedWorker(_worker); return true; } function removeWorker(address _worker) public onlyOwner returns (bool) { require(isWorker(_worker)); uint256 index = workerToIndex[_worker]; address lastWorker = workers[workers.length - 1]; workerToIndex[lastWorker] = index; workers[index] = lastWorker; workers.length--; delete workerToIndex[_worker]; emit RemovedWorker(_worker); return true; } } contract ControllerStorage { address public walletsDelegate; address public controllerDelegate; address public forward; uint256 public createdWallets; mapping(bytes32 => bytes32) public gStorage; } contract WalletStorage { address public owner; } contract DelegateProxy { function delegatedFwd(address _dst, bytes _calldata) internal { assembly { let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0) let size := returndatasize let ptr := mload(0x40) returndatacopy(ptr, 0, size) switch result case 0 { revert(ptr, size) } default { return(ptr, size) } } } } contract DelegateProvider { function getDelegate() public view returns (address delegate); } contract ControllerProxy is ControllerStorage, Ownable, HasWorkers, DelegateProvider, DelegateProxy { function getDelegate() public view returns (address delegate) { delegate = walletsDelegate; } function setWalletsDelegate(address _delegate) public onlyOwner returns (bool) { walletsDelegate = _delegate; return true; } function setControllerDelegate(address _delegate) public onlyOwner returns (bool) { controllerDelegate = _delegate; return true; } function() public payable { if (gasleft() > 2400) { delegatedFwd(controllerDelegate, msg.data); } } } contract Token { function transfer(address _to, uint _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); function approve(address _spender, uint256 _value) returns (bool success); function increaseApproval (address _spender, uint _addedValue) public returns (bool success); function balanceOf(address tokenOwner) public constant returns (uint balance); } contract WalletProxy is WalletStorage, DelegateProxy { event ReceivedETH(address from, uint256 amount); constructor() public { owner = msg.sender; } function() public payable { if (msg.value > 0) { emit ReceivedETH(msg.sender, msg.value); } if (gasleft() > 2400) { delegatedFwd(DelegateProvider(owner).getDelegate(), msg.data); } } } contract Wallet is WalletStorage { function transferERC20Token(Token token, address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return token.transfer(to, amount); } function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); } function() public payable {} } contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); } function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); } function setForward(address _forward) public onlyOwner returns (bool) { emit ChangedForward(forward, _forward, msg.sender); forward = _forward; return true; } function createWallets(uint256 number) public onlyWorker returns (bool) { for (uint256 i = 0; i < number; i++) { emit CreatedUserWallet(new WalletProxy()); } createdWallets += number; return true; } function withdrawEth(Wallet wallet) public onlyWorker returns (bool result) { uint256 balance = address(wallet).balance; result = wallet.transferEther(forward, balance); if (result) { emit WithdrawEth(wallet, forward, balance); } } function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); } } forward.call.value(address(this).balance)(); return true; } function withdrawERC20(Token token, Wallet wallet) public onlyWorker returns (bool result) { uint256 balance = token.balanceOf(wallet); result = wallet.transferERC20Token(token, forward, balance); if (result) { emit WithdrawToken(token, wallet, forward, balance); } TokenHandler(forward).handleTokens(token); } function withdrawERC20Batch(Token token, Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = token.balanceOf(wallet); if (wallet.transferERC20Token(token, forward, balance)) { emit WithdrawToken(token, wallet, forward, balance); } } TokenHandler(forward).handleTokens(token); return true; } function() public payable {} } "}
{"sol name": "13952.sol", "label": 1, "first path": "function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; function sendProfits() public returns (uint _profits) int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); function _betFailure(string _msg, uint _bet, bool _doRefund) private if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); function _uncreditUser(address _user, uint _amt) private if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); ", "second path": "function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; function sendProfits() public returns (uint _profits) int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); function _betFailure(string _msg, uint _bet, bool _doRefund) private if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); function _uncreditUser(address _user, uint _amt) private if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); ", "third path": "function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; function sendProfits() public returns (uint _profits) int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); function _betFailure(string _msg, uint _bet, bool _doRefund) private if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); function _uncreditUser(address _user, uint _amt) private if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); ", "long path": "pragma solidity ^0.4.23; interface IRegistry { function owner() external view returns (address _addr); function addressOf(bytes32 _name) external view returns (address _addr); } contract UsingRegistry { IRegistry private registry; modifier fromOwner(){ require(msg.sender == getOwner()); _; } constructor(address _registry) public { require(_registry != 0); registry = IRegistry(_registry); } function addressOf(bytes32 _name) internal view returns(address _addr) { return registry.addressOf(_name); } function getOwner() public view returns (address _addr) { return registry.owner(); } function getRegistry() public view returns (IRegistry _addr) { return registry; } } contract UsingAdmin is UsingRegistry { constructor(address _registry) UsingRegistry(_registry) public {} modifier fromAdmin(){ require(msg.sender == getAdmin()); _; } function getAdmin() public constant returns (address _addr) { return addressOf(\"ADMIN\"); } } interface ITreasury { function issueDividend() external returns (uint _profits); function profitsSendable() external view returns (uint _profits); } contract UsingTreasury is UsingRegistry { constructor(address _registry) UsingRegistry(_registry) public {} modifier fromTreasury(){ require(msg.sender == address(getTreasury())); _; } function getTreasury() public view returns (ITreasury) { return ITreasury(addressOf(\"TREASURY\")); } } contract Ledger { uint public total; struct Entry { uint balance; address next; address prev; } mapping (address => Entry) public entries; address public owner; modifier fromOwner() { require(msg.sender==owner); _; } constructor(address _owner) public { owner = _owner; } function add(address _address, uint _amt) fromOwner public { if (_address == address(0) || _amt == 0) return; Entry storage entry = entries[_address]; if (entry.balance == 0) { entry.next = entries[0x0].next; entries[entries[0x0].next].prev = _address; entries[0x0].next = _address; } total += _amt; entry.balance += _amt; } function subtract(address _address, uint _amt) fromOwner public returns (uint _amtRemoved) { if (_address == address(0) || _amt == 0) return; Entry storage entry = entries[_address]; uint _maxAmt = entry.balance; if (_maxAmt == 0) return; if (_amt >= _maxAmt) { total -= _maxAmt; entries[entry.prev].next = entry.next; entries[entry.next].prev = entry.prev; delete entries[_address]; return _maxAmt; } else { total -= _amt; entry.balance -= _amt; return _amt; } } function size() public view returns (uint _size) { Entry memory _curEntry = entries[0x0]; while (_curEntry.next > 0) { _curEntry = entries[_curEntry.next]; _size++; } return _size; } function balanceOf(address _address) public view returns (uint _balance) { return entries[_address].balance; } function balances() public view returns (address[] _addresses, uint[] _balances) { uint _size = size(); _addresses = new address[](_size); _balances = new uint[](_size); uint _i = 0; Entry memory _curEntry = entries[0x0]; while (_curEntry.next > 0) { _addresses[_i] = _curEntry.next; _balances[_i] = entries[_curEntry.next].balance; _curEntry = entries[_curEntry.next]; _i++; } return (_addresses, _balances); } } contract AddressSet { struct Entry { bool exists; address next; address prev; } mapping (address => Entry) public entries; address public owner; modifier fromOwner() { require(msg.sender==owner); _; } constructor(address _owner) public { owner = _owner; } function add(address _address) fromOwner public returns (bool _didCreate) { if (_address == address(0)) return; Entry storage entry = entries[_address]; if (entry.exists) return; else entry.exists = true; Entry storage HEAD = entries[0x0]; entry.next = HEAD.next; entries[HEAD.next].prev = _address; HEAD.next = _address; return true; } function remove(address _address) fromOwner public returns (bool _didExist) { if (_address == address(0)) return; Entry storage entry = entries[_address]; if (!entry.exists) return; entries[entry.prev].next = entry.next; entries[entry.next].prev = entry.prev; delete entries[_address]; return true; } function size() public view returns (uint _size) { Entry memory _curEntry = entries[0x0]; while (_curEntry.next > 0) { _curEntry = entries[_curEntry.next]; _size++; } return _size; } function has(address _address) public view returns (bool _exists) { return entries[_address].exists; } function addresses() public view returns (address[] _addresses) { uint _size = size(); _addresses = new address[](_size); uint _i = 0; Entry memory _curEntry = entries[0x0]; while (_curEntry.next > 0) { _addresses[_i] = _curEntry.next; _curEntry = entries[_curEntry.next]; _i++; } return _addresses; } } contract Bankrollable is UsingTreasury { uint public profitsSent; Ledger public ledger; uint public bankroll; AddressSet public whitelist; modifier fromWhitelistOwner(){ require(msg.sender == getWhitelistOwner()); _; } event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll); event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll); event ProfitsSent(uint time, address indexed treasury, uint amount); event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner); event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner); constructor(address _registry) UsingTreasury(_registry) public { ledger = new Ledger(this); whitelist = new AddressSet(this); } function addToWhitelist(address _addr) fromWhitelistOwner public { bool _didAdd = whitelist.add(_addr); if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender); } function removeFromWhitelist(address _addr) fromWhitelistOwner public { bool _didRemove = whitelist.remove(_addr); if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender); } function () public payable {} function addBankroll() public payable { require(whitelist.size()==0 || whitelist.has(msg.sender)); ledger.add(msg.sender, msg.value); bankroll = ledger.total(); emit BankrollAdded(now, msg.sender, msg.value, bankroll); } function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) { address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; } function sendProfits() public returns (uint _profits) { int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); } function getCollateral() public view returns (uint _amount); function getWhitelistOwner() public view returns (address _addr); function profits() public view returns (int _profits) { int _balance = int(address(this).balance); int _threshold = int(bankroll + getCollateral()); return _balance - _threshold; } function profitsTotal() public view returns (int _profits) { return int(profitsSent) + profits(); } function bankrollAvailable() public view returns (uint _amount) { uint _balance = address(this).balance; uint _bankroll = bankroll; uint _collat = getCollateral(); if (_balance <= _collat) return 0; else if (_balance < _collat + _bankroll) return _balance - _collat; else return _bankroll; } function bankrolledBy(address _addr) public view returns (uint _amount) { return ledger.balanceOf(_addr); } function bankrollerTable() public view returns (address[], uint[]) { return ledger.balances(); } } contract VideoPokerUtils { uint constant HAND_UNDEFINED = 0; uint constant HAND_RF = 1; uint constant HAND_SF = 2; uint constant HAND_FK = 3; uint constant HAND_FH = 4; uint constant HAND_FL = 5; uint constant HAND_ST = 6; uint constant HAND_TK = 7; uint constant HAND_TP = 8; uint constant HAND_JB = 9; uint constant HAND_HC = 10; uint constant HAND_NOT_COMPUTABLE = 11; function getHand(uint256 _hash) public pure returns (uint32) { return uint32(getCardsFromHash(_hash, 5, 0)); } function drawToHand(uint256 _hash, uint32 _hand, uint _draws) public pure returns (uint32) { assert(_draws <= 31); assert(_hand != 0 || _draws == 31); if (_draws == 0) return _hand; if (_draws == 31) return uint32(getCardsFromHash(_hash, 5, handToBitmap(_hand))); uint _newMask; for (uint _i=0; _i<5; _i++) { if (_draws & 2**_i == 0) continue; _newMask |= 63 * (2**(6*_i)); } uint _discardMask = ~_newMask & (2**31-1); uint _newHand = getCardsFromHash(_hash, 5, handToBitmap(_hand)); _newHand &= _newMask; _newHand |= _hand & _discardMask; return uint32(_newHand); } function getHandRank(uint32 _hand) public pure returns (uint) { if (_hand == 0) return HAND_NOT_COMPUTABLE; uint _card; uint[] memory _valCounts = new uint[](13); uint[] memory _suitCounts = new uint[](5); uint _pairVal; uint _minNonAce = 100; uint _maxNonAce = 0; uint _numPairs; uint _maxSet; bool _hasFlush; bool _hasAce; uint _i; uint _val; for (_i=0; _i<5; _i++) { _card = readFromCards(_hand, _i); if (_card > 51) return HAND_NOT_COMPUTABLE; _val = _card % 13; _valCounts[_val]++; _suitCounts[_card/13]++; if (_suitCounts[_card/13] == 5) _hasFlush = true; if (_val == 0) { _hasAce = true; } else { if (_val < _minNonAce) _minNonAce = _val; if (_val > _maxNonAce) _maxNonAce = _val; } if (_valCounts[_val] == 2) { if (_numPairs==0) _pairVal = _val; _numPairs++; } else if (_valCounts[_val] == 3) { _maxSet = 3; } else if (_valCounts[_val] == 4) { _maxSet = 4; } } if (_numPairs > 0){ if (_maxSet==4) return HAND_FK; if (_maxSet==3 && _numPairs==2) return HAND_FH; if (_maxSet==3) return HAND_TK; if (_numPairs==2) return HAND_TP; if (_numPairs == 1 && (_pairVal >= 10 || _pairVal==0)) return HAND_JB; return HAND_HC; } bool _hasStraight = _hasAce ? _maxNonAce == 4 || _minNonAce == 9 : _maxNonAce - _minNonAce == 4; if (_hasStraight && _hasFlush && _minNonAce==9) return HAND_RF; if (_hasStraight && _hasFlush) return HAND_SF; if (_hasFlush) return HAND_FL; if (_hasStraight) return HAND_ST; return HAND_HC; } function handToCards(uint32 _hand) public pure returns (uint8[5] _cards) { uint32 _mask; for (uint _i=0; _i<5; _i++){ _mask = uint32(63 * 2**(6*_i)); _cards[_i] = uint8((_hand & _mask) / (2**(6*_i))); } } function readFromCards(uint _cards, uint _index) internal pure returns (uint) { uint _offset = 2**(6*_index); uint _oneBits = 2**6 - 1; return (_cards & (_oneBits * _offset)) / _offset; } function handToBitmap(uint32 _hand) internal pure returns (uint _bitmap) { if (_hand == 0) return 0; uint _mask; uint _card; for (uint _i=0; _i<5; _i++){ _mask = 63 * 2**(6*_i); _card = (_hand & _mask) / (2**(6*_i)); _bitmap |= 2**_card; } } function getCardsFromHash(uint256 _hash, uint _numCards, uint _usedBitmap) internal pure returns (uint _cards) { if (_numCards == 0) return; uint _cardIdx = 0; uint _card; uint _usedMask; while (true) { _card = _hash % 52; _usedMask = 2**_card; if (_usedBitmap & _usedMask == 0) { _cards |= (_card * 2**(_cardIdx*6)); _usedBitmap |= _usedMask; _cardIdx++; if (_cardIdx == _numCards) return _cards; } _hash = uint256(keccak256(_hash)); } } } contract VideoPoker is VideoPokerUtils, Bankrollable, UsingAdmin { struct Game { uint32 userId; uint64 bet; uint16 payTableId; uint32 iBlock; uint32 iHand; uint8 draws; uint32 dBlock; uint32 dHand; uint8 handRank; } struct Vars { uint32 curId; uint64 totalWageredGwei; uint32 curUserId; uint128 empty1; uint64 totalWonGwei; uint88 totalCredits; uint8 empty2; } struct Settings { uint64 minBet; uint64 maxBet; uint16 curPayTableId; uint16 numPayTables; uint32 lastDayAdded; } Settings settings; Vars vars; mapping(uint32 => Game) public games; mapping(address => uint) public credits; mapping (address => uint32) public userIds; mapping (uint32 => address) public userAddresses; mapping(uint16=>uint16[12]) payTables; uint8 public constant version = 2; uint8 constant WARN_IHAND_TIMEOUT = 1; uint8 constant WARN_DHAND_TIMEOUT = 2; uint8 constant WARN_BOTH_TIMEOUT = 3; event Created(uint time); event PayTableAdded(uint time, address admin, uint payTableId); event SettingsChanged(uint time, address admin); event BetSuccess(uint time, address indexed user, uint32 indexed id, uint bet, uint payTableId); event BetFailure(uint time, address indexed user, uint bet, string msg); event DrawSuccess(uint time, address indexed user, uint32 indexed id, uint32 iHand, uint8 draws, uint8 warnCode); event DrawFailure(uint time, address indexed user, uint32 indexed id, uint8 draws, string msg); event FinalizeSuccess(uint time, address indexed user, uint32 indexed id, uint32 dHand, uint8 handRank, uint payout, uint8 warnCode); event FinalizeFailure(uint time, address indexed user, uint32 indexed id, string msg); event CreditsAdded(uint time, address indexed user, uint32 indexed id, uint amount); event CreditsUsed(uint time, address indexed user, uint32 indexed id, uint amount); event CreditsCashedout(uint time, address indexed user, uint amount); constructor(address _registry) Bankrollable(_registry) UsingAdmin(_registry) public { _addPayTable(800, 50, 25, 9, 6, 4, 3, 2, 1); vars.curId = 293; vars.totalWageredGwei =2864600000; vars.curUserId = 38; vars.totalWonGwei = 2450400000; settings.minBet = .001 ether; settings.maxBet = .375 ether; emit Created(now); } function changeSettings(uint64 _minBet, uint64 _maxBet, uint8 _payTableId) public fromAdmin { require(_maxBet <= .375 ether); require(_payTableId < settings.numPayTables); settings.minBet = _minBet; settings.maxBet = _maxBet; settings.curPayTableId = _payTableId; emit SettingsChanged(now, msg.sender); } function addPayTable( uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh, uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb ) public fromAdmin { uint32 _today = uint32(block.timestamp / 1 days); require(settings.lastDayAdded < _today); settings.lastDayAdded = _today; _addPayTable(_rf, _sf, _fk, _fh, _fl, _st, _tk, _tp, _jb); emit PayTableAdded(now, msg.sender, settings.numPayTables-1); } function addCredits() public payable { _creditUser(msg.sender, msg.value, 0); } function cashOut(uint _amt) public { _uncreditUser(msg.sender, _amt); } function bet() public payable { uint _bet = msg.value; if (_bet > settings.maxBet) return _betFailure(\"Bet too large.\", _bet, true); if (_bet < settings.minBet) return _betFailure(\"Bet too small.\", _bet, true); if (_bet > curMaxBet()) return _betFailure(\"The bankroll is too low.\", _bet, true); uint32 _id = _createNewGame(uint64(_bet)); emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId); } function betWithCredits(uint64 _bet) public { if (_bet > settings.maxBet) return _betFailure(\"Bet too large.\", _bet, false); if (_bet < settings.minBet) return _betFailure(\"Bet too small.\", _bet, false); if (_bet > curMaxBet()) return _betFailure(\"The bankroll is too low.\", _bet, false); if (_bet > credits[msg.sender]) return _betFailure(\"Insufficient credits\", _bet, false); uint32 _id = _createNewGame(uint64(_bet)); vars.totalCredits -= uint88(_bet); credits[msg.sender] -= _bet; emit CreditsUsed(now, msg.sender, _id, _bet); emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId); } function betFromGame(uint32 _id, bytes32 _hashCheck) public { bool _didFinalize = finalize(_id, _hashCheck); uint64 _bet = games[_id].bet; if (!_didFinalize) return _betFailure(\"Failed to finalize prior game.\", _bet, false); betWithCredits(_bet); } function _betFailure(string _msg, uint _bet, bool _doRefund) private { if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); } function draw(uint32 _id, uint8 _draws, bytes32 _hashCheck) public { Game storage _game = games[_id]; address _user = userAddresses[_game.userId]; if (_game.iBlock == 0) return _drawFailure(_id, _draws, \"Invalid game Id.\"); if (_user != msg.sender) return _drawFailure(_id, _draws, \"This is not your game.\"); if (_game.iBlock == block.number) return _drawFailure(_id, _draws, \"Initial cards not available.\"); if (_game.dBlock != 0) return _drawFailure(_id, _draws, \"Cards already drawn.\"); if (_draws > 31) return _drawFailure(_id, _draws, \"Invalid draws.\"); if (_draws == 0) return _drawFailure(_id, _draws, \"Cannot draw 0 cards. Use finalize instead.\"); if (_game.handRank != HAND_UNDEFINED) return _drawFailure(_id, _draws, \"Game already finalized.\"); _draw(_game, _id, _draws, _hashCheck); } function _drawFailure(uint32 _id, uint8 _draws, string _msg) private { emit DrawFailure(now, msg.sender, _id, _draws, _msg); } function finalize(uint32 _id, bytes32 _hashCheck) public returns (bool _didFinalize) { Game storage _game = games[_id]; address _user = userAddresses[_game.userId]; if (_game.iBlock == 0) return _finalizeFailure(_id, \"Invalid game Id.\"); if (_user != msg.sender) return _finalizeFailure(_id, \"This is not your game.\"); if (_game.iBlock == block.number) return _finalizeFailure(_id, \"Initial hand not avaiable.\"); if (_game.dBlock == block.number) return _finalizeFailure(_id, \"Drawn cards not available.\"); if (_game.handRank != HAND_UNDEFINED) return _finalizeFailure(_id, \"Game already finalized.\"); _finalize(_game, _id, _hashCheck); return true; } function _finalizeFailure(uint32 _id, string _msg) private returns (bool) { emit FinalizeFailure(now, msg.sender, _id, _msg); return false; } function _addPayTable( uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh, uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb ) private { require(_rf<=1600 && _sf<=100 && _fk<=50 && _fh<=18 && _fl<=12 && _st<=8 && _tk<=6 && _tp<=4 && _jb<=2); uint16[12] memory _pt; _pt[HAND_UNDEFINED] = 0; _pt[HAND_RF] = _rf; _pt[HAND_SF] = _sf; _pt[HAND_FK] = _fk; _pt[HAND_FH] = _fh; _pt[HAND_FL] = _fl; _pt[HAND_ST] = _st; _pt[HAND_TK] = _tk; _pt[HAND_TP] = _tp; _pt[HAND_JB] = _jb; _pt[HAND_HC] = 0; _pt[HAND_NOT_COMPUTABLE] = 0; payTables[settings.numPayTables] = _pt; settings.numPayTables++; } function _creditUser(address _user, uint _amt, uint32 _gameId) private { if (_amt == 0) return; uint64 _incr = _gameId == 0 ? 0 : uint64(_amt / 1e9); uint88 _totalCredits = vars.totalCredits + uint88(_amt); uint64 _totalWonGwei = vars.totalWonGwei + _incr; vars.totalCredits = _totalCredits; vars.totalWonGwei = _totalWonGwei; credits[_user] += _amt; emit CreditsAdded(now, _user, _gameId, _amt); } function _uncreditUser(address _user, uint _amt) private { if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); } function _createNewGame(uint64 _bet) private returns (uint32 _curId) { uint32 _curUserId = vars.curUserId; uint32 _userId = userIds[msg.sender]; if (_userId == 0) { _curUserId++; userIds[msg.sender] = _curUserId; userAddresses[_curUserId] = msg.sender; _userId = _curUserId; } _curId =  vars.curId + 1; uint64 _totalWagered = vars.totalWageredGwei + _bet / 1e9; vars.curId = _curId; vars.totalWageredGwei = _totalWagered; vars.curUserId = _curUserId; uint16 _payTableId = settings.curPayTableId; Game storage _game = games[_curId]; _game.userId = _userId; _game.bet = _bet; _game.payTableId = _payTableId; _game.iBlock = uint32(block.number); return _curId; } function _draw(Game storage _game, uint32 _id, uint8 _draws, bytes32 _hashCheck) private { assert(_game.dBlock == 0); uint32 _iHand; bytes32 _iBlockHash = blockhash(_game.iBlock); uint8 _warnCode; if (_iBlockHash != 0) { if (_iBlockHash != _hashCheck) { return _drawFailure(_id, _draws, \"HashCheck Failed. Try refreshing game.\"); } _iHand = getHand(uint(keccak256(_iBlockHash, _id))); } else { _warnCode = WARN_IHAND_TIMEOUT; _draws = 31; } _game.iHand = _iHand; _game.draws = _draws; _game.dBlock = uint32(block.number); emit DrawSuccess(now, msg.sender, _id, _game.iHand, _draws, _warnCode); } function _finalize(Game storage _game, uint32 _id, bytes32 _hashCheck) private { assert(_game.handRank == HAND_UNDEFINED); address _user = userAddresses[_game.userId]; bytes32 _blockhash; uint32 _dHand; uint32 _iHand; uint8 _warnCode; if (_game.draws != 0) { _blockhash = blockhash(_game.dBlock); if (_blockhash != 0) { _dHand = drawToHand(uint(keccak256(_blockhash, _id)), _game.iHand, _game.draws); } else { if (_game.iHand != 0){ _dHand = _game.iHand; _warnCode = WARN_DHAND_TIMEOUT; } else { _dHand = 0; _warnCode = WARN_BOTH_TIMEOUT; } } } else { _blockhash = blockhash(_game.iBlock); if (_blockhash != 0) { if (_blockhash != _hashCheck) { _finalizeFailure(_id, \"HashCheck Failed. Try refreshing game.\"); return; } _iHand = getHand(uint(keccak256(_blockhash, _id))); _dHand = _iHand; } else { _finalizeFailure(_id, \"Initial hand not available. Drawing 5 new cards.\"); _game.draws = 31; _game.dBlock = uint32(block.number); emit DrawSuccess(now, _user, _id, 0, 31, WARN_IHAND_TIMEOUT); return; } } uint8 _handRank = _dHand == 0 ? uint8(HAND_NOT_COMPUTABLE) : uint8(getHandRank(_dHand)); if (_iHand > 0) _game.iHand = _iHand; _game.dHand = _dHand; _game.handRank = _handRank; uint _payout = payTables[_game.payTableId][_handRank] * uint(_game.bet); if (_payout > 0) _creditUser(_user, _payout, _id); emit FinalizeSuccess(now, _user, _id, _game.dHand, _game.handRank, _payout, _warnCode); } function getCollateral() public view returns (uint _amount) { return vars.totalCredits; } function getWhitelistOwner() public view returns (address _wlOwner) { return getAdmin(); } function curMaxBet() public view returns (uint) { uint _maxPayout = payTables[settings.curPayTableId][HAND_RF] * 2; return bankrollAvailable() / _maxPayout; } function effectiveMaxBet() public view returns (uint _amount) { uint _curMax = curMaxBet(); return _curMax > settings.maxBet ? settings.maxBet : _curMax; } function getPayTable(uint16 _payTableId) public view returns (uint16[12]) { require(_payTableId < settings.numPayTables); return payTables[_payTableId]; } function getCurPayTable() public view returns (uint16[12]) { return getPayTable(settings.curPayTableId); } function getIHand(uint32 _id) public view returns (uint32) { Game memory _game = games[_id]; if (_game.iHand != 0) return _game.iHand; if (_game.iBlock == 0) return; bytes32 _iBlockHash = blockhash(_game.iBlock); if (_iBlockHash == 0) return; return getHand(uint(keccak256(_iBlockHash, _id))); } function getDHand(uint32 _id) public view returns (uint32) { Game memory _game = games[_id]; if (_game.dHand != 0) return _game.dHand; if (_game.draws == 0) return _game.iHand; if (_game.dBlock == 0) return; bytes32 _dBlockHash = blockhash(_game.dBlock); if (_dBlockHash == 0) return _game.iHand; return drawToHand(uint(keccak256(_dBlockHash, _id)), _game.iHand, _game.draws); } function getDHandRank(uint32 _id) public view returns (uint8) { uint32 _dHand = getDHand(_id); return _dHand == 0 ? uint8(HAND_NOT_COMPUTABLE) : uint8(getHandRank(_dHand)); } function curId() public view returns (uint32) { return vars.curId; } function totalWagered() public view returns (uint) { return uint(vars.totalWageredGwei) * 1e9; } function curUserId() public view returns (uint) { return uint(vars.curUserId); } function totalWon() public view returns (uint) { return uint(vars.totalWonGwei) * 1e9; } function totalCredits() public view returns (uint) { return vars.totalCredits; } function minBet() public view returns (uint) { return settings.minBet; } function maxBet() public view returns (uint) { return settings.maxBet; } function curPayTableId() public view returns (uint) { return settings.curPayTableId; } function numPayTables() public view returns (uint) { return settings.numPayTables; } } "}
{"sol name": "21886.sol", "label": 1, "first path": "function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); buyToken(recipient, value); function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); ", "second path": "function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); buyToken(recipient, value); function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); ", "third path": "function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); buyToken(recipient, value); function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); ", "long path": "pragma solidity ^0.4.18; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) throw; } } contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract AutomobileCyberchainToken is StandardToken, SafeMath { string public name = \"Automobile Cyberchain Token\"; string public symbol = \"AMCC\"; uint public decimals = 18; uint preSalePrice  = 32000; uint crowSalePrice = 20000; uint prePeriod = 256 * 24 * 30; uint totalPeriod = 256 * 24 * 95; uint public startBlock = 5455280; uint public endBlock = startBlock + totalPeriod; address public founder = 0xfD16CDC79382F86303E2eE8693C7f50A4d8b937F; uint256 public preEtherCap = 15625 * 10**18; uint256 public etherCap =    88125 * 10**18; uint256 public bountyAllocation = 1050000000 * 10**18; uint256 public maxToken = 3000000000 * 10**18; uint256 public presaleTokenSupply = 0; uint256 public totalEtherRaised = 0; bool public halted = false; event Buy(address indexed sender, uint eth, uint fbt); function AutomobileCyberchainToken() { balances[founder] = bountyAllocation; totalSupply = bountyAllocation; Transfer(address(0), founder, bountyAllocation); } function price() constant returns(uint) { if (block.number<startBlock || block.number > endBlock) return 0; else if (block.number>=startBlock && block.number<startBlock+prePeriod) return preSalePrice; else  return crowSalePrice; } function() public payable  { buyToken(msg.sender, msg.value); } function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); } buyToken(recipient, value); } function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); } Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); } function halt() { if (msg.sender!=founder) throw; halted = true; } function unhalt() { if (msg.sender!=founder) throw; halted = false; } function changeFounder(address newFounder) { if (msg.sender!=founder) throw; founder = newFounder; } function withdrawExtraToken(address recipient) public { require(msg.sender == founder && block.number > endBlock && totalSupply < maxToken); uint256 leftTokens = safeSub(maxToken, totalSupply); balances[recipient] = safeAdd(balances[recipient], leftTokens); totalSupply = maxToken; Transfer(address(0), recipient, leftTokens); } } "}
